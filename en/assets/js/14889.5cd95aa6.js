/*! For license information please see 14889.5cd95aa6.js.LICENSE.txt */
'use strict';
(self.webpackChunk_nl_design_system_website = self.webpackChunk_nl_design_system_website || []).push([
 [14889],
 {
  41973: (e, t, r) => {
   var n = r(75271);
   function s(e) {
    for (var t = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, r = 1; r < arguments.length; r++) t += '&args[]=' + encodeURIComponent(arguments[r]);
    return 'Minified React error #' + e + '; visit ' + t + ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.';
   }
   var i = Object.prototype.hasOwnProperty,
    a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    o = {},
    u = {};
   function l(e) {
    return !!i.call(u, e) || (!i.call(o, e) && (a.test(e) ? (u[e] = !0) : ((o[e] = !0), !1)));
   }
   function p(e, t, r, n, s, i, a) {
    (this.acceptsBooleans = 2 === t || 3 === t || 4 === t), (this.attributeName = n), (this.attributeNamespace = s), (this.mustUseProperty = r), (this.propertyName = e), (this.type = t), (this.sanitizeURL = i), (this.removeEmptyString = a);
   }
   var c = {};
   'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'.split(' ').forEach(function (e) {
    c[e] = new p(e, 0, !1, e, null, !1, !1);
   }),
    [
     ['acceptCharset', 'accept-charset'],
     ['className', 'class'],
     ['htmlFor', 'for'],
     ['httpEquiv', 'http-equiv'],
    ].forEach(function (e) {
     var t = e[0];
     c[t] = new p(t, 1, !1, e[1], null, !1, !1);
    }),
    ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
     c[e] = new p(e, 2, !1, e.toLowerCase(), null, !1, !1);
    }),
    ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) {
     c[e] = new p(e, 2, !1, e, null, !1, !1);
    }),
    'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'.split(' ').forEach(function (e) {
     c[e] = new p(e, 3, !1, e.toLowerCase(), null, !1, !1);
    }),
    ['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
     c[e] = new p(e, 3, !0, e, null, !1, !1);
    }),
    ['capture', 'download'].forEach(function (e) {
     c[e] = new p(e, 4, !1, e, null, !1, !1);
    }),
    ['cols', 'rows', 'size', 'span'].forEach(function (e) {
     c[e] = new p(e, 6, !1, e, null, !1, !1);
    }),
    ['rowSpan', 'start'].forEach(function (e) {
     c[e] = new p(e, 5, !1, e.toLowerCase(), null, !1, !1);
    });
   var h = /[\-:]([a-z])/g;
   function d(e) {
    return e[1].toUpperCase();
   }
   'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'.split(' ').forEach(function (e) {
    var t = e.replace(h, d);
    c[t] = new p(t, 1, !1, e, null, !1, !1);
   }),
    'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach(function (e) {
     var t = e.replace(h, d);
     c[t] = new p(t, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1);
    }),
    ['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
     var t = e.replace(h, d);
     c[t] = new p(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1);
    }),
    ['tabIndex', 'crossOrigin'].forEach(function (e) {
     c[e] = new p(e, 1, !1, e.toLowerCase(), null, !1, !1);
    }),
    (c.xlinkHref = new p('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)),
    ['src', 'href', 'action', 'formAction'].forEach(function (e) {
     c[e] = new p(e, 1, !1, e.toLowerCase(), null, !0, !0);
    });
   var f = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    m = ['Webkit', 'ms', 'Moz', 'O'];
   Object.keys(f).forEach(function (e) {
    m.forEach(function (t) {
     (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (f[t] = f[e]);
    });
   });
   var y = /["'&<>]/;
   function g(e) {
    if ('boolean' == typeof e || 'number' == typeof e) return '' + e;
    e = '' + e;
    var t = y.exec(e);
    if (t) {
     var r,
      n = '',
      s = 0;
     for (r = t.index; r < e.length; r++) {
      switch (e.charCodeAt(r)) {
       case 34:
        t = '&quot;';
        break;
       case 38:
        t = '&amp;';
        break;
       case 39:
        t = '&#x27;';
        break;
       case 60:
        t = '&lt;';
        break;
       case 62:
        t = '&gt;';
        break;
       default:
        continue;
      }
      s !== r && (n += e.substring(s, r)), (s = r + 1), (n += t);
     }
     e = s !== r ? n + e.substring(s, r) : n;
    }
    return e;
   }
   var D = /([A-Z])/g,
    x = /^ms-/,
    b = Array.isArray;
   function v(e, t) {
    return { insertionMode: e, selectedValue: t };
   }
   var E = new Map();
   function C(e, t, r) {
    if ('object' != typeof r) throw Error(s(62));
    for (var n in ((t = !0), r))
     if (i.call(r, n)) {
      var a = r[n];
      if (null != a && 'boolean' != typeof a && '' !== a) {
       if (0 === n.indexOf('--')) {
        var o = g(n);
        a = g(('' + a).trim());
       } else {
        o = n;
        var u = E.get(o);
        void 0 !== u || ((u = g(o.replace(D, '-$1').toLowerCase().replace(x, '-ms-'))), E.set(o, u)), (o = u), (a = 'number' == typeof a ? (0 === a || i.call(f, n) ? '' + a : a + 'px') : g(('' + a).trim()));
       }
       t ? ((t = !1), e.push(' style="', o, ':', a)) : e.push(';', o, ':', a);
      }
     }
    t || e.push('"');
   }
   function T(e, t, r, n) {
    switch (r) {
     case 'style':
      return void C(e, t, n);
     case 'defaultValue':
     case 'defaultChecked':
     case 'innerHTML':
     case 'suppressContentEditableWarning':
     case 'suppressHydrationWarning':
      return;
    }
    if (!(2 < r.length) || ('o' !== r[0] && 'O' !== r[0]) || ('n' !== r[1] && 'N' !== r[1]))
     if (null !== (t = c.hasOwnProperty(r) ? c[r] : null)) {
      switch (typeof n) {
       case 'function':
       case 'symbol':
        return;
       case 'boolean':
        if (!t.acceptsBooleans) return;
      }
      switch (((r = t.attributeName), t.type)) {
       case 3:
        n && e.push(' ', r, '=""');
        break;
       case 4:
        !0 === n ? e.push(' ', r, '=""') : !1 !== n && e.push(' ', r, '="', g(n), '"');
        break;
       case 5:
        isNaN(n) || e.push(' ', r, '="', g(n), '"');
        break;
       case 6:
        !isNaN(n) && 1 <= n && e.push(' ', r, '="', g(n), '"');
        break;
       default:
        t.sanitizeURL && (n = '' + n), e.push(' ', r, '="', g(n), '"');
      }
     } else if (l(r)) {
      switch (typeof n) {
       case 'function':
       case 'symbol':
        return;
       case 'boolean':
        if ('data-' !== (t = r.toLowerCase().slice(0, 5)) && 'aria-' !== t) return;
      }
      e.push(' ', r, '="', g(n), '"');
     }
   }
   function S(e, t, r) {
    if (null != t) {
     if (null != r) throw Error(s(60));
     if ('object' != typeof t || !('__html' in t)) throw Error(s(61));
     null != (t = t.__html) && e.push('' + t);
    }
   }
   function w(e, t, r, n) {
    e.push(k(r));
    var s,
     a = (r = null);
    for (s in t)
     if (i.call(t, s)) {
      var o = t[s];
      if (null != o)
       switch (s) {
        case 'children':
         r = o;
         break;
        case 'dangerouslySetInnerHTML':
         a = o;
         break;
        default:
         T(e, n, s, o);
       }
     }
    return e.push('>'), S(e, a, r), 'string' == typeof r ? (e.push(g(r)), null) : r;
   }
   var A = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    F = new Map();
   function k(e) {
    var t = F.get(e);
    if (void 0 === t) {
     if (!A.test(e)) throw Error(s(65, e));
     (t = '<' + e), F.set(e, t);
    }
    return t;
   }
   function P(e, t, r, a, o) {
    switch (t) {
     case 'select':
      e.push(k('select'));
      var u = null,
       p = null;
      for (f in r)
       if (i.call(r, f)) {
        var c = r[f];
        if (null != c)
         switch (f) {
          case 'children':
           u = c;
           break;
          case 'dangerouslySetInnerHTML':
           p = c;
           break;
          case 'defaultValue':
          case 'value':
           break;
          default:
           T(e, a, f, c);
         }
       }
      return e.push('>'), S(e, p, u), u;
     case 'option':
      (p = o.selectedValue), e.push(k('option'));
      var h = (c = null),
       d = null,
       f = null;
      for (u in r)
       if (i.call(r, u)) {
        var m = r[u];
        if (null != m)
         switch (u) {
          case 'children':
           c = m;
           break;
          case 'selected':
           d = m;
           break;
          case 'dangerouslySetInnerHTML':
           f = m;
           break;
          case 'value':
           h = m;
          default:
           T(e, a, u, m);
         }
       }
      if (null != p)
       if (
        ((r =
         null !== h
          ? '' + h
          : (function (e) {
             var t = '';
             return (
              n.Children.forEach(e, function (e) {
               null != e && (t += e);
              }),
              t
             );
            })(c)),
        b(p))
       ) {
        for (a = 0; a < p.length; a++)
         if ('' + p[a] === r) {
          e.push(' selected=""');
          break;
         }
       } else '' + p === r && e.push(' selected=""');
      else d && e.push(' selected=""');
      return e.push('>'), S(e, f, c), c;
     case 'textarea':
      for (c in (e.push(k('textarea')), (f = p = u = null), r))
       if (i.call(r, c) && null != (h = r[c]))
        switch (c) {
         case 'children':
          f = h;
          break;
         case 'value':
          u = h;
          break;
         case 'defaultValue':
          p = h;
          break;
         case 'dangerouslySetInnerHTML':
          throw Error(s(91));
         default:
          T(e, a, c, h);
        }
      if ((null === u && null !== p && (u = p), e.push('>'), null != f)) {
       if (null != u) throw Error(s(92));
       if (b(f) && 1 < f.length) throw Error(s(93));
       u = '' + f;
      }
      return 'string' == typeof u && '\n' === u[0] && e.push('\n'), null !== u && e.push(g('' + u)), null;
     case 'input':
      for (p in (e.push(k('input')), (h = f = c = u = null), r))
       if (i.call(r, p) && null != (d = r[p]))
        switch (p) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(399, 'input'));
         case 'defaultChecked':
          h = d;
          break;
         case 'defaultValue':
          c = d;
          break;
         case 'checked':
          f = d;
          break;
         case 'value':
          u = d;
          break;
         default:
          T(e, a, p, d);
        }
      return null !== f ? T(e, a, 'checked', f) : null !== h && T(e, a, 'checked', h), null !== u ? T(e, a, 'value', u) : null !== c && T(e, a, 'value', c), e.push('/>'), null;
     case 'menuitem':
      for (var y in (e.push(k('menuitem')), r))
       if (i.call(r, y) && null != (u = r[y]))
        switch (y) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(400));
         default:
          T(e, a, y, u);
        }
      return e.push('>'), null;
     case 'title':
      for (m in (e.push(k('title')), (u = null), r))
       if (i.call(r, m) && null != (p = r[m]))
        switch (m) {
         case 'children':
          u = p;
          break;
         case 'dangerouslySetInnerHTML':
          throw Error(s(434));
         default:
          T(e, a, m, p);
        }
      return e.push('>'), u;
     case 'listing':
     case 'pre':
      for (h in (e.push(k(t)), (p = u = null), r))
       if (i.call(r, h) && null != (c = r[h]))
        switch (h) {
         case 'children':
          u = c;
          break;
         case 'dangerouslySetInnerHTML':
          p = c;
          break;
         default:
          T(e, a, h, c);
        }
      if ((e.push('>'), null != p)) {
       if (null != u) throw Error(s(60));
       if ('object' != typeof p || !('__html' in p)) throw Error(s(61));
       null != (r = p.__html) && ('string' == typeof r && 0 < r.length && '\n' === r[0] ? e.push('\n', r) : e.push('' + r));
      }
      return 'string' == typeof u && '\n' === u[0] && e.push('\n'), u;
     case 'area':
     case 'base':
     case 'br':
     case 'col':
     case 'embed':
     case 'hr':
     case 'img':
     case 'keygen':
     case 'link':
     case 'meta':
     case 'param':
     case 'source':
     case 'track':
     case 'wbr':
      for (var D in (e.push(k(t)), r))
       if (i.call(r, D) && null != (u = r[D]))
        switch (D) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(399, t));
         default:
          T(e, a, D, u);
        }
      return e.push('/>'), null;
     case 'annotation-xml':
     case 'color-profile':
     case 'font-face':
     case 'font-face-src':
     case 'font-face-uri':
     case 'font-face-format':
     case 'font-face-name':
     case 'missing-glyph':
      return w(e, r, t, a);
     case 'html':
      return 0 === o.insertionMode && e.push('<!DOCTYPE html>'), w(e, r, t, a);
     default:
      if (-1 === t.indexOf('-') && 'string' != typeof r.is) return w(e, r, t, a);
      for (d in (e.push(k(t)), (p = u = null), r))
       if (i.call(r, d) && null != (c = r[d]))
        switch (d) {
         case 'children':
          u = c;
          break;
         case 'dangerouslySetInnerHTML':
          p = c;
          break;
         case 'style':
          C(e, a, c);
          break;
         case 'suppressContentEditableWarning':
         case 'suppressHydrationWarning':
          break;
         default:
          l(d) && 'function' != typeof c && 'symbol' != typeof c && e.push(' ', d, '="', g(c), '"');
        }
      return e.push('>'), S(e, p, u), u;
    }
   }
   function I(e, t, r) {
    if ((e.push('\x3c!--$?--\x3e<template id="'), null === r)) throw Error(s(395));
    return e.push(r), e.push('"></template>');
   }
   var N = /[<\u2028\u2029]/g;
   function B(e) {
    return JSON.stringify(e).replace(N, function (e) {
     switch (e) {
      case '<':
       return '\\u003c';
      case '\u2028':
       return '\\u2028';
      case '\u2029':
       return '\\u2029';
      default:
       throw Error('escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React');
     }
    });
   }
   function _(e, t, r, n) {
    return r.generateStaticMarkup ? (e.push(g(t)), !1) : ('' === t ? (e = n) : (n && e.push('\x3c!-- --\x3e'), e.push(g(t)), (e = !0)), e);
   }
   var L = Object.assign,
    O = Symbol.for('react.element'),
    M = Symbol.for('react.portal'),
    j = Symbol.for('react.fragment'),
    R = Symbol.for('react.strict_mode'),
    q = Symbol.for('react.profiler'),
    U = Symbol.for('react.provider'),
    $ = Symbol.for('react.context'),
    H = Symbol.for('react.forward_ref'),
    z = Symbol.for('react.suspense'),
    V = Symbol.for('react.suspense_list'),
    W = Symbol.for('react.memo'),
    J = Symbol.for('react.lazy'),
    K = Symbol.for('react.scope'),
    G = Symbol.for('react.debug_trace_mode'),
    X = Symbol.for('react.legacy_hidden'),
    Y = Symbol.for('react.default_value'),
    Q = Symbol.iterator;
   function Z(e) {
    if (null == e) return null;
    if ('function' == typeof e) return e.displayName || e.name || null;
    if ('string' == typeof e) return e;
    switch (e) {
     case j:
      return 'Fragment';
     case M:
      return 'Portal';
     case q:
      return 'Profiler';
     case R:
      return 'StrictMode';
     case z:
      return 'Suspense';
     case V:
      return 'SuspenseList';
    }
    if ('object' == typeof e)
     switch (e.$$typeof) {
      case $:
       return (e.displayName || 'Context') + '.Consumer';
      case U:
       return (e._context.displayName || 'Context') + '.Provider';
      case H:
       var t = e.render;
       return (e = e.displayName) || (e = '' !== (e = t.displayName || t.name || '') ? 'ForwardRef(' + e + ')' : 'ForwardRef'), e;
      case W:
       return null !== (t = e.displayName || null) ? t : Z(e.type) || 'Memo';
      case J:
       (t = e._payload), (e = e._init);
       try {
        return Z(e(t));
       } catch (r) {}
     }
    return null;
   }
   var ee = {};
   function te(e, t) {
    if (!(e = e.contextTypes)) return ee;
    var r,
     n = {};
    for (r in e) n[r] = t[r];
    return n;
   }
   var re = null;
   function ne(e, t) {
    if (e !== t) {
     (e.context._currentValue2 = e.parentValue), (e = e.parent);
     var r = t.parent;
     if (null === e) {
      if (null !== r) throw Error(s(401));
     } else {
      if (null === r) throw Error(s(401));
      ne(e, r);
     }
     t.context._currentValue2 = t.value;
    }
   }
   function se(e) {
    (e.context._currentValue2 = e.parentValue), null !== (e = e.parent) && se(e);
   }
   function ie(e) {
    var t = e.parent;
    null !== t && ie(t), (e.context._currentValue2 = e.value);
   }
   function ae(e, t) {
    if (((e.context._currentValue2 = e.parentValue), null === (e = e.parent))) throw Error(s(402));
    e.depth === t.depth ? ne(e, t) : ae(e, t);
   }
   function oe(e, t) {
    var r = t.parent;
    if (null === r) throw Error(s(402));
    e.depth === r.depth ? ne(e, r) : oe(e, r), (t.context._currentValue2 = t.value);
   }
   function ue(e) {
    var t = re;
    t !== e && (null === t ? ie(e) : null === e ? se(t) : t.depth === e.depth ? ne(t, e) : t.depth > e.depth ? ae(t, e) : oe(t, e), (re = e));
   }
   var le = {
    isMounted: function () {
     return !1;
    },
    enqueueSetState: function (e, t) {
     null !== (e = e._reactInternals).queue && e.queue.push(t);
    },
    enqueueReplaceState: function (e, t) {
     ((e = e._reactInternals).replace = !0), (e.queue = [t]);
    },
    enqueueForceUpdate: function () {},
   };
   function pe(e, t, r, n) {
    var s = void 0 !== e.state ? e.state : null;
    (e.updater = le), (e.props = r), (e.state = s);
    var i = { queue: [], replace: !1 };
    e._reactInternals = i;
    var a = t.contextType;
    if (((e.context = 'object' == typeof a && null !== a ? a._currentValue2 : n), 'function' == typeof (a = t.getDerivedStateFromProps) && ((s = null == (a = a(r, s)) ? s : L({}, s, a)), (e.state = s)), 'function' != typeof t.getDerivedStateFromProps && 'function' != typeof e.getSnapshotBeforeUpdate && ('function' == typeof e.UNSAFE_componentWillMount || 'function' == typeof e.componentWillMount)))
     if (((t = e.state), 'function' == typeof e.componentWillMount && e.componentWillMount(), 'function' == typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), t !== e.state && le.enqueueReplaceState(e, e.state, null), null !== i.queue && 0 < i.queue.length))
      if (((t = i.queue), (a = i.replace), (i.queue = null), (i.replace = !1), a && 1 === t.length)) e.state = t[0];
      else {
       for (i = a ? t[0] : e.state, s = !0, a = a ? 1 : 0; a < t.length; a++) {
        var o = t[a];
        null != (o = 'function' == typeof o ? o.call(e, i, r, n) : o) && (s ? ((s = !1), (i = L({}, i, o))) : L(i, o));
       }
       e.state = i;
      }
     else i.queue = null;
   }
   var ce = { id: 1, overflow: '' };
   function he(e, t, r) {
    var n = e.id;
    e = e.overflow;
    var s = 32 - de(n) - 1;
    (n &= ~(1 << s)), (r += 1);
    var i = 32 - de(t) + s;
    if (30 < i) {
     var a = s - (s % 5);
     return (i = (n & ((1 << a) - 1)).toString(32)), (n >>= a), (s -= a), { id: (1 << (32 - de(t) + s)) | (r << s) | n, overflow: i + e };
    }
    return { id: (1 << i) | (r << s) | n, overflow: e };
   }
   var de = Math.clz32
     ? Math.clz32
     : function (e) {
        return 0 === (e >>>= 0) ? 32 : (31 - ((fe(e) / me) | 0)) | 0;
       },
    fe = Math.log,
    me = Math.LN2;
   var ye =
     'function' == typeof Object.is
      ? Object.is
      : function (e, t) {
         return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
        },
    ge = null,
    De = null,
    xe = null,
    be = null,
    ve = !1,
    Ee = !1,
    Ce = 0,
    Te = null,
    Se = 0;
   function we() {
    if (null === ge) throw Error(s(321));
    return ge;
   }
   function Ae() {
    if (0 < Se) throw Error(s(312));
    return { memoizedState: null, queue: null, next: null };
   }
   function Fe() {
    return null === be ? (null === xe ? ((ve = !1), (xe = be = Ae())) : ((ve = !0), (be = xe))) : null === be.next ? ((ve = !1), (be = be.next = Ae())) : ((ve = !0), (be = be.next)), be;
   }
   function ke() {
    (De = ge = null), (Ee = !1), (xe = null), (Se = 0), (be = Te = null);
   }
   function Pe(e, t) {
    return 'function' == typeof t ? t(e) : t;
   }
   function Ie(e, t, r) {
    if (((ge = we()), (be = Fe()), ve)) {
     var n = be.queue;
     if (((t = n.dispatch), null !== Te && void 0 !== (r = Te.get(n)))) {
      Te.delete(n), (n = be.memoizedState);
      do {
       (n = e(n, r.action)), (r = r.next);
      } while (null !== r);
      return (be.memoizedState = n), [n, t];
     }
     return [be.memoizedState, t];
    }
    return (e = e === Pe ? ('function' == typeof t ? t() : t) : void 0 !== r ? r(t) : t), (be.memoizedState = e), (e = (e = be.queue = { last: null, dispatch: null }).dispatch = Be.bind(null, ge, e)), [be.memoizedState, e];
   }
   function Ne(e, t) {
    if (((ge = we()), (t = void 0 === t ? null : t), null !== (be = Fe()))) {
     var r = be.memoizedState;
     if (null !== r && null !== t) {
      var n = r[1];
      e: if (null === n) n = !1;
      else {
       for (var s = 0; s < n.length && s < t.length; s++)
        if (!ye(t[s], n[s])) {
         n = !1;
         break e;
        }
       n = !0;
      }
      if (n) return r[0];
     }
    }
    return (e = e()), (be.memoizedState = [e, t]), e;
   }
   function Be(e, t, r) {
    if (25 <= Se) throw Error(s(301));
    if (e === ge)
     if (((Ee = !0), (e = { action: r, next: null }), null === Te && (Te = new Map()), void 0 === (r = Te.get(t)))) Te.set(t, e);
     else {
      for (t = r; null !== t.next; ) t = t.next;
      t.next = e;
     }
   }
   function _e() {
    throw Error(s(394));
   }
   function Le() {}
   var Oe = {
     readContext: function (e) {
      return e._currentValue2;
     },
     useContext: function (e) {
      return we(), e._currentValue2;
     },
     useMemo: Ne,
     useReducer: Ie,
     useRef: function (e) {
      ge = we();
      var t = (be = Fe()).memoizedState;
      return null === t ? ((e = { current: e }), (be.memoizedState = e)) : t;
     },
     useState: function (e) {
      return Ie(Pe, e);
     },
     useInsertionEffect: Le,
     useLayoutEffect: function () {},
     useCallback: function (e, t) {
      return Ne(function () {
       return e;
      }, t);
     },
     useImperativeHandle: Le,
     useEffect: Le,
     useDebugValue: Le,
     useDeferredValue: function (e) {
      return we(), e;
     },
     useTransition: function () {
      return we(), [!1, _e];
     },
     useId: function () {
      var e = De.treeContext,
       t = e.overflow;
      e = ((e = e.id) & ~(1 << (32 - de(e) - 1))).toString(32) + t;
      var r = Me;
      if (null === r) throw Error(s(404));
      return (t = Ce++), (e = ':' + r.idPrefix + 'R' + e), 0 < t && (e += 'H' + t.toString(32)), e + ':';
     },
     useMutableSource: function (e, t) {
      return we(), t(e._source);
     },
     useSyncExternalStore: function (e, t, r) {
      if (void 0 === r) throw Error(s(407));
      return r();
     },
    },
    Me = null,
    je = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
   function Re(e) {
    return console.error(e), null;
   }
   function qe() {}
   function Ue(e, t, r, n, s, i, a, o) {
    e.allPendingTasks++, null === r ? e.pendingRootTasks++ : r.pendingTasks++;
    var u = {
     node: t,
     ping: function () {
      var t = e.pingedTasks;
      t.push(u), 1 === t.length && rt(e);
     },
     blockedBoundary: r,
     blockedSegment: n,
     abortSet: s,
     legacyContext: i,
     context: a,
     treeContext: o,
    };
    return s.add(u), u;
   }
   function $e(e, t, r, n, s, i) {
    return { status: 0, id: -1, index: t, parentFlushed: !1, chunks: [], children: [], formatContext: n, boundary: r, lastPushedText: s, textEmbedded: i };
   }
   function He(e, t) {
    if (null != (e = e.onError(t)) && 'string' != typeof e) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof e + '" instead');
    return e;
   }
   function ze(e, t) {
    var r = e.onShellError;
    r(t), (r = e.onFatalError)(t), null !== e.destination ? ((e.status = 2), e.destination.destroy(t)) : ((e.status = 1), (e.fatalError = t));
   }
   function Ve(e, t, r, n, s) {
    for (ge = {}, De = t, Ce = 0, e = r(n, s); Ee; ) (Ee = !1), (Ce = 0), (Se += 1), (be = null), (e = r(n, s));
    return ke(), e;
   }
   function We(e, t, r, n) {
    var i = r.render(),
     a = n.childContextTypes;
    if (null != a) {
     var o = t.legacyContext;
     if ('function' != typeof r.getChildContext) n = o;
     else {
      for (var u in (r = r.getChildContext())) if (!(u in a)) throw Error(s(108, Z(n) || 'Unknown', u));
      n = L({}, o, r);
     }
     (t.legacyContext = n), Ge(e, t, i), (t.legacyContext = o);
    } else Ge(e, t, i);
   }
   function Je(e, t) {
    if (e && e.defaultProps) {
     for (var r in ((t = L({}, t)), (e = e.defaultProps))) void 0 === t[r] && (t[r] = e[r]);
     return t;
    }
    return t;
   }
   function Ke(e, t, r, n, i) {
    if ('function' == typeof r)
     if (r.prototype && r.prototype.isReactComponent) {
      i = te(r, t.legacyContext);
      var a = r.contextType;
      pe((a = new r(n, 'object' == typeof a && null !== a ? a._currentValue2 : i)), r, n, i), We(e, t, a, r);
     } else {
      i = Ve(e, t, r, n, (a = te(r, t.legacyContext)));
      var o = 0 !== Ce;
      if ('object' == typeof i && null !== i && 'function' == typeof i.render && void 0 === i.$$typeof) pe(i, r, n, a), We(e, t, i, r);
      else if (o) {
       (n = t.treeContext), (t.treeContext = he(n, 1, 0));
       try {
        Ge(e, t, i);
       } finally {
        t.treeContext = n;
       }
      } else Ge(e, t, i);
     }
    else {
     if ('string' != typeof r) {
      switch (r) {
       case X:
       case G:
       case R:
       case q:
       case j:
       case V:
        return void Ge(e, t, n.children);
       case K:
        throw Error(s(343));
       case z:
        e: {
         (r = t.blockedBoundary), (i = t.blockedSegment), (a = n.fallback), (n = n.children);
         var u = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: (o = new Set()), errorDigest: null },
          l = $e(0, i.chunks.length, u, i.formatContext, !1, !1);
         i.children.push(l), (i.lastPushedText = !1);
         var p = $e(0, 0, null, i.formatContext, !1, !1);
         (p.parentFlushed = !0), (t.blockedBoundary = u), (t.blockedSegment = p);
         try {
          if ((Ye(e, t, n), e.responseState.generateStaticMarkup || (p.lastPushedText && p.textEmbedded && p.chunks.push('\x3c!-- --\x3e')), (p.status = 1), et(u, p), 0 === u.pendingTasks)) break e;
         } catch (c) {
          (p.status = 4), (u.forceClientRender = !0), (u.errorDigest = He(e, c));
         } finally {
          (t.blockedBoundary = r), (t.blockedSegment = i);
         }
         (t = Ue(e, a, r, l, o, t.legacyContext, t.context, t.treeContext)), e.pingedTasks.push(t);
        }
        return;
      }
      if ('object' == typeof r && null !== r)
       switch (r.$$typeof) {
        case H:
         if (((n = Ve(e, t, r.render, n, i)), 0 !== Ce)) {
          (r = t.treeContext), (t.treeContext = he(r, 1, 0));
          try {
           Ge(e, t, n);
          } finally {
           t.treeContext = r;
          }
         } else Ge(e, t, n);
         return;
        case W:
         return void Ke(e, t, (r = r.type), (n = Je(r, n)), i);
        case U:
         if (((i = n.children), (r = r._context), (n = n.value), (a = r._currentValue2), (r._currentValue2 = n), (re = n = { parent: (o = re), depth: null === o ? 0 : o.depth + 1, context: r, parentValue: a, value: n }), (t.context = n), Ge(e, t, i), null === (e = re))) throw Error(s(403));
         return (n = e.parentValue), (e.context._currentValue2 = n === Y ? e.context._defaultValue : n), (e = re = e.parent), void (t.context = e);
        case $:
         return void Ge(e, t, (n = (n = n.children)(r._currentValue2)));
        case J:
         return void Ke(e, t, (r = (i = r._init)(r._payload)), (n = Je(r, n)), void 0);
       }
      throw Error(s(130, null == r ? r : typeof r, ''));
     }
     switch (
      ((a = P((i = t.blockedSegment).chunks, r, n, e.responseState, i.formatContext)),
      (i.lastPushedText = !1),
      (o = i.formatContext),
      (i.formatContext = (function (e, t, r) {
       switch (t) {
        case 'select':
         return v(1, null != r.value ? r.value : r.defaultValue);
        case 'svg':
         return v(2, null);
        case 'math':
         return v(3, null);
        case 'foreignObject':
         return v(1, null);
        case 'table':
         return v(4, null);
        case 'thead':
        case 'tbody':
        case 'tfoot':
         return v(5, null);
        case 'colgroup':
         return v(7, null);
        case 'tr':
         return v(6, null);
       }
       return 4 <= e.insertionMode || 0 === e.insertionMode ? v(1, null) : e;
      })(o, r, n)),
      Ye(e, t, a),
      (i.formatContext = o),
      r)
     ) {
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'img':
      case 'input':
      case 'keygen':
      case 'link':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
       break;
      default:
       i.chunks.push('</', r, '>');
     }
     i.lastPushedText = !1;
    }
   }
   function Ge(e, t, r) {
    if (((t.node = r), 'object' == typeof r && null !== r)) {
     switch (r.$$typeof) {
      case O:
       return void Ke(e, t, r.type, r.props, r.ref);
      case M:
       throw Error(s(257));
      case J:
       var n = r._init;
       return void Ge(e, t, (r = n(r._payload)));
     }
     if (b(r)) return void Xe(e, t, r);
     if ((null === r || 'object' != typeof r ? (n = null) : (n = 'function' == typeof (n = (Q && r[Q]) || r['@@iterator']) ? n : null), n && (n = n.call(r)))) {
      if (!(r = n.next()).done) {
       var i = [];
       do {
        i.push(r.value), (r = n.next());
       } while (!r.done);
       Xe(e, t, i);
      }
      return;
     }
     throw ((e = Object.prototype.toString.call(r)), Error(s(31, '[object Object]' === e ? 'object with keys {' + Object.keys(r).join(', ') + '}' : e)));
    }
    'string' == typeof r ? ((n = t.blockedSegment).lastPushedText = _(t.blockedSegment.chunks, r, e.responseState, n.lastPushedText)) : 'number' == typeof r && ((n = t.blockedSegment).lastPushedText = _(t.blockedSegment.chunks, '' + r, e.responseState, n.lastPushedText));
   }
   function Xe(e, t, r) {
    for (var n = r.length, s = 0; s < n; s++) {
     var i = t.treeContext;
     t.treeContext = he(i, n, s);
     try {
      Ye(e, t, r[s]);
     } finally {
      t.treeContext = i;
     }
    }
   }
   function Ye(e, t, r) {
    var n = t.blockedSegment.formatContext,
     s = t.legacyContext,
     i = t.context;
    try {
     return Ge(e, t, r);
    } catch (u) {
     if ((ke(), 'object' != typeof u || null === u || 'function' != typeof u.then)) throw ((t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), ue(i), u);
     r = u;
     var a = t.blockedSegment,
      o = $e(0, a.chunks.length, null, a.formatContext, a.lastPushedText, !0);
     a.children.push(o), (a.lastPushedText = !1), (e = Ue(e, t.node, t.blockedBoundary, o, t.abortSet, t.legacyContext, t.context, t.treeContext).ping), r.then(e, e), (t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), ue(i);
    }
   }
   function Qe(e) {
    var t = e.blockedBoundary;
    ((e = e.blockedSegment).status = 3), tt(this, t, e);
   }
   function Ze(e, t, r) {
    var n = e.blockedBoundary;
    (e.blockedSegment.status = 3),
     null === n
      ? (t.allPendingTasks--, 2 !== t.status && ((t.status = 2), null !== t.destination && t.destination.push(null)))
      : (n.pendingTasks--,
        n.forceClientRender || ((n.forceClientRender = !0), (e = void 0 === r ? Error(s(432)) : r), (n.errorDigest = t.onError(e)), n.parentFlushed && t.clientRenderedBoundaries.push(n)),
        n.fallbackAbortableTasks.forEach(function (e) {
         return Ze(e, t, r);
        }),
        n.fallbackAbortableTasks.clear(),
        t.allPendingTasks--,
        0 === t.allPendingTasks && (n = t.onAllReady)());
   }
   function et(e, t) {
    if (0 === t.chunks.length && 1 === t.children.length && null === t.children[0].boundary) {
     var r = t.children[0];
     (r.id = t.id), (r.parentFlushed = !0), 1 === r.status && et(e, r);
    } else e.completedSegments.push(t);
   }
   function tt(e, t, r) {
    if (null === t) {
     if (r.parentFlushed) {
      if (null !== e.completedRootSegment) throw Error(s(389));
      e.completedRootSegment = r;
     }
     e.pendingRootTasks--, 0 === e.pendingRootTasks && ((e.onShellError = qe), (t = e.onShellReady)());
    } else t.pendingTasks--, t.forceClientRender || (0 === t.pendingTasks ? (r.parentFlushed && 1 === r.status && et(t, r), t.parentFlushed && e.completedBoundaries.push(t), t.fallbackAbortableTasks.forEach(Qe, e), t.fallbackAbortableTasks.clear()) : r.parentFlushed && 1 === r.status && (et(t, r), 1 === t.completedSegments.length && t.parentFlushed && e.partialBoundaries.push(t)));
    e.allPendingTasks--, 0 === e.allPendingTasks && (e = e.onAllReady)();
   }
   function rt(e) {
    if (2 !== e.status) {
     var t = re,
      r = je.current;
     je.current = Oe;
     var n = Me;
     Me = e.responseState;
     try {
      var s,
       i = e.pingedTasks;
      for (s = 0; s < i.length; s++) {
       var a = i[s],
        o = e,
        u = a.blockedSegment;
       if (0 === u.status) {
        ue(a.context);
        try {
         Ge(o, a, a.node), o.responseState.generateStaticMarkup || (u.lastPushedText && u.textEmbedded && u.chunks.push('\x3c!-- --\x3e')), a.abortSet.delete(a), (u.status = 1), tt(o, a.blockedBoundary, u);
        } catch (d) {
         if ((ke(), 'object' == typeof d && null !== d && 'function' == typeof d.then)) {
          var l = a.ping;
          d.then(l, l);
         } else {
          a.abortSet.delete(a), (u.status = 4);
          var p = a.blockedBoundary,
           c = d,
           h = He(o, c);
          if ((null === p ? ze(o, c) : (p.pendingTasks--, p.forceClientRender || ((p.forceClientRender = !0), (p.errorDigest = h), p.parentFlushed && o.clientRenderedBoundaries.push(p))), o.allPendingTasks--, 0 === o.allPendingTasks)) (0, o.onAllReady)();
         }
        }
       }
      }
      i.splice(0, s), null !== e.destination && ut(e, e.destination);
     } catch (d) {
      He(e, d), ze(e, d);
     } finally {
      (Me = n), (je.current = r), r === Oe && ue(t);
     }
    }
   }
   function nt(e, t, r) {
    switch (((r.parentFlushed = !0), r.status)) {
     case 0:
      var n = (r.id = e.nextSegmentId++);
      return (r.lastPushedText = !1), (r.textEmbedded = !1), (e = e.responseState), t.push('<template id="'), t.push(e.placeholderPrefix), (e = n.toString(16)), t.push(e), t.push('"></template>');
     case 1:
      r.status = 2;
      var i = !0;
      n = r.chunks;
      var a = 0;
      r = r.children;
      for (var o = 0; o < r.length; o++) {
       for (i = r[o]; a < i.index; a++) t.push(n[a]);
       i = st(e, t, i);
      }
      for (; a < n.length - 1; a++) t.push(n[a]);
      return a < n.length && (i = t.push(n[a])), i;
     default:
      throw Error(s(390));
    }
   }
   function st(e, t, r) {
    var n = r.boundary;
    if (null === n) return nt(e, t, r);
    if (((n.parentFlushed = !0), n.forceClientRender)) return e.responseState.generateStaticMarkup || ((n = n.errorDigest), t.push('\x3c!--$!--\x3e'), t.push('<template'), n && (t.push(' data-dgst="'), (n = g(n)), t.push(n), t.push('"')), t.push('></template>')), nt(e, t, r), (e = !!e.responseState.generateStaticMarkup || t.push('\x3c!--/$--\x3e'));
    if (0 < n.pendingTasks) {
     (n.rootSegmentID = e.nextSegmentId++), 0 < n.completedSegments.length && e.partialBoundaries.push(n);
     var i = e.responseState,
      a = i.nextSuspenseID++;
     return (i = i.boundaryPrefix + a.toString(16)), (n = n.id = i), I(t, e.responseState, n), nt(e, t, r), t.push('\x3c!--/$--\x3e');
    }
    if (n.byteSize > e.progressiveChunkSize) return (n.rootSegmentID = e.nextSegmentId++), e.completedBoundaries.push(n), I(t, e.responseState, n.id), nt(e, t, r), t.push('\x3c!--/$--\x3e');
    if ((e.responseState.generateStaticMarkup || t.push('\x3c!--$--\x3e'), 1 !== (r = n.completedSegments).length)) throw Error(s(391));
    return st(e, t, r[0]), (e = !!e.responseState.generateStaticMarkup || t.push('\x3c!--/$--\x3e'));
   }
   function it(e, t, r) {
    return (
     (function (e, t, r, n) {
      switch (r.insertionMode) {
       case 0:
       case 1:
        return e.push('<div hidden id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 2:
        return e.push('<svg aria-hidden="true" style="display:none" id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 3:
        return e.push('<math aria-hidden="true" style="display:none" id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 4:
        return e.push('<table hidden id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 5:
        return e.push('<table hidden><tbody id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 6:
        return e.push('<table hidden><tr id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 7:
        return e.push('<table hidden><colgroup id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       default:
        throw Error(s(397));
      }
     })(t, e.responseState, r.formatContext, r.id),
     st(e, t, r),
     (function (e, t) {
      switch (t.insertionMode) {
       case 0:
       case 1:
        return e.push('</div>');
       case 2:
        return e.push('</svg>');
       case 3:
        return e.push('</math>');
       case 4:
        return e.push('</table>');
       case 5:
        return e.push('</tbody></table>');
       case 6:
        return e.push('</tr></table>');
       case 7:
        return e.push('</colgroup></table>');
       default:
        throw Error(s(397));
      }
     })(t, r.formatContext)
    );
   }
   function at(e, t, r) {
    for (var n = r.completedSegments, i = 0; i < n.length; i++) ot(e, t, r, n[i]);
    if (((n.length = 0), (e = e.responseState), (n = r.id), (r = r.rootSegmentID), t.push(e.startInlineScript), e.sentCompleteBoundaryFunction ? t.push('$RC("') : ((e.sentCompleteBoundaryFunction = !0), t.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), null === n)) throw Error(s(395));
    return (r = r.toString(16)), t.push(n), t.push('","'), t.push(e.segmentPrefix), t.push(r), t.push('")</script>');
   }
   function ot(e, t, r, n) {
    if (2 === n.status) return !0;
    var i = n.id;
    if (-1 === i) {
     if (-1 === (n.id = r.rootSegmentID)) throw Error(s(392));
     return it(e, t, n);
    }
    return it(e, t, n), (e = e.responseState), t.push(e.startInlineScript), e.sentCompleteSegmentFunction ? t.push('$RS("') : ((e.sentCompleteSegmentFunction = !0), t.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), t.push(e.segmentPrefix), (i = i.toString(16)), t.push(i), t.push('","'), t.push(e.placeholderPrefix), t.push(i), t.push('")</script>');
   }
   function ut(e, t) {
    try {
     var r = e.completedRootSegment;
     if (null !== r && 0 === e.pendingRootTasks) {
      st(e, t, r), (e.completedRootSegment = null);
      var n = e.responseState.bootstrapChunks;
      for (r = 0; r < n.length - 1; r++) t.push(n[r]);
      r < n.length && t.push(n[r]);
     }
     var i,
      a = e.clientRenderedBoundaries;
     for (i = 0; i < a.length; i++) {
      var o = a[i];
      n = t;
      var u = e.responseState,
       l = o.id,
       p = o.errorDigest,
       c = o.errorMessage,
       h = o.errorComponentStack;
      if ((n.push(u.startInlineScript), u.sentClientRenderFunction ? n.push('$RX("') : ((u.sentClientRenderFunction = !0), n.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), null === l)) throw Error(s(395));
      if ((n.push(l), n.push('"'), p || c || h)) {
       n.push(',');
       var d = B(p || '');
       n.push(d);
      }
      if (c || h) {
       n.push(',');
       var f = B(c || '');
       n.push(f);
      }
      if (h) {
       n.push(',');
       var m = B(h);
       n.push(m);
      }
      if (!n.push(')</script>')) return (e.destination = null), i++, void a.splice(0, i);
     }
     a.splice(0, i);
     var y = e.completedBoundaries;
     for (i = 0; i < y.length; i++) if (!at(e, t, y[i])) return (e.destination = null), i++, void y.splice(0, i);
     y.splice(0, i);
     var g = e.partialBoundaries;
     for (i = 0; i < g.length; i++) {
      var D = g[i];
      e: {
       (a = e), (o = t);
       var x = D.completedSegments;
       for (u = 0; u < x.length; u++)
        if (!ot(a, o, D, x[u])) {
         u++, x.splice(0, u);
         var b = !1;
         break e;
        }
       x.splice(0, u), (b = !0);
      }
      if (!b) return (e.destination = null), i++, void g.splice(0, i);
     }
     g.splice(0, i);
     var v = e.completedBoundaries;
     for (i = 0; i < v.length; i++) if (!at(e, t, v[i])) return (e.destination = null), i++, void v.splice(0, i);
     v.splice(0, i);
    } finally {
     0 === e.allPendingTasks && 0 === e.pingedTasks.length && 0 === e.clientRenderedBoundaries.length && 0 === e.completedBoundaries.length && t.push(null);
    }
   }
   function lt(e, t) {
    try {
     var r = e.abortableTasks;
     r.forEach(function (r) {
      return Ze(r, e, t);
     }),
      r.clear(),
      null !== e.destination && ut(e, e.destination);
    } catch (n) {
     He(e, n), ze(e, n);
    }
   }
   function pt() {}
   function ct(e, t, r, n) {
    var i = !1,
     a = null,
     o = '',
     u = {
      push: function (e) {
       return null !== e && (o += e), !0;
      },
      destroy: function (e) {
       (i = !0), (a = e);
      },
     },
     l = !1;
    if (
     ((e = (function (e, t, r, n, s, i, a, o, u) {
      var l = [],
       p = new Set();
      return ((r = $e((t = { destination: null, responseState: t, progressiveChunkSize: void 0 === n ? 12800 : n, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: p, pingedTasks: l, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === s ? Re : s, onAllReady: void 0 === i ? qe : i, onShellReady: void 0 === a ? qe : a, onShellError: void 0 === o ? qe : o, onFatalError: void 0 === u ? qe : u }), 0, null, r, !1, !1)).parentFlushed = !0), (e = Ue(t, e, null, r, p, ee, null, ce)), l.push(e), t;
     })(
      e,
      (function (e, t) {
       return { bootstrapChunks: [], startInlineScript: '<script>', placeholderPrefix: (t = void 0 === t ? '' : t) + 'P:', segmentPrefix: t + 'S:', boundaryPrefix: t + 'B:', idPrefix: t, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: e };
      })(r, t ? t.identifierPrefix : void 0),
      { insertionMode: 1, selectedValue: null },
      1 / 0,
      pt,
      void 0,
      function () {
       l = !0;
      },
      void 0,
      void 0,
     )),
     rt(e),
     lt(e, n),
     1 === e.status)
    )
     (e.status = 2), u.destroy(e.fatalError);
    else if (2 !== e.status && null === e.destination) {
     e.destination = u;
     try {
      ut(e, u);
     } catch (p) {
      He(e, p), ze(e, p);
     }
    }
    if (i) throw a;
    if (!l) throw Error(s(426));
    return o;
   }
   (t.renderToNodeStream = function () {
    throw Error(s(207));
   }),
    (t.renderToStaticMarkup = function (e, t) {
     return ct(e, t, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }),
    (t.renderToStaticNodeStream = function () {
     throw Error(s(208));
    }),
    (t.renderToString = function (e, t) {
     return ct(e, t, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }),
    (t.version = '18.3.1');
  },
  2910: (e, t, r) => {
   var n = r(75271);
   function s(e) {
    for (var t = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, r = 1; r < arguments.length; r++) t += '&args[]=' + encodeURIComponent(arguments[r]);
    return 'Minified React error #' + e + '; visit ' + t + ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.';
   }
   var i = null,
    a = 0;
   function o(e, t) {
    if (0 !== t.length)
     if (512 < t.length) 0 < a && (e.enqueue(new Uint8Array(i.buffer, 0, a)), (i = new Uint8Array(512)), (a = 0)), e.enqueue(t);
     else {
      var r = i.length - a;
      r < t.length && (0 === r ? e.enqueue(i) : (i.set(t.subarray(0, r), a), e.enqueue(i), (t = t.subarray(r))), (i = new Uint8Array(512)), (a = 0)), i.set(t, a), (a += t.length);
     }
   }
   function u(e, t) {
    return o(e, t), !0;
   }
   function l(e) {
    i && 0 < a && (e.enqueue(new Uint8Array(i.buffer, 0, a)), (i = null), (a = 0));
   }
   var p = new TextEncoder();
   function c(e) {
    return p.encode(e);
   }
   function h(e) {
    return p.encode(e);
   }
   function d(e, t) {
    'function' == typeof e.error ? e.error(t) : e.close();
   }
   var f = Object.prototype.hasOwnProperty,
    m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    y = {},
    g = {};
   function D(e) {
    return !!f.call(g, e) || (!f.call(y, e) && (m.test(e) ? (g[e] = !0) : ((y[e] = !0), !1)));
   }
   function x(e, t, r, n, s, i, a) {
    (this.acceptsBooleans = 2 === t || 3 === t || 4 === t), (this.attributeName = n), (this.attributeNamespace = s), (this.mustUseProperty = r), (this.propertyName = e), (this.type = t), (this.sanitizeURL = i), (this.removeEmptyString = a);
   }
   var b = {};
   'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'.split(' ').forEach(function (e) {
    b[e] = new x(e, 0, !1, e, null, !1, !1);
   }),
    [
     ['acceptCharset', 'accept-charset'],
     ['className', 'class'],
     ['htmlFor', 'for'],
     ['httpEquiv', 'http-equiv'],
    ].forEach(function (e) {
     var t = e[0];
     b[t] = new x(t, 1, !1, e[1], null, !1, !1);
    }),
    ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
     b[e] = new x(e, 2, !1, e.toLowerCase(), null, !1, !1);
    }),
    ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) {
     b[e] = new x(e, 2, !1, e, null, !1, !1);
    }),
    'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'.split(' ').forEach(function (e) {
     b[e] = new x(e, 3, !1, e.toLowerCase(), null, !1, !1);
    }),
    ['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
     b[e] = new x(e, 3, !0, e, null, !1, !1);
    }),
    ['capture', 'download'].forEach(function (e) {
     b[e] = new x(e, 4, !1, e, null, !1, !1);
    }),
    ['cols', 'rows', 'size', 'span'].forEach(function (e) {
     b[e] = new x(e, 6, !1, e, null, !1, !1);
    }),
    ['rowSpan', 'start'].forEach(function (e) {
     b[e] = new x(e, 5, !1, e.toLowerCase(), null, !1, !1);
    });
   var v = /[\-:]([a-z])/g;
   function E(e) {
    return e[1].toUpperCase();
   }
   'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'.split(' ').forEach(function (e) {
    var t = e.replace(v, E);
    b[t] = new x(t, 1, !1, e, null, !1, !1);
   }),
    'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach(function (e) {
     var t = e.replace(v, E);
     b[t] = new x(t, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1);
    }),
    ['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
     var t = e.replace(v, E);
     b[t] = new x(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1);
    }),
    ['tabIndex', 'crossOrigin'].forEach(function (e) {
     b[e] = new x(e, 1, !1, e.toLowerCase(), null, !1, !1);
    }),
    (b.xlinkHref = new x('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)),
    ['src', 'href', 'action', 'formAction'].forEach(function (e) {
     b[e] = new x(e, 1, !1, e.toLowerCase(), null, !0, !0);
    });
   var C = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    T = ['Webkit', 'ms', 'Moz', 'O'];
   Object.keys(C).forEach(function (e) {
    T.forEach(function (t) {
     (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (C[t] = C[e]);
    });
   });
   var S = /["'&<>]/;
   function w(e) {
    if ('boolean' == typeof e || 'number' == typeof e) return '' + e;
    e = '' + e;
    var t = S.exec(e);
    if (t) {
     var r,
      n = '',
      s = 0;
     for (r = t.index; r < e.length; r++) {
      switch (e.charCodeAt(r)) {
       case 34:
        t = '&quot;';
        break;
       case 38:
        t = '&amp;';
        break;
       case 39:
        t = '&#x27;';
        break;
       case 60:
        t = '&lt;';
        break;
       case 62:
        t = '&gt;';
        break;
       default:
        continue;
      }
      s !== r && (n += e.substring(s, r)), (s = r + 1), (n += t);
     }
     e = s !== r ? n + e.substring(s, r) : n;
    }
    return e;
   }
   var A = /([A-Z])/g,
    F = /^ms-/,
    k = Array.isArray,
    P = h('<script>'),
    I = h('</script>'),
    N = h('<script src="'),
    B = h('<script type="module" src="'),
    _ = h('" async=""></script>'),
    L = /(<\/|<)(s)(cript)/gi;
   function O(e, t, r, n) {
    return t + ('s' === r ? '\\u0073' : '\\u0053') + n;
   }
   function M(e, t) {
    return { insertionMode: e, selectedValue: t };
   }
   var j = h('\x3c!-- --\x3e');
   function R(e, t, r, n) {
    return '' === t ? n : (n && e.push(j), e.push(c(w(t))), !0);
   }
   var q = new Map(),
    U = h(' style="'),
    $ = h(':'),
    H = h(';');
   function z(e, t, r) {
    if ('object' != typeof r) throw Error(s(62));
    for (var n in ((t = !0), r))
     if (f.call(r, n)) {
      var i = r[n];
      if (null != i && 'boolean' != typeof i && '' !== i) {
       if (0 === n.indexOf('--')) {
        var a = c(w(n));
        i = c(w(('' + i).trim()));
       } else {
        a = n;
        var o = q.get(a);
        void 0 !== o || ((o = h(w(a.replace(A, '-$1').toLowerCase().replace(F, '-ms-')))), q.set(a, o)), (a = o), (i = 'number' == typeof i ? (0 === i || f.call(C, n) ? c('' + i) : c(i + 'px')) : c(w(('' + i).trim())));
       }
       t ? ((t = !1), e.push(U, a, $, i)) : e.push(H, a, $, i);
      }
     }
    t || e.push(J);
   }
   var V = h(' '),
    W = h('="'),
    J = h('"'),
    K = h('=""');
   function G(e, t, r, n) {
    switch (r) {
     case 'style':
      return void z(e, t, n);
     case 'defaultValue':
     case 'defaultChecked':
     case 'innerHTML':
     case 'suppressContentEditableWarning':
     case 'suppressHydrationWarning':
      return;
    }
    if (!(2 < r.length) || ('o' !== r[0] && 'O' !== r[0]) || ('n' !== r[1] && 'N' !== r[1]))
     if (null !== (t = b.hasOwnProperty(r) ? b[r] : null)) {
      switch (typeof n) {
       case 'function':
       case 'symbol':
        return;
       case 'boolean':
        if (!t.acceptsBooleans) return;
      }
      switch (((r = c(t.attributeName)), t.type)) {
       case 3:
        n && e.push(V, r, K);
        break;
       case 4:
        !0 === n ? e.push(V, r, K) : !1 !== n && e.push(V, r, W, c(w(n)), J);
        break;
       case 5:
        isNaN(n) || e.push(V, r, W, c(w(n)), J);
        break;
       case 6:
        !isNaN(n) && 1 <= n && e.push(V, r, W, c(w(n)), J);
        break;
       default:
        t.sanitizeURL && (n = '' + n), e.push(V, r, W, c(w(n)), J);
      }
     } else if (D(r)) {
      switch (typeof n) {
       case 'function':
       case 'symbol':
        return;
       case 'boolean':
        if ('data-' !== (t = r.toLowerCase().slice(0, 5)) && 'aria-' !== t) return;
      }
      e.push(V, c(r), W, c(w(n)), J);
     }
   }
   var X = h('>'),
    Y = h('/>');
   function Q(e, t, r) {
    if (null != t) {
     if (null != r) throw Error(s(60));
     if ('object' != typeof t || !('__html' in t)) throw Error(s(61));
     null != (t = t.__html) && e.push(c('' + t));
    }
   }
   var Z = h(' selected=""');
   function ee(e, t, r, n) {
    e.push(se(r));
    var s,
     i = (r = null);
    for (s in t)
     if (f.call(t, s)) {
      var a = t[s];
      if (null != a)
       switch (s) {
        case 'children':
         r = a;
         break;
        case 'dangerouslySetInnerHTML':
         i = a;
         break;
        default:
         G(e, n, s, a);
       }
     }
    return e.push(X), Q(e, i, r), 'string' == typeof r ? (e.push(c(w(r))), null) : r;
   }
   var te = h('\n'),
    re = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    ne = new Map();
   function se(e) {
    var t = ne.get(e);
    if (void 0 === t) {
     if (!re.test(e)) throw Error(s(65, e));
     (t = h('<' + e)), ne.set(e, t);
    }
    return t;
   }
   var ie = h('<!DOCTYPE html>');
   function ae(e, t, r, i, a) {
    switch (t) {
     case 'select':
      e.push(se('select'));
      var o = null,
       u = null;
      for (d in r)
       if (f.call(r, d)) {
        var l = r[d];
        if (null != l)
         switch (d) {
          case 'children':
           o = l;
           break;
          case 'dangerouslySetInnerHTML':
           u = l;
           break;
          case 'defaultValue':
          case 'value':
           break;
          default:
           G(e, i, d, l);
         }
       }
      return e.push(X), Q(e, u, o), o;
     case 'option':
      (u = a.selectedValue), e.push(se('option'));
      var p = (l = null),
       h = null,
       d = null;
      for (o in r)
       if (f.call(r, o)) {
        var m = r[o];
        if (null != m)
         switch (o) {
          case 'children':
           l = m;
           break;
          case 'selected':
           h = m;
           break;
          case 'dangerouslySetInnerHTML':
           d = m;
           break;
          case 'value':
           p = m;
          default:
           G(e, i, o, m);
         }
       }
      if (null != u)
       if (
        ((r =
         null !== p
          ? '' + p
          : (function (e) {
             var t = '';
             return (
              n.Children.forEach(e, function (e) {
               null != e && (t += e);
              }),
              t
             );
            })(l)),
        k(u))
       ) {
        for (i = 0; i < u.length; i++)
         if ('' + u[i] === r) {
          e.push(Z);
          break;
         }
       } else '' + u === r && e.push(Z);
      else h && e.push(Z);
      return e.push(X), Q(e, d, l), l;
     case 'textarea':
      for (l in (e.push(se('textarea')), (d = u = o = null), r))
       if (f.call(r, l) && null != (p = r[l]))
        switch (l) {
         case 'children':
          d = p;
          break;
         case 'value':
          o = p;
          break;
         case 'defaultValue':
          u = p;
          break;
         case 'dangerouslySetInnerHTML':
          throw Error(s(91));
         default:
          G(e, i, l, p);
        }
      if ((null === o && null !== u && (o = u), e.push(X), null != d)) {
       if (null != o) throw Error(s(92));
       if (k(d) && 1 < d.length) throw Error(s(93));
       o = '' + d;
      }
      return 'string' == typeof o && '\n' === o[0] && e.push(te), null !== o && e.push(c(w('' + o))), null;
     case 'input':
      for (u in (e.push(se('input')), (p = d = l = o = null), r))
       if (f.call(r, u) && null != (h = r[u]))
        switch (u) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(399, 'input'));
         case 'defaultChecked':
          p = h;
          break;
         case 'defaultValue':
          l = h;
          break;
         case 'checked':
          d = h;
          break;
         case 'value':
          o = h;
          break;
         default:
          G(e, i, u, h);
        }
      return null !== d ? G(e, i, 'checked', d) : null !== p && G(e, i, 'checked', p), null !== o ? G(e, i, 'value', o) : null !== l && G(e, i, 'value', l), e.push(Y), null;
     case 'menuitem':
      for (var y in (e.push(se('menuitem')), r))
       if (f.call(r, y) && null != (o = r[y]))
        switch (y) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(400));
         default:
          G(e, i, y, o);
        }
      return e.push(X), null;
     case 'title':
      for (m in (e.push(se('title')), (o = null), r))
       if (f.call(r, m) && null != (u = r[m]))
        switch (m) {
         case 'children':
          o = u;
          break;
         case 'dangerouslySetInnerHTML':
          throw Error(s(434));
         default:
          G(e, i, m, u);
        }
      return e.push(X), o;
     case 'listing':
     case 'pre':
      for (p in (e.push(se(t)), (u = o = null), r))
       if (f.call(r, p) && null != (l = r[p]))
        switch (p) {
         case 'children':
          o = l;
          break;
         case 'dangerouslySetInnerHTML':
          u = l;
          break;
         default:
          G(e, i, p, l);
        }
      if ((e.push(X), null != u)) {
       if (null != o) throw Error(s(60));
       if ('object' != typeof u || !('__html' in u)) throw Error(s(61));
       null != (r = u.__html) && ('string' == typeof r && 0 < r.length && '\n' === r[0] ? e.push(te, c(r)) : e.push(c('' + r)));
      }
      return 'string' == typeof o && '\n' === o[0] && e.push(te), o;
     case 'area':
     case 'base':
     case 'br':
     case 'col':
     case 'embed':
     case 'hr':
     case 'img':
     case 'keygen':
     case 'link':
     case 'meta':
     case 'param':
     case 'source':
     case 'track':
     case 'wbr':
      for (var g in (e.push(se(t)), r))
       if (f.call(r, g) && null != (o = r[g]))
        switch (g) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(399, t));
         default:
          G(e, i, g, o);
        }
      return e.push(Y), null;
     case 'annotation-xml':
     case 'color-profile':
     case 'font-face':
     case 'font-face-src':
     case 'font-face-uri':
     case 'font-face-format':
     case 'font-face-name':
     case 'missing-glyph':
      return ee(e, r, t, i);
     case 'html':
      return 0 === a.insertionMode && e.push(ie), ee(e, r, t, i);
     default:
      if (-1 === t.indexOf('-') && 'string' != typeof r.is) return ee(e, r, t, i);
      for (h in (e.push(se(t)), (u = o = null), r))
       if (f.call(r, h) && null != (l = r[h]))
        switch (h) {
         case 'children':
          o = l;
          break;
         case 'dangerouslySetInnerHTML':
          u = l;
          break;
         case 'style':
          z(e, i, l);
          break;
         case 'suppressContentEditableWarning':
         case 'suppressHydrationWarning':
          break;
         default:
          D(h) && 'function' != typeof l && 'symbol' != typeof l && e.push(V, c(h), W, c(w(l)), J);
        }
      return e.push(X), Q(e, u, o), o;
    }
   }
   var oe = h('</'),
    ue = h('>'),
    le = h('<template id="'),
    pe = h('"></template>'),
    ce = h('\x3c!--$--\x3e'),
    he = h('\x3c!--$?--\x3e<template id="'),
    de = h('"></template>'),
    fe = h('\x3c!--$!--\x3e'),
    me = h('\x3c!--/$--\x3e'),
    ye = h('<template'),
    ge = h('"'),
    De = h(' data-dgst="');
   h(' data-msg="'), h(' data-stck="');
   var xe = h('></template>');
   function be(e, t, r) {
    if ((o(e, he), null === r)) throw Error(s(395));
    return o(e, r), u(e, de);
   }
   var ve = h('<div hidden id="'),
    Ee = h('">'),
    Ce = h('</div>'),
    Te = h('<svg aria-hidden="true" style="display:none" id="'),
    Se = h('">'),
    we = h('</svg>'),
    Ae = h('<math aria-hidden="true" style="display:none" id="'),
    Fe = h('">'),
    ke = h('</math>'),
    Pe = h('<table hidden id="'),
    Ie = h('">'),
    Ne = h('</table>'),
    Be = h('<table hidden><tbody id="'),
    _e = h('">'),
    Le = h('</tbody></table>'),
    Oe = h('<table hidden><tr id="'),
    Me = h('">'),
    je = h('</tr></table>'),
    Re = h('<table hidden><colgroup id="'),
    qe = h('">'),
    Ue = h('</colgroup></table>');
   var $e = h('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'),
    He = h('$RS("'),
    ze = h('","'),
    Ve = h('")</script>'),
    We = h('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'),
    Je = h('$RC("'),
    Ke = h('","'),
    Ge = h('")</script>'),
    Xe = h('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'),
    Ye = h('$RX("'),
    Qe = h('"'),
    Ze = h(')</script>'),
    et = h(','),
    tt = /[<\u2028\u2029]/g;
   function rt(e) {
    return JSON.stringify(e).replace(tt, function (e) {
     switch (e) {
      case '<':
       return '\\u003c';
      case '\u2028':
       return '\\u2028';
      case '\u2029':
       return '\\u2029';
      default:
       throw Error('escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React');
     }
    });
   }
   var nt = Object.assign,
    st = Symbol.for('react.element'),
    it = Symbol.for('react.portal'),
    at = Symbol.for('react.fragment'),
    ot = Symbol.for('react.strict_mode'),
    ut = Symbol.for('react.profiler'),
    lt = Symbol.for('react.provider'),
    pt = Symbol.for('react.context'),
    ct = Symbol.for('react.forward_ref'),
    ht = Symbol.for('react.suspense'),
    dt = Symbol.for('react.suspense_list'),
    ft = Symbol.for('react.memo'),
    mt = Symbol.for('react.lazy'),
    yt = Symbol.for('react.scope'),
    gt = Symbol.for('react.debug_trace_mode'),
    Dt = Symbol.for('react.legacy_hidden'),
    xt = Symbol.for('react.default_value'),
    bt = Symbol.iterator;
   function vt(e) {
    if (null == e) return null;
    if ('function' == typeof e) return e.displayName || e.name || null;
    if ('string' == typeof e) return e;
    switch (e) {
     case at:
      return 'Fragment';
     case it:
      return 'Portal';
     case ut:
      return 'Profiler';
     case ot:
      return 'StrictMode';
     case ht:
      return 'Suspense';
     case dt:
      return 'SuspenseList';
    }
    if ('object' == typeof e)
     switch (e.$$typeof) {
      case pt:
       return (e.displayName || 'Context') + '.Consumer';
      case lt:
       return (e._context.displayName || 'Context') + '.Provider';
      case ct:
       var t = e.render;
       return (e = e.displayName) || (e = '' !== (e = t.displayName || t.name || '') ? 'ForwardRef(' + e + ')' : 'ForwardRef'), e;
      case ft:
       return null !== (t = e.displayName || null) ? t : vt(e.type) || 'Memo';
      case mt:
       (t = e._payload), (e = e._init);
       try {
        return vt(e(t));
       } catch (r) {}
     }
    return null;
   }
   var Et = {};
   function Ct(e, t) {
    if (!(e = e.contextTypes)) return Et;
    var r,
     n = {};
    for (r in e) n[r] = t[r];
    return n;
   }
   var Tt = null;
   function St(e, t) {
    if (e !== t) {
     (e.context._currentValue = e.parentValue), (e = e.parent);
     var r = t.parent;
     if (null === e) {
      if (null !== r) throw Error(s(401));
     } else {
      if (null === r) throw Error(s(401));
      St(e, r);
     }
     t.context._currentValue = t.value;
    }
   }
   function wt(e) {
    (e.context._currentValue = e.parentValue), null !== (e = e.parent) && wt(e);
   }
   function At(e) {
    var t = e.parent;
    null !== t && At(t), (e.context._currentValue = e.value);
   }
   function Ft(e, t) {
    if (((e.context._currentValue = e.parentValue), null === (e = e.parent))) throw Error(s(402));
    e.depth === t.depth ? St(e, t) : Ft(e, t);
   }
   function kt(e, t) {
    var r = t.parent;
    if (null === r) throw Error(s(402));
    e.depth === r.depth ? St(e, r) : kt(e, r), (t.context._currentValue = t.value);
   }
   function Pt(e) {
    var t = Tt;
    t !== e && (null === t ? At(e) : null === e ? wt(t) : t.depth === e.depth ? St(t, e) : t.depth > e.depth ? Ft(t, e) : kt(t, e), (Tt = e));
   }
   var It = {
    isMounted: function () {
     return !1;
    },
    enqueueSetState: function (e, t) {
     null !== (e = e._reactInternals).queue && e.queue.push(t);
    },
    enqueueReplaceState: function (e, t) {
     ((e = e._reactInternals).replace = !0), (e.queue = [t]);
    },
    enqueueForceUpdate: function () {},
   };
   function Nt(e, t, r, n) {
    var s = void 0 !== e.state ? e.state : null;
    (e.updater = It), (e.props = r), (e.state = s);
    var i = { queue: [], replace: !1 };
    e._reactInternals = i;
    var a = t.contextType;
    if (((e.context = 'object' == typeof a && null !== a ? a._currentValue : n), 'function' == typeof (a = t.getDerivedStateFromProps) && ((s = null == (a = a(r, s)) ? s : nt({}, s, a)), (e.state = s)), 'function' != typeof t.getDerivedStateFromProps && 'function' != typeof e.getSnapshotBeforeUpdate && ('function' == typeof e.UNSAFE_componentWillMount || 'function' == typeof e.componentWillMount)))
     if (((t = e.state), 'function' == typeof e.componentWillMount && e.componentWillMount(), 'function' == typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), t !== e.state && It.enqueueReplaceState(e, e.state, null), null !== i.queue && 0 < i.queue.length))
      if (((t = i.queue), (a = i.replace), (i.queue = null), (i.replace = !1), a && 1 === t.length)) e.state = t[0];
      else {
       for (i = a ? t[0] : e.state, s = !0, a = a ? 1 : 0; a < t.length; a++) {
        var o = t[a];
        null != (o = 'function' == typeof o ? o.call(e, i, r, n) : o) && (s ? ((s = !1), (i = nt({}, i, o))) : nt(i, o));
       }
       e.state = i;
      }
     else i.queue = null;
   }
   var Bt = { id: 1, overflow: '' };
   function _t(e, t, r) {
    var n = e.id;
    e = e.overflow;
    var s = 32 - Lt(n) - 1;
    (n &= ~(1 << s)), (r += 1);
    var i = 32 - Lt(t) + s;
    if (30 < i) {
     var a = s - (s % 5);
     return (i = (n & ((1 << a) - 1)).toString(32)), (n >>= a), (s -= a), { id: (1 << (32 - Lt(t) + s)) | (r << s) | n, overflow: i + e };
    }
    return { id: (1 << i) | (r << s) | n, overflow: e };
   }
   var Lt = Math.clz32
     ? Math.clz32
     : function (e) {
        return 0 === (e >>>= 0) ? 32 : (31 - ((Ot(e) / Mt) | 0)) | 0;
       },
    Ot = Math.log,
    Mt = Math.LN2;
   var jt =
     'function' == typeof Object.is
      ? Object.is
      : function (e, t) {
         return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
        },
    Rt = null,
    qt = null,
    Ut = null,
    $t = null,
    Ht = !1,
    zt = !1,
    Vt = 0,
    Wt = null,
    Jt = 0;
   function Kt() {
    if (null === Rt) throw Error(s(321));
    return Rt;
   }
   function Gt() {
    if (0 < Jt) throw Error(s(312));
    return { memoizedState: null, queue: null, next: null };
   }
   function Xt() {
    return null === $t ? (null === Ut ? ((Ht = !1), (Ut = $t = Gt())) : ((Ht = !0), ($t = Ut))) : null === $t.next ? ((Ht = !1), ($t = $t.next = Gt())) : ((Ht = !0), ($t = $t.next)), $t;
   }
   function Yt() {
    (qt = Rt = null), (zt = !1), (Ut = null), (Jt = 0), ($t = Wt = null);
   }
   function Qt(e, t) {
    return 'function' == typeof t ? t(e) : t;
   }
   function Zt(e, t, r) {
    if (((Rt = Kt()), ($t = Xt()), Ht)) {
     var n = $t.queue;
     if (((t = n.dispatch), null !== Wt && void 0 !== (r = Wt.get(n)))) {
      Wt.delete(n), (n = $t.memoizedState);
      do {
       (n = e(n, r.action)), (r = r.next);
      } while (null !== r);
      return ($t.memoizedState = n), [n, t];
     }
     return [$t.memoizedState, t];
    }
    return (e = e === Qt ? ('function' == typeof t ? t() : t) : void 0 !== r ? r(t) : t), ($t.memoizedState = e), (e = (e = $t.queue = { last: null, dispatch: null }).dispatch = tr.bind(null, Rt, e)), [$t.memoizedState, e];
   }
   function er(e, t) {
    if (((Rt = Kt()), (t = void 0 === t ? null : t), null !== ($t = Xt()))) {
     var r = $t.memoizedState;
     if (null !== r && null !== t) {
      var n = r[1];
      e: if (null === n) n = !1;
      else {
       for (var s = 0; s < n.length && s < t.length; s++)
        if (!jt(t[s], n[s])) {
         n = !1;
         break e;
        }
       n = !0;
      }
      if (n) return r[0];
     }
    }
    return (e = e()), ($t.memoizedState = [e, t]), e;
   }
   function tr(e, t, r) {
    if (25 <= Jt) throw Error(s(301));
    if (e === Rt)
     if (((zt = !0), (e = { action: r, next: null }), null === Wt && (Wt = new Map()), void 0 === (r = Wt.get(t)))) Wt.set(t, e);
     else {
      for (t = r; null !== t.next; ) t = t.next;
      t.next = e;
     }
   }
   function rr() {
    throw Error(s(394));
   }
   function nr() {}
   var sr = {
     readContext: function (e) {
      return e._currentValue;
     },
     useContext: function (e) {
      return Kt(), e._currentValue;
     },
     useMemo: er,
     useReducer: Zt,
     useRef: function (e) {
      Rt = Kt();
      var t = ($t = Xt()).memoizedState;
      return null === t ? ((e = { current: e }), ($t.memoizedState = e)) : t;
     },
     useState: function (e) {
      return Zt(Qt, e);
     },
     useInsertionEffect: nr,
     useLayoutEffect: function () {},
     useCallback: function (e, t) {
      return er(function () {
       return e;
      }, t);
     },
     useImperativeHandle: nr,
     useEffect: nr,
     useDebugValue: nr,
     useDeferredValue: function (e) {
      return Kt(), e;
     },
     useTransition: function () {
      return Kt(), [!1, rr];
     },
     useId: function () {
      var e = qt.treeContext,
       t = e.overflow;
      e = ((e = e.id) & ~(1 << (32 - Lt(e) - 1))).toString(32) + t;
      var r = ir;
      if (null === r) throw Error(s(404));
      return (t = Vt++), (e = ':' + r.idPrefix + 'R' + e), 0 < t && (e += 'H' + t.toString(32)), e + ':';
     },
     useMutableSource: function (e, t) {
      return Kt(), t(e._source);
     },
     useSyncExternalStore: function (e, t, r) {
      if (void 0 === r) throw Error(s(407));
      return r();
     },
    },
    ir = null,
    ar = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
   function or(e) {
    return console.error(e), null;
   }
   function ur() {}
   function lr(e, t, r, n, s, i, a, o) {
    e.allPendingTasks++, null === r ? e.pendingRootTasks++ : r.pendingTasks++;
    var u = {
     node: t,
     ping: function () {
      var t = e.pingedTasks;
      t.push(u), 1 === t.length && Tr(e);
     },
     blockedBoundary: r,
     blockedSegment: n,
     abortSet: s,
     legacyContext: i,
     context: a,
     treeContext: o,
    };
    return s.add(u), u;
   }
   function pr(e, t, r, n, s, i) {
    return { status: 0, id: -1, index: t, parentFlushed: !1, chunks: [], children: [], formatContext: n, boundary: r, lastPushedText: s, textEmbedded: i };
   }
   function cr(e, t) {
    if (null != (e = e.onError(t)) && 'string' != typeof e) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof e + '" instead');
    return e;
   }
   function hr(e, t) {
    var r = e.onShellError;
    r(t), (r = e.onFatalError)(t), null !== e.destination ? ((e.status = 2), d(e.destination, t)) : ((e.status = 1), (e.fatalError = t));
   }
   function dr(e, t, r, n, s) {
    for (Rt = {}, qt = t, Vt = 0, e = r(n, s); zt; ) (zt = !1), (Vt = 0), (Jt += 1), ($t = null), (e = r(n, s));
    return Yt(), e;
   }
   function fr(e, t, r, n) {
    var i = r.render(),
     a = n.childContextTypes;
    if (null != a) {
     var o = t.legacyContext;
     if ('function' != typeof r.getChildContext) n = o;
     else {
      for (var u in (r = r.getChildContext())) if (!(u in a)) throw Error(s(108, vt(n) || 'Unknown', u));
      n = nt({}, o, r);
     }
     (t.legacyContext = n), gr(e, t, i), (t.legacyContext = o);
    } else gr(e, t, i);
   }
   function mr(e, t) {
    if (e && e.defaultProps) {
     for (var r in ((t = nt({}, t)), (e = e.defaultProps))) void 0 === t[r] && (t[r] = e[r]);
     return t;
    }
    return t;
   }
   function yr(e, t, r, n, i) {
    if ('function' == typeof r)
     if (r.prototype && r.prototype.isReactComponent) {
      i = Ct(r, t.legacyContext);
      var a = r.contextType;
      Nt((a = new r(n, 'object' == typeof a && null !== a ? a._currentValue : i)), r, n, i), fr(e, t, a, r);
     } else {
      i = dr(e, t, r, n, (a = Ct(r, t.legacyContext)));
      var o = 0 !== Vt;
      if ('object' == typeof i && null !== i && 'function' == typeof i.render && void 0 === i.$$typeof) Nt(i, r, n, a), fr(e, t, i, r);
      else if (o) {
       (n = t.treeContext), (t.treeContext = _t(n, 1, 0));
       try {
        gr(e, t, i);
       } finally {
        t.treeContext = n;
       }
      } else gr(e, t, i);
     }
    else {
     if ('string' != typeof r) {
      switch (r) {
       case Dt:
       case gt:
       case ot:
       case ut:
       case at:
       case dt:
        return void gr(e, t, n.children);
       case yt:
        throw Error(s(343));
       case ht:
        e: {
         (r = t.blockedBoundary), (i = t.blockedSegment), (a = n.fallback), (n = n.children);
         var u = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: (o = new Set()), errorDigest: null },
          l = pr(0, i.chunks.length, u, i.formatContext, !1, !1);
         i.children.push(l), (i.lastPushedText = !1);
         var p = pr(0, 0, null, i.formatContext, !1, !1);
         (p.parentFlushed = !0), (t.blockedBoundary = u), (t.blockedSegment = p);
         try {
          if ((xr(e, t, n), p.lastPushedText && p.textEmbedded && p.chunks.push(j), (p.status = 1), Er(u, p), 0 === u.pendingTasks)) break e;
         } catch (h) {
          (p.status = 4), (u.forceClientRender = !0), (u.errorDigest = cr(e, h));
         } finally {
          (t.blockedBoundary = r), (t.blockedSegment = i);
         }
         (t = lr(e, a, r, l, o, t.legacyContext, t.context, t.treeContext)), e.pingedTasks.push(t);
        }
        return;
      }
      if ('object' == typeof r && null !== r)
       switch (r.$$typeof) {
        case ct:
         if (((n = dr(e, t, r.render, n, i)), 0 !== Vt)) {
          (r = t.treeContext), (t.treeContext = _t(r, 1, 0));
          try {
           gr(e, t, n);
          } finally {
           t.treeContext = r;
          }
         } else gr(e, t, n);
         return;
        case ft:
         return void yr(e, t, (r = r.type), (n = mr(r, n)), i);
        case lt:
         if (((i = n.children), (r = r._context), (n = n.value), (a = r._currentValue), (r._currentValue = n), (Tt = n = { parent: (o = Tt), depth: null === o ? 0 : o.depth + 1, context: r, parentValue: a, value: n }), (t.context = n), gr(e, t, i), null === (e = Tt))) throw Error(s(403));
         return (n = e.parentValue), (e.context._currentValue = n === xt ? e.context._defaultValue : n), (e = Tt = e.parent), void (t.context = e);
        case pt:
         return void gr(e, t, (n = (n = n.children)(r._currentValue)));
        case mt:
         return void yr(e, t, (r = (i = r._init)(r._payload)), (n = mr(r, n)), void 0);
       }
      throw Error(s(130, null == r ? r : typeof r, ''));
     }
     switch (
      ((a = ae((i = t.blockedSegment).chunks, r, n, e.responseState, i.formatContext)),
      (i.lastPushedText = !1),
      (o = i.formatContext),
      (i.formatContext = (function (e, t, r) {
       switch (t) {
        case 'select':
         return M(1, null != r.value ? r.value : r.defaultValue);
        case 'svg':
         return M(2, null);
        case 'math':
         return M(3, null);
        case 'foreignObject':
         return M(1, null);
        case 'table':
         return M(4, null);
        case 'thead':
        case 'tbody':
        case 'tfoot':
         return M(5, null);
        case 'colgroup':
         return M(7, null);
        case 'tr':
         return M(6, null);
       }
       return 4 <= e.insertionMode || 0 === e.insertionMode ? M(1, null) : e;
      })(o, r, n)),
      xr(e, t, a),
      (i.formatContext = o),
      r)
     ) {
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'img':
      case 'input':
      case 'keygen':
      case 'link':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
       break;
      default:
       i.chunks.push(oe, c(r), ue);
     }
     i.lastPushedText = !1;
    }
   }
   function gr(e, t, r) {
    if (((t.node = r), 'object' == typeof r && null !== r)) {
     switch (r.$$typeof) {
      case st:
       return void yr(e, t, r.type, r.props, r.ref);
      case it:
       throw Error(s(257));
      case mt:
       var n = r._init;
       return void gr(e, t, (r = n(r._payload)));
     }
     if (k(r)) return void Dr(e, t, r);
     if ((null === r || 'object' != typeof r ? (n = null) : (n = 'function' == typeof (n = (bt && r[bt]) || r['@@iterator']) ? n : null), n && (n = n.call(r)))) {
      if (!(r = n.next()).done) {
       var i = [];
       do {
        i.push(r.value), (r = n.next());
       } while (!r.done);
       Dr(e, t, i);
      }
      return;
     }
     throw ((e = Object.prototype.toString.call(r)), Error(s(31, '[object Object]' === e ? 'object with keys {' + Object.keys(r).join(', ') + '}' : e)));
    }
    'string' == typeof r ? ((n = t.blockedSegment).lastPushedText = R(t.blockedSegment.chunks, r, e.responseState, n.lastPushedText)) : 'number' == typeof r && ((n = t.blockedSegment).lastPushedText = R(t.blockedSegment.chunks, '' + r, e.responseState, n.lastPushedText));
   }
   function Dr(e, t, r) {
    for (var n = r.length, s = 0; s < n; s++) {
     var i = t.treeContext;
     t.treeContext = _t(i, n, s);
     try {
      xr(e, t, r[s]);
     } finally {
      t.treeContext = i;
     }
    }
   }
   function xr(e, t, r) {
    var n = t.blockedSegment.formatContext,
     s = t.legacyContext,
     i = t.context;
    try {
     return gr(e, t, r);
    } catch (u) {
     if ((Yt(), 'object' != typeof u || null === u || 'function' != typeof u.then)) throw ((t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), Pt(i), u);
     r = u;
     var a = t.blockedSegment,
      o = pr(0, a.chunks.length, null, a.formatContext, a.lastPushedText, !0);
     a.children.push(o), (a.lastPushedText = !1), (e = lr(e, t.node, t.blockedBoundary, o, t.abortSet, t.legacyContext, t.context, t.treeContext).ping), r.then(e, e), (t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), Pt(i);
    }
   }
   function br(e) {
    var t = e.blockedBoundary;
    ((e = e.blockedSegment).status = 3), Cr(this, t, e);
   }
   function vr(e, t, r) {
    var n = e.blockedBoundary;
    (e.blockedSegment.status = 3),
     null === n
      ? (t.allPendingTasks--, 2 !== t.status && ((t.status = 2), null !== t.destination && t.destination.close()))
      : (n.pendingTasks--,
        n.forceClientRender || ((n.forceClientRender = !0), (e = void 0 === r ? Error(s(432)) : r), (n.errorDigest = t.onError(e)), n.parentFlushed && t.clientRenderedBoundaries.push(n)),
        n.fallbackAbortableTasks.forEach(function (e) {
         return vr(e, t, r);
        }),
        n.fallbackAbortableTasks.clear(),
        t.allPendingTasks--,
        0 === t.allPendingTasks && (n = t.onAllReady)());
   }
   function Er(e, t) {
    if (0 === t.chunks.length && 1 === t.children.length && null === t.children[0].boundary) {
     var r = t.children[0];
     (r.id = t.id), (r.parentFlushed = !0), 1 === r.status && Er(e, r);
    } else e.completedSegments.push(t);
   }
   function Cr(e, t, r) {
    if (null === t) {
     if (r.parentFlushed) {
      if (null !== e.completedRootSegment) throw Error(s(389));
      e.completedRootSegment = r;
     }
     e.pendingRootTasks--, 0 === e.pendingRootTasks && ((e.onShellError = ur), (t = e.onShellReady)());
    } else t.pendingTasks--, t.forceClientRender || (0 === t.pendingTasks ? (r.parentFlushed && 1 === r.status && Er(t, r), t.parentFlushed && e.completedBoundaries.push(t), t.fallbackAbortableTasks.forEach(br, e), t.fallbackAbortableTasks.clear()) : r.parentFlushed && 1 === r.status && (Er(t, r), 1 === t.completedSegments.length && t.parentFlushed && e.partialBoundaries.push(t)));
    e.allPendingTasks--, 0 === e.allPendingTasks && (e = e.onAllReady)();
   }
   function Tr(e) {
    if (2 !== e.status) {
     var t = Tt,
      r = ar.current;
     ar.current = sr;
     var n = ir;
     ir = e.responseState;
     try {
      var s,
       i = e.pingedTasks;
      for (s = 0; s < i.length; s++) {
       var a = i[s],
        o = e,
        u = a.blockedSegment;
       if (0 === u.status) {
        Pt(a.context);
        try {
         gr(o, a, a.node), u.lastPushedText && u.textEmbedded && u.chunks.push(j), a.abortSet.delete(a), (u.status = 1), Cr(o, a.blockedBoundary, u);
        } catch (d) {
         if ((Yt(), 'object' == typeof d && null !== d && 'function' == typeof d.then)) {
          var l = a.ping;
          d.then(l, l);
         } else {
          a.abortSet.delete(a), (u.status = 4);
          var p = a.blockedBoundary,
           c = d,
           h = cr(o, c);
          if ((null === p ? hr(o, c) : (p.pendingTasks--, p.forceClientRender || ((p.forceClientRender = !0), (p.errorDigest = h), p.parentFlushed && o.clientRenderedBoundaries.push(p))), o.allPendingTasks--, 0 === o.allPendingTasks)) (0, o.onAllReady)();
         }
        }
       }
      }
      i.splice(0, s), null !== e.destination && Pr(e, e.destination);
     } catch (d) {
      cr(e, d), hr(e, d);
     } finally {
      (ir = n), (ar.current = r), r === sr && Pt(t);
     }
    }
   }
   function Sr(e, t, r) {
    switch (((r.parentFlushed = !0), r.status)) {
     case 0:
      var n = (r.id = e.nextSegmentId++);
      return (r.lastPushedText = !1), (r.textEmbedded = !1), (e = e.responseState), o(t, le), o(t, e.placeholderPrefix), o(t, (e = c(n.toString(16)))), u(t, pe);
     case 1:
      r.status = 2;
      var i = !0;
      n = r.chunks;
      var a = 0;
      r = r.children;
      for (var l = 0; l < r.length; l++) {
       for (i = r[l]; a < i.index; a++) o(t, n[a]);
       i = wr(e, t, i);
      }
      for (; a < n.length - 1; a++) o(t, n[a]);
      return a < n.length && (i = u(t, n[a])), i;
     default:
      throw Error(s(390));
    }
   }
   function wr(e, t, r) {
    var n = r.boundary;
    if (null === n) return Sr(e, t, r);
    if (((n.parentFlushed = !0), n.forceClientRender)) (n = n.errorDigest), u(t, fe), o(t, ye), n && (o(t, De), o(t, c(w(n))), o(t, ge)), u(t, xe), Sr(e, t, r);
    else if (0 < n.pendingTasks) {
     (n.rootSegmentID = e.nextSegmentId++), 0 < n.completedSegments.length && e.partialBoundaries.push(n);
     var i = e.responseState,
      a = i.nextSuspenseID++;
     (i = h(i.boundaryPrefix + a.toString(16))), (n = n.id = i), be(t, e.responseState, n), Sr(e, t, r);
    } else if (n.byteSize > e.progressiveChunkSize) (n.rootSegmentID = e.nextSegmentId++), e.completedBoundaries.push(n), be(t, e.responseState, n.id), Sr(e, t, r);
    else {
     if ((u(t, ce), 1 !== (r = n.completedSegments).length)) throw Error(s(391));
     wr(e, t, r[0]);
    }
    return u(t, me);
   }
   function Ar(e, t, r) {
    return (
     (function (e, t, r, n) {
      switch (r.insertionMode) {
       case 0:
       case 1:
        return o(e, ve), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Ee);
       case 2:
        return o(e, Te), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Se);
       case 3:
        return o(e, Ae), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Fe);
       case 4:
        return o(e, Pe), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Ie);
       case 5:
        return o(e, Be), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, _e);
       case 6:
        return o(e, Oe), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Me);
       case 7:
        return o(e, Re), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, qe);
       default:
        throw Error(s(397));
      }
     })(t, e.responseState, r.formatContext, r.id),
     wr(e, t, r),
     (function (e, t) {
      switch (t.insertionMode) {
       case 0:
       case 1:
        return u(e, Ce);
       case 2:
        return u(e, we);
       case 3:
        return u(e, ke);
       case 4:
        return u(e, Ne);
       case 5:
        return u(e, Le);
       case 6:
        return u(e, je);
       case 7:
        return u(e, Ue);
       default:
        throw Error(s(397));
      }
     })(t, r.formatContext)
    );
   }
   function Fr(e, t, r) {
    for (var n = r.completedSegments, i = 0; i < n.length; i++) kr(e, t, r, n[i]);
    if (((n.length = 0), (e = e.responseState), (n = r.id), (r = r.rootSegmentID), o(t, e.startInlineScript), e.sentCompleteBoundaryFunction ? o(t, Je) : ((e.sentCompleteBoundaryFunction = !0), o(t, We)), null === n)) throw Error(s(395));
    return (r = c(r.toString(16))), o(t, n), o(t, Ke), o(t, e.segmentPrefix), o(t, r), u(t, Ge);
   }
   function kr(e, t, r, n) {
    if (2 === n.status) return !0;
    var i = n.id;
    if (-1 === i) {
     if (-1 === (n.id = r.rootSegmentID)) throw Error(s(392));
     return Ar(e, t, n);
    }
    return Ar(e, t, n), o(t, (e = e.responseState).startInlineScript), e.sentCompleteSegmentFunction ? o(t, He) : ((e.sentCompleteSegmentFunction = !0), o(t, $e)), o(t, e.segmentPrefix), o(t, (i = c(i.toString(16)))), o(t, ze), o(t, e.placeholderPrefix), o(t, i), u(t, Ve);
   }
   function Pr(e, t) {
    (i = new Uint8Array(512)), (a = 0);
    try {
     var r = e.completedRootSegment;
     if (null !== r && 0 === e.pendingRootTasks) {
      wr(e, t, r), (e.completedRootSegment = null);
      var n = e.responseState.bootstrapChunks;
      for (r = 0; r < n.length - 1; r++) o(t, n[r]);
      r < n.length && u(t, n[r]);
     }
     var p,
      h = e.clientRenderedBoundaries;
     for (p = 0; p < h.length; p++) {
      var d = h[p];
      n = t;
      var f = e.responseState,
       m = d.id,
       y = d.errorDigest,
       g = d.errorMessage,
       D = d.errorComponentStack;
      if ((o(n, f.startInlineScript), f.sentClientRenderFunction ? o(n, Ye) : ((f.sentClientRenderFunction = !0), o(n, Xe)), null === m)) throw Error(s(395));
      if ((o(n, m), o(n, Qe), (y || g || D) && (o(n, et), o(n, c(rt(y || '')))), (g || D) && (o(n, et), o(n, c(rt(g || '')))), D && (o(n, et), o(n, c(rt(D)))), !u(n, Ze))) return (e.destination = null), p++, void h.splice(0, p);
     }
     h.splice(0, p);
     var x = e.completedBoundaries;
     for (p = 0; p < x.length; p++) if (!Fr(e, t, x[p])) return (e.destination = null), p++, void x.splice(0, p);
     x.splice(0, p), l(t), (i = new Uint8Array(512)), (a = 0);
     var b = e.partialBoundaries;
     for (p = 0; p < b.length; p++) {
      var v = b[p];
      e: {
       (h = e), (d = t);
       var E = v.completedSegments;
       for (f = 0; f < E.length; f++)
        if (!kr(h, d, v, E[f])) {
         f++, E.splice(0, f);
         var C = !1;
         break e;
        }
       E.splice(0, f), (C = !0);
      }
      if (!C) return (e.destination = null), p++, void b.splice(0, p);
     }
     b.splice(0, p);
     var T = e.completedBoundaries;
     for (p = 0; p < T.length; p++) if (!Fr(e, t, T[p])) return (e.destination = null), p++, void T.splice(0, p);
     T.splice(0, p);
    } finally {
     l(t), 0 === e.allPendingTasks && 0 === e.pingedTasks.length && 0 === e.clientRenderedBoundaries.length && 0 === e.completedBoundaries.length && t.close();
    }
   }
   function Ir(e, t) {
    try {
     var r = e.abortableTasks;
     r.forEach(function (r) {
      return vr(r, e, t);
     }),
      r.clear(),
      null !== e.destination && Pr(e, e.destination);
    } catch (n) {
     cr(e, n), hr(e, n);
    }
   }
   (t.renderToReadableStream = function (e, t) {
    return new Promise(function (r, n) {
     var s,
      i,
      a = new Promise(function (e, t) {
       (i = e), (s = t);
      }),
      o = (function (e, t, r, n, s, i, a, o, u) {
       var l = [],
        p = new Set();
       return ((r = pr((t = { destination: null, responseState: t, progressiveChunkSize: void 0 === n ? 12800 : n, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: p, pingedTasks: l, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === s ? or : s, onAllReady: void 0 === i ? ur : i, onShellReady: void 0 === a ? ur : a, onShellError: void 0 === o ? ur : o, onFatalError: void 0 === u ? ur : u }), 0, null, r, !1, !1)).parentFlushed = !0), (e = lr(t, e, null, r, p, Et, null, Bt)), l.push(e), t;
      })(
       e,
       (function (e, t, r, n, s) {
        (e = void 0 === e ? '' : e), (t = void 0 === t ? P : h('<script nonce="' + w(t) + '">'));
        var i = [];
        if ((void 0 !== r && i.push(t, c(('' + r).replace(L, O)), I), void 0 !== n)) for (r = 0; r < n.length; r++) i.push(N, c(w(n[r])), _);
        if (void 0 !== s) for (n = 0; n < s.length; n++) i.push(B, c(w(s[n])), _);
        return { bootstrapChunks: i, startInlineScript: t, placeholderPrefix: h(e + 'P:'), segmentPrefix: h(e + 'S:'), boundaryPrefix: e + 'B:', idPrefix: e, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
       })(t ? t.identifierPrefix : void 0, t ? t.nonce : void 0, t ? t.bootstrapScriptContent : void 0, t ? t.bootstrapScripts : void 0, t ? t.bootstrapModules : void 0),
       (function (e) {
        return M('http://www.w3.org/2000/svg' === e ? 2 : 'http://www.w3.org/1998/Math/MathML' === e ? 3 : 0, null);
       })(t ? t.namespaceURI : void 0),
       t ? t.progressiveChunkSize : void 0,
       t ? t.onError : void 0,
       i,
       function () {
        var e = new ReadableStream(
         {
          type: 'bytes',
          pull: function (e) {
           if (1 === o.status) (o.status = 2), d(e, o.fatalError);
           else if (2 !== o.status && null === o.destination) {
            o.destination = e;
            try {
             Pr(o, e);
            } catch (t) {
             cr(o, t), hr(o, t);
            }
           }
          },
          cancel: function () {
           Ir(o);
          },
         },
         { highWaterMark: 0 },
        );
        (e.allReady = a), r(e);
       },
       function (e) {
        a.catch(function () {}), n(e);
       },
       s,
      );
     if (t && t.signal) {
      var u = t.signal,
       l = function () {
        Ir(o, u.reason), u.removeEventListener('abort', l);
       };
      u.addEventListener('abort', l);
     }
     Tr(o);
    });
   }),
    (t.version = '18.3.1');
  },
  60027: (e, t, r) => {
   var n, s;
   (n = r(41973)), (s = r(2910)), n.version, n.renderToString, (t.uS = n.renderToStaticMarkup), n.renderToNodeStream, n.renderToStaticNodeStream, s.renderToReadableStream;
  },
  27266: (e, t, r) => {
   r.d(t, { Z: () => n });
   var n = (0, r(81226).Z)('outline', 'mood-happy', 'IconMoodHappy', [
    ['path', { d: 'M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0', key: 'svg-0' }],
    ['path', { d: 'M9 9l.01 0', key: 'svg-1' }],
    ['path', { d: 'M15 9l.01 0', key: 'svg-2' }],
    ['path', { d: 'M8 13a4 4 0 1 0 8 0h-8', key: 'svg-3' }],
   ]);
  },
  10709: (e, t, r) => {
   r.d(t, { Z: () => n });
   var n = (0, r(81226).Z)('outline', 'mood-sad', 'IconMoodSad', [
    ['path', { d: 'M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0', key: 'svg-0' }],
    ['path', { d: 'M9 10l.01 0', key: 'svg-1' }],
    ['path', { d: 'M15 10l.01 0', key: 'svg-2' }],
    ['path', { d: 'M9.5 15.25a3.5 3.5 0 0 1 5 0', key: 'svg-3' }],
   ]);
  },
  73891: (e, t, r) => {
   r.d(t, { Z: () => he });
   var n = Object.create,
    s = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    p = (e, t, r) => (
     (r = null != e ? n(o(e)) : {}),
     ((e, t, r, n) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && s(e, o, { get: () => t[o], enumerable: !(n = i(t, o)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : s(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    c = l((e) => {
     function t(e, t) {
      if (null == e) return {};
      var r,
       n,
       s = {},
       i = Object.keys(e);
      for (n = 0; n < i.length; n++) (r = i[n]), !(t.indexOf(r) >= 0) && (s[r] = e[r]);
      return s;
     }
     Object.defineProperty(e, '__esModule', { value: !0 });
     var r = class {
       constructor(e, t, r) {
        (this.line = void 0), (this.column = void 0), (this.index = void 0), (this.line = e), (this.column = t), (this.index = r);
       }
      },
      n = class {
       constructor(e, t) {
        (this.start = void 0), (this.end = void 0), (this.filename = void 0), (this.identifierName = void 0), (this.start = e), (this.end = t);
       }
      };
     function s(e, t) {
      let { line: n, column: s, index: i } = e;
      return new r(n, s + t, i + t);
     }
     var i = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
      a = { ImportMetaOutsideModule: { message: 'import.meta may appear only with \'sourceType: "module"\'', code: i }, ImportOutsideModule: { message: "'import' and 'export' may appear only with 'sourceType: \"module\"'", code: i } },
      o = { ArrayPattern: 'array destructuring pattern', AssignmentExpression: 'assignment expression', AssignmentPattern: 'assignment expression', ArrowFunctionExpression: 'arrow function expression', ConditionalExpression: 'conditional expression', CatchClause: 'catch clause', ForOfStatement: 'for-of statement', ForInStatement: 'for-in statement', ForStatement: 'for-loop', FormalParameters: 'function parameter list', Identifier: 'identifier', ImportSpecifier: 'import specifier', ImportDefaultSpecifier: 'import default specifier', ImportNamespaceSpecifier: 'import namespace specifier', ObjectPattern: 'object destructuring pattern', ParenthesizedExpression: 'parenthesized expression', RestElement: 'rest element', UpdateExpression: { true: 'prefix operation', false: 'postfix operation' }, VariableDeclarator: 'variable declaration', YieldExpression: 'yield expression' },
      u = (e) => ('UpdateExpression' === e.type ? o.UpdateExpression[`${e.prefix}`] : o[e.type]),
      l = { AccessorIsGenerator: ({ kind: e }) => `A ${e}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: 'Async functions can only be declared at the top level or inside a block.', AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: 'Class constructor may not be an accessor.', ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: e }) => `Missing initializer in ${e} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: 'Decorators must not be followed by a semicolon.', DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: 'Deleting a private field is not allowed.', DestructureNamedImport: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.', DuplicateConstructor: 'Duplicate constructor in the same class.', DuplicateDefaultExport: 'Only one default export allowed per module.', DuplicateExport: ({ exportName: e }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: 'Redefinition of __proto__ property.', DuplicateRegExpFlags: 'Duplicate regular expression flag.', DynamicImportPhaseRequiresImportExpressions: ({ phase: e }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: 'Rest element must be last element.', EscapedCharNotAnIdentifier: 'Invalid Unicode escape.', ExportBindingIsString: ({ localName: e, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: e }) => `'${'ForInStatement' === e ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: 'Generators can only be declared at the top level or inside a block.', IllegalBreakContinue: ({ type: e }) => `Unsyntactic ${'BreakStatement' === e ? 'break' : 'continue'}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: 'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.', ImportBindingIsString: ({ importName: e }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${e}" as foo }\`?`, ImportCallArgumentTrailingComma: 'Trailing comma is disallowed inside import(...) arguments.', ImportCallArity: ({ maxArgumentCount: e }) => `\`import()\` requires exactly ${1 === e ? 'one argument' : 'one or two arguments'}.`, ImportCallNotNewExpression: 'Cannot use new with import(...).', ImportCallSpreadArgument: '`...` is not allowed in `import()`.', ImportJSONBindingNotDefault: 'A JSON module can only be imported with `default`.', ImportReflectionHasAssertion: '`import module x` cannot have assertions.', ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: 'Invalid BigIntLiteral.', InvalidCodePoint: 'Code point out of bounds.', InvalidCoverInitializedName: 'Invalid shorthand property initializer.', InvalidDecimal: 'Invalid decimal.', InvalidDigit: ({ radix: e }) => `Expected number in radix ${e}.`, InvalidEscapeSequence: 'Bad character escape sequence.', InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.', InvalidEscapedReservedWord: ({ reservedWord: e }) => `Escape sequence in keyword ${e}.`, InvalidIdentifier: ({ identifierName: e }) => `Invalid identifier ${e}.`, InvalidLhs: ({ ancestor: e }) => `Invalid left-hand side in ${u(e)}.`, InvalidLhsBinding: ({ ancestor: e }) => `Binding invalid left-hand side in ${u(e)}.`, InvalidLhsOptionalChaining: ({ ancestor: e }) => `Invalid optional chaining in the left-hand side of ${u(e)}.`, InvalidNumber: 'Invalid number.', InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: e }) => `Unexpected character '${e}'.`, InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern.', InvalidPrivateFieldResolution: ({ identifierName: e }) => `Private name #${e} is not defined.`, InvalidPropertyBindingPattern: 'Binding member expression.', InvalidRecordProperty: 'Only properties and spread elements are allowed in record definitions.', InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: e }) => `Label '${e}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: 'Invalid regular expression flag.', MissingClassName: 'A class name is required.', MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: 'Missing semicolon.', MissingPlugin: ({ missingPlugin: e }) => `This experimental syntax requires enabling the parser plugin: ${e.map((e) => JSON.stringify(e)).join(', ')}.`, MissingOneOfPlugins: ({ missingPlugin: e }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((e) => JSON.stringify(e)).join(', ')}.`, MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.', MixingCoalesceWithLogical: 'Nullish coalescing operator(??) requires parens when mixing with logical operators.', ModuleAttributeDifferentFromType: 'The only accepted module attribute is `type`.', ModuleAttributeInvalidValue: 'Only string literals are allowed as module attribute values.', ModuleAttributesWithDuplicateKeys: ({ key: e }) => `Duplicate key "${e}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, ModuleExportUndefined: ({ localName: e }) => `Export '${e}' is not defined.`, MultipleDefaultsInSwitch: 'Multiple default clauses.', NewlineAfterThrow: 'Illegal newline after throw.', NoCatchOrFinally: 'Missing catch or finally clause.', NumberIdentifier: 'Identifier directly after number.', NumericSeparatorInEscapeSequence: 'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.', ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: 'Constructors in/after an Optional Chain are not allowed.', OptionalChainingNoTemplate: 'Tagged Template Literals are not allowed in optionalChain.', OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: 'Argument name clash.', PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: e }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: e }) => `Duplicate private name #${e}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: 'Unexpected trailing comma after rest element.', SloppyFunction: 'In non-strict mode code, functions can only be declared at top level or inside a block.', SloppyFunctionAnnexB: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.', SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: 'Classes may not have static property named prototype.', SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: 'Decorators must be attached to a class element.', TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.', UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: 'Unexpected digit after hash token.', UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: e }) => `Unexpected keyword '${e}'.`, UnexpectedLeadingDecorator: 'Leading decorators must be attached to a class declaration.', UnexpectedLexicalDeclaration: 'Lexical declaration cannot appear in a single-statement context.', UnexpectedNewTarget: '`new.target` can only be used in functions or class properties.', UnexpectedNumericSeparator: 'A numeric separator is only allowed between two digits.', UnexpectedPrivateField: 'Unexpected private name.', UnexpectedReservedWord: ({ reservedWord: e }) => `Unexpected reserved word '${e}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: e, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ''}${e ? `, expected "${e}"` : ''}`, UnexpectedTokenUnaryExponentiation: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.', UnexpectedUsingDeclaration: 'Using declaration cannot appear in the top level when source type is `script`.', UnsupportedBind: 'Binding should be performed on object property.', UnsupportedDecoratorExport: 'A decorated export must export a class declaration.', UnsupportedDefaultExport: 'Only expressions, functions or classes are allowed as the `default` export.', UnsupportedImport: '`import` can only be used in `import()` or `import.meta`.', UnsupportedMetaProperty: ({ target: e, onlyValidPropertyName: t }) => `The only valid meta property for ${e} is ${e}.${t}.`, UnsupportedParameterDecorator: 'Decorators cannot be used to decorate parameters.', UnsupportedPropertyDecorator: 'Decorators cannot be used to decorate object literal properties.', UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: 'Unterminated comment.', UnterminatedRegExp: 'Unterminated regular expression.', UnterminatedString: 'Unterminated string constant.', UnterminatedTemplate: 'Unterminated template.', UsingDeclarationExport: 'Using declaration cannot be exported.', UsingDeclarationHasBindingPattern: 'Using declaration cannot have destructuring patterns.', VarRedeclaration: ({ identifierName: e }) => `Identifier '${e}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: 'Yield expression is not allowed in formal parameters.', ZeroDigitNumericSeparator: 'Numeric separator can not be used after leading 0.' },
      p = new Set(['ArrowFunctionExpression', 'AssignmentExpression', 'ConditionalExpression', 'YieldExpression']),
      c = { PipeBodyIsTighter: 'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.', PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: 'Topic reference is unbound; it must be inside a pipe body.', PipeTopicUnconfiguredToken: ({ token: e }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`, PipeTopicUnused: 'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.', PipeUnparenthesizedBody: ({ type: e }) => `Hack-style pipe body cannot be an unparenthesized ${u({ type: e })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: 'Pipeline body may not be a comma-separated sequence expression.', PipelineHeadSequenceExpression: 'Pipeline head should not be a comma-separated sequence expression.', PipelineTopicUnused: 'Pipeline is in topic style but does not use topic reference.', PrimaryTopicNotAllowed: 'Topic reference was used in a lexical context without topic binding.', PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' },
      h = ['toMessage'],
      d = ['message'];
     function f(e, t, r) {
      Object.defineProperty(e, t, { enumerable: !1, configurable: !0, value: r });
     }
     function m(e) {
      let { toMessage: n } = e,
       s = t(e, h);
      return function e(t, i) {
       let a = new SyntaxError();
       return (
        Object.assign(a, s, { loc: t, pos: t.index }),
        'missingPlugin' in i && Object.assign(a, { missingPlugin: i.missingPlugin }),
        f(a, 'clone', function (n = {}) {
         var s;
         let { line: a, column: o, index: u } = null != (s = n.loc) ? s : t;
         return e(new r(a, o, u), Object.assign({}, i, n.details));
        }),
        f(a, 'details', i),
        Object.defineProperty(a, 'message', {
         configurable: !0,
         get() {
          let e = `${n(i)} (${t.line}:${t.column})`;
          return (this.message = e), e;
         },
         set(e) {
          Object.defineProperty(this, 'message', { value: e, writable: !0 });
         },
        }),
        a
       );
      };
     }
     function y(e, r) {
      if (Array.isArray(e)) return (t) => y(t, e[0]);
      let n = {};
      for (let s of Object.keys(e)) {
       let i = e[s],
        a = 'string' == typeof i ? { message: () => i } : 'function' == typeof i ? { message: i } : i,
        { message: o } = a,
        u = t(a, d),
        l = 'string' == typeof o ? () => o : o;
       n[s] = m(Object.assign({ code: 'BABEL_PARSER_SYNTAX_ERROR', reasonCode: s, toMessage: l }, r ? { syntaxPlugin: r } : {}, u));
      }
      return n;
     }
     var g = Object.assign({}, y(a), y(l), y({ StrictDelete: 'Deleting local variable in strict mode.', StrictEvalArguments: ({ referenceName: e }) => `Assigning to '${e}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: e }) => `Binding '${e}' in strict mode.`, StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block.', StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode.', StrictWith: "'with' in strict mode." }), y`pipelineOperator`(c)),
      { defineProperty: D } = Object,
      x = (e, t) => D(e, t, { enumerable: !1, value: e[t] });
     function b(e) {
      return e.loc.start && x(e.loc.start, 'index'), e.loc.end && x(e.loc.end, 'index'), e;
     }
     var v = class {
       constructor(e, t) {
        (this.token = void 0), (this.preserveSpace = void 0), (this.token = e), (this.preserveSpace = !!t);
       }
      },
      E = { brace: new v('{'), j_oTag: new v('<tag'), j_cTag: new v('</tag'), j_expr: new v('<tag>...</tag>', !0) };
     E.template = new v('`', !0);
     var C = !0,
      T = !0,
      S = !0,
      w = !0,
      A = !0,
      F = class {
       constructor(e, t = {}) {
        (this.label = void 0), (this.keyword = void 0), (this.beforeExpr = void 0), (this.startsExpr = void 0), (this.rightAssociative = void 0), (this.isLoop = void 0), (this.isAssign = void 0), (this.prefix = void 0), (this.postfix = void 0), (this.binop = void 0), (this.label = e), (this.keyword = t.keyword), (this.beforeExpr = !!t.beforeExpr), (this.startsExpr = !!t.startsExpr), (this.rightAssociative = !!t.rightAssociative), (this.isLoop = !!t.isLoop), (this.isAssign = !!t.isAssign), (this.prefix = !!t.prefix), (this.postfix = !!t.postfix), (this.binop = null != t.binop ? t.binop : null), (this.updateContext = null);
       }
      },
      k = new Map();
     function P(e, t = {}) {
      t.keyword = e;
      let r = R(e, t);
      return k.set(e, r), r;
     }
     function I(e, t) {
      return R(e, { beforeExpr: C, binop: t });
     }
     var N = -1,
      B = [],
      _ = [],
      L = [],
      O = [],
      M = [],
      j = [];
     function R(e, t = {}) {
      var r, n, s, i;
      return ++N, _.push(e), L.push(null != (r = t.binop) ? r : -1), O.push(null != (n = t.beforeExpr) && n), M.push(null != (s = t.startsExpr) && s), j.push(null != (i = t.prefix) && i), B.push(new F(e, t)), N;
     }
     function q(e, t = {}) {
      var r, n, s, i;
      return ++N, k.set(e, N), _.push(e), L.push(null != (r = t.binop) ? r : -1), O.push(null != (n = t.beforeExpr) && n), M.push(null != (s = t.startsExpr) && s), j.push(null != (i = t.prefix) && i), B.push(new F('name', t)), N;
     }
     var U = { bracketL: R('[', { beforeExpr: C, startsExpr: T }), bracketHashL: R('#[', { beforeExpr: C, startsExpr: T }), bracketBarL: R('[|', { beforeExpr: C, startsExpr: T }), bracketR: R(']'), bracketBarR: R('|]'), braceL: R('{', { beforeExpr: C, startsExpr: T }), braceBarL: R('{|', { beforeExpr: C, startsExpr: T }), braceHashL: R('#{', { beforeExpr: C, startsExpr: T }), braceR: R('}'), braceBarR: R('|}'), parenL: R('(', { beforeExpr: C, startsExpr: T }), parenR: R(')'), comma: R(',', { beforeExpr: C }), semi: R(';', { beforeExpr: C }), colon: R(':', { beforeExpr: C }), doubleColon: R('::', { beforeExpr: C }), dot: R('.'), question: R('?', { beforeExpr: C }), questionDot: R('?.'), arrow: R('=>', { beforeExpr: C }), template: R('template'), ellipsis: R('...', { beforeExpr: C }), backQuote: R('`', { startsExpr: T }), dollarBraceL: R('${', { beforeExpr: C, startsExpr: T }), templateTail: R('...`', { startsExpr: T }), templateNonTail: R('...${', { beforeExpr: C, startsExpr: T }), at: R('@'), hash: R('#', { startsExpr: T }), interpreterDirective: R('#!...'), eq: R('=', { beforeExpr: C, isAssign: w }), assign: R('_=', { beforeExpr: C, isAssign: w }), slashAssign: R('_=', { beforeExpr: C, isAssign: w }), xorAssign: R('_=', { beforeExpr: C, isAssign: w }), moduloAssign: R('_=', { beforeExpr: C, isAssign: w }), incDec: R('++/--', { prefix: A, postfix: !0, startsExpr: T }), bang: R('!', { beforeExpr: C, prefix: A, startsExpr: T }), tilde: R('~', { beforeExpr: C, prefix: A, startsExpr: T }), doubleCaret: R('^^', { startsExpr: T }), doubleAt: R('@@', { startsExpr: T }), pipeline: I('|>', 0), nullishCoalescing: I('??', 1), logicalOR: I('||', 1), logicalAND: I('&&', 2), bitwiseOR: I('|', 3), bitwiseXOR: I('^', 4), bitwiseAND: I('&', 5), equality: I('==/!=/===/!==', 6), lt: I('</>/<=/>=', 7), gt: I('</>/<=/>=', 7), relational: I('</>/<=/>=', 7), bitShift: I('<</>>/>>>', 8), bitShiftL: I('<</>>/>>>', 8), bitShiftR: I('<</>>/>>>', 8), plusMin: R('+/-', { beforeExpr: C, binop: 9, prefix: A, startsExpr: T }), modulo: R('%', { binop: 10, startsExpr: T }), star: R('*', { binop: 10 }), slash: I('/', 10), exponent: R('**', { beforeExpr: C, binop: 11, rightAssociative: !0 }), _in: P('in', { beforeExpr: C, binop: 7 }), _instanceof: P('instanceof', { beforeExpr: C, binop: 7 }), _break: P('break'), _case: P('case', { beforeExpr: C }), _catch: P('catch'), _continue: P('continue'), _debugger: P('debugger'), _default: P('default', { beforeExpr: C }), _else: P('else', { beforeExpr: C }), _finally: P('finally'), _function: P('function', { startsExpr: T }), _if: P('if'), _return: P('return', { beforeExpr: C }), _switch: P('switch'), _throw: P('throw', { beforeExpr: C, prefix: A, startsExpr: T }), _try: P('try'), _var: P('var'), _const: P('const'), _with: P('with'), _new: P('new', { beforeExpr: C, startsExpr: T }), _this: P('this', { startsExpr: T }), _super: P('super', { startsExpr: T }), _class: P('class', { startsExpr: T }), _extends: P('extends', { beforeExpr: C }), _export: P('export'), _import: P('import', { startsExpr: T }), _null: P('null', { startsExpr: T }), _true: P('true', { startsExpr: T }), _false: P('false', { startsExpr: T }), _typeof: P('typeof', { beforeExpr: C, prefix: A, startsExpr: T }), _void: P('void', { beforeExpr: C, prefix: A, startsExpr: T }), _delete: P('delete', { beforeExpr: C, prefix: A, startsExpr: T }), _do: P('do', { isLoop: S, beforeExpr: C }), _for: P('for', { isLoop: S }), _while: P('while', { isLoop: S }), _as: q('as', { startsExpr: T }), _assert: q('assert', { startsExpr: T }), _async: q('async', { startsExpr: T }), _await: q('await', { startsExpr: T }), _defer: q('defer', { startsExpr: T }), _from: q('from', { startsExpr: T }), _get: q('get', { startsExpr: T }), _let: q('let', { startsExpr: T }), _meta: q('meta', { startsExpr: T }), _of: q('of', { startsExpr: T }), _sent: q('sent', { startsExpr: T }), _set: q('set', { startsExpr: T }), _source: q('source', { startsExpr: T }), _static: q('static', { startsExpr: T }), _using: q('using', { startsExpr: T }), _yield: q('yield', { startsExpr: T }), _asserts: q('asserts', { startsExpr: T }), _checks: q('checks', { startsExpr: T }), _exports: q('exports', { startsExpr: T }), _global: q('global', { startsExpr: T }), _implements: q('implements', { startsExpr: T }), _intrinsic: q('intrinsic', { startsExpr: T }), _infer: q('infer', { startsExpr: T }), _is: q('is', { startsExpr: T }), _mixins: q('mixins', { startsExpr: T }), _proto: q('proto', { startsExpr: T }), _require: q('require', { startsExpr: T }), _satisfies: q('satisfies', { startsExpr: T }), _keyof: q('keyof', { startsExpr: T }), _readonly: q('readonly', { startsExpr: T }), _unique: q('unique', { startsExpr: T }), _abstract: q('abstract', { startsExpr: T }), _declare: q('declare', { startsExpr: T }), _enum: q('enum', { startsExpr: T }), _module: q('module', { startsExpr: T }), _namespace: q('namespace', { startsExpr: T }), _interface: q('interface', { startsExpr: T }), _type: q('type', { startsExpr: T }), _opaque: q('opaque', { startsExpr: T }), name: R('name', { startsExpr: T }), string: R('string', { startsExpr: T }), num: R('num', { startsExpr: T }), bigint: R('bigint', { startsExpr: T }), decimal: R('decimal', { startsExpr: T }), regexp: R('regexp', { startsExpr: T }), privateName: R('#name', { startsExpr: T }), eof: R('eof'), jsxName: R('jsxName'), jsxText: R('jsxText', { beforeExpr: !0 }), jsxTagStart: R('jsxTagStart', { startsExpr: !0 }), jsxTagEnd: R('jsxTagEnd'), placeholder: R('%%', { startsExpr: !0 }) };
     function $(e) {
      return e >= 93 && e <= 132;
     }
     function H(e) {
      return e >= 58 && e <= 132;
     }
     function z(e) {
      return e >= 58 && e <= 136;
     }
     function V(e) {
      return M[e];
     }
     function W(e) {
      return e >= 129 && e <= 131;
     }
     function J(e) {
      return e >= 58 && e <= 92;
     }
     function K(e) {
      return _[e];
     }
     function G(e) {
      return L[e];
     }
     function X(e) {
      return e >= 24 && e <= 25;
     }
     function Y(e) {
      return B[e];
     }
     (B[8].updateContext = (e) => {
      e.pop();
     }),
      (B[5].updateContext =
       B[7].updateContext =
       B[23].updateContext =
        (e) => {
         e.push(E.brace);
        }),
      (B[22].updateContext = (e) => {
       e[e.length - 1] === E.template ? e.pop() : e.push(E.template);
      }),
      (B[142].updateContext = (e) => {
       e.push(E.j_expr, E.j_oTag);
      });
     var Q = '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc',
      Z = '\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65',
      ee = new RegExp('[' + Q + ']'),
      te = new RegExp('[' + Q + Z + ']');
     Q = Z = null;
     var re = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191],
      ne = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
     function se(e, t) {
      let r = 65536;
      for (let n = 0, s = t.length; n < s; n += 2) {
       if (((r += t[n]), r > e)) return !1;
       if (((r += t[n + 1]), r >= e)) return !0;
      }
      return !1;
     }
     function ie(e) {
      return e < 65 ? 36 === e : e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && ee.test(String.fromCharCode(e)) : se(e, re)));
     }
     function ae(e) {
      return e < 48 ? 36 === e : e < 58 || (!(e < 65) && (e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && te.test(String.fromCharCode(e)) : se(e, re) || se(e, ne)))));
     }
     var oe = ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
      ue = ['eval', 'arguments'],
      le = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete']),
      pe = new Set(oe),
      ce = new Set(ue);
     function he(e, t) {
      return (t && 'await' === e) || 'enum' === e;
     }
     function de(e, t) {
      return he(e, t) || pe.has(e);
     }
     function fe(e) {
      return ce.has(e);
     }
     function me(e, t) {
      return de(e, t) || fe(e);
     }
     var ye = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'eval', 'arguments', 'enum', 'await']);
     var ge = class {
       constructor(e) {
        (this.flags = 0), (this.names = new Map()), (this.firstLexicalName = ''), (this.flags = e);
       }
      },
      De = class {
       constructor(e, t) {
        (this.parser = void 0), (this.scopeStack = []), (this.inModule = void 0), (this.undefinedExports = new Map()), (this.parser = e), (this.inModule = t);
       }
       get inTopLevel() {
        return (1 & this.currentScope().flags) > 0;
       }
       get inFunction() {
        return (2 & this.currentVarScopeFlags()) > 0;
       }
       get allowSuper() {
        return (16 & this.currentThisScopeFlags()) > 0;
       }
       get allowDirectSuper() {
        return (32 & this.currentThisScopeFlags()) > 0;
       }
       get inClass() {
        return (64 & this.currentThisScopeFlags()) > 0;
       }
       get inClassAndNotInNonArrowFunction() {
        let e = this.currentThisScopeFlags();
        return (64 & e) > 0 && 0 == (2 & e);
       }
       get inStaticBlock() {
        for (let e = this.scopeStack.length - 1; ; e--) {
         let { flags: t } = this.scopeStack[e];
         if (128 & t) return !0;
         if (451 & t) return !1;
        }
       }
       get inNonArrowFunction() {
        return (2 & this.currentThisScopeFlags()) > 0;
       }
       get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
       }
       createScope(e) {
        return new ge(e);
       }
       enter(e) {
        this.scopeStack.push(this.createScope(e));
       }
       exit() {
        return this.scopeStack.pop().flags;
       }
       treatFunctionsAsVarInScope(e) {
        return !!(130 & e.flags || (!this.parser.inModule && 1 & e.flags));
       }
       declareName(e, t, r) {
        let n = this.currentScope();
        if (8 & t || 16 & t) {
         this.checkRedeclarationInScope(n, e, t, r);
         let s = n.names.get(e) || 0;
         16 & t ? (s |= 4) : (n.firstLexicalName || (n.firstLexicalName = e), (s |= 2)), n.names.set(e, s), 8 & t && this.maybeExportDefined(n, e);
        } else if (4 & t) for (let s = this.scopeStack.length - 1; s >= 0 && ((n = this.scopeStack[s]), this.checkRedeclarationInScope(n, e, t, r), n.names.set(e, 1 | (n.names.get(e) || 0)), this.maybeExportDefined(n, e), !(387 & n.flags)); --s);
        this.parser.inModule && 1 & n.flags && this.undefinedExports.delete(e);
       }
       maybeExportDefined(e, t) {
        this.parser.inModule && 1 & e.flags && this.undefinedExports.delete(t);
       }
       checkRedeclarationInScope(e, t, r, n) {
        this.isRedeclaredInScope(e, t, r) && this.parser.raise(g.VarRedeclaration, n, { identifierName: t });
       }
       isRedeclaredInScope(e, t, r) {
        if (!(1 & r)) return !1;
        if (8 & r) return e.names.has(t);
        let n = e.names.get(t);
        return 16 & r ? (2 & n) > 0 || (!this.treatFunctionsAsVarInScope(e) && (1 & n) > 0) : ((2 & n) > 0 && !(8 & e.flags && e.firstLexicalName === t)) || (!this.treatFunctionsAsVarInScope(e) && (4 & n) > 0);
       }
       checkLocalExport(e) {
        let { name: t } = e;
        this.scopeStack[0].names.has(t) || this.undefinedExports.set(t, e.loc.start);
       }
       currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
       }
       currentVarScopeFlags() {
        for (let e = this.scopeStack.length - 1; ; e--) {
         let { flags: t } = this.scopeStack[e];
         if (387 & t) return t;
        }
       }
       currentThisScopeFlags() {
        for (let e = this.scopeStack.length - 1; ; e--) {
         let { flags: t } = this.scopeStack[e];
         if (451 & t && !(4 & t)) return t;
        }
       }
      },
      xe = class extends ge {
       constructor(...e) {
        super(...e), (this.declareFunctions = new Set());
       }
      },
      be = class extends De {
       createScope(e) {
        return new xe(e);
       }
       declareName(e, t, r) {
        let n = this.currentScope();
        if (2048 & t) return this.checkRedeclarationInScope(n, e, t, r), this.maybeExportDefined(n, e), void n.declareFunctions.add(e);
        super.declareName(e, t, r);
       }
       isRedeclaredInScope(e, t, r) {
        if (super.isRedeclaredInScope(e, t, r)) return !0;
        if (2048 & r && !e.declareFunctions.has(t)) {
         let r = e.names.get(t);
         return (4 & r) > 0 || (2 & r) > 0;
        }
        return !1;
       }
       checkLocalExport(e) {
        this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
       }
      },
      ve = class {
       constructor() {
        (this.sawUnambiguousESM = !1), (this.ambiguousScriptDifferentAst = !1);
       }
       hasPlugin(e) {
        if ('string' == typeof e) return this.plugins.has(e);
        {
         let [t, r] = e;
         if (!this.hasPlugin(t)) return !1;
         let n = this.plugins.get(t);
         for (let e of Object.keys(r)) if ((null == n ? void 0 : n[e]) !== r[e]) return !1;
         return !0;
        }
       }
       getPluginOption(e, t) {
        var r;
        return null == (r = this.plugins.get(e)) ? void 0 : r[t];
       }
      };
     function Ee(e, t) {
      void 0 === e.trailingComments ? (e.trailingComments = t) : e.trailingComments.unshift(...t);
     }
     function Ce(e, t) {
      void 0 === e.innerComments ? (e.innerComments = t) : e.innerComments.unshift(...t);
     }
     function Te(e, t, r) {
      let n = null,
       s = t.length;
      for (; null === n && s > 0; ) n = t[--s];
      null === n || n.start > r.start ? Ce(e, r.comments) : Ee(n, r.comments);
     }
     var Se = class extends ve {
       addComment(e) {
        this.filename && (e.loc.filename = this.filename);
        let { commentsLen: t } = this.state;
        this.comments.length !== t && (this.comments.length = t), this.comments.push(e), this.state.commentsLen++;
       }
       processComment(e) {
        let { commentStack: t } = this.state,
         r = t.length;
        if (0 === r) return;
        let n = r - 1,
         s = t[n];
        s.start === e.end && ((s.leadingNode = e), n--);
        let { start: i } = e;
        for (; n >= 0; n--) {
         let r = t[n],
          s = r.end;
         if (!(s > i)) {
          s === i && (r.trailingNode = e);
          break;
         }
         (r.containingNode = e), this.finalizeComment(r), t.splice(n, 1);
        }
       }
       finalizeComment(e) {
        let { comments: t } = e;
        if (null !== e.leadingNode || null !== e.trailingNode)
         null !== e.leadingNode && Ee(e.leadingNode, t),
          null !== e.trailingNode &&
           (function (e, t) {
            void 0 === e.leadingComments ? (e.leadingComments = t) : e.leadingComments.unshift(...t);
           })(e.trailingNode, t);
        else {
         let { containingNode: r, start: n } = e;
         if (44 === this.input.charCodeAt(n - 1))
          switch (r.type) {
           case 'ObjectExpression':
           case 'ObjectPattern':
           case 'RecordExpression':
            Te(r, r.properties, e);
            break;
           case 'CallExpression':
           case 'OptionalCallExpression':
            Te(r, r.arguments, e);
            break;
           case 'FunctionDeclaration':
           case 'FunctionExpression':
           case 'ArrowFunctionExpression':
           case 'ObjectMethod':
           case 'ClassMethod':
           case 'ClassPrivateMethod':
            Te(r, r.params, e);
            break;
           case 'ArrayExpression':
           case 'ArrayPattern':
           case 'TupleExpression':
            Te(r, r.elements, e);
            break;
           case 'ExportNamedDeclaration':
           case 'ImportDeclaration':
            Te(r, r.specifiers, e);
            break;
           default:
            Ce(r, t);
          }
         else Ce(r, t);
        }
       }
       finalizeRemainingComments() {
        let { commentStack: e } = this.state;
        for (let t = e.length - 1; t >= 0; t--) this.finalizeComment(e[t]);
        this.state.commentStack = [];
       }
       resetPreviousNodeTrailingComments(e) {
        let { commentStack: t } = this.state,
         { length: r } = t;
        if (0 === r) return;
        let n = t[r - 1];
        n.leadingNode === e && (n.leadingNode = null);
       }
       resetPreviousIdentifierLeadingComments(e) {
        let { commentStack: t } = this.state,
         { length: r } = t;
        0 !== r && (t[r - 1].trailingNode === e ? (t[r - 1].trailingNode = null) : r >= 2 && t[r - 2].trailingNode === e && (t[r - 2].trailingNode = null));
       }
       takeSurroundingComments(e, t, r) {
        let { commentStack: n } = this.state,
         s = n.length;
        if (0 === s) return;
        let i = s - 1;
        for (; i >= 0; i--) {
         let s = n[i],
          a = s.end;
         if (s.start === r) s.leadingNode = e;
         else if (a === t) s.trailingNode = e;
         else if (a < t) break;
        }
       }
      },
      we = /\r\n?|[\n\u2028\u2029]/,
      Ae = new RegExp(we.source, 'g');
     function Fe(e) {
      switch (e) {
       case 10:
       case 13:
       case 8232:
       case 8233:
        return !0;
       default:
        return !1;
      }
     }
     var ke = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
      Pe = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g,
      Ie = new RegExp('(?=(' + Pe.source + '))\\1' + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, 'y');
     function Ne(e) {
      switch (e) {
       case 9:
       case 11:
       case 12:
       case 32:
       case 160:
       case 5760:
       case 8192:
       case 8193:
       case 8194:
       case 8195:
       case 8196:
       case 8197:
       case 8198:
       case 8199:
       case 8200:
       case 8201:
       case 8202:
       case 8239:
       case 8287:
       case 12288:
       case 65279:
        return !0;
       default:
        return !1;
      }
     }
     var Be = class e {
       constructor() {
        (this.flags = 1024), (this.curLine = void 0), (this.lineStart = void 0), (this.startLoc = void 0), (this.endLoc = void 0), (this.errors = []), (this.potentialArrowAt = -1), (this.noArrowAt = []), (this.noArrowParamsConversionAt = []), (this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }), (this.labels = []), (this.commentsLen = 0), (this.commentStack = []), (this.pos = 0), (this.type = 139), (this.value = null), (this.start = 0), (this.end = 0), (this.lastTokEndLoc = null), (this.lastTokStartLoc = null), (this.context = [E.brace]), (this.firstInvalidTemplateEscapePos = null), (this.strictErrors = new Map()), (this.tokensLength = 0);
       }
       get strict() {
        return (1 & this.flags) > 0;
       }
       set strict(e) {
        e ? (this.flags |= 1) : (this.flags &= -2);
       }
       init({ strictMode: e, sourceType: t, startLine: n, startColumn: s }) {
        (this.strict = !1 !== e && (!0 === e || 'module' === t)), (this.curLine = n), (this.lineStart = -s), (this.startLoc = this.endLoc = new r(n, s, 0));
       }
       get maybeInArrowParameters() {
        return (2 & this.flags) > 0;
       }
       set maybeInArrowParameters(e) {
        e ? (this.flags |= 2) : (this.flags &= -3);
       }
       get inType() {
        return (4 & this.flags) > 0;
       }
       set inType(e) {
        e ? (this.flags |= 4) : (this.flags &= -5);
       }
       get noAnonFunctionType() {
        return (8 & this.flags) > 0;
       }
       set noAnonFunctionType(e) {
        e ? (this.flags |= 8) : (this.flags &= -9);
       }
       get hasFlowComment() {
        return (16 & this.flags) > 0;
       }
       set hasFlowComment(e) {
        e ? (this.flags |= 16) : (this.flags &= -17);
       }
       get isAmbientContext() {
        return (32 & this.flags) > 0;
       }
       set isAmbientContext(e) {
        e ? (this.flags |= 32) : (this.flags &= -33);
       }
       get inAbstractClass() {
        return (64 & this.flags) > 0;
       }
       set inAbstractClass(e) {
        e ? (this.flags |= 64) : (this.flags &= -65);
       }
       get inDisallowConditionalTypesContext() {
        return (128 & this.flags) > 0;
       }
       set inDisallowConditionalTypesContext(e) {
        e ? (this.flags |= 128) : (this.flags &= -129);
       }
       get soloAwait() {
        return (256 & this.flags) > 0;
       }
       set soloAwait(e) {
        e ? (this.flags |= 256) : (this.flags &= -257);
       }
       get inFSharpPipelineDirectBody() {
        return (512 & this.flags) > 0;
       }
       set inFSharpPipelineDirectBody(e) {
        e ? (this.flags |= 512) : (this.flags &= -513);
       }
       get canStartJSXElement() {
        return (1024 & this.flags) > 0;
       }
       set canStartJSXElement(e) {
        e ? (this.flags |= 1024) : (this.flags &= -1025);
       }
       get containsEsc() {
        return (2048 & this.flags) > 0;
       }
       set containsEsc(e) {
        e ? (this.flags |= 2048) : (this.flags &= -2049);
       }
       curPosition() {
        return new r(this.curLine, this.pos - this.lineStart, this.pos);
       }
       clone() {
        let t = new e();
        return (t.flags = this.flags), (t.curLine = this.curLine), (t.lineStart = this.lineStart), (t.startLoc = this.startLoc), (t.endLoc = this.endLoc), (t.errors = this.errors.slice()), (t.potentialArrowAt = this.potentialArrowAt), (t.noArrowAt = this.noArrowAt.slice()), (t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice()), (t.topicContext = this.topicContext), (t.labels = this.labels.slice()), (t.commentsLen = this.commentsLen), (t.commentStack = this.commentStack.slice()), (t.pos = this.pos), (t.type = this.type), (t.value = this.value), (t.start = this.start), (t.end = this.end), (t.lastTokEndLoc = this.lastTokEndLoc), (t.lastTokStartLoc = this.lastTokStartLoc), (t.context = this.context.slice()), (t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos), (t.strictErrors = this.strictErrors), (t.tokensLength = this.tokensLength), t;
       }
      },
      _e = function (e) {
       return e >= 48 && e <= 57;
      },
      Le = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
      Oe = { bin: (e) => 48 === e || 49 === e, oct: (e) => e >= 48 && e <= 55, dec: (e) => e >= 48 && e <= 57, hex: (e) => (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102) };
     function Me(e, t, r, n, s, i) {
      let a = r,
       o = n,
       u = s,
       l = '',
       p = null,
       c = r,
       { length: h } = t;
      for (;;) {
       if (r >= h) {
        i.unterminated(a, o, u), (l += t.slice(c, r));
        break;
       }
       let d = t.charCodeAt(r);
       if (je(e, d, t, r)) {
        l += t.slice(c, r);
        break;
       }
       if (92 === d) {
        l += t.slice(c, r);
        let a = Re(t, r, n, s, 'template' === e, i);
        null !== a.ch || p ? (l += a.ch) : (p = { pos: r, lineStart: n, curLine: s }), ({ pos: r, lineStart: n, curLine: s } = a), (c = r);
       } else 8232 === d || 8233 === d ? (++s, (n = ++r)) : 10 === d || 13 === d ? ('template' === e ? ((l += t.slice(c, r) + '\n'), ++r, 13 === d && 10 === t.charCodeAt(r) && ++r, ++s, (c = n = r)) : i.unterminated(a, o, u)) : ++r;
      }
      return { pos: r, str: l, firstInvalidLoc: p, lineStart: n, curLine: s, containsInvalid: !!p };
     }
     function je(e, t, r, n) {
      return 'template' === e ? 96 === t || (36 === t && 123 === r.charCodeAt(n + 1)) : t === ('double' === e ? 34 : 39);
     }
     function Re(e, t, r, n, s, i) {
      let a = !s;
      t++;
      let o = (e) => ({ pos: t, ch: e, lineStart: r, curLine: n }),
       u = e.charCodeAt(t++);
      switch (u) {
       case 110:
        return o('\n');
       case 114:
        return o('\r');
       case 120: {
        let s;
        return ({ code: s, pos: t } = qe(e, t, r, n, 2, !1, a, i)), o(null === s ? null : String.fromCharCode(s));
       }
       case 117: {
        let s;
        return ({ code: s, pos: t } = $e(e, t, r, n, a, i)), o(null === s ? null : String.fromCodePoint(s));
       }
       case 116:
        return o('\t');
       case 98:
        return o('\b');
       case 118:
        return o('\v');
       case 102:
        return o('\f');
       case 13:
        10 === e.charCodeAt(t) && ++t;
       case 10:
        (r = t), ++n;
       case 8232:
       case 8233:
        return o('');
       case 56:
       case 57:
        if (s) return o(null);
        i.strictNumericEscape(t - 1, r, n);
       default:
        if (u >= 48 && u <= 55) {
         let a = t - 1,
          u = e.slice(a, t + 2).match(/^[0-7]+/)[0],
          l = parseInt(u, 8);
         l > 255 && ((u = u.slice(0, -1)), (l = parseInt(u, 8))), (t += u.length - 1);
         let p = e.charCodeAt(t);
         if ('0' !== u || 56 === p || 57 === p) {
          if (s) return o(null);
          i.strictNumericEscape(a, r, n);
         }
         return o(String.fromCharCode(l));
        }
        return o(String.fromCharCode(u));
      }
     }
     function qe(e, t, r, n, s, i, a, o) {
      let u,
       l = t;
      return ({ n: u, pos: t } = Ue(e, t, r, n, 16, s, i, !1, o, !a)), null === u && (a ? o.invalidEscapeSequence(l, r, n) : (t = l - 1)), { code: u, pos: t };
     }
     function Ue(e, t, r, n, s, i, a, o, u, l) {
      let p = t,
       c = 16 === s ? Le.hex : Le.decBinOct,
       h = 16 === s ? Oe.hex : 10 === s ? Oe.dec : 8 === s ? Oe.oct : Oe.bin,
       d = !1,
       f = 0;
      for (let m = 0, y = i ?? 1 / 0; m < y; ++m) {
       let i,
        p = e.charCodeAt(t);
       if (95 !== p || 'bail' === o) {
        if (((i = p >= 97 ? p - 97 + 10 : p >= 65 ? p - 65 + 10 : _e(p) ? p - 48 : 1 / 0), i >= s)) {
         if (i <= 9 && l) return { n: null, pos: t };
         if (i <= 9 && u.invalidDigit(t, r, n, s)) i = 0;
         else {
          if (!a) break;
          (i = 0), (d = !0);
         }
        }
        ++t, (f = f * s + i);
       } else {
        let s = e.charCodeAt(t - 1),
         i = e.charCodeAt(t + 1);
        if (o) {
         if (Number.isNaN(i) || !h(i) || c.has(s) || c.has(i)) {
          if (l) return { n: null, pos: t };
          u.unexpectedNumericSeparator(t, r, n);
         }
        } else {
         if (l) return { n: null, pos: t };
         u.numericSeparatorInEscapeSequence(t, r, n);
        }
        ++t;
       }
      }
      return t === p || (null != i && t - p !== i) || d ? { n: null, pos: t } : { n: f, pos: t };
     }
     function $e(e, t, r, n, s, i) {
      let a;
      if (123 === e.charCodeAt(t)) {
       if ((++t, ({ code: a, pos: t } = qe(e, t, r, n, e.indexOf('}', t) - t, !0, s, i)), ++t, null !== a && a > 1114111)) {
        if (!s) return { code: null, pos: t };
        i.invalidCodePoint(t, r, n);
       }
      } else ({ code: a, pos: t } = qe(e, t, r, n, 4, !1, s, i));
      return { code: a, pos: t };
     }
     function He(e, t, n) {
      return new r(n, e - t, e);
     }
     var ze = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
      Ve = class {
       constructor(e) {
        (this.type = e.type), (this.value = e.value), (this.start = e.start), (this.end = e.end), (this.loc = new n(e.startLoc, e.endLoc));
       }
      },
      We = class extends Se {
       constructor(e, t) {
        super(),
         (this.isLookahead = void 0),
         (this.tokens = []),
         (this.errorHandlers_readInt = { invalidDigit: (e, t, r, n) => !!this.options.errorRecovery && (this.raise(g.InvalidDigit, He(e, t, r), { radix: n }), !0), numericSeparatorInEscapeSequence: this.errorBuilder(g.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(g.UnexpectedNumericSeparator) }),
         (this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(g.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(g.InvalidCodePoint) })),
         (this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (e, t, r) => {
           this.recordStrictModeErrors(g.StrictNumericEscape, He(e, t, r));
          },
          unterminated: (e, t, r) => {
           throw this.raise(g.UnterminatedString, He(e - 1, t, r));
          },
         })),
         (this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(g.StrictNumericEscape),
          unterminated: (e, t, r) => {
           throw this.raise(g.UnterminatedTemplate, He(e, t, r));
          },
         })),
         (this.state = new Be()),
         this.state.init(e),
         (this.input = t),
         (this.length = t.length),
         (this.comments = []),
         (this.isLookahead = !1);
       }
       pushToken(e) {
        (this.tokens.length = this.state.tokensLength), this.tokens.push(e), ++this.state.tokensLength;
       }
       next() {
        this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Ve(this.state)), (this.state.lastTokEndLoc = this.state.endLoc), (this.state.lastTokStartLoc = this.state.startLoc), this.nextToken();
       }
       eat(e) {
        return !!this.match(e) && (this.next(), !0);
       }
       match(e) {
        return this.state.type === e;
       }
       createLookaheadState(e) {
        return { pos: e.pos, value: null, type: e.type, start: e.start, end: e.end, context: [this.curContext()], inType: e.inType, startLoc: e.startLoc, lastTokEndLoc: e.lastTokEndLoc, curLine: e.curLine, lineStart: e.lineStart, curPosition: e.curPosition };
       }
       lookahead() {
        let e = this.state;
        (this.state = this.createLookaheadState(e)), (this.isLookahead = !0), this.nextToken(), (this.isLookahead = !1);
        let t = this.state;
        return (this.state = e), t;
       }
       nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
       }
       nextTokenStartSince(e) {
        return (ke.lastIndex = e), ke.test(this.input) ? ke.lastIndex : e;
       }
       lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
       }
       nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
       }
       nextTokenInLineStartSince(e) {
        return (Pe.lastIndex = e), Pe.test(this.input) ? Pe.lastIndex : e;
       }
       lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
       }
       codePointAtPos(e) {
        let t = this.input.charCodeAt(e);
        if (55296 == (64512 & t) && ++e < this.input.length) {
         let r = this.input.charCodeAt(e);
         56320 == (64512 & r) && (t = 65536 + ((1023 & t) << 10) + (1023 & r));
        }
        return t;
       }
       setStrict(e) {
        (this.state.strict = e), e && (this.state.strictErrors.forEach(([e, t]) => this.raise(e, t)), this.state.strictErrors.clear());
       }
       curContext() {
        return this.state.context[this.state.context.length - 1];
       }
       nextToken() {
        this.skipSpace(), (this.state.start = this.state.pos), this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(139) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
       }
       skipBlockComment(e) {
        let t;
        this.isLookahead || (t = this.state.curPosition());
        let r = this.state.pos,
         s = this.input.indexOf(e, r + 2);
        if (-1 === s) throw this.raise(g.UnterminatedComment, this.state.curPosition());
        for (this.state.pos = s + e.length, Ae.lastIndex = r + 2; Ae.test(this.input) && Ae.lastIndex <= s; ) ++this.state.curLine, (this.state.lineStart = Ae.lastIndex);
        if (this.isLookahead) return;
        let i = { type: 'CommentBlock', value: this.input.slice(r + 2, s), start: r, end: s + e.length, loc: new n(t, this.state.curPosition()) };
        return this.options.tokens && this.pushToken(i), i;
       }
       skipLineComment(e) {
        let t,
         r = this.state.pos;
        this.isLookahead || (t = this.state.curPosition());
        let s = this.input.charCodeAt((this.state.pos += e));
        if (this.state.pos < this.length) for (; !Fe(s) && ++this.state.pos < this.length; ) s = this.input.charCodeAt(this.state.pos);
        if (this.isLookahead) return;
        let i = this.state.pos,
         a = { type: 'CommentLine', value: this.input.slice(r + e, i), start: r, end: i, loc: new n(t, this.state.curPosition()) };
        return this.options.tokens && this.pushToken(a), a;
       }
       skipSpace() {
        let e = this.state.pos,
         t = [];
        e: for (; this.state.pos < this.length; ) {
         let r = this.input.charCodeAt(this.state.pos);
         switch (r) {
          case 32:
          case 160:
          case 9:
           ++this.state.pos;
           break;
          case 13:
           10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
           ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos);
           break;
          case 47:
           switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42: {
             let e = this.skipBlockComment('*/');
             void 0 !== e && (this.addComment(e), this.options.attachComment && t.push(e));
             break;
            }
            case 47: {
             let e = this.skipLineComment(2);
             void 0 !== e && (this.addComment(e), this.options.attachComment && t.push(e));
             break;
            }
            default:
             break e;
           }
           break;
          default:
           if (Ne(r)) ++this.state.pos;
           else if (45 === r && !this.inModule && this.options.annexB) {
            let r = this.state.pos;
            if (45 !== this.input.charCodeAt(r + 1) || 62 !== this.input.charCodeAt(r + 2) || !(0 === e || this.state.lineStart > e)) break e;
            {
             let e = this.skipLineComment(3);
             void 0 !== e && (this.addComment(e), this.options.attachComment && t.push(e));
            }
           } else {
            if (60 !== r || this.inModule || !this.options.annexB) break e;
            {
             let e = this.state.pos;
             if (33 !== this.input.charCodeAt(e + 1) || 45 !== this.input.charCodeAt(e + 2) || 45 !== this.input.charCodeAt(e + 3)) break e;
             {
              let e = this.skipLineComment(4);
              void 0 !== e && (this.addComment(e), this.options.attachComment && t.push(e));
             }
            }
           }
         }
        }
        if (t.length > 0) {
         let r = { start: e, end: this.state.pos, comments: t, leadingNode: null, trailingNode: null, containingNode: null };
         this.state.commentStack.push(r);
        }
       }
       finishToken(e, t) {
        (this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition());
        let r = this.state.type;
        (this.state.type = e), (this.state.value = t), this.isLookahead || this.updateContext(r);
       }
       replaceToken(e) {
        (this.state.type = e), this.updateContext();
       }
       readToken_numberSign() {
        if (0 === this.state.pos && this.readToken_interpreter()) return;
        let e = this.state.pos + 1,
         t = this.codePointAtPos(e);
        if (t >= 48 && t <= 57) throw this.raise(g.UnexpectedDigitAfterHash, this.state.curPosition());
        if (123 === t || (91 === t && this.hasPlugin('recordAndTuple'))) {
         if ((this.expectPlugin('recordAndTuple'), 'bar' === this.getPluginOption('recordAndTuple', 'syntaxType'))) throw this.raise(123 === t ? g.RecordExpressionHashIncorrectStartSyntaxType : g.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
         (this.state.pos += 2), 123 === t ? this.finishToken(7) : this.finishToken(1);
        } else ie(t) ? (++this.state.pos, this.finishToken(138, this.readWord1(t))) : 92 === t ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
       }
       readToken_dot() {
        let e = this.input.charCodeAt(this.state.pos + 1);
        e >= 48 && e <= 57 ? this.readNumber(!0) : 46 === e && 46 === this.input.charCodeAt(this.state.pos + 2) ? ((this.state.pos += 3), this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
       }
       readToken_slash() {
        61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
       }
       readToken_interpreter() {
        if (0 !== this.state.pos || this.length < 2) return !1;
        let e = this.input.charCodeAt(this.state.pos + 1);
        if (33 !== e) return !1;
        let t = this.state.pos;
        for (this.state.pos += 1; !Fe(e) && ++this.state.pos < this.length; ) e = this.input.charCodeAt(this.state.pos);
        let r = this.input.slice(t + 2, this.state.pos);
        return this.finishToken(28, r), !0;
       }
       readToken_mult_modulo(e) {
        let t = 42 === e ? 55 : 54,
         r = 1,
         n = this.input.charCodeAt(this.state.pos + 1);
        42 === e && 42 === n && (r++, (n = this.input.charCodeAt(this.state.pos + 2)), (t = 57)), 61 === n && !this.state.inType && (r++, (t = 37 === e ? 33 : 30)), this.finishOp(t, r);
       }
       readToken_pipe_amp(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        if (t !== e) {
         if (124 === e) {
          if (62 === t) return void this.finishOp(39, 2);
          if (this.hasPlugin('recordAndTuple') && 125 === t) {
           if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(g.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
           return (this.state.pos += 2), void this.finishToken(9);
          }
          if (this.hasPlugin('recordAndTuple') && 93 === t) {
           if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(g.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
           return (this.state.pos += 2), void this.finishToken(4);
          }
         }
         61 !== t ? this.finishOp(124 === e ? 43 : 45, 1) : this.finishOp(30, 2);
        } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e ? 41 : 42, 2);
       }
       readToken_caret() {
        let e = this.input.charCodeAt(this.state.pos + 1);
        61 !== e || this.state.inType ? (94 === e && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '^^' }]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1)) : this.finishOp(32, 2);
       }
       readToken_atSign() {
        64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '@@' }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
       }
       readToken_plus_min(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        t !== e ? (61 === t ? this.finishOp(30, 2) : this.finishOp(53, 1)) : this.finishOp(34, 2);
       }
       readToken_lt() {
        let { pos: e } = this.state,
         t = this.input.charCodeAt(e + 1);
        if (60 === t) return 61 === this.input.charCodeAt(e + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
        61 !== t ? this.finishOp(47, 1) : this.finishOp(49, 2);
       }
       readToken_gt() {
        let { pos: e } = this.state,
         t = this.input.charCodeAt(e + 1);
        if (62 === t) {
         let t = 62 === this.input.charCodeAt(e + 2) ? 3 : 2;
         return 61 === this.input.charCodeAt(e + t) ? void this.finishOp(30, t + 1) : void this.finishOp(52, t);
        }
        61 !== t ? this.finishOp(48, 1) : this.finishOp(49, 2);
       }
       readToken_eq_excl(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        if (61 !== t) return 61 === e && 62 === t ? ((this.state.pos += 2), void this.finishToken(19)) : void this.finishOp(61 === e ? 29 : 35, 1);
        this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
       }
       readToken_question() {
        let e = this.input.charCodeAt(this.state.pos + 1),
         t = this.input.charCodeAt(this.state.pos + 2);
        63 === e ? (61 === t ? this.finishOp(30, 3) : this.finishOp(40, 2)) : 46 !== e || (t >= 48 && t <= 57) ? (++this.state.pos, this.finishToken(17)) : ((this.state.pos += 2), this.finishToken(18));
       }
       getTokenFromCode(e) {
        switch (e) {
         case 46:
          return void this.readToken_dot();
         case 40:
          return ++this.state.pos, void this.finishToken(10);
         case 41:
          return ++this.state.pos, void this.finishToken(11);
         case 59:
          return ++this.state.pos, void this.finishToken(13);
         case 44:
          return ++this.state.pos, void this.finishToken(12);
         case 91:
          if (this.hasPlugin('recordAndTuple') && 124 === this.input.charCodeAt(this.state.pos + 1)) {
           if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(g.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
           (this.state.pos += 2), this.finishToken(2);
          } else ++this.state.pos, this.finishToken(0);
          return;
         case 93:
          return ++this.state.pos, void this.finishToken(3);
         case 123:
          if (this.hasPlugin('recordAndTuple') && 124 === this.input.charCodeAt(this.state.pos + 1)) {
           if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(g.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
           (this.state.pos += 2), this.finishToken(6);
          } else ++this.state.pos, this.finishToken(5);
          return;
         case 125:
          return ++this.state.pos, void this.finishToken(8);
         case 58:
          return void (this.hasPlugin('functionBind') && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
         case 63:
          return void this.readToken_question();
         case 96:
          return void this.readTemplateToken();
         case 48: {
          let e = this.input.charCodeAt(this.state.pos + 1);
          if (120 === e || 88 === e) return void this.readRadixNumber(16);
          if (111 === e || 79 === e) return void this.readRadixNumber(8);
          if (98 === e || 66 === e) return void this.readRadixNumber(2);
         }
         case 49:
         case 50:
         case 51:
         case 52:
         case 53:
         case 54:
         case 55:
         case 56:
         case 57:
          return void this.readNumber(!1);
         case 34:
         case 39:
          return void this.readString(e);
         case 47:
          return void this.readToken_slash();
         case 37:
         case 42:
          return void this.readToken_mult_modulo(e);
         case 124:
         case 38:
          return void this.readToken_pipe_amp(e);
         case 94:
          return void this.readToken_caret();
         case 43:
         case 45:
          return void this.readToken_plus_min(e);
         case 60:
          return void this.readToken_lt();
         case 62:
          return void this.readToken_gt();
         case 61:
         case 33:
          return void this.readToken_eq_excl(e);
         case 126:
          return void this.finishOp(36, 1);
         case 64:
          return void this.readToken_atSign();
         case 35:
          return void this.readToken_numberSign();
         case 92:
          return void this.readWord();
         default:
          if (ie(e)) return void this.readWord(e);
        }
        throw this.raise(g.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(e) });
       }
       finishOp(e, t) {
        let r = this.input.slice(this.state.pos, this.state.pos + t);
        (this.state.pos += t), this.finishToken(e, r);
       }
       readRegexp() {
        let e,
         t,
         r = this.state.startLoc,
         n = this.state.start + 1,
         { pos: i } = this.state;
        for (; ; ++i) {
         if (i >= this.length) throw this.raise(g.UnterminatedRegExp, s(r, 1));
         let n = this.input.charCodeAt(i);
         if (Fe(n)) throw this.raise(g.UnterminatedRegExp, s(r, 1));
         if (e) e = !1;
         else {
          if (91 === n) t = !0;
          else if (93 === n && t) t = !1;
          else if (47 === n && !t) break;
          e = 92 === n;
         }
        }
        let a = this.input.slice(n, i);
        ++i;
        let o = '',
         u = () => s(r, i + 2 - n);
        for (; i < this.length; ) {
         let e = this.codePointAtPos(i),
          t = String.fromCharCode(e);
         if (ze.has(e)) 118 === e ? o.includes('u') && this.raise(g.IncompatibleRegExpUVFlags, u()) : 117 === e && o.includes('v') && this.raise(g.IncompatibleRegExpUVFlags, u()), o.includes(t) && this.raise(g.DuplicateRegExpFlags, u());
         else {
          if (!ae(e) && 92 !== e) break;
          this.raise(g.MalformedRegExpFlags, u());
         }
         ++i, (o += t);
        }
        (this.state.pos = i), this.finishToken(137, { pattern: a, flags: o });
       }
       readInt(e, t, r = !1, n = !0) {
        let { n: s, pos: i } = Ue(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, t, r, n, this.errorHandlers_readInt, !1);
        return (this.state.pos = i), s;
       }
       readRadixNumber(e) {
        let t = this.state.curPosition(),
         r = !1;
        this.state.pos += 2;
        let n = this.readInt(e);
        null == n && this.raise(g.InvalidDigit, s(t, 2), { radix: e });
        let i = this.input.charCodeAt(this.state.pos);
        if (110 === i) ++this.state.pos, (r = !0);
        else if (109 === i) throw this.raise(g.InvalidDecimal, t);
        if (ie(this.codePointAtPos(this.state.pos))) throw this.raise(g.NumberIdentifier, this.state.curPosition());
        if (r) {
         let e = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, '');
         this.finishToken(135, e);
        } else this.finishToken(134, n);
       }
       readNumber(e) {
        let t = this.state.pos,
         r = this.state.curPosition(),
         n = !1,
         i = !1,
         a = !1,
         o = !1,
         u = !1;
        !e && null === this.readInt(10) && this.raise(g.InvalidNumber, this.state.curPosition());
        let l = this.state.pos - t >= 2 && 48 === this.input.charCodeAt(t);
        if (l) {
         let e = this.input.slice(t, this.state.pos);
         if ((this.recordStrictModeErrors(g.StrictOctalLiteral, r), !this.state.strict)) {
          let t = e.indexOf('_');
          t > 0 && this.raise(g.ZeroDigitNumericSeparator, s(r, t));
         }
         u = l && !/[89]/.test(e);
        }
        let p = this.input.charCodeAt(this.state.pos);
        if ((46 === p && !u && (++this.state.pos, this.readInt(10), (n = !0), (p = this.input.charCodeAt(this.state.pos))), (69 === p || 101 === p) && !u && ((p = this.input.charCodeAt(++this.state.pos)), (43 === p || 45 === p) && ++this.state.pos, null === this.readInt(10) && this.raise(g.InvalidOrMissingExponent, r), (n = !0), (o = !0), (p = this.input.charCodeAt(this.state.pos))), 110 === p && ((n || l) && this.raise(g.InvalidBigIntLiteral, r), ++this.state.pos, (i = !0)), 109 === p && (this.expectPlugin('decimal', this.state.curPosition()), (o || l) && this.raise(g.InvalidDecimal, r), ++this.state.pos, (a = !0)), ie(this.codePointAtPos(this.state.pos)))) throw this.raise(g.NumberIdentifier, this.state.curPosition());
        let c = this.input.slice(t, this.state.pos).replace(/[_mn]/g, '');
        if (i) return void this.finishToken(135, c);
        if (a) return void this.finishToken(136, c);
        let h = u ? parseInt(c, 8) : parseFloat(c);
        this.finishToken(134, h);
       }
       readCodePoint(e) {
        let { code: t, pos: r } = $e(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
        return (this.state.pos = r), t;
       }
       readString(e) {
        let { str: t, pos: r, curLine: n, lineStart: s } = Me(34 === e ? 'double' : 'single', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        (this.state.pos = r + 1), (this.state.lineStart = s), (this.state.curLine = n), this.finishToken(133, t);
       }
       readTemplateContinuation() {
        this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
       }
       readTemplateToken() {
        let e = this.input[this.state.pos],
         { str: t, firstInvalidLoc: n, pos: s, curLine: i, lineStart: a } = Me('template', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        (this.state.pos = s + 1), (this.state.lineStart = a), (this.state.curLine = i), n && (this.state.firstInvalidTemplateEscapePos = new r(n.curLine, n.pos - n.lineStart, n.pos)), 96 === this.input.codePointAt(s) ? this.finishToken(24, n ? null : e + t + '`') : (this.state.pos++, this.finishToken(25, n ? null : e + t + '${'));
       }
       recordStrictModeErrors(e, t) {
        let r = t.index;
        this.state.strict && !this.state.strictErrors.has(r) ? this.raise(e, t) : this.state.strictErrors.set(r, [e, t]);
       }
       readWord1(e) {
        this.state.containsEsc = !1;
        let t = '',
         r = this.state.pos,
         n = this.state.pos;
        for (void 0 !== e && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
         let e = this.codePointAtPos(this.state.pos);
         if (ae(e)) this.state.pos += e <= 65535 ? 1 : 2;
         else {
          if (92 !== e) break;
          {
           (this.state.containsEsc = !0), (t += this.input.slice(n, this.state.pos));
           let e = this.state.curPosition(),
            s = this.state.pos === r ? ie : ae;
           if (117 !== this.input.charCodeAt(++this.state.pos)) {
            this.raise(g.MissingUnicodeEscape, this.state.curPosition()), (n = this.state.pos - 1);
            continue;
           }
           ++this.state.pos;
           let i = this.readCodePoint(!0);
           null !== i && (s(i) || this.raise(g.EscapedCharNotAnIdentifier, e), (t += String.fromCodePoint(i))), (n = this.state.pos);
          }
         }
        }
        return t + this.input.slice(n, this.state.pos);
       }
       readWord(e) {
        let t = this.readWord1(e),
         r = k.get(t);
        void 0 !== r ? this.finishToken(r, K(r)) : this.finishToken(132, t);
       }
       checkKeywordEscapes() {
        let { type: e } = this.state;
        J(e) && this.state.containsEsc && this.raise(g.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: K(e) });
       }
       raise(e, t, n = {}) {
        let s = e(t instanceof r ? t : t.loc.start, n);
        if (!this.options.errorRecovery) throw s;
        return this.isLookahead || this.state.errors.push(s), s;
       }
       raiseOverwrite(e, t, n = {}) {
        let s = t instanceof r ? t : t.loc.start,
         i = s.index,
         a = this.state.errors;
        for (let r = a.length - 1; r >= 0; r--) {
         let t = a[r];
         if (t.loc.index === i) return (a[r] = e(s, n));
         if (t.loc.index < i) break;
        }
        return this.raise(e, t, n);
       }
       updateContext(e) {}
       unexpected(e, t) {
        throw this.raise(g.UnexpectedToken, e ?? this.state.startLoc, { expected: t ? K(t) : null });
       }
       expectPlugin(e, t) {
        if (this.hasPlugin(e)) return !0;
        throw this.raise(g.MissingPlugin, t ?? this.state.startLoc, { missingPlugin: [e] });
       }
       expectOnePlugin(e) {
        if (!e.some((e) => this.hasPlugin(e))) throw this.raise(g.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: e });
       }
       errorBuilder(e) {
        return (t, r, n) => {
         this.raise(e, He(t, r, n));
        };
       }
      },
      Je = class {
       constructor() {
        (this.privateNames = new Set()), (this.loneAccessors = new Map()), (this.undefinedPrivateNames = new Map());
       }
      },
      Ke = class {
       constructor(e) {
        (this.parser = void 0), (this.stack = []), (this.undefinedPrivateNames = new Map()), (this.parser = e);
       }
       current() {
        return this.stack[this.stack.length - 1];
       }
       enter() {
        this.stack.push(new Je());
       }
       exit() {
        let e = this.stack.pop(),
         t = this.current();
        for (let [r, n] of Array.from(e.undefinedPrivateNames)) t ? t.undefinedPrivateNames.has(r) || t.undefinedPrivateNames.set(r, n) : this.parser.raise(g.InvalidPrivateFieldResolution, n, { identifierName: r });
       }
       declarePrivateName(e, t, r) {
        let { privateNames: n, loneAccessors: s, undefinedPrivateNames: i } = this.current(),
         a = n.has(e);
        if (3 & t) {
         let r = a && s.get(e);
         if (r) {
          (a = (3 & r) === (3 & t) || (4 & r) !== (4 & t)), a || s.delete(e);
         } else a || s.set(e, t);
        }
        a && this.parser.raise(g.PrivateNameRedeclaration, r, { identifierName: e }), n.add(e), i.delete(e);
       }
       usePrivateName(e, t) {
        let r;
        for (r of this.stack) if (r.privateNames.has(e)) return;
        r ? r.undefinedPrivateNames.set(e, t) : this.parser.raise(g.InvalidPrivateFieldResolution, t, { identifierName: e });
       }
      },
      Ge = class {
       constructor(e = 0) {
        this.type = e;
       }
       canBeArrowParameterDeclaration() {
        return 2 === this.type || 1 === this.type;
       }
       isCertainlyParameterDeclaration() {
        return 3 === this.type;
       }
      },
      Xe = class extends Ge {
       constructor(e) {
        super(e), (this.declarationErrors = new Map());
       }
       recordDeclarationError(e, t) {
        let r = t.index;
        this.declarationErrors.set(r, [e, t]);
       }
       clearDeclarationError(e) {
        this.declarationErrors.delete(e);
       }
       iterateErrors(e) {
        this.declarationErrors.forEach(e);
       }
      },
      Ye = class {
       constructor(e) {
        (this.parser = void 0), (this.stack = [new Ge()]), (this.parser = e);
       }
       enter(e) {
        this.stack.push(e);
       }
       exit() {
        this.stack.pop();
       }
       recordParameterInitializerError(e, t) {
        let r = t.loc.start,
         { stack: n } = this,
         s = n.length - 1,
         i = n[s];
        for (; !i.isCertainlyParameterDeclaration(); ) {
         if (!i.canBeArrowParameterDeclaration()) return;
         i.recordDeclarationError(e, r), (i = n[--s]);
        }
        this.parser.raise(e, r);
       }
       recordArrowParameterBindingError(e, t) {
        let { stack: r } = this,
         n = r[r.length - 1],
         s = t.loc.start;
        if (n.isCertainlyParameterDeclaration()) this.parser.raise(e, s);
        else {
         if (!n.canBeArrowParameterDeclaration()) return;
         n.recordDeclarationError(e, s);
        }
       }
       recordAsyncArrowParametersError(e) {
        let { stack: t } = this,
         r = t.length - 1,
         n = t[r];
        for (; n.canBeArrowParameterDeclaration(); ) 2 === n.type && n.recordDeclarationError(g.AwaitBindingIdentifier, e), (n = t[--r]);
       }
       validateAsPattern() {
        let { stack: e } = this,
         t = e[e.length - 1];
        t.canBeArrowParameterDeclaration() &&
         t.iterateErrors(([t, r]) => {
          this.parser.raise(t, r);
          let n = e.length - 2,
           s = e[n];
          for (; s.canBeArrowParameterDeclaration(); ) s.clearDeclarationError(r.index), (s = e[--n]);
         });
       }
      };
     function Qe() {
      return new Ge();
     }
     var Ze = class {
      constructor() {
       this.stacks = [];
      }
      enter(e) {
       this.stacks.push(e);
      }
      exit() {
       this.stacks.pop();
      }
      currentFlags() {
       return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
       return (2 & this.currentFlags()) > 0;
      }
      get hasYield() {
       return (1 & this.currentFlags()) > 0;
      }
      get hasReturn() {
       return (4 & this.currentFlags()) > 0;
      }
      get hasIn() {
       return (8 & this.currentFlags()) > 0;
      }
     };
     function et(e, t) {
      return (e ? 2 : 0) | (t ? 1 : 0);
     }
     var tt = class extends We {
       addExtra(e, t, r, n = !0) {
        if (!e) return;
        let s = (e.extra = e.extra || {});
        n ? (s[t] = r) : Object.defineProperty(s, t, { enumerable: n, value: r });
       }
       isContextual(e) {
        return this.state.type === e && !this.state.containsEsc;
       }
       isUnparsedContextual(e, t) {
        let r = e + t.length;
        if (this.input.slice(e, r) === t) {
         let e = this.input.charCodeAt(r);
         return !(ae(e) || 55296 == (64512 & e));
        }
        return !1;
       }
       isLookaheadContextual(e) {
        let t = this.nextTokenStart();
        return this.isUnparsedContextual(t, e);
       }
       eatContextual(e) {
        return !!this.isContextual(e) && (this.next(), !0);
       }
       expectContextual(e, t) {
        if (!this.eatContextual(e)) {
         if (null != t) throw this.raise(t, this.state.startLoc);
         this.unexpected(null, e);
        }
       }
       canInsertSemicolon() {
        return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
       }
       hasPrecedingLineBreak() {
        return we.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
       }
       hasFollowingLineBreak() {
        return (Ie.lastIndex = this.state.end), Ie.test(this.input);
       }
       isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
       }
       semicolon(e = !0) {
        (e ? this.isLineTerminator() : this.eat(13)) || this.raise(g.MissingSemicolon, this.state.lastTokEndLoc);
       }
       expect(e, t) {
        this.eat(e) || this.unexpected(t, e);
       }
       tryParse(e, t = this.state.clone()) {
        let r = { node: null };
        try {
         let n = e((e = null) => {
          throw ((r.node = e), r);
         });
         if (this.state.errors.length > t.errors.length) {
          let e = this.state;
          return (this.state = t), (this.state.tokensLength = e.tokensLength), { node: n, error: e.errors[t.errors.length], thrown: !1, aborted: !1, failState: e };
         }
         return { node: n, error: null, thrown: !1, aborted: !1, failState: null };
        } catch (n) {
         let e = this.state;
         if (((this.state = t), n instanceof SyntaxError)) return { node: null, error: n, thrown: !0, aborted: !1, failState: e };
         if (n === r) return { node: r.node, error: null, thrown: !1, aborted: !0, failState: e };
         throw n;
        }
       }
       checkExpressionErrors(e, t) {
        if (!e) return !1;
        let { shorthandAssignLoc: r, doubleProtoLoc: n, privateKeyLoc: s, optionalParametersLoc: i } = e;
        if (!t) return !!(r || n || i || s);
        null != r && this.raise(g.InvalidCoverInitializedName, r), null != n && this.raise(g.DuplicateProto, n), null != s && this.raise(g.UnexpectedPrivateField, s), null != i && this.unexpected(i);
       }
       isLiteralPropertyName() {
        return z(this.state.type);
       }
       isPrivateName(e) {
        return 'PrivateName' === e.type;
       }
       getPrivateNameSV(e) {
        return e.id.name;
       }
       hasPropertyAsPrivateName(e) {
        return ('MemberExpression' === e.type || 'OptionalMemberExpression' === e.type) && this.isPrivateName(e.property);
       }
       isObjectProperty(e) {
        return 'ObjectProperty' === e.type;
       }
       isObjectMethod(e) {
        return 'ObjectMethod' === e.type;
       }
       initializeScopes(e = 'module' === this.options.sourceType) {
        let t = this.state.labels;
        this.state.labels = [];
        let r = this.exportedIdentifiers;
        this.exportedIdentifiers = new Set();
        let n = this.inModule;
        this.inModule = e;
        let s = this.scope,
         i = this.getScopeHandler();
        this.scope = new i(this, e);
        let a = this.prodParam;
        this.prodParam = new Ze();
        let o = this.classScope;
        this.classScope = new Ke(this);
        let u = this.expressionScope;
        return (
         (this.expressionScope = new Ye(this)),
         () => {
          (this.state.labels = t), (this.exportedIdentifiers = r), (this.inModule = n), (this.scope = s), (this.prodParam = a), (this.classScope = o), (this.expressionScope = u);
         }
        );
       }
       enterInitialScopes() {
        let e = 0;
        this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
       }
       checkDestructuringPrivate(e) {
        let { privateKeyLoc: t } = e;
        null !== t && this.expectPlugin('destructuringPrivate', t);
       }
      },
      rt = class {
       constructor() {
        (this.shorthandAssignLoc = null), (this.doubleProtoLoc = null), (this.privateKeyLoc = null), (this.optionalParametersLoc = null);
       }
      },
      nt = class {
       constructor(e, t, r) {
        (this.type = ''), (this.start = t), (this.end = 0), (this.loc = new n(r)), null != e && e.options.ranges && (this.range = [t, 0]), null != e && e.filename && (this.loc.filename = e.filename);
       }
      },
      st = nt.prototype;
     function it(e) {
      let { type: t, start: r, end: n, loc: s, range: i, extra: a, name: o } = e,
       u = Object.create(st);
      return (u.type = t), (u.start = r), (u.end = n), (u.loc = s), (u.range = i), (u.extra = a), (u.name = o), 'Placeholder' === t && (u.expectedNode = e.expectedNode), u;
     }
     function at(e) {
      let { type: t, start: r, end: n, loc: s, range: i, extra: a } = e;
      if ('Placeholder' === t)
       return (function (e) {
        return it(e);
       })(e);
      let o = Object.create(st);
      return (o.type = t), (o.start = r), (o.end = n), (o.loc = s), (o.range = i), void 0 !== e.raw ? (o.raw = e.raw) : (o.extra = a), (o.value = e.value), o;
     }
     st.__clone = function () {
      let e = new nt(void 0, this.start, this.loc.start),
       t = Object.keys(this);
      for (let r = 0, n = t.length; r < n; r++) {
       let n = t[r];
       'leadingComments' !== n && 'trailingComments' !== n && 'innerComments' !== n && (e[n] = this[n]);
      }
      return e;
     };
     var ot = class extends tt {
       startNode() {
        let e = this.state.startLoc;
        return new nt(this, e.index, e);
       }
       startNodeAt(e) {
        return new nt(this, e.index, e);
       }
       startNodeAtNode(e) {
        return this.startNodeAt(e.loc.start);
       }
       finishNode(e, t) {
        return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
       }
       finishNodeAt(e, t, r) {
        return (e.type = t), (e.end = r.index), (e.loc.end = r), this.options.ranges && (e.range[1] = r.index), this.options.attachComment && this.processComment(e), e;
       }
       resetStartLocation(e, t) {
        (e.start = t.index), (e.loc.start = t), this.options.ranges && (e.range[0] = t.index);
       }
       resetEndLocation(e, t = this.state.lastTokEndLoc) {
        (e.end = t.index), (e.loc.end = t), this.options.ranges && (e.range[1] = t.index);
       }
       resetStartLocationFromNode(e, t) {
        this.resetStartLocation(e, t.loc.start);
       }
      },
      ut = new Set(['_', 'any', 'bool', 'boolean', 'empty', 'extends', 'false', 'interface', 'mixed', 'null', 'number', 'static', 'string', 'true', 'typeof', 'void']),
      lt = y`flow`({ AmbiguousConditionalArrow: 'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.', AmbiguousDeclareModuleKind: 'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.', AssignReservedType: ({ reservedType: e }) => `Cannot overwrite reserved type ${e}.`, DeclareClassElement: 'The `declare` modifier can only appear on class fields.', DeclareClassFieldInitializer: 'Initializers are not allowed in fields with the `declare` modifier.', DuplicateDeclareModuleExports: 'Duplicate `declare module.exports` statement.', EnumBooleanMemberNotInitialized: ({ memberName: e, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, EnumDuplicateMemberName: ({ memberName: e, enumName: t }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, EnumInconsistentMemberValues: ({ enumName: e }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: e, enumName: t }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: e, memberName: t, explicitType: r }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: e, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: e, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, EnumInvalidMemberName: ({ enumName: e, memberName: t, suggestion: r }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`, EnumNumberMemberNotInitialized: ({ enumName: e, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: e }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.', ImportReflectionHasImportType: 'An `import module` declaration can not use `type` or `typeof` keyword.', ImportTypeShorthandOnlyInPureImport: 'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.', InexactInsideExact: 'Explicit inexact syntax cannot appear inside an explicit exact object type.', InexactInsideNonObject: 'Explicit inexact syntax cannot appear in class or interface definitions.', InexactVariance: 'Explicit inexact syntax cannot have variance.', InvalidNonTypeImportInDeclareModule: 'Imports within a `declare module` body must always be `import type` or `import typeof`.', MissingTypeParamDefault: 'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.', NestedDeclareModule: '`declare module` cannot be used inside another `declare module`.', NestedFlowComment: 'Cannot have a flow comment inside another flow comment.', PatternIsOptional: Object.assign({ message: 'A binding pattern parameter cannot be optional in an implementation signature.' }, { reasonCode: 'OptionalBindingPattern' }), SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.', SpreadVariance: 'Spread properties cannot have variance.', ThisParamAnnotationRequired: 'A type annotation is required for the `this` parameter.', ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.', ThisParamMustBeFirst: 'The `this` parameter must be the first function parameter.', ThisParamNoDefault: 'The `this` parameter may not have a default value.', TypeBeforeInitializer: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.', TypeCastInPattern: 'The type cast expression is expected to be wrapped with parenthesis.', UnexpectedExplicitInexactInObject: 'Explicit inexact syntax must appear at the end of an inexact object.', UnexpectedReservedType: ({ reservedType: e }) => `Unexpected reserved type ${e}.`, UnexpectedReservedUnderscore: '`_` is only allowed as a type argument to call or new.', UnexpectedSpaceBetweenModuloChecks: 'Spaces between `%` and `checks` are not allowed here.', UnexpectedSpreadType: 'Spread operator cannot appear in class or interface definitions.', UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: 'Expected an arrow function after this type parameter declaration.', UnexpectedTypeParameterBeforeAsyncArrowFunction: 'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.', UnsupportedDeclareExportKind: ({ unsupportedExportKind: e, suggestion: t }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, UnsupportedStatementInDeclareModule: 'Only declares and type imports are allowed inside declare module.', UnterminatedFlowComment: 'Unterminated flow-comment.' });
     function pt(e) {
      return 'type' === e.importKind || 'typeof' === e.importKind;
     }
     var ct = { const: 'declare export var', let: 'declare export var', type: 'export type', interface: 'export interface' };
     var ht = /\*?\s*@((?:no)?flow)\b/,
      dt = y`jsx`({ AttributeIsEmpty: 'JSX attributes must only be assigned a non-empty expression.', MissingClosingTagElement: ({ openingTagName: e }) => `Expected corresponding JSX closing tag for <${e}>.`, MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>.', UnexpectedSequenceExpression: 'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?', UnexpectedToken: ({ unexpected: e, HTMLEntity: t }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, UnsupportedJsxValue: 'JSX value should be either an expression or a quoted JSX text.', UnterminatedJsxContent: 'Unterminated JSX contents.', UnwrappedAdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?' });
     function ft(e) {
      return !!e && ('JSXOpeningFragment' === e.type || 'JSXClosingFragment' === e.type);
     }
     function mt(e) {
      if ('JSXIdentifier' === e.type) return e.name;
      if ('JSXNamespacedName' === e.type) return e.namespace.name + ':' + e.name.name;
      if ('JSXMemberExpression' === e.type) return mt(e.object) + '.' + mt(e.property);
      throw new Error('Node had unexpected type: ' + e.type);
     }
     var yt = class extends ge {
       constructor(...e) {
        super(...e), (this.tsNames = new Map());
       }
      },
      gt = class extends De {
       constructor(...e) {
        super(...e), (this.importsStack = []);
       }
       createScope(e) {
        return this.importsStack.push(new Set()), new yt(e);
       }
       enter(e) {
        256 === e && this.importsStack.push(new Set()), super.enter(e);
       }
       exit() {
        let e = super.exit();
        return 256 === e && this.importsStack.pop(), e;
       }
       hasImport(e, t) {
        let r = this.importsStack.length;
        if (this.importsStack[r - 1].has(e)) return !0;
        if (!t && r > 1) for (let n = 0; n < r - 1; n++) if (this.importsStack[n].has(e)) return !0;
        return !1;
       }
       declareName(e, t, r) {
        if (4096 & t) return this.hasImport(e, !0) && this.parser.raise(g.VarRedeclaration, r, { identifierName: e }), void this.importsStack[this.importsStack.length - 1].add(e);
        let n = this.currentScope(),
         s = n.tsNames.get(e) || 0;
        if (1024 & t) return this.maybeExportDefined(n, e), void n.tsNames.set(e, 16 | s);
        super.declareName(e, t, r), 2 & t && (1 & t || (this.checkRedeclarationInScope(n, e, t, r), this.maybeExportDefined(n, e)), (s |= 1)), 256 & t && (s |= 2), 512 & t && (s |= 4), 128 & t && (s |= 8), s && n.tsNames.set(e, s);
       }
       isRedeclaredInScope(e, t, r) {
        let n = e.tsNames.get(t);
        if ((2 & n) > 0) {
         if (256 & r) {
          return !!(512 & r) !== (4 & n) > 0;
         }
         return !0;
        }
        return 128 & r && (8 & n) > 0 ? !!(2 & e.names.get(t)) && !!(1 & r) : !!(2 & r && (1 & n) > 0) || super.isRedeclaredInScope(e, t, r);
       }
       checkLocalExport(e) {
        let { name: t } = e;
        if (!this.hasImport(t)) {
         for (let e = this.scopeStack.length - 1; e >= 0; e--) {
          let r = this.scopeStack[e].tsNames.get(t);
          if ((1 & r) > 0 || (16 & r) > 0) return;
         }
         super.checkLocalExport(e);
        }
       }
      },
      Dt = (e) => ('ParenthesizedExpression' === e.type ? Dt(e.expression) : e),
      xt = class extends ot {
       toAssignable(e, t = !1) {
        var r, n;
        let s;
        switch ((('ParenthesizedExpression' === e.type || (null != (r = e.extra) && r.parenthesized)) && ((s = Dt(e)), t ? ('Identifier' === s.type ? this.expressionScope.recordArrowParameterBindingError(g.InvalidParenthesizedAssignment, e) : 'MemberExpression' !== s.type && !this.isOptionalMemberExpression(s) && this.raise(g.InvalidParenthesizedAssignment, e)) : this.raise(g.InvalidParenthesizedAssignment, e)), e.type)) {
         case 'Identifier':
         case 'ObjectPattern':
         case 'ArrayPattern':
         case 'AssignmentPattern':
         case 'RestElement':
          break;
         case 'ObjectExpression':
          e.type = 'ObjectPattern';
          for (let r = 0, n = e.properties.length, s = n - 1; r < n; r++) {
           var i;
           let n = e.properties[r],
            a = r === s;
           this.toAssignableObjectExpressionProp(n, a, t), a && 'RestElement' === n.type && null != (i = e.extra) && i.trailingCommaLoc && this.raise(g.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
         case 'ObjectProperty': {
          let { key: r, value: n } = e;
          this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(n, t);
          break;
         }
         case 'SpreadElement':
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
         case 'ArrayExpression':
          (e.type = 'ArrayPattern'), this.toAssignableList(e.elements, null == (n = e.extra) ? void 0 : n.trailingCommaLoc, t);
          break;
         case 'AssignmentExpression':
          '=' !== e.operator && this.raise(g.MissingEqInAssignment, e.left.loc.end), (e.type = 'AssignmentPattern'), delete e.operator, this.toAssignable(e.left, t);
          break;
         case 'ParenthesizedExpression':
          this.toAssignable(s, t);
        }
       }
       toAssignableObjectExpressionProp(e, t, r) {
        if ('ObjectMethod' === e.type) this.raise('get' === e.kind || 'set' === e.kind ? g.PatternHasAccessor : g.PatternHasMethod, e.key);
        else if ('SpreadElement' === e.type) {
         e.type = 'RestElement';
         let n = e.argument;
         this.checkToRestConversion(n, !1), this.toAssignable(n, r), t || this.raise(g.RestTrailingComma, e);
        } else this.toAssignable(e, r);
       }
       toAssignableList(e, t, r) {
        let n = e.length - 1;
        for (let s = 0; s <= n; s++) {
         let i = e[s];
         if (i) {
          if ('SpreadElement' === i.type) {
           i.type = 'RestElement';
           let e = i.argument;
           this.checkToRestConversion(e, !0), this.toAssignable(e, r);
          } else this.toAssignable(i, r);
          'RestElement' === i.type && (s < n ? this.raise(g.RestTrailingComma, i) : t && this.raise(g.RestTrailingComma, t));
         }
        }
       }
       isAssignable(e, t) {
        switch (e.type) {
         case 'Identifier':
         case 'ObjectPattern':
         case 'ArrayPattern':
         case 'AssignmentPattern':
         case 'RestElement':
          return !0;
         case 'ObjectExpression': {
          let t = e.properties.length - 1;
          return e.properties.every((e, r) => 'ObjectMethod' !== e.type && (r === t || 'SpreadElement' !== e.type) && this.isAssignable(e));
         }
         case 'ObjectProperty':
          return this.isAssignable(e.value);
         case 'SpreadElement':
          return this.isAssignable(e.argument);
         case 'ArrayExpression':
          return e.elements.every((e) => null === e || this.isAssignable(e));
         case 'AssignmentExpression':
          return '=' === e.operator;
         case 'ParenthesizedExpression':
          return this.isAssignable(e.expression);
         case 'MemberExpression':
         case 'OptionalMemberExpression':
          return !t;
         default:
          return !1;
        }
       }
       toReferencedList(e, t) {
        return e;
       }
       toReferencedListDeep(e, t) {
        this.toReferencedList(e, t);
        for (let r of e) 'ArrayExpression' === (null == r ? void 0 : r.type) && this.toReferencedListDeep(r.elements);
       }
       parseSpread(e) {
        let t = this.startNode();
        return this.next(), (t.argument = this.parseMaybeAssignAllowIn(e, void 0)), this.finishNode(t, 'SpreadElement');
       }
       parseRestBinding() {
        let e = this.startNode();
        return this.next(), (e.argument = this.parseBindingAtom()), this.finishNode(e, 'RestElement');
       }
       parseBindingAtom() {
        switch (this.state.type) {
         case 0: {
          let e = this.startNode();
          return this.next(), (e.elements = this.parseBindingList(3, 93, 1)), this.finishNode(e, 'ArrayPattern');
         }
         case 5:
          return this.parseObjectLike(8, !0);
        }
        return this.parseIdentifier();
       }
       parseBindingList(e, t, r) {
        let n = 1 & r,
         s = [],
         i = !0;
        for (; !this.eat(e); )
         if ((i ? (i = !1) : this.expect(12), n && this.match(12))) s.push(null);
         else {
          if (this.eat(e)) break;
          if (this.match(21)) {
           if ((s.push(this.parseAssignableListItemTypes(this.parseRestBinding(), r)), !this.checkCommaAfterRest(t))) {
            this.expect(e);
            break;
           }
          } else {
           let e = [];
           for (this.match(26) && this.hasPlugin('decorators') && this.raise(g.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) e.push(this.parseDecorator());
           s.push(this.parseAssignableListItem(r, e));
          }
         }
        return s;
       }
       parseBindingRestProperty(e) {
        return this.next(), (e.argument = this.parseIdentifier()), this.checkCommaAfterRest(125), this.finishNode(e, 'RestElement');
       }
       parseBindingProperty() {
        let { type: e, startLoc: t } = this.state;
        if (21 === e) return this.parseBindingRestProperty(this.startNode());
        let r = this.startNode();
        return 138 === e ? (this.expectPlugin('destructuringPrivate', t), this.classScope.usePrivateName(this.state.value, t), (r.key = this.parsePrivateName())) : this.parsePropertyName(r), (r.method = !1), this.parseObjPropValue(r, t, !1, !1, !0, !1);
       }
       parseAssignableListItem(e, t) {
        let r = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(r, e);
        let n = this.parseMaybeDefault(r.loc.start, r);
        return t.length && (r.decorators = t), n;
       }
       parseAssignableListItemTypes(e, t) {
        return e;
       }
       parseMaybeDefault(e, t) {
        var r;
        if ((null != e || (e = this.state.startLoc), (t = null != (r = t) ? r : this.parseBindingAtom()), !this.eat(29))) return t;
        let n = this.startNodeAt(e);
        return (n.left = t), (n.right = this.parseMaybeAssignAllowIn()), this.finishNode(n, 'AssignmentPattern');
       }
       isValidLVal(e, t, r) {
        return ((e, t) => hasOwnProperty.call(e, t) && e[t])({ AssignmentPattern: 'left', RestElement: 'argument', ObjectProperty: 'value', ParenthesizedExpression: 'expression', ArrayPattern: 'elements', ObjectPattern: 'properties' }, e);
       }
       isOptionalMemberExpression(e) {
        return 'OptionalMemberExpression' === e.type;
       }
       checkLVal(e, { in: t, binding: r = 64, checkClashes: n = !1, strictModeChanged: s = !1, hasParenthesizedAncestor: i = !1 }) {
        var a;
        let o = e.type;
        if (this.isObjectMethod(e)) return;
        let u = this.isOptionalMemberExpression(e);
        if (u || 'MemberExpression' === o) return u && (this.expectPlugin('optionalChainingAssign', e.loc.start), 'AssignmentExpression' !== t.type && this.raise(g.InvalidLhsOptionalChaining, e, { ancestor: t })), void (64 !== r && this.raise(g.InvalidPropertyBindingPattern, e));
        if ('Identifier' === o) {
         this.checkIdentifier(e, r, s);
         let { name: t } = e;
         return void (n && (n.has(t) ? this.raise(g.ParamDupe, e) : n.add(t)));
        }
        let l = this.isValidLVal(o, !(i || (null != (a = e.extra) && a.parenthesized)) && 'AssignmentExpression' === t.type, r);
        if (!0 === l) return;
        if (!1 === l) {
         let n = 64 === r ? g.InvalidLhs : g.InvalidLhsBinding;
         return void this.raise(n, e, { ancestor: t });
        }
        let [p, c] = Array.isArray(l) ? l : [l, 'ParenthesizedExpression' === o],
         h = 'ArrayPattern' === o || 'ObjectPattern' === o ? { type: o } : t;
        for (let d of [].concat(e[p])) d && this.checkLVal(d, { in: h, binding: r, checkClashes: n, strictModeChanged: s, hasParenthesizedAncestor: c });
       }
       checkIdentifier(e, t, r = !1) {
        this.state.strict && (r ? me(e.name, this.inModule) : fe(e.name)) && (64 === t ? this.raise(g.StrictEvalArguments, e, { referenceName: e.name }) : this.raise(g.StrictEvalArgumentsBinding, e, { bindingName: e.name })), 8192 & t && 'let' === e.name && this.raise(g.LetInLexicalBinding, e), 64 & t || this.declareNameFromIdentifier(e, t);
       }
       declareNameFromIdentifier(e, t) {
        this.scope.declareName(e.name, t, e.loc.start);
       }
       checkToRestConversion(e, t) {
        switch (e.type) {
         case 'ParenthesizedExpression':
          this.checkToRestConversion(e.expression, t);
          break;
         case 'Identifier':
         case 'MemberExpression':
          break;
         case 'ArrayExpression':
         case 'ObjectExpression':
          if (t) break;
         default:
          this.raise(g.InvalidRestAssignmentPattern, e);
        }
       }
       checkCommaAfterRest(e) {
        return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e ? g.RestTrailingComma : g.ElementAfterRest, this.state.startLoc), !0);
       }
      };
     function bt(e) {
      if (!e) throw new Error('Assert fail');
     }
     var vt = y`typescript`({ AbstractMethodHasImplementation: ({ methodName: e }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: e }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: 'An accessor cannot have type parameters.', AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: 'Type parameters cannot appear on a constructor declaration.', DeclareAccessor: ({ kind: e }) => `'declare' is not allowed in ${e}ters.`, DeclareClassFieldHasInitializer: 'Initializers are not allowed in ambient contexts.', DeclareFunctionHasImplementation: 'An implementation cannot be declared in ambient contexts.', DuplicateAccessibilityModifier: ({ modifier: e }) => 'Accessibility modifier already seen.', DuplicateModifier: ({ modifier: e }) => `Duplicate modifier: '${e}'.`, EmptyHeritageClauseType: ({ token: e }) => `'${e}' list cannot be empty.`, EmptyTypeArguments: 'Type argument list cannot be empty.', EmptyTypeParameters: 'Type parameter list cannot be empty.', ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: 'An `import module` declaration can not use `type` modifier', IncompatibleModifiers: ({ modifiers: e }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: e }) => `Index signatures cannot have an accessibility modifier ('${e}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: 'Initializers are not allowed in ambient contexts.', InvalidModifierOnTypeMember: ({ modifier: e }) => `'${e}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: e }) => `'${e}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: e }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: e }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: 'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.', InvalidTupleMemberLabel: 'Tuple members must be labeled with a simple identifier.', MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: 'Abstract methods can only appear within an abstract class.', NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: 'A required element cannot follow an optional element.', OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: 'A binding pattern parameter cannot be optional in an implementation signature.', PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: e }) => `Private elements cannot have an accessibility modifier ('${e}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: 'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.', ReservedTypeAssertion: 'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.', SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, StaticBlockCannotHaveModifier: 'Static class blocks cannot have any modifier.', TupleOptionalAfterType: 'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).', TypeAnnotationAfterAssign: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.', TypeImportCannotSpecifyDefaultAndNamed: 'A type-only import can specify a default import or named bindings, but not both.', TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: 'A parameter property is only allowed in a constructor implementation.', UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: 'Did not expect a type annotation here.', UnexpectedTypeCastInParameter: 'Unexpected type cast in parameter position.', UnsupportedImportTypeArgument: 'Argument in a type import must be a string literal.', UnsupportedParameterPropertyKind: 'A parameter property may not be declared using a binding pattern.', UnsupportedSignatureParameterKind: ({ type: e }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.` });
     function Et(e) {
      return 'private' === e || 'public' === e || 'protected' === e;
     }
     function Ct(e) {
      return 'in' === e || 'out' === e;
     }
     function Tt(e) {
      if ('MemberExpression' !== e.type) return !1;
      let { computed: t, property: r } = e;
      return (!t || 'StringLiteral' === r.type || !('TemplateLiteral' !== r.type || r.expressions.length > 0)) && At(e.object);
     }
     function St(e, t) {
      var r;
      let { type: n } = e;
      if (null != (r = e.extra) && r.parenthesized) return !1;
      if (t) {
       if ('Literal' === n) {
        let { value: t } = e;
        if ('string' == typeof t || 'boolean' == typeof t) return !0;
       }
      } else if ('StringLiteral' === n || 'BooleanLiteral' === n) return !0;
      return !!(
       wt(e, t) ||
       (function (e, t) {
        if ('UnaryExpression' === e.type) {
         let { operator: r, argument: n } = e;
         if ('-' === r && wt(n, t)) return !0;
        }
        return !1;
       })(e, t) ||
       ('TemplateLiteral' === n && 0 === e.expressions.length) ||
       Tt(e)
      );
     }
     function wt(e, t) {
      return t ? 'Literal' === e.type && ('number' == typeof e.value || 'bigint' in e) : 'NumericLiteral' === e.type || 'BigIntLiteral' === e.type;
     }
     function At(e) {
      return 'Identifier' === e.type || ('MemberExpression' === e.type && !e.computed && At(e.object));
     }
     var Ft = y`placeholders`({ ClassNameIsRequired: 'A class name is required.', UnexpectedSpace: 'Unexpected space in placeholder.' });
     function kt(e, t) {
      let [r, n] = 'string' == typeof t ? [t, {}] : t,
       s = Object.keys(n),
       i = 0 === s.length;
      return e.some((e) => {
       if ('string' == typeof e) return i && e === r;
       {
        let [t, i] = e;
        if (t !== r) return !1;
        for (let e of s) if (i[e] !== n[e]) return !1;
        return !0;
       }
      });
     }
     function Pt(e, t, r) {
      let n = e.find((e) => (Array.isArray(e) ? e[0] === t : e === t));
      return n && Array.isArray(n) && n.length > 1 ? n[1][r] : null;
     }
     var It = ['minimal', 'fsharp', 'hack', 'smart'],
      Nt = ['^^', '@@', '^', '%', '#'];
     var Bt = {
       estree: (e) =>
        class extends e {
         parse() {
          let e = b(super.parse());
          return this.options.tokens && (e.tokens = e.tokens.map(b)), e;
         }
         parseRegExpLiteral({ pattern: e, flags: t }) {
          let r = null;
          try {
           r = new RegExp(e, t);
          } catch {}
          let n = this.estreeParseLiteral(r);
          return (n.regex = { pattern: e, flags: t }), n;
         }
         parseBigIntLiteral(e) {
          let t;
          try {
           t = BigInt(e);
          } catch {
           t = null;
          }
          let r = this.estreeParseLiteral(t);
          return (r.bigint = String(r.value || e)), r;
         }
         parseDecimalLiteral(e) {
          let t = this.estreeParseLiteral(null);
          return (t.decimal = String(t.value || e)), t;
         }
         estreeParseLiteral(e) {
          return this.parseLiteral(e, 'Literal');
         }
         parseStringLiteral(e) {
          return this.estreeParseLiteral(e);
         }
         parseNumericLiteral(e) {
          return this.estreeParseLiteral(e);
         }
         parseNullLiteral() {
          return this.estreeParseLiteral(null);
         }
         parseBooleanLiteral(e) {
          return this.estreeParseLiteral(e);
         }
         directiveToStmt(e) {
          let t = e.value;
          delete e.value, (t.type = 'Literal'), (t.raw = t.extra.raw), (t.value = t.extra.expressionValue);
          let r = e;
          return (r.type = 'ExpressionStatement'), (r.expression = t), (r.directive = t.extra.rawValue), delete t.extra, r;
         }
         initFunction(e, t) {
          super.initFunction(e, t), (e.expression = !1);
         }
         checkDeclaration(e) {
          null != e && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
         }
         getObjectOrClassMethodParams(e) {
          return e.value.params;
         }
         isValidDirective(e) {
          var t;
          return 'ExpressionStatement' === e.type && 'Literal' === e.expression.type && 'string' == typeof e.expression.value && !(null != (t = e.expression.extra) && t.parenthesized);
         }
         parseBlockBody(e, t, r, n, s) {
          super.parseBlockBody(e, t, r, n, s);
          let i = e.directives.map((e) => this.directiveToStmt(e));
          (e.body = i.concat(e.body)), delete e.directives;
         }
         pushClassMethod(e, t, r, n, s, i) {
          this.parseMethod(t, r, n, s, i, 'ClassMethod', !0), t.typeParameters && ((t.value.typeParameters = t.typeParameters), delete t.typeParameters), e.body.push(t);
         }
         parsePrivateName() {
          let e = super.parsePrivateName();
          return this.getPluginOption('estree', 'classFeatures') ? this.convertPrivateNameToPrivateIdentifier(e) : e;
         }
         convertPrivateNameToPrivateIdentifier(e) {
          let t = super.getPrivateNameSV(e);
          return delete e.id, (e.name = t), (e.type = 'PrivateIdentifier'), e;
         }
         isPrivateName(e) {
          return this.getPluginOption('estree', 'classFeatures') ? 'PrivateIdentifier' === e.type : super.isPrivateName(e);
         }
         getPrivateNameSV(e) {
          return this.getPluginOption('estree', 'classFeatures') ? e.name : super.getPrivateNameSV(e);
         }
         parseLiteral(e, t) {
          let r = super.parseLiteral(e, t);
          return (r.raw = r.extra.raw), delete r.extra, r;
         }
         parseFunctionBody(e, t, r = !1) {
          super.parseFunctionBody(e, t, r), (e.expression = 'BlockStatement' !== e.body.type);
         }
         parseMethod(e, t, r, n, s, i, a = !1) {
          let o = this.startNode();
          return (o.kind = e.kind), (o = super.parseMethod(o, t, r, n, s, i, a)), (o.type = 'FunctionExpression'), delete o.kind, (e.value = o), 'ClassPrivateMethod' === i && (e.computed = !1), this.finishNode(e, 'MethodDefinition');
         }
         nameIsConstructor(e) {
          return 'Literal' === e.type ? 'constructor' === e.value : super.nameIsConstructor(e);
         }
         parseClassProperty(...e) {
          let t = super.parseClassProperty(...e);
          return this.getPluginOption('estree', 'classFeatures') && (t.type = 'PropertyDefinition'), t;
         }
         parseClassPrivateProperty(...e) {
          let t = super.parseClassPrivateProperty(...e);
          return this.getPluginOption('estree', 'classFeatures') && ((t.type = 'PropertyDefinition'), (t.computed = !1)), t;
         }
         parseObjectMethod(e, t, r, n, s) {
          let i = super.parseObjectMethod(e, t, r, n, s);
          return i && ((i.type = 'Property'), 'method' === i.kind && (i.kind = 'init'), (i.shorthand = !1)), i;
         }
         parseObjectProperty(e, t, r, n) {
          let s = super.parseObjectProperty(e, t, r, n);
          return s && ((s.kind = 'init'), (s.type = 'Property')), s;
         }
         isValidLVal(e, t, r) {
          return 'Property' === e ? 'value' : super.isValidLVal(e, t, r);
         }
         isAssignable(e, t) {
          return null != e && this.isObjectProperty(e) ? this.isAssignable(e.value, t) : super.isAssignable(e, t);
         }
         toAssignable(e, t = !1) {
          if (null != e && this.isObjectProperty(e)) {
           let { key: r, value: n } = e;
           this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(n, t);
          } else super.toAssignable(e, t);
         }
         toAssignableObjectExpressionProp(e, t, r) {
          'Property' !== e.type || ('get' !== e.kind && 'set' !== e.kind) ? ('Property' === e.type && e.method ? this.raise(g.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, t, r)) : this.raise(g.PatternHasAccessor, e.key);
         }
         finishCallExpression(e, t) {
          let r = super.finishCallExpression(e, t);
          if ('Import' === r.callee.type) {
           var n, s;
           if (((r.type = 'ImportExpression'), (r.source = r.arguments[0]), this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions'))) (r.options = null != (n = r.arguments[1]) ? n : null), (r.attributes = null != (s = r.arguments[1]) ? s : null);
           delete r.arguments, delete r.callee;
          }
          return r;
         }
         toReferencedArguments(e) {
          'ImportExpression' !== e.type && super.toReferencedArguments(e);
         }
         parseExport(e, t) {
          let r = this.state.lastTokStartLoc,
           n = super.parseExport(e, t);
          switch (n.type) {
           case 'ExportAllDeclaration':
            n.exported = null;
            break;
           case 'ExportNamedDeclaration':
            1 === n.specifiers.length && 'ExportNamespaceSpecifier' === n.specifiers[0].type && ((n.type = 'ExportAllDeclaration'), (n.exported = n.specifiers[0].exported), delete n.specifiers);
           case 'ExportDefaultDeclaration': {
            var s;
            let { declaration: e } = n;
            'ClassDeclaration' === (null == e ? void 0 : e.type) && (null == (s = e.decorators) ? void 0 : s.length) > 0 && e.start === n.start && this.resetStartLocation(n, r);
           }
          }
          return n;
         }
         parseSubscript(e, t, r, n) {
          let s = super.parseSubscript(e, t, r, n);
          if (n.optionalChainMember) {
           if ((('OptionalMemberExpression' === s.type || 'OptionalCallExpression' === s.type) && (s.type = s.type.substring(8)), n.stop)) {
            let e = this.startNodeAtNode(s);
            return (e.expression = s), this.finishNode(e, 'ChainExpression');
           }
          } else ('MemberExpression' === s.type || 'CallExpression' === s.type) && (s.optional = !1);
          return s;
         }
         isOptionalMemberExpression(e) {
          return 'ChainExpression' === e.type ? 'MemberExpression' === e.expression.type : super.isOptionalMemberExpression(e);
         }
         hasPropertyAsPrivateName(e) {
          return 'ChainExpression' === e.type && (e = e.expression), super.hasPropertyAsPrivateName(e);
         }
         isObjectProperty(e) {
          return 'Property' === e.type && 'init' === e.kind && !e.method;
         }
         isObjectMethod(e) {
          return 'Property' === e.type && (e.method || 'get' === e.kind || 'set' === e.kind);
         }
         finishNodeAt(e, t, r) {
          return b(super.finishNodeAt(e, t, r));
         }
         resetStartLocation(e, t) {
          super.resetStartLocation(e, t), b(e);
         }
         resetEndLocation(e, t = this.state.lastTokEndLoc) {
          super.resetEndLocation(e, t), b(e);
         }
        },
       jsx: (e) =>
        class extends e {
         jsxReadToken() {
          let e = '',
           t = this.state.pos;
          for (;;) {
           if (this.state.pos >= this.length) throw this.raise(dt.UnterminatedJsxContent, this.state.startLoc);
           let r = this.input.charCodeAt(this.state.pos);
           switch (r) {
            case 60:
            case 123:
             return this.state.pos === this.state.start ? void (60 === r && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(r)) : ((e += this.input.slice(t, this.state.pos)), void this.finishToken(141, e));
            case 38:
             (e += this.input.slice(t, this.state.pos)), (e += this.jsxReadEntity()), (t = this.state.pos);
             break;
            default:
             Fe(r) ? ((e += this.input.slice(t, this.state.pos)), (e += this.jsxReadNewLine(!0)), (t = this.state.pos)) : ++this.state.pos;
           }
          }
         }
         jsxReadNewLine(e) {
          let t,
           r = this.input.charCodeAt(this.state.pos);
          return ++this.state.pos, 13 === r && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, (t = e ? '\n' : '\r\n')) : (t = String.fromCharCode(r)), ++this.state.curLine, (this.state.lineStart = this.state.pos), t;
         }
         jsxReadString(e) {
          let t = '',
           r = ++this.state.pos;
          for (;;) {
           if (this.state.pos >= this.length) throw this.raise(g.UnterminatedString, this.state.startLoc);
           let n = this.input.charCodeAt(this.state.pos);
           if (n === e) break;
           38 === n ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadEntity()), (r = this.state.pos)) : Fe(n) ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadNewLine(!1)), (r = this.state.pos)) : ++this.state.pos;
          }
          (t += this.input.slice(r, this.state.pos++)), this.finishToken(133, t);
         }
         jsxReadEntity() {
          let e = ++this.state.pos;
          if (35 === this.codePointAtPos(this.state.pos)) {
           ++this.state.pos;
           let e = 10;
           120 === this.codePointAtPos(this.state.pos) && ((e = 16), ++this.state.pos);
           let t = this.readInt(e, void 0, !1, 'bail');
           if (null !== t && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t);
          } else {
           let t = 0,
            r = !1;
           for (; t++ < 10 && this.state.pos < this.length && !(r = 59 === this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
           if (r) {
            let t;
            this.input.slice(e, this.state.pos);
            if ((++this.state.pos, t)) return t;
           }
          }
          return (this.state.pos = e), '&';
         }
         jsxReadWord() {
          let e,
           t = this.state.pos;
          do {
           e = this.input.charCodeAt(++this.state.pos);
          } while (ae(e) || 45 === e);
          this.finishToken(140, this.input.slice(t, this.state.pos));
         }
         jsxParseIdentifier() {
          let e = this.startNode();
          return this.match(140) ? (e.name = this.state.value) : J(this.state.type) ? (e.name = K(this.state.type)) : this.unexpected(), this.next(), this.finishNode(e, 'JSXIdentifier');
         }
         jsxParseNamespacedName() {
          let e = this.state.startLoc,
           t = this.jsxParseIdentifier();
          if (!this.eat(14)) return t;
          let r = this.startNodeAt(e);
          return (r.namespace = t), (r.name = this.jsxParseIdentifier()), this.finishNode(r, 'JSXNamespacedName');
         }
         jsxParseElementName() {
          let e = this.state.startLoc,
           t = this.jsxParseNamespacedName();
          if ('JSXNamespacedName' === t.type) return t;
          for (; this.eat(16); ) {
           let r = this.startNodeAt(e);
           (r.object = t), (r.property = this.jsxParseIdentifier()), (t = this.finishNode(r, 'JSXMemberExpression'));
          }
          return t;
         }
         jsxParseAttributeValue() {
          let e;
          switch (this.state.type) {
           case 5:
            return (e = this.startNode()), this.setContext(E.brace), this.next(), (e = this.jsxParseExpressionContainer(e, E.j_oTag)), 'JSXEmptyExpression' === e.expression.type && this.raise(dt.AttributeIsEmpty, e), e;
           case 142:
           case 133:
            return this.parseExprAtom();
           default:
            throw this.raise(dt.UnsupportedJsxValue, this.state.startLoc);
          }
         }
         jsxParseEmptyExpression() {
          let e = this.startNodeAt(this.state.lastTokEndLoc);
          return this.finishNodeAt(e, 'JSXEmptyExpression', this.state.startLoc);
         }
         jsxParseSpreadChild(e) {
          return this.next(), (e.expression = this.parseExpression()), this.setContext(E.j_expr), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXSpreadChild');
         }
         jsxParseExpressionContainer(e, t) {
          if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
          else {
           let t = this.parseExpression();
           e.expression = t;
          }
          return this.setContext(t), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXExpressionContainer');
         }
         jsxParseAttribute() {
          let e = this.startNode();
          return this.match(5) ? (this.setContext(E.brace), this.next(), this.expect(21), (e.argument = this.parseMaybeAssignAllowIn()), this.setContext(E.j_oTag), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXSpreadAttribute')) : ((e.name = this.jsxParseNamespacedName()), (e.value = this.eat(29) ? this.jsxParseAttributeValue() : null), this.finishNode(e, 'JSXAttribute'));
         }
         jsxParseOpeningElementAt(e) {
          let t = this.startNodeAt(e);
          return this.eat(143) ? this.finishNode(t, 'JSXOpeningFragment') : ((t.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(t));
         }
         jsxParseOpeningElementAfterName(e) {
          let t = [];
          for (; !this.match(56) && !this.match(143); ) t.push(this.jsxParseAttribute());
          return (e.attributes = t), (e.selfClosing = this.eat(56)), this.expect(143), this.finishNode(e, 'JSXOpeningElement');
         }
         jsxParseClosingElementAt(e) {
          let t = this.startNodeAt(e);
          return this.eat(143) ? this.finishNode(t, 'JSXClosingFragment') : ((t.name = this.jsxParseElementName()), this.expect(143), this.finishNode(t, 'JSXClosingElement'));
         }
         jsxParseElementAt(e) {
          let t = this.startNodeAt(e),
           r = [],
           n = this.jsxParseOpeningElementAt(e),
           s = null;
          if (!n.selfClosing) {
           e: for (;;)
            switch (this.state.type) {
             case 142:
              if (((e = this.state.startLoc), this.next(), this.eat(56))) {
               s = this.jsxParseClosingElementAt(e);
               break e;
              }
              r.push(this.jsxParseElementAt(e));
              break;
             case 141:
              r.push(this.parseLiteral(this.state.value, 'JSXText'));
              break;
             case 5: {
              let e = this.startNode();
              this.setContext(E.brace), this.next(), this.match(21) ? r.push(this.jsxParseSpreadChild(e)) : r.push(this.jsxParseExpressionContainer(e, E.j_expr));
              break;
             }
             default:
              this.unexpected();
            }
           ft(n) && !ft(s) && null !== s ? this.raise(dt.MissingClosingTagFragment, s) : ((!ft(n) && ft(s)) || (!ft(n) && !ft(s) && mt(s.name) !== mt(n.name))) && this.raise(dt.MissingClosingTagElement, s, { openingTagName: mt(n.name) });
          }
          if ((ft(n) ? ((t.openingFragment = n), (t.closingFragment = s)) : ((t.openingElement = n), (t.closingElement = s)), (t.children = r), this.match(47))) throw this.raise(dt.UnwrappedAdjacentJSXElements, this.state.startLoc);
          return ft(n) ? this.finishNode(t, 'JSXFragment') : this.finishNode(t, 'JSXElement');
         }
         jsxParseElement() {
          let e = this.state.startLoc;
          return this.next(), this.jsxParseElementAt(e);
         }
         setContext(e) {
          let { context: t } = this.state;
          t[t.length - 1] = e;
         }
         parseExprAtom(e) {
          return this.match(142) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(e);
         }
         skipSpace() {
          this.curContext().preserveSpace || super.skipSpace();
         }
         getTokenFromCode(e) {
          let t = this.curContext();
          if (t !== E.j_expr) {
           if (t === E.j_oTag || t === E.j_cTag) {
            if (ie(e)) return void this.jsxReadWord();
            if (62 === e) return ++this.state.pos, void this.finishToken(143);
            if ((34 === e || 39 === e) && t === E.j_oTag) return void this.jsxReadString(e);
           }
           if (60 === e && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(142);
           super.getTokenFromCode(e);
          } else this.jsxReadToken();
         }
         updateContext(e) {
          let { context: t, type: r } = this.state;
          if (56 === r && 142 === e) t.splice(-2, 2, E.j_cTag), (this.state.canStartJSXElement = !1);
          else if (142 === r) t.push(E.j_oTag);
          else if (143 === r) {
           let r = t[t.length - 1];
           (r === E.j_oTag && 56 === e) || r === E.j_cTag ? (t.pop(), (this.state.canStartJSXElement = t[t.length - 1] === E.j_expr)) : (this.setContext(E.j_expr), (this.state.canStartJSXElement = !0));
          } else
           this.state.canStartJSXElement = (function (e) {
            return O[e];
           })(r);
         }
        },
       flow: (e) =>
        class extends e {
         constructor(...e) {
          super(...e), (this.flowPragma = void 0);
         }
         getScopeHandler() {
          return be;
         }
         shouldParseTypes() {
          return this.getPluginOption('flow', 'all') || 'flow' === this.flowPragma;
         }
         shouldParseEnums() {
          return !!this.getPluginOption('flow', 'enums');
         }
         finishToken(e, t) {
          133 !== e && 13 !== e && 28 !== e && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e, t);
         }
         addComment(e) {
          if (void 0 === this.flowPragma) {
           let t = ht.exec(e.value);
           if (t)
            if ('flow' === t[1]) this.flowPragma = 'flow';
            else {
             if ('noflow' !== t[1]) throw new Error('Unexpected flow pragma');
             this.flowPragma = 'noflow';
            }
          }
          super.addComment(e);
         }
         flowParseTypeInitialiser(e) {
          let t = this.state.inType;
          (this.state.inType = !0), this.expect(e || 14);
          let r = this.flowParseType();
          return (this.state.inType = t), r;
         }
         flowParsePredicate() {
          let e = this.startNode(),
           t = this.state.startLoc;
          return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > t.index + 1 && this.raise(lt.UnexpectedSpaceBetweenModuloChecks, t), this.eat(10) ? ((e.value = super.parseExpression()), this.expect(11), this.finishNode(e, 'DeclaredPredicate')) : this.finishNode(e, 'InferredPredicate');
         }
         flowParseTypeAndPredicateInitialiser() {
          let e = this.state.inType;
          (this.state.inType = !0), this.expect(14);
          let t = null,
           r = null;
          return this.match(54) ? ((this.state.inType = e), (r = this.flowParsePredicate())) : ((t = this.flowParseType()), (this.state.inType = e), this.match(54) && (r = this.flowParsePredicate())), [t, r];
         }
         flowParseDeclareClass(e) {
          return this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, 'DeclareClass');
         }
         flowParseDeclareFunction(e) {
          this.next();
          let t = (e.id = this.parseIdentifier()),
           r = this.startNode(),
           n = this.startNode();
          this.match(47) ? (r.typeParameters = this.flowParseTypeParameterDeclaration()) : (r.typeParameters = null), this.expect(10);
          let s = this.flowParseFunctionTypeParams();
          return (r.params = s.params), (r.rest = s.rest), (r.this = s._this), this.expect(11), ([r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (n.typeAnnotation = this.finishNode(r, 'FunctionTypeAnnotation')), (t.typeAnnotation = this.finishNode(n, 'TypeAnnotation')), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, 'DeclareFunction');
         }
         flowParseDeclare(e, t) {
          return this.match(80) ? this.flowParseDeclareClass(e) : this.match(68) ? this.flowParseDeclareFunction(e) : this.match(74) ? this.flowParseDeclareVariable(e) : this.eatContextual(127) ? (this.match(16) ? this.flowParseDeclareModuleExports(e) : (t && this.raise(lt.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e))) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(e) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(e) : this.isContextual(129) ? this.flowParseDeclareInterface(e) : this.match(82) ? this.flowParseDeclareExportDeclaration(e, t) : void this.unexpected();
         }
         flowParseDeclareVariable(e) {
          return this.next(), (e.id = this.flowParseTypeAnnotatableIdentifier(!0)), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, 'DeclareVariable');
         }
         flowParseDeclareModule(e) {
          this.scope.enter(0), this.match(133) ? (e.id = super.parseExprAtom()) : (e.id = this.parseIdentifier());
          let t = (e.body = this.startNode()),
           r = (t.body = []);
          for (this.expect(5); !this.match(8); ) {
           let e = this.startNode();
           this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(lt.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(e)) : (this.expectContextual(125, lt.UnsupportedStatementInDeclareModule), (e = this.flowParseDeclare(e, !0))), r.push(e);
          }
          this.scope.exit(), this.expect(8), this.finishNode(t, 'BlockStatement');
          let n = null,
           s = !1;
          return (
           r.forEach((e) => {
            !(function (e) {
             return 'DeclareExportAllDeclaration' === e.type || ('DeclareExportDeclaration' === e.type && (!e.declaration || ('TypeAlias' !== e.declaration.type && 'InterfaceDeclaration' !== e.declaration.type)));
            })(e)
             ? 'DeclareModuleExports' === e.type && (s && this.raise(lt.DuplicateDeclareModuleExports, e), 'ES' === n && this.raise(lt.AmbiguousDeclareModuleKind, e), (n = 'CommonJS'), (s = !0))
             : ('CommonJS' === n && this.raise(lt.AmbiguousDeclareModuleKind, e), (n = 'ES'));
           }),
           (e.kind = n || 'CommonJS'),
           this.finishNode(e, 'DeclareModule')
          );
         }
         flowParseDeclareExportDeclaration(e, t) {
          if ((this.expect(82), this.eat(65))) return this.match(68) || this.match(80) ? (e.declaration = this.flowParseDeclare(this.startNode())) : ((e.declaration = this.flowParseType()), this.semicolon()), (e.default = !0), this.finishNode(e, 'DeclareExportDeclaration');
          if (this.match(75) || this.isLet() || ((this.isContextual(130) || this.isContextual(129)) && !t)) {
           let e = this.state.value;
           throw this.raise(lt.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: e, suggestion: ct[e] });
          }
          return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? ((e.declaration = this.flowParseDeclare(this.startNode())), (e.default = !1), this.finishNode(e, 'DeclareExportDeclaration')) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ('ExportNamedDeclaration' === (e = this.parseExport(e, null)).type && ((e.type = 'ExportDeclaration'), (e.default = !1), delete e.exportKind), (e.type = 'Declare' + e.type), e) : void this.unexpected();
         }
         flowParseDeclareModuleExports(e) {
          return this.next(), this.expectContextual(111), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.semicolon(), this.finishNode(e, 'DeclareModuleExports');
         }
         flowParseDeclareTypeAlias(e) {
          this.next();
          let t = this.flowParseTypeAlias(e);
          return (t.type = 'DeclareTypeAlias'), t;
         }
         flowParseDeclareOpaqueType(e) {
          this.next();
          let t = this.flowParseOpaqueType(e, !0);
          return (t.type = 'DeclareOpaqueType'), t;
         }
         flowParseDeclareInterface(e) {
          return this.next(), this.flowParseInterfaceish(e, !1), this.finishNode(e, 'DeclareInterface');
         }
         flowParseInterfaceish(e, t) {
          if (((e.id = this.flowParseRestrictedIdentifier(!t, !0)), this.scope.declareName(e.id.name, t ? 17 : 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.extends = []), this.eat(81)))
           do {
            e.extends.push(this.flowParseInterfaceExtends());
           } while (!t && this.eat(12));
          if (t) {
           if (((e.implements = []), (e.mixins = []), this.eatContextual(117)))
            do {
             e.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
           if (this.eatContextual(113))
            do {
             e.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          e.body = this.flowParseObjectType({ allowStatic: t, allowExact: !1, allowSpread: !1, allowProto: t, allowInexact: !1 });
         }
         flowParseInterfaceExtends() {
          let e = this.startNode();
          return (e.id = this.flowParseQualifiedTypeIdentifier()), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), this.finishNode(e, 'InterfaceExtends');
         }
         flowParseInterface(e) {
          return this.flowParseInterfaceish(e, !1), this.finishNode(e, 'InterfaceDeclaration');
         }
         checkNotUnderscore(e) {
          '_' === e && this.raise(lt.UnexpectedReservedUnderscore, this.state.startLoc);
         }
         checkReservedType(e, t, r) {
          ut.has(e) && this.raise(r ? lt.AssignReservedType : lt.UnexpectedReservedType, t, { reservedType: e });
         }
         flowParseRestrictedIdentifier(e, t) {
          return this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e);
         }
         flowParseTypeAlias(e) {
          return (e.id = this.flowParseRestrictedIdentifier(!1, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.right = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, 'TypeAlias');
         }
         flowParseOpaqueType(e, t) {
          return this.expectContextual(130), (e.id = this.flowParseRestrictedIdentifier(!0, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.supertype = null), this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), (e.impltype = null), t || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, 'OpaqueType');
         }
         flowParseTypeParameter(e = !1) {
          let t = this.state.startLoc,
           r = this.startNode(),
           n = this.flowParseVariance(),
           s = this.flowParseTypeAnnotatableIdentifier();
          return (r.name = s.name), (r.variance = n), (r.bound = s.typeAnnotation), this.match(29) ? (this.eat(29), (r.default = this.flowParseType())) : e && this.raise(lt.MissingTypeParamDefault, t), this.finishNode(r, 'TypeParameter');
         }
         flowParseTypeParameterDeclaration() {
          let e = this.state.inType,
           t = this.startNode();
          (t.params = []), (this.state.inType = !0), this.match(47) || this.match(142) ? this.next() : this.unexpected();
          let r = !1;
          do {
           let e = this.flowParseTypeParameter(r);
           t.params.push(e), e.default && (r = !0), this.match(48) || this.expect(12);
          } while (!this.match(48));
          return this.expect(48), (this.state.inType = e), this.finishNode(t, 'TypeParameterDeclaration');
         }
         flowParseTypeParameterInstantiation() {
          let e = this.startNode(),
           t = this.state.inType;
          (e.params = []), (this.state.inType = !0), this.expect(47);
          let r = this.state.noAnonFunctionType;
          for (this.state.noAnonFunctionType = !1; !this.match(48); ) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
          return (this.state.noAnonFunctionType = r), this.expect(48), (this.state.inType = t), this.finishNode(e, 'TypeParameterInstantiation');
         }
         flowParseTypeParameterInstantiationCallOrNew() {
          let e = this.startNode(),
           t = this.state.inType;
          for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
          return this.expect(48), (this.state.inType = t), this.finishNode(e, 'TypeParameterInstantiation');
         }
         flowParseInterfaceType() {
          let e = this.startNode();
          if ((this.expectContextual(129), (e.extends = []), this.eat(81)))
           do {
            e.extends.push(this.flowParseInterfaceExtends());
           } while (this.eat(12));
          return (e.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 })), this.finishNode(e, 'InterfaceTypeAnnotation');
         }
         flowParseObjectPropertyKey() {
          return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
         }
         flowParseObjectTypeIndexer(e, t, r) {
          return (e.static = t), 14 === this.lookahead().type ? ((e.id = this.flowParseObjectPropertyKey()), (e.key = this.flowParseTypeInitialiser())) : ((e.id = null), (e.key = this.flowParseType())), this.expect(3), (e.value = this.flowParseTypeInitialiser()), (e.variance = r), this.finishNode(e, 'ObjectTypeIndexer');
         }
         flowParseObjectTypeInternalSlot(e, t) {
          return (e.static = t), (e.id = this.flowParseObjectPropertyKey()), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? ((e.method = !0), (e.optional = !1), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)))) : ((e.method = !1), this.eat(17) && (e.optional = !0), (e.value = this.flowParseTypeInitialiser())), this.finishNode(e, 'ObjectTypeInternalSlot');
         }
         flowParseObjectTypeMethodish(e) {
          for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && ((e.this = this.flowParseFunctionTypeParam(!0)), (e.this.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
          return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), (e.returnType = this.flowParseTypeInitialiser()), this.finishNode(e, 'FunctionTypeAnnotation');
         }
         flowParseObjectTypeCallProperty(e, t) {
          let r = this.startNode();
          return (e.static = t), (e.value = this.flowParseObjectTypeMethodish(r)), this.finishNode(e, 'ObjectTypeCallProperty');
         }
         flowParseObjectType({ allowStatic: e, allowExact: t, allowSpread: r, allowProto: n, allowInexact: s }) {
          let i = this.state.inType;
          this.state.inType = !0;
          let a = this.startNode();
          (a.callProperties = []), (a.properties = []), (a.indexers = []), (a.internalSlots = []);
          let o,
           u,
           l = !1;
          for (t && this.match(6) ? (this.expect(6), (o = 9), (u = !0)) : (this.expect(5), (o = 8), (u = !1)), a.exact = u; !this.match(o); ) {
           let t = !1,
            i = null,
            o = null,
            p = this.startNode();
           if (n && this.isContextual(118)) {
            let t = this.lookahead();
            14 !== t.type && 17 !== t.type && (this.next(), (i = this.state.startLoc), (e = !1));
           }
           if (e && this.isContextual(106)) {
            let e = this.lookahead();
            14 !== e.type && 17 !== e.type && (this.next(), (t = !0));
           }
           let c = this.flowParseVariance();
           if (this.eat(0)) null != i && this.unexpected(i), this.eat(0) ? (c && this.unexpected(c.loc.start), a.internalSlots.push(this.flowParseObjectTypeInternalSlot(p, t))) : a.indexers.push(this.flowParseObjectTypeIndexer(p, t, c));
           else if (this.match(10) || this.match(47)) null != i && this.unexpected(i), c && this.unexpected(c.loc.start), a.callProperties.push(this.flowParseObjectTypeCallProperty(p, t));
           else {
            let e = 'init';
            if (this.isContextual(99) || this.isContextual(104)) {
             z(this.lookahead().type) && ((e = this.state.value), this.next());
            }
            let n = this.flowParseObjectTypeProperty(p, t, i, c, e, r, s ?? !u);
            null === n ? ((l = !0), (o = this.state.lastTokStartLoc)) : a.properties.push(n);
           }
           this.flowObjectTypeSemicolon(), o && !this.match(8) && !this.match(9) && this.raise(lt.UnexpectedExplicitInexactInObject, o);
          }
          this.expect(o), r && (a.inexact = l);
          let p = this.finishNode(a, 'ObjectTypeAnnotation');
          return (this.state.inType = i), p;
         }
         flowParseObjectTypeProperty(e, t, r, n, s, i, a) {
          if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (i ? a || this.raise(lt.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(lt.InexactInsideNonObject, this.state.lastTokStartLoc), n && this.raise(lt.InexactVariance, n), null) : (i || this.raise(lt.UnexpectedSpreadType, this.state.lastTokStartLoc), null != r && this.unexpected(r), n && this.raise(lt.SpreadVariance, n), (e.argument = this.flowParseType()), this.finishNode(e, 'ObjectTypeSpreadProperty'));
          {
           (e.key = this.flowParseObjectPropertyKey()), (e.static = t), (e.proto = null != r), (e.kind = s);
           let a = !1;
           return this.match(47) || this.match(10) ? ((e.method = !0), null != r && this.unexpected(r), n && this.unexpected(n.loc.start), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))), ('get' === s || 'set' === s) && this.flowCheckGetterSetterParams(e), !i && 'constructor' === e.key.name && e.value.this && this.raise(lt.ThisParamBannedInConstructor, e.value.this)) : ('init' !== s && this.unexpected(), (e.method = !1), this.eat(17) && (a = !0), (e.value = this.flowParseTypeInitialiser()), (e.variance = n)), (e.optional = a), this.finishNode(e, 'ObjectTypeProperty');
          }
         }
         flowCheckGetterSetterParams(e) {
          let t = 'get' === e.kind ? 0 : 1,
           r = e.value.params.length + (e.value.rest ? 1 : 0);
          e.value.this && this.raise('get' === e.kind ? lt.GetterMayNotHaveThisParam : lt.SetterMayNotHaveThisParam, e.value.this), r !== t && this.raise('get' === e.kind ? g.BadGetterArity : g.BadSetterArity, e), 'set' === e.kind && e.value.rest && this.raise(g.BadSetterRestParameter, e);
         }
         flowObjectTypeSemicolon() {
          !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
         }
         flowParseQualifiedTypeIdentifier(e, t) {
          null != e || (e = this.state.startLoc);
          let r = t || this.flowParseRestrictedIdentifier(!0);
          for (; this.eat(16); ) {
           let t = this.startNodeAt(e);
           (t.qualification = r), (t.id = this.flowParseRestrictedIdentifier(!0)), (r = this.finishNode(t, 'QualifiedTypeIdentifier'));
          }
          return r;
         }
         flowParseGenericType(e, t) {
          let r = this.startNodeAt(e);
          return (r.typeParameters = null), (r.id = this.flowParseQualifiedTypeIdentifier(e, t)), this.match(47) && (r.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r, 'GenericTypeAnnotation');
         }
         flowParseTypeofType() {
          let e = this.startNode();
          return this.expect(87), (e.argument = this.flowParsePrimaryType()), this.finishNode(e, 'TypeofTypeAnnotation');
         }
         flowParseTupleType() {
          let e = this.startNode();
          for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
          return this.expect(3), this.finishNode(e, 'TupleTypeAnnotation');
         }
         flowParseFunctionTypeParam(e) {
          let t = null,
           r = !1,
           n = null,
           s = this.startNode(),
           i = this.lookahead(),
           a = 78 === this.state.type;
          return 14 === i.type || 17 === i.type ? (a && !e && this.raise(lt.ThisParamMustBeFirst, s), (t = this.parseIdentifier(a)), this.eat(17) && ((r = !0), a && this.raise(lt.ThisParamMayNotBeOptional, s)), (n = this.flowParseTypeInitialiser())) : (n = this.flowParseType()), (s.name = t), (s.optional = r), (s.typeAnnotation = n), this.finishNode(s, 'FunctionTypeParam');
         }
         reinterpretTypeAsFunctionTypeParam(e) {
          let t = this.startNodeAt(e.loc.start);
          return (t.name = null), (t.optional = !1), (t.typeAnnotation = e), this.finishNode(t, 'FunctionTypeParam');
         }
         flowParseFunctionTypeParams(e = []) {
          let t = null,
           r = null;
          for (this.match(78) && ((r = this.flowParseFunctionTypeParam(!0)), (r.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
          return this.eat(21) && (t = this.flowParseFunctionTypeParam(!1)), { params: e, rest: t, _this: r };
         }
         flowIdentToTypeAnnotation(e, t, r) {
          switch (r.name) {
           case 'any':
            return this.finishNode(t, 'AnyTypeAnnotation');
           case 'bool':
           case 'boolean':
            return this.finishNode(t, 'BooleanTypeAnnotation');
           case 'mixed':
            return this.finishNode(t, 'MixedTypeAnnotation');
           case 'empty':
            return this.finishNode(t, 'EmptyTypeAnnotation');
           case 'number':
            return this.finishNode(t, 'NumberTypeAnnotation');
           case 'string':
            return this.finishNode(t, 'StringTypeAnnotation');
           case 'symbol':
            return this.finishNode(t, 'SymbolTypeAnnotation');
           default:
            return this.checkNotUnderscore(r.name), this.flowParseGenericType(e, r);
          }
         }
         flowParsePrimaryType() {
          let e,
           t,
           r = this.state.startLoc,
           n = this.startNode(),
           s = !1,
           i = this.state.noAnonFunctionType;
          switch (this.state.type) {
           case 5:
            return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
           case 6:
            return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
           case 0:
            return (this.state.noAnonFunctionType = !1), (t = this.flowParseTupleType()), (this.state.noAnonFunctionType = i), t;
           case 47: {
            let t = this.startNode();
            return (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), (e = this.flowParseFunctionTypeParams()), (t.params = e.params), (t.rest = e.rest), (t.this = e._this), this.expect(11), this.expect(19), (t.returnType = this.flowParseType()), this.finishNode(t, 'FunctionTypeAnnotation');
           }
           case 10: {
            let r = this.startNode();
            if ((this.next(), !this.match(11) && !this.match(21)))
             if ($(this.state.type) || this.match(78)) {
              let e = this.lookahead().type;
              s = 17 !== e && 14 !== e;
             } else s = !0;
            if (s) {
             if (((this.state.noAnonFunctionType = !1), (t = this.flowParseType()), (this.state.noAnonFunctionType = i), this.state.noAnonFunctionType || !(this.match(12) || (this.match(11) && 19 === this.lookahead().type)))) return this.expect(11), t;
             this.eat(12);
            }
            return (e = t ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(t)]) : this.flowParseFunctionTypeParams()), (r.params = e.params), (r.rest = e.rest), (r.this = e._this), this.expect(11), this.expect(19), (r.returnType = this.flowParseType()), (r.typeParameters = null), this.finishNode(r, 'FunctionTypeAnnotation');
           }
           case 133:
            return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation');
           case 85:
           case 86:
            return (n.value = this.match(85)), this.next(), this.finishNode(n, 'BooleanLiteralTypeAnnotation');
           case 53:
            if ('-' === this.state.value) {
             if ((this.next(), this.match(134))) return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', n);
             if (this.match(135)) return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', n);
             throw this.raise(lt.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            return void this.unexpected();
           case 134:
            return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation');
           case 135:
            return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation');
           case 88:
            return this.next(), this.finishNode(n, 'VoidTypeAnnotation');
           case 84:
            return this.next(), this.finishNode(n, 'NullLiteralTypeAnnotation');
           case 78:
            return this.next(), this.finishNode(n, 'ThisTypeAnnotation');
           case 55:
            return this.next(), this.finishNode(n, 'ExistsTypeAnnotation');
           case 87:
            return this.flowParseTypeofType();
           default:
            if (J(this.state.type)) {
             let e = K(this.state.type);
             return this.next(), super.createIdentifier(n, e);
            }
            if ($(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, n, this.parseIdentifier());
          }
          this.unexpected();
         }
         flowParsePostfixType() {
          let e = this.state.startLoc,
           t = this.flowParsePrimaryType(),
           r = !1;
          for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
           let n = this.startNodeAt(e),
            s = this.eat(18);
           (r = r || s), this.expect(0), !s && this.match(3) ? ((n.elementType = t), this.next(), (t = this.finishNode(n, 'ArrayTypeAnnotation'))) : ((n.objectType = t), (n.indexType = this.flowParseType()), this.expect(3), r ? ((n.optional = s), (t = this.finishNode(n, 'OptionalIndexedAccessType'))) : (t = this.finishNode(n, 'IndexedAccessType')));
          }
          return t;
         }
         flowParsePrefixType() {
          let e = this.startNode();
          return this.eat(17) ? ((e.typeAnnotation = this.flowParsePrefixType()), this.finishNode(e, 'NullableTypeAnnotation')) : this.flowParsePostfixType();
         }
         flowParseAnonFunctionWithoutParens() {
          let e = this.flowParsePrefixType();
          if (!this.state.noAnonFunctionType && this.eat(19)) {
           let t = this.startNodeAt(e.loc.start);
           return (t.params = [this.reinterpretTypeAsFunctionTypeParam(e)]), (t.rest = null), (t.this = null), (t.returnType = this.flowParseType()), (t.typeParameters = null), this.finishNode(t, 'FunctionTypeAnnotation');
          }
          return e;
         }
         flowParseIntersectionType() {
          let e = this.startNode();
          this.eat(45);
          let t = this.flowParseAnonFunctionWithoutParens();
          for (e.types = [t]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
          return 1 === e.types.length ? t : this.finishNode(e, 'IntersectionTypeAnnotation');
         }
         flowParseUnionType() {
          let e = this.startNode();
          this.eat(43);
          let t = this.flowParseIntersectionType();
          for (e.types = [t]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
          return 1 === e.types.length ? t : this.finishNode(e, 'UnionTypeAnnotation');
         }
         flowParseType() {
          let e = this.state.inType;
          this.state.inType = !0;
          let t = this.flowParseUnionType();
          return (this.state.inType = e), t;
         }
         flowParseTypeOrImplicitInstantiation() {
          if (132 === this.state.type && '_' === this.state.value) {
           let e = this.state.startLoc,
            t = this.parseIdentifier();
           return this.flowParseGenericType(e, t);
          }
          return this.flowParseType();
         }
         flowParseTypeAnnotation() {
          let e = this.startNode();
          return (e.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(e, 'TypeAnnotation');
         }
         flowParseTypeAnnotatableIdentifier(e) {
          let t = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
          return this.match(14) && ((t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t)), t;
         }
         typeCastToParameter(e) {
          return (e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
         }
         flowParseVariance() {
          let e = null;
          return this.match(53) ? ((e = this.startNode()), '+' === this.state.value ? (e.kind = 'plus') : (e.kind = 'minus'), this.next(), this.finishNode(e, 'Variance')) : e;
         }
         parseFunctionBody(e, t, r = !1) {
          t ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, r)) : super.parseFunctionBody(e, !1, r);
         }
         parseFunctionBodyAndFinish(e, t, r = !1) {
          if (this.match(14)) {
           let t = this.startNode();
           ([t.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (e.returnType = t.typeAnnotation ? this.finishNode(t, 'TypeAnnotation') : null);
          }
          return super.parseFunctionBodyAndFinish(e, t, r);
         }
         parseStatementLike(e) {
          if (this.state.strict && this.isContextual(129)) {
           if (H(this.lookahead().type)) {
            let e = this.startNode();
            return this.next(), this.flowParseInterface(e);
           }
          } else if (this.shouldParseEnums() && this.isContextual(126)) {
           let e = this.startNode();
           return this.next(), this.flowParseEnumDeclaration(e);
          }
          let t = super.parseStatementLike(e);
          return void 0 === this.flowPragma && !this.isValidDirective(t) && (this.flowPragma = null), t;
         }
         parseExpressionStatement(e, t, r) {
          if ('Identifier' === t.type)
           if ('declare' === t.name) {
            if (this.match(80) || $(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
           } else if ($(this.state.type)) {
            if ('interface' === t.name) return this.flowParseInterface(e);
            if ('type' === t.name) return this.flowParseTypeAlias(e);
            if ('opaque' === t.name) return this.flowParseOpaqueType(e, !1);
           }
          return super.parseExpressionStatement(e, t, r);
         }
         shouldParseExportDeclaration() {
          let { type: e } = this.state;
          return W(e) || (this.shouldParseEnums() && 126 === e) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
         }
         isExportDefaultSpecifier() {
          let { type: e } = this.state;
          return W(e) || (this.shouldParseEnums() && 126 === e) ? this.state.containsEsc : super.isExportDefaultSpecifier();
         }
         parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(126)) {
           let e = this.startNode();
           return this.next(), this.flowParseEnumDeclaration(e);
          }
          return super.parseExportDefaultExpression();
         }
         parseConditional(e, t, r) {
          if (!this.match(17)) return e;
          if (this.state.maybeInArrowParameters) {
           let t = this.lookaheadCharCode();
           if (44 === t || 61 === t || 58 === t || 41 === t) return this.setOptionalParametersError(r), e;
          }
          this.expect(17);
          let n = this.state.clone(),
           s = this.state.noArrowAt,
           i = this.startNodeAt(t),
           { consequent: a, failed: o } = this.tryParseConditionalConsequent(),
           [u, l] = this.getArrowLikeExpressions(a);
          if (o || l.length > 0) {
           let e = [...s];
           if (l.length > 0) {
            (this.state = n), (this.state.noArrowAt = e);
            for (let t = 0; t < l.length; t++) e.push(l[t].start);
            ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()), ([u, l] = this.getArrowLikeExpressions(a));
           }
           o && u.length > 1 && this.raise(lt.AmbiguousConditionalArrow, n.startLoc), o && 1 === u.length && ((this.state = n), e.push(u[0].start), (this.state.noArrowAt = e), ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()));
          }
          return this.getArrowLikeExpressions(a, !0), (this.state.noArrowAt = s), this.expect(14), (i.test = e), (i.consequent = a), (i.alternate = this.forwardNoArrowParamsConversionAt(i, () => this.parseMaybeAssign(void 0, void 0))), this.finishNode(i, 'ConditionalExpression');
         }
         tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          let e = this.parseMaybeAssignAllowIn(),
           t = !this.match(14);
          return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: t };
         }
         getArrowLikeExpressions(e, t) {
          let r = [e],
           n = [];
          for (; 0 !== r.length; ) {
           let e = r.pop();
           'ArrowFunctionExpression' === e.type && 'BlockStatement' !== e.body.type ? (e.typeParameters || !e.returnType ? this.finishArrowValidation(e) : n.push(e), r.push(e.body)) : 'ConditionalExpression' === e.type && (r.push(e.consequent), r.push(e.alternate));
          }
          return t
           ? (n.forEach((e) => this.finishArrowValidation(e)), [n, []])
           : (function (e, t) {
              let r = [],
               n = [];
              for (let s = 0; s < e.length; s++) (t(e[s], s, e) ? r : n).push(e[s]);
              return [r, n];
             })(n, (e) => e.params.every((e) => this.isAssignable(e, !0)));
         }
         finishArrowValidation(e) {
          var t;
          this.toAssignableList(e.params, null == (t = e.extra) ? void 0 : t.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(e, !1, !0), this.scope.exit();
         }
         forwardNoArrowParamsConversionAt(e, t) {
          let r;
          return -1 !== this.state.noArrowParamsConversionAt.indexOf(e.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), (r = t()), this.state.noArrowParamsConversionAt.pop()) : (r = t()), r;
         }
         parseParenItem(e, t) {
          let r = super.parseParenItem(e, t);
          if ((this.eat(17) && ((r.optional = !0), this.resetEndLocation(e)), this.match(14))) {
           let e = this.startNodeAt(t);
           return (e.expression = r), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.finishNode(e, 'TypeCastExpression');
          }
          return r;
         }
         assertModuleNodeAllowed(e) {
          ('ImportDeclaration' === e.type && ('type' === e.importKind || 'typeof' === e.importKind)) || ('ExportNamedDeclaration' === e.type && 'type' === e.exportKind) || ('ExportAllDeclaration' === e.type && 'type' === e.exportKind) || super.assertModuleNodeAllowed(e);
         }
         parseExportDeclaration(e) {
          if (this.isContextual(130)) {
           e.exportKind = 'type';
           let t = this.startNode();
           return this.next(), this.match(5) ? ((e.specifiers = this.parseExportSpecifiers(!0)), super.parseExportFrom(e), null) : this.flowParseTypeAlias(t);
          }
          if (this.isContextual(131)) {
           e.exportKind = 'type';
           let t = this.startNode();
           return this.next(), this.flowParseOpaqueType(t, !1);
          }
          if (this.isContextual(129)) {
           e.exportKind = 'type';
           let t = this.startNode();
           return this.next(), this.flowParseInterface(t);
          }
          if (this.shouldParseEnums() && this.isContextual(126)) {
           e.exportKind = 'value';
           let t = this.startNode();
           return this.next(), this.flowParseEnumDeclaration(t);
          }
          return super.parseExportDeclaration(e);
         }
         eatExportStar(e) {
          return !!super.eatExportStar(e) || (!(!this.isContextual(130) || 55 !== this.lookahead().type) && ((e.exportKind = 'type'), this.next(), this.next(), !0));
         }
         maybeParseExportNamespaceSpecifier(e) {
          let { startLoc: t } = this.state,
           r = super.maybeParseExportNamespaceSpecifier(e);
          return r && 'type' === e.exportKind && this.unexpected(t), r;
         }
         parseClassId(e, t, r) {
          super.parseClassId(e, t, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
         }
         parseClassMember(e, t, r) {
          let { startLoc: n } = this.state;
          if (this.isContextual(125)) {
           if (super.parseClassMemberFromModifier(e, t)) return;
           t.declare = !0;
          }
          super.parseClassMember(e, t, r), t.declare && ('ClassProperty' !== t.type && 'ClassPrivateProperty' !== t.type && 'PropertyDefinition' !== t.type ? this.raise(lt.DeclareClassElement, n) : t.value && this.raise(lt.DeclareClassFieldInitializer, t.value));
         }
         isIterator(e) {
          return 'iterator' === e || 'asyncIterator' === e;
         }
         readIterator() {
          let e = super.readWord1(),
           t = '@@' + e;
          (!this.isIterator(e) || !this.state.inType) && this.raise(g.InvalidIdentifier, this.state.curPosition(), { identifierName: t }), this.finishToken(132, t);
         }
         getTokenFromCode(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          123 === e && 124 === t
           ? this.finishOp(6, 2)
           : !this.state.inType || (62 !== e && 60 !== e)
             ? this.state.inType && 63 === e
               ? 46 === t
                 ? this.finishOp(18, 2)
                 : this.finishOp(17, 1)
               : (function (e, t, r) {
                    return 64 === e && 64 === t && ie(r);
                   })(e, t, this.input.charCodeAt(this.state.pos + 2))
                 ? ((this.state.pos += 2), this.readIterator())
                 : super.getTokenFromCode(e)
             : this.finishOp(62 === e ? 48 : 47, 1);
         }
         isAssignable(e, t) {
          return 'TypeCastExpression' === e.type ? this.isAssignable(e.expression, t) : super.isAssignable(e, t);
         }
         toAssignable(e, t = !1) {
          !t && 'AssignmentExpression' === e.type && 'TypeCastExpression' === e.left.type && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, t);
         }
         toAssignableList(e, t, r) {
          for (let n = 0; n < e.length; n++) {
           let t = e[n];
           'TypeCastExpression' === (null == t ? void 0 : t.type) && (e[n] = this.typeCastToParameter(t));
          }
          super.toAssignableList(e, t, r);
         }
         toReferencedList(e, t) {
          for (let n = 0; n < e.length; n++) {
           var r;
           let s = e[n];
           s && 'TypeCastExpression' === s.type && (null == (r = s.extra) || !r.parenthesized) && (e.length > 1 || !t) && this.raise(lt.TypeCastInPattern, s.typeAnnotation);
          }
          return e;
         }
         parseArrayLike(e, t, r, n) {
          let s = super.parseArrayLike(e, t, r, n);
          return t && !this.state.maybeInArrowParameters && this.toReferencedList(s.elements), s;
         }
         isValidLVal(e, t, r) {
          return 'TypeCastExpression' === e || super.isValidLVal(e, t, r);
         }
         parseClassProperty(e) {
          return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
         }
         parseClassPrivateProperty(e) {
          return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
         }
         isClassMethod() {
          return this.match(47) || super.isClassMethod();
         }
         isClassProperty() {
          return this.match(14) || super.isClassProperty();
         }
         isNonstaticConstructor(e) {
          return !this.match(14) && super.isNonstaticConstructor(e);
         }
         pushClassMethod(e, t, r, n, s, i) {
          if ((t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, t, r, n, s, i), t.params && s)) {
           let e = t.params;
           e.length > 0 && this.isThisParam(e[0]) && this.raise(lt.ThisParamBannedInConstructor, t);
          } else if ('MethodDefinition' === t.type && s && t.value.params) {
           let e = t.value.params;
           e.length > 0 && this.isThisParam(e[0]) && this.raise(lt.ThisParamBannedInConstructor, t);
          }
         }
         pushClassPrivateMethod(e, t, r, n) {
          t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, t, r, n);
         }
         parseClassSuper(e) {
          if ((super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113))) {
           this.next();
           let t = (e.implements = []);
           do {
            let e = this.startNode();
            (e.id = this.flowParseRestrictedIdentifier(!0)), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), t.push(this.finishNode(e, 'ClassImplements'));
           } while (this.eat(12));
          }
         }
         checkGetterSetterParams(e) {
          super.checkGetterSetterParams(e);
          let t = this.getObjectOrClassMethodParams(e);
          if (t.length > 0) {
           let r = t[0];
           this.isThisParam(r) && 'get' === e.kind ? this.raise(lt.GetterMayNotHaveThisParam, r) : this.isThisParam(r) && this.raise(lt.SetterMayNotHaveThisParam, r);
          }
         }
         parsePropertyNamePrefixOperator(e) {
          e.variance = this.flowParseVariance();
         }
         parseObjPropValue(e, t, r, n, s, i, a) {
          let o;
          e.variance && this.unexpected(e.variance.loc.start), delete e.variance, this.match(47) && !i && ((o = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected());
          let u = super.parseObjPropValue(e, t, r, n, s, i, a);
          return o && ((u.value || u).typeParameters = o), u;
         }
         parseAssignableListItemTypes(e) {
          return this.eat(17) && ('Identifier' !== e.type && this.raise(lt.PatternIsOptional, e), this.isThisParam(e) && this.raise(lt.ThisParamMayNotBeOptional, e), (e.optional = !0)), this.match(14) ? (e.typeAnnotation = this.flowParseTypeAnnotation()) : this.isThisParam(e) && this.raise(lt.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(lt.ThisParamNoDefault, e), this.resetEndLocation(e), e;
         }
         parseMaybeDefault(e, t) {
          let r = super.parseMaybeDefault(e, t);
          return 'AssignmentPattern' === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(lt.TypeBeforeInitializer, r.typeAnnotation), r;
         }
         checkImportReflection(e) {
          super.checkImportReflection(e), e.module && 'value' !== e.importKind && this.raise(lt.ImportReflectionHasImportType, e.specifiers[0].loc.start);
         }
         parseImportSpecifierLocal(e, t, r) {
          (t.local = pt(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r));
         }
         isPotentialImportPhase(e) {
          if (super.isPotentialImportPhase(e)) return !0;
          if (this.isContextual(130)) {
           if (!e) return !0;
           let t = this.lookaheadCharCode();
           return 123 === t || 42 === t;
          }
          return !e && this.isContextual(87);
         }
         applyImportPhase(e, t, r, n) {
          if ((super.applyImportPhase(e, t, r, n), t)) {
           if (!r && this.match(65)) return;
           e.exportKind = 'type' === r ? r : 'value';
          } else 'type' === r && this.match(55) && this.unexpected(), (e.importKind = 'type' === r || 'typeof' === r ? r : 'value');
         }
         parseImportSpecifier(e, t, r, n, s) {
          let i = e.imported,
           a = null;
          'Identifier' === i.type && ('type' === i.name ? (a = 'type') : 'typeof' === i.name && (a = 'typeof'));
          let o = !1;
          if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
           let t = this.parseIdentifier(!0);
           null === a || H(this.state.type) ? ((e.imported = i), (e.importKind = null), (e.local = this.parseIdentifier())) : ((e.imported = t), (e.importKind = a), (e.local = it(t)));
          } else {
           if (null !== a && H(this.state.type)) (e.imported = this.parseIdentifier(!0)), (e.importKind = a);
           else {
            if (t) throw this.raise(g.ImportBindingIsString, e, { importName: i.value });
            (e.imported = i), (e.importKind = null);
           }
           this.eatContextual(93) ? (e.local = this.parseIdentifier()) : ((o = !0), (e.local = it(e.imported)));
          }
          let u = pt(e);
          return r && u && this.raise(lt.ImportTypeShorthandOnlyInPureImport, e), (r || u) && this.checkReservedType(e.local.name, e.local.loc.start, !0), o && !r && !u && this.checkReservedWord(e.local.name, e.loc.start, !0, !0), this.finishImportSpecifier(e, 'ImportSpecifier');
         }
         parseBindingAtom() {
          return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
         }
         parseFunctionParams(e, t) {
          let r = e.kind;
          'get' !== r && 'set' !== r && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, t);
         }
         parseVarId(e, t) {
          super.parseVarId(e, t), this.match(14) && ((e.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(e.id));
         }
         parseAsyncArrowFromCallExpression(e, t) {
          if (this.match(14)) {
           let t = this.state.noAnonFunctionType;
           (this.state.noAnonFunctionType = !0), (e.returnType = this.flowParseTypeAnnotation()), (this.state.noAnonFunctionType = t);
          }
          return super.parseAsyncArrowFromCallExpression(e, t);
         }
         shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
         }
         parseMaybeAssign(e, t) {
          var r;
          let n,
           s = null;
          if (this.hasPlugin('jsx') && (this.match(142) || this.match(47))) {
           if (((s = this.state.clone()), (n = this.tryParse(() => super.parseMaybeAssign(e, t), s)), !n.error)) return n.node;
           let { context: r } = this.state,
            i = r[r.length - 1];
           (i === E.j_oTag || i === E.j_expr) && r.pop();
          }
          if ((null != (r = n) && r.error) || this.match(47)) {
           var i, a;
           s = s || this.state.clone();
           let r,
            o = this.tryParse((n) => {
             var s;
             r = this.flowParseTypeParameterDeclaration();
             let i = this.forwardNoArrowParamsConversionAt(r, () => {
              let n = super.parseMaybeAssign(e, t);
              return this.resetStartLocationFromNode(n, r), n;
             });
             null != (s = i.extra) && s.parenthesized && n();
             let a = this.maybeUnwrapTypeCastExpression(i);
             return 'ArrowFunctionExpression' !== a.type && n(), (a.typeParameters = r), this.resetStartLocationFromNode(a, r), i;
            }, s),
            u = null;
           if (o.node && 'ArrowFunctionExpression' === this.maybeUnwrapTypeCastExpression(o.node).type) {
            if (!o.error && !o.aborted) return o.node.async && this.raise(lt.UnexpectedTypeParameterBeforeAsyncArrowFunction, r), o.node;
            u = o.node;
           }
           if (null != (i = n) && i.node) return (this.state = n.failState), n.node;
           if (u) return (this.state = o.failState), u;
           throw null != (a = n) && a.thrown ? n.error : o.thrown ? o.error : this.raise(lt.UnexpectedTokenAfterTypeParameter, r);
          }
          return super.parseMaybeAssign(e, t);
         }
         parseArrow(e) {
          if (this.match(14)) {
           let t = this.tryParse(() => {
            let t = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = !0;
            let r = this.startNode();
            return ([r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (this.state.noAnonFunctionType = t), this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r;
           });
           if (t.thrown) return null;
           t.error && (this.state = t.failState), (e.returnType = t.node.typeAnnotation ? this.finishNode(t.node, 'TypeAnnotation') : null);
          }
          return super.parseArrow(e);
         }
         shouldParseArrow(e) {
          return this.match(14) || super.shouldParseArrow(e);
         }
         setArrowFunctionParameters(e, t) {
          -1 !== this.state.noArrowParamsConversionAt.indexOf(e.start) ? (e.params = t) : super.setArrowFunctionParameters(e, t);
         }
         checkParams(e, t, r, n = !0) {
          if (!r || -1 === this.state.noArrowParamsConversionAt.indexOf(e.start)) {
           for (let t = 0; t < e.params.length; t++) this.isThisParam(e.params[t]) && t > 0 && this.raise(lt.ThisParamMustBeFirst, e.params[t]);
           super.checkParams(e, t, r, n);
          }
         }
         parseParenAndDistinguishExpression(e) {
          return super.parseParenAndDistinguishExpression(e && -1 === this.state.noArrowAt.indexOf(this.state.start));
         }
         parseSubscripts(e, t, r) {
          if ('Identifier' === e.type && 'async' === e.name && -1 !== this.state.noArrowAt.indexOf(t.index)) {
           this.next();
           let r = this.startNodeAt(t);
           (r.callee = e), (r.arguments = super.parseCallExpressionArguments(11, !1)), (e = this.finishNode(r, 'CallExpression'));
          } else if ('Identifier' === e.type && 'async' === e.name && this.match(47)) {
           let n = this.state.clone(),
            s = this.tryParse((e) => this.parseAsyncArrowWithTypeParameters(t) || e(), n);
           if (!s.error && !s.aborted) return s.node;
           let i = this.tryParse(() => super.parseSubscripts(e, t, r), n);
           if (i.node && !i.error) return i.node;
           if (s.node) return (this.state = s.failState), s.node;
           if (i.node) return (this.state = i.failState), i.node;
           throw s.error || i.error;
          }
          return super.parseSubscripts(e, t, r);
         }
         parseSubscript(e, t, r, n) {
          if (this.match(18) && this.isLookaheadToken_lt()) {
           if (((n.optionalChainMember = !0), r)) return (n.stop = !0), e;
           this.next();
           let s = this.startNodeAt(t);
           return (s.callee = e), (s.typeArguments = this.flowParseTypeParameterInstantiation()), this.expect(10), (s.arguments = this.parseCallExpressionArguments(11, !1)), (s.optional = !0), this.finishCallExpression(s, !0);
          }
          if (!r && this.shouldParseTypes() && this.match(47)) {
           let r = this.startNodeAt(t);
           r.callee = e;
           let s = this.tryParse(() => ((r.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()), this.expect(10), (r.arguments = super.parseCallExpressionArguments(11, !1)), n.optionalChainMember && (r.optional = !1), this.finishCallExpression(r, n.optionalChainMember)));
           if (s.node) return s.error && (this.state = s.failState), s.node;
          }
          return super.parseSubscript(e, t, r, n);
         }
         parseNewCallee(e) {
          super.parseNewCallee(e);
          let t = null;
          this.shouldParseTypes() && this.match(47) && (t = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), (e.typeArguments = t);
         }
         parseAsyncArrowWithTypeParameters(e) {
          let t = this.startNodeAt(e);
          if ((this.parseFunctionParams(t, !1), this.parseArrow(t))) return super.parseArrowExpression(t, void 0, !0);
         }
         readToken_mult_modulo(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          if (42 === e && 47 === t && this.state.hasFlowComment) return (this.state.hasFlowComment = !1), (this.state.pos += 2), void this.nextToken();
          super.readToken_mult_modulo(e);
         }
         readToken_pipe_amp(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          124 !== e || 125 !== t ? super.readToken_pipe_amp(e) : this.finishOp(9, 2);
         }
         parseTopLevel(e, t) {
          let r = super.parseTopLevel(e, t);
          return this.state.hasFlowComment && this.raise(lt.UnterminatedFlowComment, this.state.curPosition()), r;
         }
         skipBlockComment() {
          if (!this.hasPlugin('flowComments') || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? '*-/' : '*/');
          {
           if (this.state.hasFlowComment) throw this.raise(lt.NestedFlowComment, this.state.startLoc);
           this.hasFlowCommentCompletion();
           let e = this.skipFlowComment();
           e && ((this.state.pos += e), (this.state.hasFlowComment = !0));
          }
         }
         skipFlowComment() {
          let { pos: e } = this.state,
           t = 2;
          for (; [32, 9].includes(this.input.charCodeAt(e + t)); ) t++;
          let r = this.input.charCodeAt(t + e),
           n = this.input.charCodeAt(t + e + 1);
          return 58 === r && 58 === n ? t + 2 : 'flow-include' === this.input.slice(t + e, t + e + 12) ? t + 12 : 58 === r && 58 !== n && t;
         }
         hasFlowCommentCompletion() {
          if (-1 === this.input.indexOf('*/', this.state.pos)) throw this.raise(g.UnterminatedComment, this.state.curPosition());
         }
         flowEnumErrorBooleanMemberNotInitialized(e, { enumName: t, memberName: r }) {
          this.raise(lt.EnumBooleanMemberNotInitialized, e, { memberName: r, enumName: t });
         }
         flowEnumErrorInvalidMemberInitializer(e, t) {
          return this.raise(t.explicitType ? ('symbol' === t.explicitType ? lt.EnumInvalidMemberInitializerSymbolType : lt.EnumInvalidMemberInitializerPrimaryType) : lt.EnumInvalidMemberInitializerUnknownType, e, t);
         }
         flowEnumErrorNumberMemberNotInitialized(e, t) {
          this.raise(lt.EnumNumberMemberNotInitialized, e, t);
         }
         flowEnumErrorStringMemberInconsistentlyInitialized(e, t) {
          this.raise(lt.EnumStringMemberInconsistentlyInitialized, e, t);
         }
         flowEnumMemberInit() {
          let e = this.state.startLoc,
           t = () => this.match(12) || this.match(8);
          switch (this.state.type) {
           case 134: {
            let r = this.parseNumericLiteral(this.state.value);
            return t() ? { type: 'number', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
           }
           case 133: {
            let r = this.parseStringLiteral(this.state.value);
            return t() ? { type: 'string', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
           }
           case 85:
           case 86: {
            let r = this.parseBooleanLiteral(this.match(85));
            return t() ? { type: 'boolean', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
           }
           default:
            return { type: 'invalid', loc: e };
          }
         }
         flowEnumMemberRaw() {
          let e = this.state.startLoc;
          return { id: this.parseIdentifier(!0), init: this.eat(29) ? this.flowEnumMemberInit() : { type: 'none', loc: e } };
         }
         flowEnumCheckExplicitTypeMismatch(e, t, r) {
          let { explicitType: n } = t;
          null !== n && n !== r && this.flowEnumErrorInvalidMemberInitializer(e, t);
         }
         flowEnumMembers({ enumName: e, explicitType: t }) {
          let r = new Set(),
           n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] },
           s = !1;
          for (; !this.match(8); ) {
           if (this.eat(21)) {
            s = !0;
            break;
           }
           let i = this.startNode(),
            { id: a, init: o } = this.flowEnumMemberRaw(),
            u = a.name;
           if ('' === u) continue;
           /^[a-z]/.test(u) && this.raise(lt.EnumInvalidMemberName, a, { memberName: u, suggestion: u[0].toUpperCase() + u.slice(1), enumName: e }), r.has(u) && this.raise(lt.EnumDuplicateMemberName, a, { memberName: u, enumName: e }), r.add(u);
           let l = { enumName: e, explicitType: t, memberName: u };
           switch (((i.id = a), o.type)) {
            case 'boolean':
             this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'boolean'), (i.init = o.value), n.booleanMembers.push(this.finishNode(i, 'EnumBooleanMember'));
             break;
            case 'number':
             this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'number'), (i.init = o.value), n.numberMembers.push(this.finishNode(i, 'EnumNumberMember'));
             break;
            case 'string':
             this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'string'), (i.init = o.value), n.stringMembers.push(this.finishNode(i, 'EnumStringMember'));
             break;
            case 'invalid':
             throw this.flowEnumErrorInvalidMemberInitializer(o.loc, l);
            case 'none':
             switch (t) {
              case 'boolean':
               this.flowEnumErrorBooleanMemberNotInitialized(o.loc, l);
               break;
              case 'number':
               this.flowEnumErrorNumberMemberNotInitialized(o.loc, l);
               break;
              default:
               n.defaultedMembers.push(this.finishNode(i, 'EnumDefaultedMember'));
             }
           }
           this.match(8) || this.expect(12);
          }
          return { members: n, hasUnknownMembers: s };
         }
         flowEnumStringMembers(e, t, { enumName: r }) {
          if (0 === e.length) return t;
          if (0 === t.length) return e;
          if (t.length > e.length) {
           for (let t of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(t, { enumName: r });
           return t;
          }
          for (let n of t) this.flowEnumErrorStringMemberInconsistentlyInitialized(n, { enumName: r });
          return e;
         }
         flowEnumParseExplicitType({ enumName: e }) {
          if (!this.eatContextual(102)) return null;
          if (!$(this.state.type)) throw this.raise(lt.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e });
          let { value: t } = this.state;
          return this.next(), 'boolean' !== t && 'number' !== t && 'string' !== t && 'symbol' !== t && this.raise(lt.EnumInvalidExplicitType, this.state.startLoc, { enumName: e, invalidEnumType: t }), t;
         }
         flowEnumBody(e, t) {
          let r = t.name,
           n = t.loc.start,
           s = this.flowEnumParseExplicitType({ enumName: r });
          this.expect(5);
          let { members: i, hasUnknownMembers: a } = this.flowEnumMembers({ enumName: r, explicitType: s });
          switch (((e.hasUnknownMembers = a), s)) {
           case 'boolean':
            return (e.explicitType = !0), (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody');
           case 'number':
            return (e.explicitType = !0), (e.members = i.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody');
           case 'string':
            return (e.explicitType = !0), (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, 'EnumStringBody');
           case 'symbol':
            return (e.members = i.defaultedMembers), this.expect(8), this.finishNode(e, 'EnumSymbolBody');
           default: {
            let t = () => ((e.members = []), this.expect(8), this.finishNode(e, 'EnumStringBody'));
            e.explicitType = !1;
            let s = i.booleanMembers.length,
             a = i.numberMembers.length,
             o = i.stringMembers.length,
             u = i.defaultedMembers.length;
            if (!(s || a || o || u)) return t();
            if (!s && !a) return (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, 'EnumStringBody');
            if (!a && !o && s >= u) {
             for (let e of i.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
             return (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody');
            }
            if (!s && !o && a >= u) {
             for (let e of i.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
             return (e.members = i.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody');
            }
            return this.raise(lt.EnumInconsistentMemberValues, n, { enumName: r }), t();
           }
          }
         }
         flowParseEnumDeclaration(e) {
          let t = this.parseIdentifier();
          return (e.id = t), (e.body = this.flowEnumBody(this.startNode(), t)), this.finishNode(e, 'EnumDeclaration');
         }
         isLookaheadToken_lt() {
          let e = this.nextTokenStart();
          if (60 === this.input.charCodeAt(e)) {
           let t = this.input.charCodeAt(e + 1);
           return 60 !== t && 61 !== t;
          }
          return !1;
         }
         maybeUnwrapTypeCastExpression(e) {
          return 'TypeCastExpression' === e.type ? e.expression : e;
         }
        },
       typescript: (e) =>
        class extends e {
         constructor(...e) {
          super(...e), (this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ['in', 'out'], disallowedModifiers: ['const', 'public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'], errorTemplate: vt.InvalidModifierOnTypeParameter })), (this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ['const'], disallowedModifiers: ['in', 'out'], errorTemplate: vt.InvalidModifierOnTypeParameterPositions })), (this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ['in', 'out', 'const'], disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'], errorTemplate: vt.InvalidModifierOnTypeParameter }));
         }
         getScopeHandler() {
          return gt;
         }
         tsIsIdentifier() {
          return $(this.state.type);
         }
         tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
         }
         tsNextTokenCanFollowModifier() {
          return this.next(), this.tsTokenCanFollowModifier();
         }
         tsParseModifier(e, t) {
          if (!$(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
          let r = this.state.value;
          if (-1 !== e.indexOf(r)) {
           if (t && this.tsIsStartOfStaticBlocks()) return;
           if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return r;
          }
         }
         tsParseModifiers({ allowedModifiers: e, disallowedModifiers: t, stopOnStartOfClassStaticBlock: r, errorTemplate: n = vt.InvalidModifierOnTypeMember }, s) {
          let i = (e, t, r, n) => {
            t === r && s[n] && this.raise(vt.InvalidModifiersOrder, e, { orderedModifiers: [r, n] });
           },
           a = (e, t, r, n) => {
            ((s[r] && t === n) || (s[n] && t === r)) && this.raise(vt.IncompatibleModifiers, e, { modifiers: [r, n] });
           };
          for (;;) {
           let { startLoc: o } = this.state,
            u = this.tsParseModifier(e.concat(t ?? []), r);
           if (!u) break;
           Et(u) ? (s.accessibility ? this.raise(vt.DuplicateAccessibilityModifier, o, { modifier: u }) : (i(o, u, u, 'override'), i(o, u, u, 'static'), i(o, u, u, 'readonly'), (s.accessibility = u))) : Ct(u) ? (s[u] && this.raise(vt.DuplicateModifier, o, { modifier: u }), (s[u] = !0), i(o, u, 'in', 'out')) : (hasOwnProperty.call(s, u) ? this.raise(vt.DuplicateModifier, o, { modifier: u }) : (i(o, u, 'static', 'readonly'), i(o, u, 'static', 'override'), i(o, u, 'override', 'readonly'), i(o, u, 'abstract', 'override'), a(o, u, 'declare', 'override'), a(o, u, 'static', 'abstract')), (s[u] = !0)), null != t && t.includes(u) && this.raise(n, o, { modifier: u });
          }
         }
         tsIsListTerminator(e) {
          switch (e) {
           case 'EnumMembers':
           case 'TypeMembers':
            return this.match(8);
           case 'HeritageClauseElement':
            return this.match(5);
           case 'TupleElementTypes':
            return this.match(3);
           case 'TypeParametersOrArguments':
            return this.match(48);
          }
         }
         tsParseList(e, t) {
          let r = [];
          for (; !this.tsIsListTerminator(e); ) r.push(t());
          return r;
         }
         tsParseDelimitedList(e, t, r) {
          return (function (e) {
           if (null == e) throw new Error(`Unexpected ${e} value.`);
           return e;
          })(this.tsParseDelimitedListWorker(e, t, !0, r));
         }
         tsParseDelimitedListWorker(e, t, r, n) {
          let s = [],
           i = -1;
          for (; !this.tsIsListTerminator(e); ) {
           i = -1;
           let n = t();
           if (null == n) return;
           if ((s.push(n), !this.eat(12))) {
            if (this.tsIsListTerminator(e)) break;
            return void (r && this.expect(12));
           }
           i = this.state.lastTokStartLoc.index;
          }
          return n && (n.value = i), s;
         }
         tsParseBracketedList(e, t, r, n, s) {
          n || (r ? this.expect(0) : this.expect(47));
          let i = this.tsParseDelimitedList(e, t, s);
          return r ? this.expect(3) : this.expect(48), i;
         }
         tsParseImportType() {
          let e = this.startNode();
          return this.expect(83), this.expect(10), this.match(133) || this.raise(vt.UnsupportedImportTypeArgument, this.state.startLoc), (e.argument = super.parseExprAtom()), (this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions')) && (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || ((e.options = super.parseMaybeAssignAllowIn()), this.eat(12))), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSImportType');
         }
         tsParseEntityName(e = !0) {
          let t = this.parseIdentifier(e);
          for (; this.eat(16); ) {
           let r = this.startNodeAtNode(t);
           (r.left = t), (r.right = this.parseIdentifier(e)), (t = this.finishNode(r, 'TSQualifiedName'));
          }
          return t;
         }
         tsParseTypeReference() {
          let e = this.startNode();
          return (e.typeName = this.tsParseEntityName()), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSTypeReference');
         }
         tsParseThisTypePredicate(e) {
          this.next();
          let t = this.startNodeAtNode(e);
          return (t.parameterName = e), (t.typeAnnotation = this.tsParseTypeAnnotation(!1)), (t.asserts = !1), this.finishNode(t, 'TSTypePredicate');
         }
         tsParseThisTypeNode() {
          let e = this.startNode();
          return this.next(), this.finishNode(e, 'TSThisType');
         }
         tsParseTypeQuery() {
          let e = this.startNode();
          return this.expect(87), this.match(83) ? (e.exprName = this.tsParseImportType()) : (e.exprName = this.tsParseEntityName()), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSTypeQuery');
         }
         tsParseTypeParameter(e) {
          let t = this.startNode();
          return e(t), (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsEatThenParseType(81)), (t.default = this.tsEatThenParseType(29)), this.finishNode(t, 'TSTypeParameter');
         }
         tsTryParseTypeParameters(e) {
          if (this.match(47)) return this.tsParseTypeParameters(e);
         }
         tsParseTypeParameters(e) {
          let t = this.startNode();
          this.match(47) || this.match(142) ? this.next() : this.unexpected();
          let r = { value: -1 };
          return (t.params = this.tsParseBracketedList('TypeParametersOrArguments', this.tsParseTypeParameter.bind(this, e), !1, !0, r)), 0 === t.params.length && this.raise(vt.EmptyTypeParameters, t), -1 !== r.value && this.addExtra(t, 'trailingComma', r.value), this.finishNode(t, 'TSTypeParameterDeclaration');
         }
         tsFillSignature(e, t) {
          let r = 19 === e,
           n = 'typeAnnotation';
          (t.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier)), this.expect(10), (t.parameters = this.tsParseBindingListForSignature()), (r || this.match(e)) && (t[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
         }
         tsParseBindingListForSignature() {
          let e = super.parseBindingList(11, 41, 2);
          for (let t of e) {
           let { type: e } = t;
           ('AssignmentPattern' === e || 'TSParameterProperty' === e) && this.raise(vt.UnsupportedSignatureParameterKind, t, { type: e });
          }
          return e;
         }
         tsParseTypeMemberSemicolon() {
          !this.eat(12) && !this.isLineTerminator() && this.expect(13);
         }
         tsParseSignatureMember(e, t) {
          return this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e);
         }
         tsIsUnambiguouslyIndexSignature() {
          return this.next(), !!$(this.state.type) && (this.next(), this.match(14));
         }
         tsTryParseIndexSignature(e) {
          if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
          this.expect(0);
          let t = this.parseIdentifier();
          (t.typeAnnotation = this.tsParseTypeAnnotation()), this.resetEndLocation(t), this.expect(3), (e.parameters = [t]);
          let r = this.tsTryParseTypeAnnotation();
          return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSIndexSignature');
         }
         tsParsePropertyOrMethodSignature(e, t) {
          this.eat(17) && (e.optional = !0);
          let r = e;
          if (this.match(10) || this.match(47)) {
           t && this.raise(vt.ReadonlyForMethodSignature, e);
           let n = r;
           n.kind && this.match(47) && this.raise(vt.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon();
           let s = 'parameters',
            i = 'typeAnnotation';
           if ('get' === n.kind) n[s].length > 0 && (this.raise(g.BadGetterArity, this.state.curPosition()), this.isThisParam(n[s][0]) && this.raise(vt.AccesorCannotDeclareThisParameter, this.state.curPosition()));
           else if ('set' === n.kind) {
            if (1 !== n[s].length) this.raise(g.BadSetterArity, this.state.curPosition());
            else {
             let e = n[s][0];
             this.isThisParam(e) && this.raise(vt.AccesorCannotDeclareThisParameter, this.state.curPosition()), 'Identifier' === e.type && e.optional && this.raise(vt.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), 'RestElement' === e.type && this.raise(vt.SetAccesorCannotHaveRestParameter, this.state.curPosition());
            }
            n[i] && this.raise(vt.SetAccesorCannotHaveReturnType, n[i]);
           } else n.kind = 'method';
           return this.finishNode(n, 'TSMethodSignature');
          }
          {
           let e = r;
           t && (e.readonly = !0);
           let n = this.tsTryParseTypeAnnotation();
           return n && (e.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSPropertySignature');
          }
         }
         tsParseTypeMember() {
          let e = this.startNode();
          if (this.match(10) || this.match(47)) return this.tsParseSignatureMember('TSCallSignatureDeclaration', e);
          if (this.match(77)) {
           let t = this.startNode();
           return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember('TSConstructSignatureDeclaration', e) : ((e.key = this.createIdentifier(t, 'new')), this.tsParsePropertyOrMethodSignature(e, !1));
          }
          return this.tsParseModifiers({ allowedModifiers: ['readonly'], disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'] }, e), this.tsTryParseIndexSignature(e) || (super.parsePropertyName(e), !e.computed && 'Identifier' === e.key.type && ('get' === e.key.name || 'set' === e.key.name) && this.tsTokenCanFollowModifier() && ((e.kind = e.key.name), super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
         }
         tsParseTypeLiteral() {
          let e = this.startNode();
          return (e.members = this.tsParseObjectTypeMembers()), this.finishNode(e, 'TSTypeLiteral');
         }
         tsParseObjectTypeMembers() {
          this.expect(5);
          let e = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this));
          return this.expect(8), e;
         }
         tsIsStartOfMappedType() {
          return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !(!this.match(0) || (this.next(), !this.tsIsIdentifier())) && (this.next(), this.match(58)));
         }
         tsParseMappedTypeParameter() {
          let e = this.startNode();
          return (e.name = this.tsParseTypeParameterName()), (e.constraint = this.tsExpectThenParseType(58)), this.finishNode(e, 'TSTypeParameter');
         }
         tsParseMappedType() {
          let e = this.startNode();
          return this.expect(5), this.match(53) ? ((e.readonly = this.state.value), this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = !0), this.expect(0), (e.typeParameter = this.tsParseMappedTypeParameter()), (e.nameType = this.eatContextual(93) ? this.tsParseType() : null), this.expect(3), this.match(53) ? ((e.optional = this.state.value), this.next(), this.expect(17)) : this.eat(17) && (e.optional = !0), (e.typeAnnotation = this.tsTryParseType()), this.semicolon(), this.expect(8), this.finishNode(e, 'TSMappedType');
         }
         tsParseTupleType() {
          let e = this.startNode();
          e.elementTypes = this.tsParseBracketedList('TupleElementTypes', this.tsParseTupleElementType.bind(this), !0, !1);
          let t = !1;
          return (
           e.elementTypes.forEach((e) => {
            let { type: r } = e;
            t && 'TSRestType' !== r && 'TSOptionalType' !== r && !('TSNamedTupleMember' === r && e.optional) && this.raise(vt.OptionalTypeBeforeRequired, e), t || (t = ('TSNamedTupleMember' === r && e.optional) || 'TSOptionalType' === r);
           }),
           this.finishNode(e, 'TSTupleType')
          );
         }
         tsParseTupleElementType() {
          let e,
           t,
           r,
           n,
           { startLoc: s } = this.state,
           i = this.eat(21),
           a = H(this.state.type) ? this.lookaheadCharCode() : null;
          if (58 === a) (e = !0), (r = !1), (t = this.parseIdentifier(!0)), this.expect(14), (n = this.tsParseType());
          else if (63 === a) {
           r = !0;
           let s = this.state.startLoc,
            i = this.state.value,
            a = this.tsParseNonArrayType();
           58 === this.lookaheadCharCode() ? ((e = !0), (t = this.createIdentifier(this.startNodeAt(s), i)), this.expect(17), this.expect(14), (n = this.tsParseType())) : ((e = !1), (n = a), this.expect(17));
          } else (n = this.tsParseType()), (r = this.eat(17)), (e = this.eat(14));
          if (e) {
           let e;
           t ? ((e = this.startNodeAtNode(t)), (e.optional = r), (e.label = t), (e.elementType = n), this.eat(17) && ((e.optional = !0), this.raise(vt.TupleOptionalAfterType, this.state.lastTokStartLoc))) : ((e = this.startNodeAtNode(n)), (e.optional = r), this.raise(vt.InvalidTupleMemberLabel, n), (e.label = n), (e.elementType = this.tsParseType())), (n = this.finishNode(e, 'TSNamedTupleMember'));
          } else if (r) {
           let e = this.startNodeAtNode(n);
           (e.typeAnnotation = n), (n = this.finishNode(e, 'TSOptionalType'));
          }
          if (i) {
           let e = this.startNodeAt(s);
           (e.typeAnnotation = n), (n = this.finishNode(e, 'TSRestType'));
          }
          return n;
         }
         tsParseParenthesizedType() {
          let e = this.startNode();
          return this.expect(10), (e.typeAnnotation = this.tsParseType()), this.expect(11), this.finishNode(e, 'TSParenthesizedType');
         }
         tsParseFunctionOrConstructorType(e, t) {
          let r = this.startNode();
          return 'TSConstructorType' === e && ((r.abstract = !!t), t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r)), this.finishNode(r, e);
         }
         tsParseLiteralTypeNode() {
          let e = this.startNode();
          switch (this.state.type) {
           case 134:
           case 135:
           case 133:
           case 85:
           case 86:
            e.literal = super.parseExprAtom();
            break;
           default:
            this.unexpected();
          }
          return this.finishNode(e, 'TSLiteralType');
         }
         tsParseTemplateLiteralType() {
          let e = this.startNode();
          return (e.literal = super.parseTemplate(!1)), this.finishNode(e, 'TSLiteralType');
         }
         parseTemplateSubstitution() {
          return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
         }
         tsParseThisTypeOrThisTypePredicate() {
          let e = this.tsParseThisTypeNode();
          return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
         }
         tsParseNonArrayType() {
          switch (this.state.type) {
           case 133:
           case 134:
           case 135:
           case 85:
           case 86:
            return this.tsParseLiteralTypeNode();
           case 53:
            if ('-' === this.state.value) {
             let e = this.startNode(),
              t = this.lookahead();
             return 134 !== t.type && 135 !== t.type && this.unexpected(), (e.literal = this.parseMaybeUnary()), this.finishNode(e, 'TSLiteralType');
            }
            break;
           case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
           case 87:
            return this.tsParseTypeQuery();
           case 83:
            return this.tsParseImportType();
           case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
           case 0:
            return this.tsParseTupleType();
           case 10:
            return this.tsParseParenthesizedType();
           case 25:
           case 24:
            return this.tsParseTemplateLiteralType();
           default: {
            let { type: e } = this.state;
            if ($(e) || 88 === e || 84 === e) {
             let t =
              88 === e
               ? 'TSVoidKeyword'
               : 84 === e
                 ? 'TSNullKeyword'
                 : (function (e) {
                    switch (e) {
                     case 'any':
                      return 'TSAnyKeyword';
                     case 'boolean':
                      return 'TSBooleanKeyword';
                     case 'bigint':
                      return 'TSBigIntKeyword';
                     case 'never':
                      return 'TSNeverKeyword';
                     case 'number':
                      return 'TSNumberKeyword';
                     case 'object':
                      return 'TSObjectKeyword';
                     case 'string':
                      return 'TSStringKeyword';
                     case 'symbol':
                      return 'TSSymbolKeyword';
                     case 'undefined':
                      return 'TSUndefinedKeyword';
                     case 'unknown':
                      return 'TSUnknownKeyword';
                     default:
                      return;
                    }
                   })(this.state.value);
             if (void 0 !== t && 46 !== this.lookaheadCharCode()) {
              let e = this.startNode();
              return this.next(), this.finishNode(e, t);
             }
             return this.tsParseTypeReference();
            }
           }
          }
          this.unexpected();
         }
         tsParseArrayTypeOrHigher() {
          let e = this.tsParseNonArrayType();
          for (; !this.hasPrecedingLineBreak() && this.eat(0); )
           if (this.match(3)) {
            let t = this.startNodeAtNode(e);
            (t.elementType = e), this.expect(3), (e = this.finishNode(t, 'TSArrayType'));
           } else {
            let t = this.startNodeAtNode(e);
            (t.objectType = e), (t.indexType = this.tsParseType()), this.expect(3), (e = this.finishNode(t, 'TSIndexedAccessType'));
           }
          return e;
         }
         tsParseTypeOperator() {
          let e = this.startNode(),
           t = this.state.value;
          return this.next(), (e.operator = t), (e.typeAnnotation = this.tsParseTypeOperatorOrHigher()), 'readonly' === t && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, 'TSTypeOperator');
         }
         tsCheckTypeAnnotationForReadOnly(e) {
          switch (e.typeAnnotation.type) {
           case 'TSTupleType':
           case 'TSArrayType':
            return;
           default:
            this.raise(vt.UnexpectedReadonly, e);
          }
         }
         tsParseInferType() {
          let e = this.startNode();
          this.expectContextual(115);
          let t = this.startNode();
          return (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())), (e.typeParameter = this.finishNode(t, 'TSTypeParameter')), this.finishNode(e, 'TSInferType');
         }
         tsParseConstraintForInferType() {
          if (this.eat(81)) {
           let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
           if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
          }
         }
         tsParseTypeOperatorOrHigher() {
          return (function (e) {
           return e >= 121 && e <= 123;
          })(this.state.type) && !this.state.containsEsc
           ? this.tsParseTypeOperator()
           : this.isContextual(115)
             ? this.tsParseInferType()
             : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
         }
         tsParseUnionOrIntersectionType(e, t, r) {
          let n = this.startNode(),
           s = this.eat(r),
           i = [];
          do {
           i.push(t());
          } while (this.eat(r));
          return 1 !== i.length || s ? ((n.types = i), this.finishNode(n, e)) : i[0];
         }
         tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType('TSIntersectionType', this.tsParseTypeOperatorOrHigher.bind(this), 45);
         }
         tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43);
         }
         tsIsStartOfFunctionType() {
          return !!this.match(47) || (this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this)));
         }
         tsSkipParameterStart() {
          if ($(this.state.type) || this.match(78)) return this.next(), !0;
          if (this.match(5)) {
           let { errors: e } = this.state,
            t = e.length;
           try {
            return this.parseObjectLike(8, !0), e.length === t;
           } catch {
            return !1;
           }
          }
          if (this.match(0)) {
           this.next();
           let { errors: e } = this.state,
            t = e.length;
           try {
            return super.parseBindingList(3, 93, 1), e.length === t;
           } catch {
            return !1;
           }
          }
          return !1;
         }
         tsIsUnambiguouslyStartOfFunctionType() {
          return this.next(), !!(this.match(11) || this.match(21) || (this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || (this.match(11) && (this.next(), this.match(19))))));
         }
         tsParseTypeOrTypePredicateAnnotation(e) {
          return this.tsInType(() => {
           let t = this.startNode();
           this.expect(e);
           let r = this.startNode(),
            n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
           if (n && this.match(78)) {
            let e = this.tsParseThisTypeOrThisTypePredicate();
            return 'TSThisType' === e.type ? ((r.parameterName = e), (r.asserts = !0), (r.typeAnnotation = null), (e = this.finishNode(r, 'TSTypePredicate'))) : (this.resetStartLocationFromNode(e, r), (e.asserts = !0)), (t.typeAnnotation = e), this.finishNode(t, 'TSTypeAnnotation');
           }
           let s = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
           if (!s) return n ? ((r.parameterName = this.parseIdentifier()), (r.asserts = n), (r.typeAnnotation = null), (t.typeAnnotation = this.finishNode(r, 'TSTypePredicate')), this.finishNode(t, 'TSTypeAnnotation')) : this.tsParseTypeAnnotation(!1, t);
           let i = this.tsParseTypeAnnotation(!1);
           return (r.parameterName = s), (r.typeAnnotation = i), (r.asserts = n), (t.typeAnnotation = this.finishNode(r, 'TSTypePredicate')), this.finishNode(t, 'TSTypeAnnotation');
          });
         }
         tsTryParseTypeOrTypePredicateAnnotation() {
          if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
         }
         tsTryParseTypeAnnotation() {
          if (this.match(14)) return this.tsParseTypeAnnotation();
         }
         tsTryParseType() {
          return this.tsEatThenParseType(14);
         }
         tsParseTypePredicatePrefix() {
          let e = this.parseIdentifier();
          if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e;
         }
         tsParseTypePredicateAsserts() {
          if (109 !== this.state.type) return !1;
          let e = this.state.containsEsc;
          return this.next(), !(!$(this.state.type) && !this.match(78)) && (e && this.raise(g.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: 'asserts' }), !0);
         }
         tsParseTypeAnnotation(e = !0, t = this.startNode()) {
          return (
           this.tsInType(() => {
            e && this.expect(14), (t.typeAnnotation = this.tsParseType());
           }),
           this.finishNode(t, 'TSTypeAnnotation')
          );
         }
         tsParseType() {
          bt(this.state.inType);
          let e = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
          let t = this.startNodeAtNode(e);
          return (t.checkType = e), (t.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())), this.expect(17), (t.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.expect(14), (t.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.finishNode(t, 'TSConditionalType');
         }
         isAbstractConstructorSignature() {
          return this.isContextual(124) && 77 === this.lookahead().type;
         }
         tsParseNonConditionalType() {
          return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType('TSFunctionType') : this.match(77) ? this.tsParseFunctionOrConstructorType('TSConstructorType') : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0) : this.tsParseUnionTypeOrHigher();
         }
         tsParseTypeAssertion() {
          this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') && this.raise(vt.ReservedTypeAssertion, this.state.startLoc);
          let e = this.startNode();
          return (e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType()))), this.expect(48), (e.expression = this.parseMaybeUnary()), this.finishNode(e, 'TSTypeAssertion');
         }
         tsParseHeritageClause(e) {
          let t = this.state.startLoc,
           r = this.tsParseDelimitedList('HeritageClauseElement', () => {
            let e = this.startNode();
            return (e.expression = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSExpressionWithTypeArguments');
           });
          return r.length || this.raise(vt.EmptyHeritageClauseType, t, { token: e }), r;
         }
         tsParseInterfaceDeclaration(e, t = {}) {
          if (this.hasFollowingLineBreak()) return null;
          this.expectContextual(129), t.declare && (e.declare = !0), $(this.state.type) ? ((e.id = this.parseIdentifier()), this.checkIdentifier(e.id, 130)) : ((e.id = null), this.raise(vt.MissingInterfaceName, this.state.startLoc)), (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers)), this.eat(81) && (e.extends = this.tsParseHeritageClause('extends'));
          let r = this.startNode();
          return (r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))), (e.body = this.finishNode(r, 'TSInterfaceBody')), this.finishNode(e, 'TSInterfaceDeclaration');
         }
         tsParseTypeAliasDeclaration(e) {
          return (
           (e.id = this.parseIdentifier()),
           this.checkIdentifier(e.id, 2),
           (e.typeAnnotation = this.tsInType(() => {
            if (((e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers)), this.expect(29), this.isContextual(114) && 16 !== this.lookahead().type)) {
             let e = this.startNode();
             return this.next(), this.finishNode(e, 'TSIntrinsicKeyword');
            }
            return this.tsParseType();
           })),
           this.semicolon(),
           this.finishNode(e, 'TSTypeAliasDeclaration')
          );
         }
         tsInNoContext(e) {
          let t = this.state.context;
          this.state.context = [t[0]];
          try {
           return e();
          } finally {
           this.state.context = t;
          }
         }
         tsInType(e) {
          let t = this.state.inType;
          this.state.inType = !0;
          try {
           return e();
          } finally {
           this.state.inType = t;
          }
         }
         tsInDisallowConditionalTypesContext(e) {
          let t = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !0;
          try {
           return e();
          } finally {
           this.state.inDisallowConditionalTypesContext = t;
          }
         }
         tsInAllowConditionalTypesContext(e) {
          let t = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !1;
          try {
           return e();
          } finally {
           this.state.inDisallowConditionalTypesContext = t;
          }
         }
         tsEatThenParseType(e) {
          if (this.match(e)) return this.tsNextThenParseType();
         }
         tsExpectThenParseType(e) {
          return this.tsInType(() => (this.expect(e), this.tsParseType()));
         }
         tsNextThenParseType() {
          return this.tsInType(() => (this.next(), this.tsParseType()));
         }
         tsParseEnumMember() {
          let e = this.startNode();
          return (e.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0)), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, 'TSEnumMember');
         }
         tsParseEnumDeclaration(e, t = {}) {
          return t.const && (e.const = !0), t.declare && (e.declare = !0), this.expectContextual(126), (e.id = this.parseIdentifier()), this.checkIdentifier(e.id, e.const ? 8971 : 8459), this.expect(5), (e.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))), this.expect(8), this.finishNode(e, 'TSEnumDeclaration');
         }
         tsParseModuleBlock() {
          let e = this.startNode();
          return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody((e.body = []), void 0, !0, 8), this.scope.exit(), this.finishNode(e, 'TSModuleBlock');
         }
         tsParseModuleOrNamespaceDeclaration(e, t = !1) {
          if (((e.id = this.parseIdentifier()), t || this.checkIdentifier(e.id, 1024), this.eat(16))) {
           let t = this.startNode();
           this.tsParseModuleOrNamespaceDeclaration(t, !0), (e.body = t);
          } else this.scope.enter(256), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit();
          return this.finishNode(e, 'TSModuleDeclaration');
         }
         tsParseAmbientExternalModuleDeclaration(e) {
          return this.isContextual(112) ? ((e.global = !0), (e.id = this.parseIdentifier())) : this.match(133) ? (e.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, 'TSModuleDeclaration');
         }
         tsParseImportEqualsDeclaration(e, t, r) {
          (e.isExport = r || !1), (e.id = t || this.parseIdentifier()), this.checkIdentifier(e.id, 4096), this.expect(29);
          let n = this.tsParseModuleReference();
          return 'type' === e.importKind && 'TSExternalModuleReference' !== n.type && this.raise(vt.ImportAliasHasImportType, n), (e.moduleReference = n), this.semicolon(), this.finishNode(e, 'TSImportEqualsDeclaration');
         }
         tsIsExternalModuleReference() {
          return this.isContextual(119) && 40 === this.lookaheadCharCode();
         }
         tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
         }
         tsParseExternalModuleReference() {
          let e = this.startNode();
          return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), (e.expression = super.parseExprAtom()), this.expect(11), (this.sawUnambiguousESM = !0), this.finishNode(e, 'TSExternalModuleReference');
         }
         tsLookAhead(e) {
          let t = this.state.clone(),
           r = e();
          return (this.state = t), r;
         }
         tsTryParseAndCatch(e) {
          let t = this.tryParse((t) => e() || t());
          if (!t.aborted && t.node) return t.error && (this.state = t.failState), t.node;
         }
         tsTryParse(e) {
          let t = this.state.clone(),
           r = e();
          if (void 0 !== r && !1 !== r) return r;
          this.state = t;
         }
         tsTryParseDeclare(e) {
          if (this.isLineTerminator()) return;
          let t,
           r = this.state.type;
          return (
           this.isContextual(100) && ((r = 74), (t = 'let')),
           this.tsInAmbientContext(() => {
            switch (r) {
             case 68:
              return (e.declare = !0), super.parseFunctionStatement(e, !1, !1);
             case 80:
              return (e.declare = !0), this.parseClass(e, !0, !1);
             case 126:
              return this.tsParseEnumDeclaration(e, { declare: !0 });
             case 112:
              return this.tsParseAmbientExternalModuleDeclaration(e);
             case 75:
             case 74:
              return this.match(75) && this.isLookaheadContextual('enum') ? (this.expect(75), this.tsParseEnumDeclaration(e, { const: !0, declare: !0 })) : ((e.declare = !0), this.parseVarStatement(e, t || this.state.value, !0));
             case 129: {
              let t = this.tsParseInterfaceDeclaration(e, { declare: !0 });
              if (t) return t;
             }
             default:
              if ($(r)) return this.tsParseDeclaration(e, this.state.value, !0, null);
            }
           })
          );
         }
         tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
         }
         tsParseExpressionStatement(e, t, r) {
          switch (t.name) {
           case 'declare': {
            let t = this.tsTryParseDeclare(e);
            return t && (t.declare = !0), t;
           }
           case 'global':
            if (this.match(5)) {
             this.scope.enter(256), this.prodParam.enter(0);
             let r = e;
             return (r.global = !0), (r.id = t), (r.body = this.tsParseModuleBlock()), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, 'TSModuleDeclaration');
            }
            break;
           default:
            return this.tsParseDeclaration(e, t.name, !1, r);
          }
         }
         tsParseDeclaration(e, t, r, n) {
          switch (t) {
           case 'abstract':
            if (this.tsCheckLineTerminator(r) && (this.match(80) || $(this.state.type))) return this.tsParseAbstractDeclaration(e, n);
            break;
           case 'module':
            if (this.tsCheckLineTerminator(r)) {
             if (this.match(133)) return this.tsParseAmbientExternalModuleDeclaration(e);
             if ($(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
            }
            break;
           case 'namespace':
            if (this.tsCheckLineTerminator(r) && $(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
            break;
           case 'type':
            if (this.tsCheckLineTerminator(r) && $(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
          }
         }
         tsCheckLineTerminator(e) {
          return e ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
         }
         tsTryParseGenericAsyncArrowFunction(e) {
          if (!this.match(47)) return;
          let t = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = !0;
          let r = this.tsTryParseAndCatch(() => {
           let t = this.startNodeAt(e);
           return (t.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier)), super.parseFunctionParams(t), (t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()), this.expect(19), t;
          });
          return (this.state.maybeInArrowParameters = t), r ? super.parseArrowExpression(r, null, !0) : void 0;
         }
         tsParseTypeArgumentsInExpression() {
          if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
         }
         tsParseTypeArguments() {
          let e = this.startNode();
          return (e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this)))))), 0 === e.params.length ? this.raise(vt.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === E.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, 'TSTypeParameterInstantiation');
         }
         tsIsDeclarationStart() {
          return (function (e) {
           return e >= 124 && e <= 130;
          })(this.state.type);
         }
         isExportDefaultSpecifier() {
          return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
         }
         parseAssignableListItem(e, t) {
          let r = this.state.startLoc,
           n = {};
          this.tsParseModifiers({ allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'] }, n);
          let s = n.accessibility,
           i = n.override,
           a = n.readonly;
          !(4 & e) && (s || a || i) && this.raise(vt.UnexpectedParameterModifier, r);
          let o = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(o, e);
          let u = this.parseMaybeDefault(o.loc.start, o);
          if (s || a || i) {
           let e = this.startNodeAt(r);
           return t.length && (e.decorators = t), s && (e.accessibility = s), a && (e.readonly = a), i && (e.override = i), 'Identifier' !== u.type && 'AssignmentPattern' !== u.type && this.raise(vt.UnsupportedParameterPropertyKind, e), (e.parameter = u), this.finishNode(e, 'TSParameterProperty');
          }
          return t.length && (o.decorators = t), u;
         }
         isSimpleParameter(e) {
          return ('TSParameterProperty' === e.type && super.isSimpleParameter(e.parameter)) || super.isSimpleParameter(e);
         }
         tsDisallowOptionalPattern(e) {
          for (let t of e.params) 'Identifier' !== t.type && t.optional && !this.state.isAmbientContext && this.raise(vt.PatternIsOptional, t);
         }
         setArrowFunctionParameters(e, t, r) {
          super.setArrowFunctionParameters(e, t, r), this.tsDisallowOptionalPattern(e);
         }
         parseFunctionBodyAndFinish(e, t, r = !1) {
          this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
          let n = 'FunctionDeclaration' === t ? 'TSDeclareFunction' : 'ClassMethod' === t || 'ClassPrivateMethod' === t ? 'TSDeclareMethod' : void 0;
          return n && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, n) : 'TSDeclareFunction' === n && this.state.isAmbientContext && (this.raise(vt.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, n, r) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, t, r));
         }
         registerFunctionStatementId(e) {
          !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
         }
         tsCheckForInvalidTypeCasts(e) {
          e.forEach((e) => {
           'TSTypeCastExpression' === (null == e ? void 0 : e.type) && this.raise(vt.UnexpectedTypeAnnotation, e.typeAnnotation);
          });
         }
         toReferencedList(e, t) {
          return this.tsCheckForInvalidTypeCasts(e), e;
         }
         parseArrayLike(e, t, r, n) {
          let s = super.parseArrayLike(e, t, r, n);
          return 'ArrayExpression' === s.type && this.tsCheckForInvalidTypeCasts(s.elements), s;
         }
         parseSubscript(e, t, r, n) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
           (this.state.canStartJSXElement = !1), this.next();
           let r = this.startNodeAt(t);
           return (r.expression = e), this.finishNode(r, 'TSNonNullExpression');
          }
          let s = !1;
          if (this.match(18) && 60 === this.lookaheadCharCode()) {
           if (r) return (n.stop = !0), e;
           (n.optionalChainMember = s = !0), this.next();
          }
          if (this.match(47) || this.match(51)) {
           let i,
            a = this.tsTryParseAndCatch(() => {
             if (!r && this.atPossibleAsyncArrow(e)) {
              let e = this.tsTryParseGenericAsyncArrowFunction(t);
              if (e) return e;
             }
             let a = this.tsParseTypeArgumentsInExpression();
             if (!a) return;
             if (s && !this.match(10)) return void (i = this.state.curPosition());
             if (X(this.state.type)) {
              let r = super.parseTaggedTemplateExpression(e, t, n);
              return (r.typeParameters = a), r;
             }
             if (!r && this.eat(10)) {
              let r = this.startNodeAt(t);
              return (r.callee = e), (r.arguments = this.parseCallExpressionArguments(11, !1)), this.tsCheckForInvalidTypeCasts(r.arguments), (r.typeParameters = a), n.optionalChainMember && (r.optional = s), this.finishCallExpression(r, n.optionalChainMember);
             }
             let o = this.state.type;
             if (48 === o || 52 === o || (10 !== o && V(o) && !this.hasPrecedingLineBreak())) return;
             let u = this.startNodeAt(t);
             return (u.expression = e), (u.typeParameters = a), this.finishNode(u, 'TSInstantiationExpression');
            });
           if ((i && this.unexpected(i, 10), a)) return 'TSInstantiationExpression' === a.type && (this.match(16) || (this.match(18) && 40 !== this.lookaheadCharCode())) && this.raise(vt.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), a;
          }
          return super.parseSubscript(e, t, r, n);
         }
         parseNewCallee(e) {
          var t;
          super.parseNewCallee(e);
          let { callee: r } = e;
          'TSInstantiationExpression' === r.type && (null == (t = r.extra) || !t.parenthesized) && ((e.typeParameters = r.typeParameters), (e.callee = r.expression));
         }
         parseExprOp(e, t, r) {
          let n;
          if (G(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(120)))) {
           let s = this.startNodeAt(t);
           return (s.expression = e), (s.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n && this.raise(g.UnexpectedKeyword, this.state.startLoc, { keyword: 'const' }), this.tsParseTypeReference()) : this.tsParseType()))), this.finishNode(s, n ? 'TSSatisfiesExpression' : 'TSAsExpression'), this.reScan_lt_gt(), this.parseExprOp(s, t, r);
          }
          return super.parseExprOp(e, t, r);
         }
         checkReservedWord(e, t, r, n) {
          this.state.isAmbientContext || super.checkReservedWord(e, t, r, n);
         }
         checkImportReflection(e) {
          super.checkImportReflection(e), e.module && 'value' !== e.importKind && this.raise(vt.ImportReflectionHasImportType, e.specifiers[0].loc.start);
         }
         checkDuplicateExports() {}
         isPotentialImportPhase(e) {
          if (super.isPotentialImportPhase(e)) return !0;
          if (this.isContextual(130)) {
           let t = this.lookaheadCharCode();
           return e ? 123 === t || 42 === t : 61 !== t;
          }
          return !e && this.isContextual(87);
         }
         applyImportPhase(e, t, r, n) {
          super.applyImportPhase(e, t, r, n), t ? (e.exportKind = 'type' === r ? 'type' : 'value') : (e.importKind = 'type' === r || 'typeof' === r ? r : 'value');
         }
         parseImport(e) {
          if (this.match(133)) return (e.importKind = 'value'), super.parseImport(e);
          let t;
          if ($(this.state.type) && 61 === this.lookaheadCharCode()) return (e.importKind = 'value'), this.tsParseImportEqualsDeclaration(e);
          if (this.isContextual(130)) {
           let r = this.parseMaybeImportPhase(e, !1);
           if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e, r);
           t = super.parseImportSpecifiersAndAfter(e, r);
          } else t = super.parseImport(e);
          return 'type' === t.importKind && t.specifiers.length > 1 && 'ImportDefaultSpecifier' === t.specifiers[0].type && this.raise(vt.TypeImportCannotSpecifyDefaultAndNamed, t), t;
         }
         parseExport(e, t) {
          if (this.match(83)) {
           this.next();
           let t = e,
            r = null;
           return this.isContextual(130) && this.isPotentialImportPhase(!1) ? (r = this.parseMaybeImportPhase(t, !1)) : (t.importKind = 'value'), this.tsParseImportEqualsDeclaration(t, r, !0);
          }
          if (this.eat(29)) {
           let t = e;
           return (t.expression = super.parseExpression()), this.semicolon(), (this.sawUnambiguousESM = !0), this.finishNode(t, 'TSExportAssignment');
          }
          if (this.eatContextual(93)) {
           let t = e;
           return this.expectContextual(128), (t.id = this.parseIdentifier()), this.semicolon(), this.finishNode(t, 'TSNamespaceExportDeclaration');
          }
          return super.parseExport(e, t);
         }
         isAbstractClass() {
          return this.isContextual(124) && 80 === this.lookahead().type;
         }
         parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
           let e = this.startNode();
           return this.next(), (e.abstract = !0), this.parseClass(e, !0, !0);
          }
          if (this.match(129)) {
           let e = this.tsParseInterfaceDeclaration(this.startNode());
           if (e) return e;
          }
          return super.parseExportDefaultExpression();
         }
         parseVarStatement(e, t, r = !1) {
          let { isAmbientContext: n } = this.state,
           s = super.parseVarStatement(e, t, r || n);
          if (!n) return s;
          for (let { id: i, init: a } of s.declarations) a && ('const' !== t || i.typeAnnotation ? this.raise(vt.InitializerNotAllowedInAmbientContext, a) : St(a, this.hasPlugin('estree')) || this.raise(vt.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, a));
          return s;
         }
         parseStatementContent(e, t) {
          if (this.match(75) && this.isLookaheadContextual('enum')) {
           let e = this.startNode();
           return this.expect(75), this.tsParseEnumDeclaration(e, { const: !0 });
          }
          if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
          if (this.isContextual(129)) {
           let e = this.tsParseInterfaceDeclaration(this.startNode());
           if (e) return e;
          }
          return super.parseStatementContent(e, t);
         }
         parseAccessModifier() {
          return this.tsParseModifier(['public', 'protected', 'private']);
         }
         tsHasSomeModifiers(e, t) {
          return t.some((t) => (Et(t) ? e.accessibility === t : !!e[t]));
         }
         tsIsStartOfStaticBlocks() {
          return this.isContextual(106) && 123 === this.lookaheadCharCode();
         }
         parseClassMember(e, t, r) {
          let n = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static'];
          this.tsParseModifiers({ allowedModifiers: n, disallowedModifiers: ['in', 'out'], stopOnStartOfClassStaticBlock: !0, errorTemplate: vt.InvalidModifierOnTypeParameterPositions }, t);
          let s = () => {
           this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, n) && this.raise(vt.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, t)) : this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
          };
          t.declare ? this.tsInAmbientContext(s) : s();
         }
         parseClassMemberWithIsStatic(e, t, r, n) {
          let s = this.tsTryParseIndexSignature(t);
          if (s) return e.body.push(s), t.abstract && this.raise(vt.IndexSignatureHasAbstract, t), t.accessibility && this.raise(vt.IndexSignatureHasAccessibility, t, { modifier: t.accessibility }), t.declare && this.raise(vt.IndexSignatureHasDeclare, t), void (t.override && this.raise(vt.IndexSignatureHasOverride, t));
          !this.state.inAbstractClass && t.abstract && this.raise(vt.NonAbstractClassHasAbstractMethod, t), t.override && (r.hadSuperClass || this.raise(vt.OverrideNotInSubClass, t)), super.parseClassMemberWithIsStatic(e, t, r, n);
         }
         parsePostMemberNameModifiers(e) {
          this.eat(17) && (e.optional = !0), e.readonly && this.match(10) && this.raise(vt.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(vt.ClassMethodHasDeclare, e);
         }
         parseExpressionStatement(e, t, r) {
          return ('Identifier' === t.type ? this.tsParseExpressionStatement(e, t, r) : void 0) || super.parseExpressionStatement(e, t, r);
         }
         shouldParseExportDeclaration() {
          return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
         }
         parseConditional(e, t, r) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, t, r);
          let n = this.tryParse(() => super.parseConditional(e, t));
          return n.node ? (n.error && (this.state = n.failState), n.node) : (n.error && super.setOptionalParametersError(r, n.error), e);
         }
         parseParenItem(e, t) {
          let r = super.parseParenItem(e, t);
          if ((this.eat(17) && ((r.optional = !0), this.resetEndLocation(e)), this.match(14))) {
           let r = this.startNodeAt(t);
           return (r.expression = e), (r.typeAnnotation = this.tsParseTypeAnnotation()), this.finishNode(r, 'TSTypeCastExpression');
          }
          return e;
         }
         parseExportDeclaration(e) {
          if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
          let t = this.state.startLoc,
           r = this.eatContextual(125);
          if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(vt.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
          let n = ($(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(e);
          return n ? (('TSInterfaceDeclaration' === n.type || 'TSTypeAliasDeclaration' === n.type || r) && (e.exportKind = 'type'), r && (this.resetStartLocation(n, t), (n.declare = !0)), n) : null;
         }
         parseClassId(e, t, r, n) {
          if ((!t || r) && this.isContextual(113)) return;
          super.parseClassId(e, t, r, e.declare ? 1024 : 8331);
          let s = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
          s && (e.typeParameters = s);
         }
         parseClassPropertyAnnotation(e) {
          e.optional || (this.eat(35) ? (e.definite = !0) : this.eat(17) && (e.optional = !0));
          let t = this.tsTryParseTypeAnnotation();
          t && (e.typeAnnotation = t);
         }
         parseClassProperty(e) {
          if ((this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(vt.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29))) {
           let { key: t } = e;
           this.raise(vt.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: 'Identifier' !== t.type || e.computed ? `[${this.input.slice(t.start, t.end)}]` : t.name });
          }
          return super.parseClassProperty(e);
         }
         parseClassPrivateProperty(e) {
          return e.abstract && this.raise(vt.PrivateElementHasAbstract, e), e.accessibility && this.raise(vt.PrivateElementHasAccessibility, e, { modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
         }
         parseClassAccessorProperty(e) {
          return this.parseClassPropertyAnnotation(e), e.optional && this.raise(vt.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e);
         }
         pushClassMethod(e, t, r, n, s, i) {
          let a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          a && s && this.raise(vt.ConstructorHasTypeParameters, a);
          let { declare: o = !1, kind: u } = t;
          o && ('get' === u || 'set' === u) && this.raise(vt.DeclareAccessor, t, { kind: u }), a && (t.typeParameters = a), super.pushClassMethod(e, t, r, n, s, i);
         }
         pushClassPrivateMethod(e, t, r, n) {
          let s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          s && (t.typeParameters = s), super.pushClassPrivateMethod(e, t, r, n);
         }
         declareClassPrivateMethodInScope(e, t) {
          'TSDeclareMethod' !== e.type && (('MethodDefinition' === e.type && !hasOwnProperty.call(e.value, 'body')) || super.declareClassPrivateMethodInScope(e, t));
         }
         parseClassSuper(e) {
          super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause('implements'));
         }
         parseObjPropValue(e, t, r, n, s, i, a) {
          let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          return o && (e.typeParameters = o), super.parseObjPropValue(e, t, r, n, s, i, a);
         }
         parseFunctionParams(e, t) {
          let r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          r && (e.typeParameters = r), super.parseFunctionParams(e, t);
         }
         parseVarId(e, t) {
          super.parseVarId(e, t), 'Identifier' === e.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0);
          let r = this.tsTryParseTypeAnnotation();
          r && ((e.id.typeAnnotation = r), this.resetEndLocation(e.id));
         }
         parseAsyncArrowFromCallExpression(e, t) {
          return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, t);
         }
         parseMaybeAssign(e, t) {
          var r, n, s, i, a;
          let o, u, l;
          if (this.hasPlugin('jsx') && (this.match(142) || this.match(47))) {
           if (((o = this.state.clone()), (u = this.tryParse(() => super.parseMaybeAssign(e, t), o)), !u.error)) return u.node;
           let { context: r } = this.state,
            n = r[r.length - 1];
           (n === E.j_oTag || n === E.j_expr) && r.pop();
          }
          if (!((null != (r = u) && r.error) || this.match(47))) return super.parseMaybeAssign(e, t);
          (!o || o === this.state) && (o = this.state.clone());
          let p,
           c = this.tryParse((r) => {
            var n, s;
            p = this.tsParseTypeParameters(this.tsParseConstModifier);
            let i = super.parseMaybeAssign(e, t);
            return ('ArrowFunctionExpression' !== i.type || (null != (n = i.extra) && n.parenthesized)) && r(), 0 !== (null == (s = p) ? void 0 : s.params.length) && this.resetStartLocationFromNode(i, p), (i.typeParameters = p), i;
           }, o);
          if (!c.error && !c.aborted) return p && this.reportReservedArrowTypeParam(p), c.node;
          if (!u && (bt(!this.hasPlugin('jsx')), (l = this.tryParse(() => super.parseMaybeAssign(e, t), o)), !l.error)) return l.node;
          if (null != (n = u) && n.node) return (this.state = u.failState), u.node;
          if (c.node) return (this.state = c.failState), p && this.reportReservedArrowTypeParam(p), c.node;
          if (null != (s = l) && s.node) return (this.state = l.failState), l.node;
          throw (null == (i = u) ? void 0 : i.error) || c.error || (null == (a = l) ? void 0 : a.error);
         }
         reportReservedArrowTypeParam(e) {
          var t;
          1 === e.params.length && !e.params[0].constraint && (null == (t = e.extra) || !t.trailingComma) && this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') && this.raise(vt.ReservedArrowTypeParam, e);
         }
         parseMaybeUnary(e, t) {
          return !this.hasPlugin('jsx') && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, t);
         }
         parseArrow(e) {
          if (this.match(14)) {
           let t = this.tryParse((e) => {
            let t = this.tsParseTypeOrTypePredicateAnnotation(14);
            return (this.canInsertSemicolon() || !this.match(19)) && e(), t;
           });
           if (t.aborted) return;
           t.thrown || (t.error && (this.state = t.failState), (e.returnType = t.node));
          }
          return super.parseArrow(e);
         }
         parseAssignableListItemTypes(e, t) {
          if (!(2 & t)) return e;
          this.eat(17) && (e.optional = !0);
          let r = this.tsTryParseTypeAnnotation();
          return r && (e.typeAnnotation = r), this.resetEndLocation(e), e;
         }
         isAssignable(e, t) {
          switch (e.type) {
           case 'TSTypeCastExpression':
            return this.isAssignable(e.expression, t);
           case 'TSParameterProperty':
            return !0;
           default:
            return super.isAssignable(e, t);
          }
         }
         toAssignable(e, t = !1) {
          switch (e.type) {
           case 'ParenthesizedExpression':
            this.toAssignableParenthesizedExpression(e, t);
            break;
           case 'TSAsExpression':
           case 'TSSatisfiesExpression':
           case 'TSNonNullExpression':
           case 'TSTypeAssertion':
            t ? this.expressionScope.recordArrowParameterBindingError(vt.UnexpectedTypeCastInParameter, e) : this.raise(vt.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, t);
            break;
           case 'AssignmentExpression':
            !t && 'TSTypeCastExpression' === e.left.type && (e.left = this.typeCastToParameter(e.left));
           default:
            super.toAssignable(e, t);
          }
         }
         toAssignableParenthesizedExpression(e, t) {
          switch (e.expression.type) {
           case 'TSAsExpression':
           case 'TSSatisfiesExpression':
           case 'TSNonNullExpression':
           case 'TSTypeAssertion':
           case 'ParenthesizedExpression':
            this.toAssignable(e.expression, t);
            break;
           default:
            super.toAssignable(e, t);
          }
         }
         checkToRestConversion(e, t) {
          switch (e.type) {
           case 'TSAsExpression':
           case 'TSSatisfiesExpression':
           case 'TSTypeAssertion':
           case 'TSNonNullExpression':
            this.checkToRestConversion(e.expression, !1);
            break;
           default:
            super.checkToRestConversion(e, t);
          }
         }
         isValidLVal(e, t, r) {
          return ((e, t) => hasOwnProperty.call(e, t) && e[t])({ TSTypeCastExpression: !0, TSParameterProperty: 'parameter', TSNonNullExpression: 'expression', TSInstantiationExpression: 'expression', TSAsExpression: (64 !== r || !t) && ['expression', !0], TSSatisfiesExpression: (64 !== r || !t) && ['expression', !0], TSTypeAssertion: (64 !== r || !t) && ['expression', !0] }, e) || super.isValidLVal(e, t, r);
         }
         parseBindingAtom() {
          return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
         }
         parseMaybeDecoratorArguments(e) {
          if (this.match(47) || this.match(51)) {
           let t = this.tsParseTypeArgumentsInExpression();
           if (this.match(10)) {
            let r = super.parseMaybeDecoratorArguments(e);
            return (r.typeParameters = t), r;
           }
           this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(e);
         }
         checkCommaAfterRest(e) {
          return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), !1) : super.checkCommaAfterRest(e);
         }
         isClassMethod() {
          return this.match(47) || super.isClassMethod();
         }
         isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
         }
         parseMaybeDefault(e, t) {
          let r = super.parseMaybeDefault(e, t);
          return 'AssignmentPattern' === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(vt.TypeAnnotationAfterAssign, r.typeAnnotation), r;
         }
         getTokenFromCode(e) {
          if (this.state.inType) {
           if (62 === e) return void this.finishOp(48, 1);
           if (60 === e) return void this.finishOp(47, 1);
          }
          super.getTokenFromCode(e);
         }
         reScan_lt_gt() {
          let { type: e } = this.state;
          47 === e ? ((this.state.pos -= 1), this.readToken_lt()) : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
         }
         reScan_lt() {
          let { type: e } = this.state;
          return 51 === e ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e;
         }
         toAssignableList(e, t, r) {
          for (let n = 0; n < e.length; n++) {
           let t = e[n];
           'TSTypeCastExpression' === (null == t ? void 0 : t.type) && (e[n] = this.typeCastToParameter(t));
          }
          super.toAssignableList(e, t, r);
         }
         typeCastToParameter(e) {
          return (e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
         }
         shouldParseArrow(e) {
          return this.match(14) ? e.every((e) => this.isAssignable(e, !0)) : super.shouldParseArrow(e);
         }
         shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
         }
         canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
         }
         jsxParseOpeningElementAfterName(e) {
          if (this.match(47) || this.match(51)) {
           let t = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
           t && (e.typeParameters = t);
          }
          return super.jsxParseOpeningElementAfterName(e);
         }
         getGetterSetterExpectedParamCount(e) {
          let t = super.getGetterSetterExpectedParamCount(e),
           r = this.getObjectOrClassMethodParams(e)[0];
          return r && this.isThisParam(r) ? t + 1 : t;
         }
         parseCatchClauseParam() {
          let e = super.parseCatchClauseParam(),
           t = this.tsTryParseTypeAnnotation();
          return t && ((e.typeAnnotation = t), this.resetEndLocation(e)), e;
         }
         tsInAmbientContext(e) {
          let t = this.state.isAmbientContext;
          this.state.isAmbientContext = !0;
          try {
           return e();
          } finally {
           this.state.isAmbientContext = t;
          }
         }
         parseClass(e, t, r) {
          let n = this.state.inAbstractClass;
          this.state.inAbstractClass = !!e.abstract;
          try {
           return super.parseClass(e, t, r);
          } finally {
           this.state.inAbstractClass = n;
          }
         }
         tsParseAbstractDeclaration(e, t) {
          if (this.match(80)) return (e.abstract = !0), this.maybeTakeDecorators(t, this.parseClass(e, !0, !1));
          if (this.isContextual(129)) {
           if (!this.hasFollowingLineBreak()) return (e.abstract = !0), this.raise(vt.NonClassMethodPropertyHasAbstractModifer, e), this.tsParseInterfaceDeclaration(e);
          } else this.unexpected(null, 80);
         }
         parseMethod(e, t, r, n, s, i, a) {
          let o = super.parseMethod(e, t, r, n, s, i, a);
          if (o.abstract && (this.hasPlugin('estree') ? o.value.body : o.body)) {
           let { key: e } = o;
           this.raise(vt.AbstractMethodHasImplementation, o, { methodName: 'Identifier' !== e.type || o.computed ? `[${this.input.slice(e.start, e.end)}]` : e.name });
          }
          return o;
         }
         tsParseTypeParameterName() {
          return this.parseIdentifier().name;
         }
         shouldParseAsAmbientContext() {
          return !!this.getPluginOption('typescript', 'dts');
         }
         parse() {
          return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
         }
         getExpression() {
          return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
         }
         parseExportSpecifier(e, t, r, n) {
          return !t && n ? (this.parseTypeOnlyImportExportSpecifier(e, !1, r), this.finishNode(e, 'ExportSpecifier')) : ((e.exportKind = 'value'), super.parseExportSpecifier(e, t, r, n));
         }
         parseImportSpecifier(e, t, r, n, s) {
          return !t && n ? (this.parseTypeOnlyImportExportSpecifier(e, !0, r), this.finishNode(e, 'ImportSpecifier')) : ((e.importKind = 'value'), super.parseImportSpecifier(e, t, r, n, r ? 4098 : 4096));
         }
         parseTypeOnlyImportExportSpecifier(e, t, r) {
          let n,
           s = t ? 'imported' : 'local',
           i = t ? 'local' : 'exported',
           a = e[s],
           o = !1,
           u = !0,
           l = a.loc.start;
          if (this.isContextual(93)) {
           let e = this.parseIdentifier();
           if (this.isContextual(93)) {
            let r = this.parseIdentifier();
            H(this.state.type) ? ((o = !0), (a = e), (n = t ? this.parseIdentifier() : this.parseModuleExportName()), (u = !1)) : ((n = r), (u = !1));
           } else H(this.state.type) ? ((u = !1), (n = t ? this.parseIdentifier() : this.parseModuleExportName())) : ((o = !0), (a = e));
          } else H(this.state.type) && ((o = !0), t ? ((a = this.parseIdentifier(!0)), this.isContextual(93) || this.checkReservedWord(a.name, a.loc.start, !0, !0)) : (a = this.parseModuleExportName()));
          o && r && this.raise(t ? vt.TypeModifierIsUsedInTypeImports : vt.TypeModifierIsUsedInTypeExports, l), (e[s] = a), (e[i] = n), (e[t ? 'importKind' : 'exportKind'] = o ? 'type' : 'value'), u && this.eatContextual(93) && (e[i] = t ? this.parseIdentifier() : this.parseModuleExportName()), e[i] || (e[i] = it(e[s])), t && this.checkIdentifier(e[i], o ? 4098 : 4096);
         }
        },
       v8intrinsic: (e) =>
        class extends e {
         parseV8Intrinsic() {
          if (this.match(54)) {
           let e = this.state.startLoc,
            t = this.startNode();
           if ((this.next(), $(this.state.type))) {
            let e = this.parseIdentifierName(),
             r = this.createIdentifier(t, e);
            if (((r.type = 'V8IntrinsicIdentifier'), this.match(10))) return r;
           }
           this.unexpected(e);
          }
         }
         parseExprAtom(e) {
          return this.parseV8Intrinsic() || super.parseExprAtom(e);
         }
        },
       placeholders: (e) =>
        class extends e {
         parsePlaceholder(e) {
          if (this.match(144)) {
           let t = this.startNode();
           return this.next(), this.assertNoSpace(), (t.name = super.parseIdentifier(!0)), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(t, e);
          }
         }
         finishPlaceholder(e, t) {
          let r = e;
          return (!r.expectedNode || !r.type) && (r = this.finishNode(r, 'Placeholder')), (r.expectedNode = t), r;
         }
         getTokenFromCode(e) {
          37 === e && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(144, 2) : super.getTokenFromCode(e);
         }
         parseExprAtom(e) {
          return this.parsePlaceholder('Expression') || super.parseExprAtom(e);
         }
         parseIdentifier(e) {
          return this.parsePlaceholder('Identifier') || super.parseIdentifier(e);
         }
         checkReservedWord(e, t, r, n) {
          void 0 !== e && super.checkReservedWord(e, t, r, n);
         }
         parseBindingAtom() {
          return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
         }
         isValidLVal(e, t, r) {
          return 'Placeholder' === e || super.isValidLVal(e, t, r);
         }
         toAssignable(e, t) {
          e && 'Placeholder' === e.type && 'Expression' === e.expectedNode ? (e.expectedNode = 'Pattern') : super.toAssignable(e, t);
         }
         chStartsBindingIdentifier(e, t) {
          return !(!super.chStartsBindingIdentifier(e, t) && 144 !== this.lookahead().type);
         }
         verifyBreakContinue(e, t) {
          (e.label && 'Placeholder' === e.label.type) || super.verifyBreakContinue(e, t);
         }
         parseExpressionStatement(e, t) {
          var r;
          if ('Placeholder' !== t.type || (null != (r = t.extra) && r.parenthesized)) return super.parseExpressionStatement(e, t);
          if (this.match(14)) {
           let r = e;
           return (r.label = this.finishPlaceholder(t, 'Identifier')), this.next(), (r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration()), this.finishNode(r, 'LabeledStatement');
          }
          this.semicolon();
          let n = e;
          return (n.name = t.name), this.finishPlaceholder(n, 'Statement');
         }
         parseBlock(e, t, r) {
          return this.parsePlaceholder('BlockStatement') || super.parseBlock(e, t, r);
         }
         parseFunctionId(e) {
          return this.parsePlaceholder('Identifier') || super.parseFunctionId(e);
         }
         parseClass(e, t, r) {
          let n = t ? 'ClassDeclaration' : 'ClassExpression';
          this.next();
          let s = this.state.strict,
           i = this.parsePlaceholder('Identifier');
          if (i) {
           if (!(this.match(81) || this.match(144) || this.match(5))) {
            if (r || !t) return (e.id = null), (e.body = this.finishPlaceholder(i, 'ClassBody')), this.finishNode(e, n);
            throw this.raise(Ft.ClassNameIsRequired, this.state.startLoc);
           }
           e.id = i;
          } else this.parseClassId(e, t, r);
          return super.parseClassSuper(e), (e.body = this.parsePlaceholder('ClassBody') || super.parseClassBody(!!e.superClass, s)), this.finishNode(e, n);
         }
         parseExport(e, t) {
          let r = this.parsePlaceholder('Identifier');
          if (!r) return super.parseExport(e, t);
          let n = e;
          if (!this.isContextual(98) && !this.match(12)) return (n.specifiers = []), (n.source = null), (n.declaration = this.finishPlaceholder(r, 'Declaration')), this.finishNode(n, 'ExportNamedDeclaration');
          this.expectPlugin('exportDefaultFrom');
          let s = this.startNode();
          return (s.exported = r), (n.specifiers = [this.finishNode(s, 'ExportDefaultSpecifier')]), super.parseExport(n, t);
         }
         isExportDefaultSpecifier() {
          if (this.match(65)) {
           let e = this.nextTokenStart();
           if (this.isUnparsedContextual(e, 'from') && this.input.startsWith(K(144), this.nextTokenStartSince(e + 4))) return !0;
          }
          return super.isExportDefaultSpecifier();
         }
         maybeParseExportDefaultSpecifier(e, t) {
          var r;
          return !(null == (r = e.specifiers) || !r.length) || super.maybeParseExportDefaultSpecifier(e, t);
         }
         checkExport(e) {
          let { specifiers: t } = e;
          null != t && t.length && (e.specifiers = t.filter((e) => 'Placeholder' === e.exported.type)), super.checkExport(e), (e.specifiers = t);
         }
         parseImport(e) {
          let t = this.parsePlaceholder('Identifier');
          if (!t) return super.parseImport(e);
          if (((e.specifiers = []), !this.isContextual(98) && !this.match(12))) return (e.source = this.finishPlaceholder(t, 'StringLiteral')), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
          let r = this.startNodeAtNode(t);
          return (r.local = t), e.specifiers.push(this.finishNode(r, 'ImportDefaultSpecifier')), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), (e.source = this.parseImportSource()), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
         }
         parseImportSource() {
          return this.parsePlaceholder('StringLiteral') || super.parseImportSource();
         }
         assertNoSpace() {
          this.state.start > this.state.lastTokEndLoc.index && this.raise(Ft.UnexpectedSpace, this.state.lastTokEndLoc);
         }
        },
      },
      _t = Object.keys(Bt),
      Lt = { sourceType: 'script', sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
     var Ot = class extends xt {
       checkProto(e, t, r, n) {
        if ('SpreadElement' === e.type || this.isObjectMethod(e) || e.computed || e.shorthand) return;
        let s = e.key;
        if ('__proto__' === ('Identifier' === s.type ? s.name : s.value)) {
         if (t) return void this.raise(g.RecordNoProto, s);
         r.used && (n ? null === n.doubleProtoLoc && (n.doubleProtoLoc = s.loc.start) : this.raise(g.DuplicateProto, s)), (r.used = !0);
        }
       }
       shouldExitDescending(e, t) {
        return 'ArrowFunctionExpression' === e.type && e.start === t;
       }
       getExpression() {
        this.enterInitialScopes(), this.nextToken();
        let e = this.parseExpression();
        return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), (e.comments = this.comments), (e.errors = this.state.errors), this.options.tokens && (e.tokens = this.tokens), e;
       }
       parseExpression(e, t) {
        return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
       }
       parseExpressionBase(e) {
        let t = this.state.startLoc,
         r = this.parseMaybeAssign(e);
        if (this.match(12)) {
         let n = this.startNodeAt(t);
         for (n.expressions = [r]; this.eat(12); ) n.expressions.push(this.parseMaybeAssign(e));
         return this.toReferencedList(n.expressions), this.finishNode(n, 'SequenceExpression');
        }
        return r;
       }
       parseMaybeAssignDisallowIn(e, t) {
        return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
       }
       parseMaybeAssignAllowIn(e, t) {
        return this.allowInAnd(() => this.parseMaybeAssign(e, t));
       }
       setOptionalParametersError(e, t) {
        var r;
        e.optionalParametersLoc = null != (r = null == t ? void 0 : t.loc) ? r : this.state.startLoc;
       }
       parseMaybeAssign(e, t) {
        let r,
         n = this.state.startLoc;
        if (this.isContextual(108) && this.prodParam.hasYield) {
         let e = this.parseYield();
         return t && (e = t.call(this, e, n)), e;
        }
        e ? (r = !1) : ((e = new rt()), (r = !0));
        let { type: s } = this.state;
        (10 === s || $(s)) && (this.state.potentialArrowAt = this.state.start);
        let i = this.parseMaybeConditional(e);
        if ((t && (i = t.call(this, i, n)), (a = this.state.type) >= 29 && a <= 33)) {
         let t = this.startNodeAt(n),
          r = this.state.value;
         if (((t.operator = r), this.match(29))) {
          this.toAssignable(i, !0), (t.left = i);
          let r = n.index;
          null != e.doubleProtoLoc && e.doubleProtoLoc.index >= r && (e.doubleProtoLoc = null), null != e.shorthandAssignLoc && e.shorthandAssignLoc.index >= r && (e.shorthandAssignLoc = null), null != e.privateKeyLoc && e.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e), (e.privateKeyLoc = null));
         } else t.left = i;
         return this.next(), (t.right = this.parseMaybeAssign()), this.checkLVal(i, { in: this.finishNode(t, 'AssignmentExpression') }), t;
        }
        var a;
        return r && this.checkExpressionErrors(e, !0), i;
       }
       parseMaybeConditional(e) {
        let t = this.state.startLoc,
         r = this.state.potentialArrowAt,
         n = this.parseExprOps(e);
        return this.shouldExitDescending(n, r) ? n : this.parseConditional(n, t, e);
       }
       parseConditional(e, t, r) {
        if (this.eat(17)) {
         let r = this.startNodeAt(t);
         return (r.test = e), (r.consequent = this.parseMaybeAssignAllowIn()), this.expect(14), (r.alternate = this.parseMaybeAssign()), this.finishNode(r, 'ConditionalExpression');
        }
        return e;
       }
       parseMaybeUnaryOrPrivate(e) {
        return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
       }
       parseExprOps(e) {
        let t = this.state.startLoc,
         r = this.state.potentialArrowAt,
         n = this.parseMaybeUnaryOrPrivate(e);
        return this.shouldExitDescending(n, r) ? n : this.parseExprOp(n, t, -1);
       }
       parseExprOp(e, t, r) {
        if (this.isPrivateName(e)) {
         let t = this.getPrivateNameSV(e);
         (r >= G(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(g.PrivateInExpectedIn, e, { identifierName: t }), this.classScope.usePrivateName(t, e.loc.start);
        }
        let n = this.state.type;
        if ((s = n) >= 39 && s <= 59 && (this.prodParam.hasIn || !this.match(58))) {
         let s = G(n);
         if (s > r) {
          if (39 === n) {
           if ((this.expectPlugin('pipelineOperator'), this.state.inFSharpPipelineDirectBody)) return e;
           this.checkPipelineAtInfixOperator(e, t);
          }
          let i = this.startNodeAt(t);
          (i.left = e), (i.operator = this.state.value);
          let a = 41 === n || 42 === n,
           o = 40 === n;
          if ((o && (s = G(42)), this.next(), 39 === n && this.hasPlugin(['pipelineOperator', { proposal: 'minimal' }]) && 96 === this.state.type && this.prodParam.hasAwait)) throw this.raise(g.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          i.right = this.parseExprOpRightExpr(n, s);
          let u = this.finishNode(i, a || o ? 'LogicalExpression' : 'BinaryExpression'),
           l = this.state.type;
          if ((o && (41 === l || 42 === l)) || (a && 40 === l)) throw this.raise(g.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(u, t, r);
         }
        }
        var s;
        return e;
       }
       parseExprOpRightExpr(e, t) {
        let r = this.state.startLoc;
        if (39 === e)
         switch (this.getPluginOption('pipelineOperator', 'proposal')) {
          case 'hack':
           return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case 'smart':
           return this.withTopicBindingContext(() => {
            if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(g.PipeBodyIsTighter, this.state.startLoc);
            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), r);
           });
          case 'fsharp':
           return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
         }
        return this.parseExprOpBaseRightExpr(e, t);
       }
       parseExprOpBaseRightExpr(e, t) {
        let r = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, 57 === e ? t - 1 : t);
       }
       parseHackPipeBody() {
        var e;
        let { startLoc: t } = this.state,
         r = this.parseMaybeAssign();
        return p.has(r.type) && !(null != (e = r.extra) && e.parenthesized) && this.raise(g.PipeUnparenthesizedBody, t, { type: r.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipeTopicUnused, t), r;
       }
       checkExponentialAfterUnary(e) {
        this.match(57) && this.raise(g.UnexpectedTokenUnaryExponentiation, e.argument);
       }
       parseMaybeUnary(e, t) {
        let r = this.state.startLoc,
         n = this.isContextual(96);
        if (n && this.isAwaitAllowed()) {
         this.next();
         let e = this.parseAwait(r);
         return t || this.checkExponentialAfterUnary(e), e;
        }
        let s = this.match(34),
         i = this.startNode();
        if (((a = this.state.type), j[a])) {
         (i.operator = this.state.value), (i.prefix = !0), this.match(72) && this.expectPlugin('throwExpressions');
         let r = this.match(89);
         if ((this.next(), (i.argument = this.parseMaybeUnary(null, !0)), this.checkExpressionErrors(e, !0), this.state.strict && r)) {
          let e = i.argument;
          'Identifier' === e.type ? this.raise(g.StrictDelete, i) : this.hasPropertyAsPrivateName(e) && this.raise(g.DeletePrivateField, i);
         }
         if (!s) return t || this.checkExponentialAfterUnary(i), this.finishNode(i, 'UnaryExpression');
        }
        var a;
        let o = this.parseUpdate(i, s, e);
        if (n) {
         let { type: e } = this.state;
         if ((this.hasPlugin('v8intrinsic') ? V(e) : V(e) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(g.AwaitNotInAsyncContext, r), this.parseAwait(r);
        }
        return o;
       }
       parseUpdate(e, t, r) {
        if (t) {
         let t = e;
         return this.checkLVal(t.argument, { in: this.finishNode(t, 'UpdateExpression') }), e;
        }
        let n = this.state.startLoc,
         s = this.parseExprSubscripts(r);
        if (this.checkExpressionErrors(r, !1)) return s;
        for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
         let e = this.startNodeAt(n);
         (e.operator = this.state.value), (e.prefix = !1), (e.argument = s), this.next(), this.checkLVal(s, { in: (s = this.finishNode(e, 'UpdateExpression')) });
        }
        return s;
       }
       parseExprSubscripts(e) {
        let t = this.state.startLoc,
         r = this.state.potentialArrowAt,
         n = this.parseExprAtom(e);
        return this.shouldExitDescending(n, r) ? n : this.parseSubscripts(n, t);
       }
       parseSubscripts(e, t, r) {
        let n = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(e), stop: !1 };
        do {
         (e = this.parseSubscript(e, t, r, n)), (n.maybeAsyncArrow = !1);
        } while (!n.stop);
        return e;
       }
       parseSubscript(e, t, r, n) {
        let { type: s } = this.state;
        if (!r && 15 === s) return this.parseBind(e, t, r, n);
        if (X(s)) return this.parseTaggedTemplateExpression(e, t, n);
        let i = !1;
        if (18 === s) {
         if (r && (this.raise(g.OptionalChainingNoNew, this.state.startLoc), 40 === this.lookaheadCharCode())) return (n.stop = !0), e;
         (n.optionalChainMember = i = !0), this.next();
        }
        if (!r && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e, t, n, i);
        {
         let r = this.eat(0);
         return r || i || this.eat(16) ? this.parseMember(e, t, n, r, i) : ((n.stop = !0), e);
        }
       }
       parseMember(e, t, r, n, s) {
        let i = this.startNodeAt(t);
        return (i.object = e), (i.computed = n), n ? ((i.property = this.parseExpression()), this.expect(3)) : this.match(138) ? ('Super' === e.type && this.raise(g.SuperPrivateField, t), this.classScope.usePrivateName(this.state.value, this.state.startLoc), (i.property = this.parsePrivateName())) : (i.property = this.parseIdentifier(!0)), r.optionalChainMember ? ((i.optional = s), this.finishNode(i, 'OptionalMemberExpression')) : this.finishNode(i, 'MemberExpression');
       }
       parseBind(e, t, r, n) {
        let s = this.startNodeAt(t);
        return (s.object = e), this.next(), (s.callee = this.parseNoCallExpr()), (n.stop = !0), this.parseSubscripts(this.finishNode(s, 'BindExpression'), t, r);
       }
       parseCoverCallAndAsyncArrowHead(e, t, r, n) {
        let s = this.state.maybeInArrowParameters,
         i = null;
        (this.state.maybeInArrowParameters = !0), this.next();
        let a = this.startNodeAt(t);
        a.callee = e;
        let { maybeAsyncArrow: o, optionalChainMember: u } = r;
        o && (this.expressionScope.enter(new Xe(2)), (i = new rt())), u && (a.optional = n), (a.arguments = n ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, 'Import' === e.type, 'Super' !== e.type, a, i));
        let l = this.finishCallExpression(a, u);
        return o && this.shouldParseAsyncArrow() && !n ? ((r.stop = !0), this.checkDestructuringPrivate(i), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), (l = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), l))) : (o && (this.checkExpressionErrors(i, !0), this.expressionScope.exit()), this.toReferencedArguments(l)), (this.state.maybeInArrowParameters = s), l;
       }
       toReferencedArguments(e, t) {
        this.toReferencedListDeep(e.arguments, t);
       }
       parseTaggedTemplateExpression(e, t, r) {
        let n = this.startNodeAt(t);
        return (n.tag = e), (n.quasi = this.parseTemplate(!0)), r.optionalChainMember && this.raise(g.OptionalChainingNoTemplate, t), this.finishNode(n, 'TaggedTemplateExpression');
       }
       atPossibleAsyncArrow(e) {
        return 'Identifier' === e.type && 'async' === e.name && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start == 5 && e.start === this.state.potentialArrowAt;
       }
       expectImportAttributesPlugin() {
        this.hasPlugin('importAssertions') || this.expectPlugin('importAttributes');
       }
       finishCallExpression(e, t) {
        if ('Import' === e.callee.type)
         if ((2 === e.arguments.length && (this.hasPlugin('moduleAttributes') || this.expectImportAttributesPlugin()), 0 === e.arguments.length || e.arguments.length > 2)) this.raise(g.ImportCallArity, e, { maxArgumentCount: this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions') || this.hasPlugin('moduleAttributes') ? 2 : 1 });
         else for (let r of e.arguments) 'SpreadElement' === r.type && this.raise(g.ImportCallSpreadArgument, r);
        return this.finishNode(e, t ? 'OptionalCallExpression' : 'CallExpression');
       }
       parseCallExpressionArguments(e, t, r, n, s) {
        let i = [],
         a = !0,
         o = this.state.inFSharpPipelineDirectBody;
        for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
         if (a) a = !1;
         else if ((this.expect(12), this.match(e))) {
          t && !this.hasPlugin('importAttributes') && !this.hasPlugin('importAssertions') && !this.hasPlugin('moduleAttributes') && this.raise(g.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
         }
         i.push(this.parseExprListItem(!1, s, r));
        }
        return (this.state.inFSharpPipelineDirectBody = o), i;
       }
       shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
       }
       parseAsyncArrowFromCallExpression(e, t) {
        var r;
        return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, !0, null == (r = t.extra) ? void 0 : r.trailingCommaLoc), t.innerComments && Ce(e, t.innerComments), t.callee.trailingComments && Ce(e, t.callee.trailingComments), e;
       }
       parseNoCallExpr() {
        let e = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), e, !0);
       }
       parseExprAtom(e) {
        let t,
         r = null,
         { type: n } = this.state;
        switch (n) {
         case 79:
          return this.parseSuper();
         case 83:
          return (t = this.startNode()), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : this.match(10) ? (this.options.createImportExpressions ? this.parseImportCall(t) : this.finishNode(t, 'Import')) : (this.raise(g.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t, 'Import'));
         case 78:
          return (t = this.startNode()), this.next(), this.finishNode(t, 'ThisExpression');
         case 90:
          return this.parseDo(this.startNode(), !1);
         case 56:
         case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
         case 134:
          return this.parseNumericLiteral(this.state.value);
         case 135:
          return this.parseBigIntLiteral(this.state.value);
         case 136:
          return this.parseDecimalLiteral(this.state.value);
         case 133:
          return this.parseStringLiteral(this.state.value);
         case 84:
          return this.parseNullLiteral();
         case 85:
          return this.parseBooleanLiteral(!0);
         case 86:
          return this.parseBooleanLiteral(!1);
         case 10: {
          let e = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(e);
         }
         case 2:
         case 1:
          return this.parseArrayLike(2 === this.state.type ? 4 : 3, !1, !0);
         case 0:
          return this.parseArrayLike(3, !0, !1, e);
         case 6:
         case 7:
          return this.parseObjectLike(6 === this.state.type ? 9 : 8, !1, !0);
         case 5:
          return this.parseObjectLike(8, !1, !1, e);
         case 68:
          return this.parseFunctionOrFunctionSent();
         case 26:
          r = this.parseDecorators();
         case 80:
          return this.parseClass(this.maybeTakeDecorators(r, this.startNode()), !1);
         case 77:
          return this.parseNewOrNewTarget();
         case 25:
         case 24:
          return this.parseTemplate(!1);
         case 15: {
          (t = this.startNode()), this.next(), (t.object = null);
          let e = (t.callee = this.parseNoCallExpr());
          if ('MemberExpression' === e.type) return this.finishNode(t, 'BindExpression');
          throw this.raise(g.UnsupportedBind, e);
         }
         case 138:
          return this.raise(g.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
         case 33:
          return this.parseTopicReferenceThenEqualsSign(54, '%');
         case 32:
          return this.parseTopicReferenceThenEqualsSign(44, '^');
         case 37:
         case 38:
          return this.parseTopicReference('hack');
         case 44:
         case 54:
         case 27: {
          let e = this.getPluginOption('pipelineOperator', 'proposal');
          if (e) return this.parseTopicReference(e);
          this.unexpected();
          break;
         }
         case 47: {
          let e = this.input.codePointAt(this.nextTokenStart());
          ie(e) || 62 === e ? this.expectOnePlugin(['jsx', 'flow', 'typescript']) : this.unexpected();
          break;
         }
         default:
          if ($(n)) {
           if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
           let e = this.state.potentialArrowAt === this.state.start,
            t = this.state.containsEsc,
            r = this.parseIdentifier();
           if (!t && 'async' === r.name && !this.canInsertSemicolon()) {
            let { type: e } = this.state;
            if (68 === e) return this.resetPreviousNodeTrailingComments(r), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r));
            if ($(e)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r)) : r;
            if (90 === e) return this.resetPreviousNodeTrailingComments(r), this.parseDo(this.startNodeAtNode(r), !0);
           }
           return e && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r), [r], !1)) : r;
          }
          this.unexpected();
        }
       }
       parseTopicReferenceThenEqualsSign(e, t) {
        let r = this.getPluginOption('pipelineOperator', 'proposal');
        if (r) return (this.state.type = e), (this.state.value = t), this.state.pos--, this.state.end--, (this.state.endLoc = s(this.state.endLoc, -1)), this.parseTopicReference(r);
        this.unexpected();
       }
       parseTopicReference(e) {
        let t = this.startNode(),
         r = this.state.startLoc,
         n = this.state.type;
        return this.next(), this.finishTopicReference(t, r, e, n);
       }
       finishTopicReference(e, t, r, n) {
        if (this.testTopicReferenceConfiguration(r, t, n)) {
         let n = 'smart' === r ? 'PipelinePrimaryTopicReference' : 'TopicReference';
         return this.topicReferenceIsAllowedInCurrentContext() || this.raise('smart' === r ? g.PrimaryTopicNotAllowed : g.PipeTopicUnbound, t), this.registerTopicReference(), this.finishNode(e, n);
        }
        throw this.raise(g.PipeTopicUnconfiguredToken, t, { token: K(n) });
       }
       testTopicReferenceConfiguration(e, t, r) {
        switch (e) {
         case 'hack':
          return this.hasPlugin(['pipelineOperator', { topicToken: K(r) }]);
         case 'smart':
          return 27 === r;
         default:
          throw this.raise(g.PipeTopicRequiresHackPipes, t);
        }
       }
       parseAsyncArrowUnaryFunction(e) {
        this.prodParam.enter(et(!0, this.prodParam.hasYield));
        let t = [this.parseIdentifier()];
        return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(g.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e, t, !0);
       }
       parseDo(e, t) {
        this.expectPlugin('doExpressions'), t && this.expectPlugin('asyncDoExpressions'), (e.async = t), this.next();
        let r = this.state.labels;
        return (this.state.labels = []), t ? (this.prodParam.enter(2), (e.body = this.parseBlock()), this.prodParam.exit()) : (e.body = this.parseBlock()), (this.state.labels = r), this.finishNode(e, 'DoExpression');
       }
       parseSuper() {
        let e = this.startNode();
        return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(g.UnexpectedSuper, e) : this.raise(g.SuperNotAllowed, e), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(g.UnsupportedSuper, e), this.finishNode(e, 'Super');
       }
       parsePrivateName() {
        let e = this.startNode(),
         t = this.startNodeAt(s(this.state.startLoc, 1)),
         r = this.state.value;
        return this.next(), (e.id = this.createIdentifier(t, r)), this.finishNode(e, 'PrivateName');
       }
       parseFunctionOrFunctionSent() {
        let e = this.startNode();
        if ((this.next(), this.prodParam.hasYield && this.match(16))) {
         let t = this.createIdentifier(this.startNodeAtNode(e), 'function');
         return this.next(), this.match(103) ? this.expectPlugin('functionSent') : this.hasPlugin('functionSent') || this.unexpected(), this.parseMetaProperty(e, t, 'sent');
        }
        return this.parseFunction(e);
       }
       parseMetaProperty(e, t, r) {
        e.meta = t;
        let n = this.state.containsEsc;
        return (e.property = this.parseIdentifier(!0)), (e.property.name !== r || n) && this.raise(g.UnsupportedMetaProperty, e.property, { target: t.name, onlyValidPropertyName: r }), this.finishNode(e, 'MetaProperty');
       }
       parseImportMetaProperty(e) {
        let t = this.createIdentifier(this.startNodeAtNode(e), 'import');
        if ((this.next(), this.isContextual(101))) this.inModule || this.raise(g.ImportMetaOutsideModule, t), (this.sawUnambiguousESM = !0);
        else if (this.isContextual(105) || this.isContextual(97)) {
         let t = this.isContextual(105);
         if ((t || this.unexpected(), this.expectPlugin(t ? 'sourcePhaseImports' : 'deferredImportEvaluation'), !this.options.createImportExpressions)) throw this.raise(g.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
         return this.next(), (e.phase = t ? 'source' : 'defer'), this.parseImportCall(e);
        }
        return this.parseMetaProperty(e, t, 'meta');
       }
       parseLiteralAtNode(e, t, r) {
        return this.addExtra(r, 'rawValue', e), this.addExtra(r, 'raw', this.input.slice(r.start, this.state.end)), (r.value = e), this.next(), this.finishNode(r, t);
       }
       parseLiteral(e, t) {
        let r = this.startNode();
        return this.parseLiteralAtNode(e, t, r);
       }
       parseStringLiteral(e) {
        return this.parseLiteral(e, 'StringLiteral');
       }
       parseNumericLiteral(e) {
        return this.parseLiteral(e, 'NumericLiteral');
       }
       parseBigIntLiteral(e) {
        return this.parseLiteral(e, 'BigIntLiteral');
       }
       parseDecimalLiteral(e) {
        return this.parseLiteral(e, 'DecimalLiteral');
       }
       parseRegExpLiteral(e) {
        let t = this.parseLiteral(e.value, 'RegExpLiteral');
        return (t.pattern = e.pattern), (t.flags = e.flags), t;
       }
       parseBooleanLiteral(e) {
        let t = this.startNode();
        return (t.value = e), this.next(), this.finishNode(t, 'BooleanLiteral');
       }
       parseNullLiteral() {
        let e = this.startNode();
        return this.next(), this.finishNode(e, 'NullLiteral');
       }
       parseParenAndDistinguishExpression(e) {
        let t,
         r = this.state.startLoc;
        this.next(), this.expressionScope.enter(new Xe(1));
        let n = this.state.maybeInArrowParameters,
         s = this.state.inFSharpPipelineDirectBody;
        (this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1);
        let i,
         a,
         o = this.state.startLoc,
         u = [],
         l = new rt(),
         p = !0;
        for (; !this.match(11); ) {
         if (p) p = !1;
         else if ((this.expect(12, null === l.optionalParametersLoc ? null : l.optionalParametersLoc), this.match(11))) {
          a = this.state.startLoc;
          break;
         }
         if (this.match(21)) {
          let e = this.state.startLoc;
          if (((i = this.state.startLoc), u.push(this.parseParenItem(this.parseRestBinding(), e)), !this.checkCommaAfterRest(41))) break;
         } else u.push(this.parseMaybeAssignAllowIn(l, this.parseParenItem));
        }
        let c = this.state.lastTokEndLoc;
        this.expect(11), (this.state.maybeInArrowParameters = n), (this.state.inFSharpPipelineDirectBody = s);
        let h = this.startNodeAt(r);
        return e && this.shouldParseArrow(u) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, u, !1), h) : (this.expressionScope.exit(), u.length || this.unexpected(this.state.lastTokStartLoc), a && this.unexpected(a), i && this.unexpected(i), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(u, !0), u.length > 1 ? ((t = this.startNodeAt(o)), (t.expressions = u), this.finishNode(t, 'SequenceExpression'), this.resetEndLocation(t, c)) : (t = u[0]), this.wrapParenthesis(r, t));
       }
       wrapParenthesis(e, t) {
        if (!this.options.createParenthesizedExpressions) return this.addExtra(t, 'parenthesized', !0), this.addExtra(t, 'parenStart', e.index), this.takeSurroundingComments(t, e.index, this.state.lastTokEndLoc.index), t;
        let r = this.startNodeAt(e);
        return (r.expression = t), this.finishNode(r, 'ParenthesizedExpression');
       }
       shouldParseArrow(e) {
        return !this.canInsertSemicolon();
       }
       parseArrow(e) {
        if (this.eat(19)) return e;
       }
       parseParenItem(e, t) {
        return e;
       }
       parseNewOrNewTarget() {
        let e = this.startNode();
        if ((this.next(), this.match(16))) {
         let t = this.createIdentifier(this.startNodeAtNode(e), 'new');
         this.next();
         let r = this.parseMetaProperty(e, t, 'target');
         return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(g.UnexpectedNewTarget, r), r;
        }
        return this.parseNew(e);
       }
       parseNew(e) {
        if ((this.parseNewCallee(e), this.eat(10))) {
         let t = this.parseExprList(11);
         this.toReferencedList(t), (e.arguments = t);
        } else e.arguments = [];
        return this.finishNode(e, 'NewExpression');
       }
       parseNewCallee(e) {
        let t = this.match(83),
         r = this.parseNoCallExpr();
        (e.callee = r), t && ('Import' === r.type || 'ImportExpression' === r.type) && this.raise(g.ImportCallNotNewExpression, r);
       }
       parseTemplateElement(e) {
        let { start: t, startLoc: r, end: n, value: i } = this.state,
         a = t + 1,
         o = this.startNodeAt(s(r, 1));
        null === i && (e || this.raise(g.InvalidEscapeSequenceTemplate, s(this.state.firstInvalidTemplateEscapePos, 1)));
        let u = this.match(24),
         l = u ? -1 : -2,
         p = n + l;
        (o.value = { raw: this.input.slice(a, p).replace(/\r\n?/g, '\n'), cooked: null === i ? null : i.slice(1, l) }), (o.tail = u), this.next();
        let c = this.finishNode(o, 'TemplateElement');
        return this.resetEndLocation(c, s(this.state.lastTokEndLoc, l)), c;
       }
       parseTemplate(e) {
        let t = this.startNode(),
         r = this.parseTemplateElement(e),
         n = [r],
         s = [];
        for (; !r.tail; ) s.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), n.push((r = this.parseTemplateElement(e)));
        return (t.expressions = s), (t.quasis = n), this.finishNode(t, 'TemplateLiteral');
       }
       parseTemplateSubstitution() {
        return this.parseExpression();
       }
       parseObjectLike(e, t, r, n) {
        r && this.expectPlugin('recordAndTuple');
        let s = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !1;
        let i = Object.create(null),
         a = !0,
         o = this.startNode();
        for (o.properties = [], this.next(); !this.match(e); ) {
         if (a) a = !1;
         else if ((this.expect(12), this.match(e))) {
          this.addTrailingCommaExtraToNode(o);
          break;
         }
         let s;
         t ? (s = this.parseBindingProperty()) : ((s = this.parsePropertyDefinition(n)), this.checkProto(s, r, i, n)), r && !this.isObjectProperty(s) && 'SpreadElement' !== s.type && this.raise(g.InvalidRecordProperty, s), s.shorthand && this.addExtra(s, 'shorthand', !0), o.properties.push(s);
        }
        this.next(), (this.state.inFSharpPipelineDirectBody = s);
        let u = 'ObjectExpression';
        return t ? (u = 'ObjectPattern') : r && (u = 'RecordExpression'), this.finishNode(o, u);
       }
       addTrailingCommaExtraToNode(e) {
        this.addExtra(e, 'trailingComma', this.state.lastTokStartLoc.index), this.addExtra(e, 'trailingCommaLoc', this.state.lastTokStartLoc, !1);
       }
       maybeAsyncOrAccessorProp(e) {
        return !e.computed && 'Identifier' === e.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
       }
       parsePropertyDefinition(e) {
        let t = [];
        if (this.match(26)) for (this.hasPlugin('decorators') && this.raise(g.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) t.push(this.parseDecorator());
        let r,
         n = this.startNode(),
         s = !1,
         i = !1;
        if (this.match(21)) return t.length && this.unexpected(), this.parseSpread();
        t.length && ((n.decorators = t), (t = [])), (n.method = !1), e && (r = this.state.startLoc);
        let a = this.eat(55);
        this.parsePropertyNamePrefixOperator(n);
        let o = this.state.containsEsc;
        if ((this.parsePropertyName(n, e), !a && !o && this.maybeAsyncOrAccessorProp(n))) {
         let { key: e } = n,
          t = e.name;
         'async' === t && !this.hasPrecedingLineBreak() && ((s = !0), this.resetPreviousNodeTrailingComments(e), (a = this.eat(55)), this.parsePropertyName(n)), ('get' === t || 'set' === t) && ((i = !0), this.resetPreviousNodeTrailingComments(e), (n.kind = t), this.match(55) && ((a = !0), this.raise(g.AccessorIsGenerator, this.state.curPosition(), { kind: t }), this.next()), this.parsePropertyName(n));
        }
        return this.parseObjPropValue(n, r, a, s, !1, i, e);
       }
       getGetterSetterExpectedParamCount(e) {
        return 'get' === e.kind ? 0 : 1;
       }
       getObjectOrClassMethodParams(e) {
        return e.params;
       }
       checkGetterSetterParams(e) {
        var t;
        let r = this.getGetterSetterExpectedParamCount(e),
         n = this.getObjectOrClassMethodParams(e);
        n.length !== r && this.raise('get' === e.kind ? g.BadGetterArity : g.BadSetterArity, e), 'set' === e.kind && 'RestElement' === (null == (t = n[n.length - 1]) ? void 0 : t.type) && this.raise(g.BadSetterRestParameter, e);
       }
       parseObjectMethod(e, t, r, n, s) {
        if (s) {
         let r = this.parseMethod(e, t, !1, !1, !1, 'ObjectMethod');
         return this.checkGetterSetterParams(r), r;
        }
        if (r || t || this.match(10)) return n && this.unexpected(), (e.kind = 'method'), (e.method = !0), this.parseMethod(e, t, r, !1, !1, 'ObjectMethod');
       }
       parseObjectProperty(e, t, r, n) {
        if (((e.shorthand = !1), this.eat(14))) return (e.value = r ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n)), this.finishNode(e, 'ObjectProperty');
        if (!e.computed && 'Identifier' === e.key.type) {
         if ((this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), r)) e.value = this.parseMaybeDefault(t, it(e.key));
         else if (this.match(29)) {
          let r = this.state.startLoc;
          null != n ? null === n.shorthandAssignLoc && (n.shorthandAssignLoc = r) : this.raise(g.InvalidCoverInitializedName, r), (e.value = this.parseMaybeDefault(t, it(e.key)));
         } else e.value = it(e.key);
         return (e.shorthand = !0), this.finishNode(e, 'ObjectProperty');
        }
       }
       parseObjPropValue(e, t, r, n, s, i, a) {
        let o = this.parseObjectMethod(e, r, n, s, i) || this.parseObjectProperty(e, t, s, a);
        return o || this.unexpected(), o;
       }
       parsePropertyName(e, t) {
        if (this.eat(0)) (e.computed = !0), (e.key = this.parseMaybeAssignAllowIn()), this.expect(3);
        else {
         let r,
          { type: n, value: s } = this.state;
         if (H(n)) r = this.parseIdentifier(!0);
         else
          switch (n) {
           case 134:
            r = this.parseNumericLiteral(s);
            break;
           case 133:
            r = this.parseStringLiteral(s);
            break;
           case 135:
            r = this.parseBigIntLiteral(s);
            break;
           case 136:
            r = this.parseDecimalLiteral(s);
            break;
           case 138: {
            let e = this.state.startLoc;
            null != t ? null === t.privateKeyLoc && (t.privateKeyLoc = e) : this.raise(g.UnexpectedPrivateField, e), (r = this.parsePrivateName());
            break;
           }
           default:
            this.unexpected();
          }
         (e.key = r), 138 !== n && (e.computed = !1);
        }
       }
       initFunction(e, t) {
        (e.id = null), (e.generator = !1), (e.async = t);
       }
       parseMethod(e, t, r, n, s, i, a = !1) {
        this.initFunction(e, r), (e.generator = t), this.scope.enter(18 | (a ? 64 : 0) | (s ? 32 : 0)), this.prodParam.enter(et(r, e.generator)), this.parseFunctionParams(e, n);
        let o = this.parseFunctionBodyAndFinish(e, i, !0);
        return this.prodParam.exit(), this.scope.exit(), o;
       }
       parseArrayLike(e, t, r, n) {
        r && this.expectPlugin('recordAndTuple');
        let s = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !1;
        let i = this.startNode();
        return this.next(), (i.elements = this.parseExprList(e, !r, n, i)), (this.state.inFSharpPipelineDirectBody = s), this.finishNode(i, r ? 'TupleExpression' : 'ArrayExpression');
       }
       parseArrowExpression(e, t, r, n) {
        this.scope.enter(6);
        let s = et(r, !1);
        !this.match(5) && this.prodParam.hasIn && (s |= 8), this.prodParam.enter(s), this.initFunction(e, r);
        let i = this.state.maybeInArrowParameters;
        return t && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(e, t, n)), (this.state.maybeInArrowParameters = !1), this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), (this.state.maybeInArrowParameters = i), this.finishNode(e, 'ArrowFunctionExpression');
       }
       setArrowFunctionParameters(e, t, r) {
        this.toAssignableList(t, r, !1), (e.params = t);
       }
       parseFunctionBodyAndFinish(e, t, r = !1) {
        return this.parseFunctionBody(e, !1, r), this.finishNode(e, t);
       }
       parseFunctionBody(e, t, r = !1) {
        let n = t && !this.match(5);
        if ((this.expressionScope.enter(Qe()), n)) (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, t, !1);
        else {
         let n = this.state.strict,
          s = this.state.labels;
         (this.state.labels = []),
          this.prodParam.enter(4 | this.prodParam.currentFlags()),
          (e.body = this.parseBlock(!0, !1, (s) => {
           let i = !this.isSimpleParamList(e.params);
           s && i && this.raise(g.IllegalLanguageModeDirective, ('method' !== e.kind && 'constructor' !== e.kind) || !e.key ? e : e.key.loc.end);
           let a = !n && this.state.strict;
           this.checkParams(e, !(this.state.strict || t || r || i), t, a), this.state.strict && e.id && this.checkIdentifier(e.id, 65, a);
          })),
          this.prodParam.exit(),
          (this.state.labels = s);
        }
        this.expressionScope.exit();
       }
       isSimpleParameter(e) {
        return 'Identifier' === e.type;
       }
       isSimpleParamList(e) {
        for (let t = 0, r = e.length; t < r; t++) if (!this.isSimpleParameter(e[t])) return !1;
        return !0;
       }
       checkParams(e, t, r, n = !0) {
        let s = !t && new Set(),
         i = { type: 'FormalParameters' };
        for (let a of e.params) this.checkLVal(a, { in: i, binding: 5, checkClashes: s, strictModeChanged: n });
       }
       parseExprList(e, t, r, n) {
        let s = [],
         i = !0;
        for (; !this.eat(e); ) {
         if (i) i = !1;
         else if ((this.expect(12), this.match(e))) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
         }
         s.push(this.parseExprListItem(t, r));
        }
        return s;
       }
       parseExprListItem(e, t, r) {
        let n;
        if (this.match(12)) e || this.raise(g.UnexpectedToken, this.state.curPosition(), { unexpected: ',' }), (n = null);
        else if (this.match(21)) {
         let e = this.state.startLoc;
         n = this.parseParenItem(this.parseSpread(t), e);
        } else if (this.match(17)) {
         this.expectPlugin('partialApplication'), r || this.raise(g.UnexpectedArgumentPlaceholder, this.state.startLoc);
         let e = this.startNode();
         this.next(), (n = this.finishNode(e, 'ArgumentPlaceholder'));
        } else n = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
        return n;
       }
       parseIdentifier(e) {
        let t = this.startNode(),
         r = this.parseIdentifierName(e);
        return this.createIdentifier(t, r);
       }
       createIdentifier(e, t) {
        return (e.name = t), (e.loc.identifierName = t), this.finishNode(e, 'Identifier');
       }
       parseIdentifierName(e) {
        let t,
         { startLoc: r, type: n } = this.state;
        H(n) ? (t = this.state.value) : this.unexpected();
        let s = n <= 92;
        return e ? s && this.replaceToken(132) : this.checkReservedWord(t, r, s, !1), this.next(), t;
       }
       checkReservedWord(e, t, r, n) {
        var s;
        if (!(e.length > 10) && ((s = e), ye.has(s)))
         if (
          r &&
          (function (e) {
           return le.has(e);
          })(e)
         )
          this.raise(g.UnexpectedKeyword, t, { keyword: e });
         else if ((this.state.strict ? (n ? me : de) : he)(e, this.inModule)) this.raise(g.UnexpectedReservedWord, t, { reservedWord: e });
         else if ('yield' === e) {
          if (this.prodParam.hasYield) return void this.raise(g.YieldBindingIdentifier, t);
         } else if ('await' === e) {
          if (this.prodParam.hasAwait) return void this.raise(g.AwaitBindingIdentifier, t);
          if (this.scope.inStaticBlock) return void this.raise(g.AwaitBindingIdentifierInStaticBlock, t);
          this.expressionScope.recordAsyncArrowParametersError(t);
         } else if ('arguments' === e && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(g.ArgumentsInClass, t);
       }
       isAwaitAllowed() {
        return !!(this.prodParam.hasAwait || (this.options.allowAwaitOutsideFunction && !this.scope.inFunction));
       }
       parseAwait(e) {
        let t = this.startNodeAt(e);
        return this.expressionScope.recordParameterInitializerError(g.AwaitExpressionFormalParameter, t), this.eat(55) && this.raise(g.ObsoleteAwaitStar, t), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)), this.state.soloAwait || (t.argument = this.parseMaybeUnary(null, !0)), this.finishNode(t, 'AwaitExpression');
       }
       isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak()) return !0;
        let { type: e } = this.state;
        return 53 === e || 10 === e || 0 === e || X(e) || (102 === e && !this.state.containsEsc) || 137 === e || 56 === e || (this.hasPlugin('v8intrinsic') && 54 === e);
       }
       parseYield() {
        let e = this.startNode();
        this.expressionScope.recordParameterInitializerError(g.YieldInParameter, e), this.next();
        let t = !1,
         r = null;
        if (!this.hasPrecedingLineBreak())
         switch (((t = this.eat(55)), this.state.type)) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
           if (!t) break;
          default:
           r = this.parseMaybeAssign();
         }
        return (e.delegate = t), (e.argument = r), this.finishNode(e, 'YieldExpression');
       }
       parseImportCall(e) {
        return this.next(), (e.source = this.parseMaybeAssignAllowIn()), (this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions')) && (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || ((e.options = this.parseMaybeAssignAllowIn()), this.eat(12))), this.expect(11), this.finishNode(e, 'ImportExpression');
       }
       checkPipelineAtInfixOperator(e, t) {
        this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) && 'SequenceExpression' === e.type && this.raise(g.PipelineHeadSequenceExpression, t);
       }
       parseSmartPipelineBodyInStyle(e, t) {
        if (this.isSimpleReference(e)) {
         let r = this.startNodeAt(t);
         return (r.callee = e), this.finishNode(r, 'PipelineBareFunction');
        }
        {
         let r = this.startNodeAt(t);
         return this.checkSmartPipeTopicBodyEarlyErrors(t), (r.expression = e), this.finishNode(r, 'PipelineTopicExpression');
        }
       }
       isSimpleReference(e) {
        switch (e.type) {
         case 'MemberExpression':
          return !e.computed && this.isSimpleReference(e.object);
         case 'Identifier':
          return !0;
         default:
          return !1;
        }
       }
       checkSmartPipeTopicBodyEarlyErrors(e) {
        if (this.match(19)) throw this.raise(g.PipelineBodyNoArrow, this.state.startLoc);
        this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipelineTopicUnused, e);
       }
       withTopicBindingContext(e) {
        let t = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
        try {
         return e();
        } finally {
         this.state.topicContext = t;
        }
       }
       withSmartMixTopicForbiddingContext(e) {
        if (!this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) return e();
        {
         let t = this.state.topicContext;
         this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
         try {
          return e();
         } finally {
          this.state.topicContext = t;
         }
        }
       }
       withSoloAwaitPermittingContext(e) {
        let t = this.state.soloAwait;
        this.state.soloAwait = !0;
        try {
         return e();
        } finally {
         this.state.soloAwait = t;
        }
       }
       allowInAnd(e) {
        let t = this.prodParam.currentFlags();
        if (8 & ~t) {
         this.prodParam.enter(8 | t);
         try {
          return e();
         } finally {
          this.prodParam.exit();
         }
        }
        return e();
       }
       disallowInAnd(e) {
        let t = this.prodParam.currentFlags();
        if (8 & t) {
         this.prodParam.enter(-9 & t);
         try {
          return e();
         } finally {
          this.prodParam.exit();
         }
        }
        return e();
       }
       registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
       }
       topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
       }
       topicReferenceWasUsedInCurrentContext() {
        return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
       }
       parseFSharpPipelineBody(e) {
        let t = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        let r = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !0;
        let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
        return (this.state.inFSharpPipelineDirectBody = r), n;
       }
       parseModuleExpression() {
        this.expectPlugin('moduleBlocks');
        let e = this.startNode();
        this.next(), this.match(5) || this.unexpected(null, 5);
        let t = this.startNodeAt(this.state.endLoc);
        this.next();
        let r = this.initializeScopes(!0);
        this.enterInitialScopes();
        try {
         e.body = this.parseProgram(t, 8, 'module');
        } finally {
         r();
        }
        return this.finishNode(e, 'ModuleExpression');
       }
       parsePropertyNamePrefixOperator(e) {}
      },
      Mt = { kind: 1 },
      jt = { kind: 2 },
      Rt = /[\uD800-\uDFFF]/u,
      qt = /in(?:stanceof)?/y;
     var Ut = class extends Ot {
       parseTopLevel(e, t) {
        return (
         (e.program = this.parseProgram(t)),
         (e.comments = this.comments),
         this.options.tokens &&
          (e.tokens = (function (e, t) {
           for (let r = 0; r < e.length; r++) {
            let n = e[r],
             { type: i } = n;
            if ('number' == typeof i) {
             if (138 === i) {
              let { loc: t, start: i, value: a, end: o } = n,
               u = i + 1,
               l = s(t.start, 1);
              e.splice(r, 1, new Ve({ type: Y(27), value: '#', start: i, end: u, startLoc: t.start, endLoc: l }), new Ve({ type: Y(132), value: a, start: u, end: o, startLoc: l, endLoc: t.end })), r++;
              continue;
             }
             if (X(i)) {
              let a,
               o,
               u,
               l,
               p,
               { loc: c, start: h, value: d, end: f } = n,
               m = h + 1,
               y = s(c.start, 1);
              (a = 96 === t.charCodeAt(h) ? new Ve({ type: Y(22), value: '`', start: h, end: m, startLoc: c.start, endLoc: y }) : new Ve({ type: Y(8), value: '}', start: h, end: m, startLoc: c.start, endLoc: y })), 24 === i ? ((u = f - 1), (l = s(c.end, -1)), (o = null === d ? null : d.slice(1, -1)), (p = new Ve({ type: Y(22), value: '`', start: u, end: f, startLoc: l, endLoc: c.end }))) : ((u = f - 2), (l = s(c.end, -2)), (o = null === d ? null : d.slice(1, -2)), (p = new Ve({ type: Y(23), value: '${', start: u, end: f, startLoc: l, endLoc: c.end }))), e.splice(r, 1, a, new Ve({ type: Y(20), value: o, start: m, end: u, startLoc: y, endLoc: l }), p), (r += 2);
              continue;
             }
             n.type = Y(i);
            }
           }
           return e;
          })(this.tokens, this.input)),
         this.finishNode(e, 'File')
        );
       }
       parseProgram(e, t = 139, r = this.options.sourceType) {
        if (((e.sourceType = r), (e.interpreter = this.parseInterpreterDirective()), this.parseBlockBody(e, !0, !0, t), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)) for (let [s, i] of Array.from(this.scope.undefinedExports)) this.raise(g.ModuleExportUndefined, i, { localName: s });
        let n;
        return (n = 139 === t ? this.finishNode(e, 'Program') : this.finishNodeAt(e, 'Program', s(this.state.startLoc, -1))), n;
       }
       stmtToDirective(e) {
        let t = e;
        (t.type = 'Directive'), (t.value = t.expression), delete t.expression;
        let r = t.value,
         n = r.value,
         s = this.input.slice(r.start, r.end),
         i = (r.value = s.slice(1, -1));
        return this.addExtra(r, 'raw', s), this.addExtra(r, 'rawValue', i), this.addExtra(r, 'expressionValue', n), (r.type = 'DirectiveLiteral'), t;
       }
       parseInterpreterDirective() {
        if (!this.match(28)) return null;
        let e = this.startNode();
        return (e.value = this.state.value), this.next(), this.finishNode(e, 'InterpreterDirective');
       }
       isLet() {
        return !!this.isContextual(100) && this.hasFollowingBindingAtom();
       }
       chStartsBindingIdentifier(e, t) {
        if (ie(e)) {
         if (((qt.lastIndex = t), qt.test(this.input))) {
          let e = this.codePointAtPos(qt.lastIndex);
          if (!ae(e) && 92 !== e) return !1;
         }
         return !0;
        }
        return 92 === e;
       }
       chStartsBindingPattern(e) {
        return 91 === e || 123 === e;
       }
       hasFollowingBindingAtom() {
        let e = this.nextTokenStart(),
         t = this.codePointAtPos(e);
        return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e);
       }
       hasInLineFollowingBindingIdentifier() {
        let e = this.nextTokenInLineStart(),
         t = this.codePointAtPos(e);
        return this.chStartsBindingIdentifier(t, e);
       }
       startsUsingForOf() {
        let { type: e, containsEsc: t } = this.lookahead();
        return !(102 === e && !t) && ($(e) && !this.hasFollowingLineBreak() ? (this.expectPlugin('explicitResourceManagement'), !0) : void 0);
       }
       startsAwaitUsing() {
        let e = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(e, 'using')) {
         e = this.nextTokenInLineStartSince(e + 5);
         let t = this.codePointAtPos(e);
         if (this.chStartsBindingIdentifier(t, e)) return this.expectPlugin('explicitResourceManagement'), !0;
        }
        return !1;
       }
       parseModuleItem() {
        return this.parseStatementLike(15);
       }
       parseStatementListItem() {
        return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
       }
       parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
        let t = 0;
        return this.options.annexB && !this.state.strict && ((t |= 4), e && (t |= 8)), this.parseStatementLike(t);
       }
       parseStatement() {
        return this.parseStatementLike(0);
       }
       parseStatementLike(e) {
        let t = null;
        return this.match(26) && (t = this.parseDecorators(!0)), this.parseStatementContent(e, t);
       }
       parseStatementContent(e, t) {
        let r = this.state.type,
         n = this.startNode(),
         s = !!(2 & e),
         i = !!(4 & e),
         a = 1 & e;
        switch (r) {
         case 60:
          return this.parseBreakContinueStatement(n, !0);
         case 63:
          return this.parseBreakContinueStatement(n, !1);
         case 64:
          return this.parseDebuggerStatement(n);
         case 90:
          return this.parseDoWhileStatement(n);
         case 91:
          return this.parseForStatement(n);
         case 68:
          if (46 === this.lookaheadCharCode()) break;
          return i || this.raise(this.state.strict ? g.StrictFunction : this.options.annexB ? g.SloppyFunctionAnnexB : g.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(n, !1, !s && i);
         case 80:
          return s || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t, n), !0);
         case 69:
          return this.parseIfStatement(n);
         case 70:
          return this.parseReturnStatement(n);
         case 71:
          return this.parseSwitchStatement(n);
         case 72:
          return this.parseThrowStatement(n);
         case 73:
          return this.parseTryStatement(n);
         case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? s || this.raise(g.UnexpectedLexicalDeclaration, n) : this.raise(g.AwaitUsingNotInAsyncContext, n), this.next(), this.parseVarStatement(n, 'await using');
          break;
         case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
          return this.expectPlugin('explicitResourceManagement'), !this.scope.inModule && this.scope.inTopLevel ? this.raise(g.UnexpectedUsingDeclaration, this.state.startLoc) : s || this.raise(g.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n, 'using');
         case 100: {
          if (this.state.containsEsc) break;
          let e = this.nextTokenStart(),
           t = this.codePointAtPos(e);
          if (91 !== t && ((!s && this.hasFollowingLineBreak()) || (!this.chStartsBindingIdentifier(t, e) && 123 !== t))) break;
         }
         case 75:
          s || this.raise(g.UnexpectedLexicalDeclaration, this.state.startLoc);
         case 74: {
          let e = this.state.value;
          return this.parseVarStatement(n, e);
         }
         case 92:
          return this.parseWhileStatement(n);
         case 76:
          return this.parseWithStatement(n);
         case 5:
          return this.parseBlock();
         case 13:
          return this.parseEmptyStatement(n);
         case 83: {
          let e = this.lookaheadCharCode();
          if (40 === e || 46 === e) break;
         }
         case 82: {
          let e;
          return !this.options.allowImportExportEverywhere && !a && this.raise(g.UnexpectedImportExport, this.state.startLoc), this.next(), 83 === r ? ((e = this.parseImport(n)), 'ImportDeclaration' === e.type && (!e.importKind || 'value' === e.importKind) && (this.sawUnambiguousESM = !0)) : ((e = this.parseExport(n, t)), (('ExportNamedDeclaration' === e.type && (!e.exportKind || 'value' === e.exportKind)) || ('ExportAllDeclaration' === e.type && (!e.exportKind || 'value' === e.exportKind)) || 'ExportDefaultDeclaration' === e.type) && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(e), e;
         }
         default:
          if (this.isAsyncFunction()) return s || this.raise(g.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n, !0, !s && i);
        }
        let o = this.state.value,
         u = this.parseExpression();
        return $(r) && 'Identifier' === u.type && this.eat(14) ? this.parseLabeledStatement(n, o, u, e) : this.parseExpressionStatement(n, u, t);
       }
       assertModuleNodeAllowed(e) {
        !this.options.allowImportExportEverywhere && !this.inModule && this.raise(g.ImportOutsideModule, e);
       }
       decoratorsEnabledBeforeExport() {
        return !!this.hasPlugin('decorators-legacy') || (this.hasPlugin('decorators') && !1 !== this.getPluginOption('decorators', 'decoratorsBeforeExport'));
       }
       maybeTakeDecorators(e, t, r) {
        return e && (t.decorators && t.decorators.length > 0 ? ('boolean' != typeof this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(g.DecoratorsBeforeAfterExport, t.decorators[0]), t.decorators.unshift(...e)) : (t.decorators = e), this.resetStartLocationFromNode(t, e[0]), r && this.resetStartLocationFromNode(r, t)), t;
       }
       canHaveLeadingDecorator() {
        return this.match(80);
       }
       parseDecorators(e) {
        let t = [];
        do {
         t.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(g.DecoratorExportClass, this.state.startLoc);
        else if (!this.canHaveLeadingDecorator()) throw this.raise(g.UnexpectedLeadingDecorator, this.state.startLoc);
        return t;
       }
       parseDecorator() {
        this.expectOnePlugin(['decorators', 'decorators-legacy']);
        let e = this.startNode();
        if ((this.next(), this.hasPlugin('decorators'))) {
         let t,
          r = this.state.startLoc;
         if (this.match(10)) {
          let r = this.state.startLoc;
          this.next(), (t = this.parseExpression()), this.expect(11), (t = this.wrapParenthesis(r, t));
          let n = this.state.startLoc;
          (e.expression = this.parseMaybeDecoratorArguments(t)), !1 === this.getPluginOption('decorators', 'allowCallParenthesized') && e.expression !== t && this.raise(g.DecoratorArgumentsOutsideParentheses, n);
         } else {
          for (t = this.parseIdentifier(!1); this.eat(16); ) {
           let e = this.startNodeAt(r);
           (e.object = t), this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), (e.property = this.parsePrivateName())) : (e.property = this.parseIdentifier(!0)), (e.computed = !1), (t = this.finishNode(e, 'MemberExpression'));
          }
          e.expression = this.parseMaybeDecoratorArguments(t);
         }
        } else e.expression = this.parseExprSubscripts();
        return this.finishNode(e, 'Decorator');
       }
       parseMaybeDecoratorArguments(e) {
        if (this.eat(10)) {
         let t = this.startNodeAtNode(e);
         return (t.callee = e), (t.arguments = this.parseCallExpressionArguments(11, !1)), this.toReferencedList(t.arguments), this.finishNode(t, 'CallExpression');
        }
        return e;
       }
       parseBreakContinueStatement(e, t) {
        return this.next(), this.isLineTerminator() ? (e.label = null) : ((e.label = this.parseIdentifier()), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? 'BreakStatement' : 'ContinueStatement');
       }
       verifyBreakContinue(e, t) {
        let r;
        for (r = 0; r < this.state.labels.length; ++r) {
         let n = this.state.labels[r];
         if ((null == e.label || n.name === e.label.name) && ((null != n.kind && (t || 1 === n.kind)) || (e.label && t))) break;
        }
        if (r === this.state.labels.length) {
         let r = t ? 'BreakStatement' : 'ContinueStatement';
         this.raise(g.IllegalBreakContinue, e, { type: r });
        }
       }
       parseDebuggerStatement(e) {
        return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement');
       }
       parseHeaderExpression() {
        this.expect(10);
        let e = this.parseExpression();
        return this.expect(11), e;
       }
       parseDoWhileStatement(e) {
        return this.next(), this.state.labels.push(Mt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.expect(92), (e.test = this.parseHeaderExpression()), this.eat(13), this.finishNode(e, 'DoWhileStatement');
       }
       parseForStatement(e) {
        this.next(), this.state.labels.push(Mt);
        let t = null;
        if ((this.isAwaitAllowed() && this.eatContextual(96) && (t = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))) return null !== t && this.unexpected(t), this.parseFor(e, null);
        let r = this.isContextual(100);
        {
         let n = this.isContextual(96) && this.startsAwaitUsing(),
          s = n || (this.isContextual(107) && this.startsUsingForOf()),
          i = (r && this.hasFollowingBindingAtom()) || s;
         if (this.match(74) || this.match(75) || i) {
          let r,
           i = this.startNode();
          n ? ((r = 'await using'), this.isAwaitAllowed() || this.raise(g.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : (r = this.state.value), this.next(), this.parseVar(i, !0, r);
          let a = this.finishNode(i, 'VariableDeclaration'),
           o = this.match(58);
          return o && s && this.raise(g.ForInUsing, a), (o || this.isContextual(102)) && 1 === a.declarations.length ? this.parseForIn(e, a, t) : (null !== t && this.unexpected(t), this.parseFor(e, a));
         }
        }
        let n = this.isContextual(95),
         s = new rt(),
         i = this.parseExpression(!0, s),
         a = this.isContextual(102);
        if ((a && (r && this.raise(g.ForOfLet, i), null === t && n && 'Identifier' === i.type && this.raise(g.ForOfAsync, i)), a || this.match(58))) {
         this.checkDestructuringPrivate(s), this.toAssignable(i, !0);
         let r = a ? 'ForOfStatement' : 'ForInStatement';
         return this.checkLVal(i, { in: { type: r } }), this.parseForIn(e, i, t);
        }
        return this.checkExpressionErrors(s, !0), null !== t && this.unexpected(t), this.parseFor(e, i);
       }
       parseFunctionStatement(e, t, r) {
        return this.next(), this.parseFunction(e, 1 | (r ? 2 : 0) | (t ? 8 : 0));
       }
       parseIfStatement(e) {
        return this.next(), (e.test = this.parseHeaderExpression()), (e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration()), (e.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null), this.finishNode(e, 'IfStatement');
       }
       parseReturnStatement(e) {
        return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(g.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? (e.argument = null) : ((e.argument = this.parseExpression()), this.semicolon()), this.finishNode(e, 'ReturnStatement');
       }
       parseSwitchStatement(e) {
        this.next(), (e.discriminant = this.parseHeaderExpression());
        let t,
         r = (e.cases = []);
        this.expect(5), this.state.labels.push(jt), this.scope.enter(0);
        for (let n; !this.match(8); )
         if (this.match(61) || this.match(65)) {
          let e = this.match(61);
          t && this.finishNode(t, 'SwitchCase'), r.push((t = this.startNode())), (t.consequent = []), this.next(), e ? (t.test = this.parseExpression()) : (n && this.raise(g.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), (n = !0), (t.test = null)), this.expect(14);
         } else t ? t.consequent.push(this.parseStatementListItem()) : this.unexpected();
        return this.scope.exit(), t && this.finishNode(t, 'SwitchCase'), this.next(), this.state.labels.pop(), this.finishNode(e, 'SwitchStatement');
       }
       parseThrowStatement(e) {
        return this.next(), this.hasPrecedingLineBreak() && this.raise(g.NewlineAfterThrow, this.state.lastTokEndLoc), (e.argument = this.parseExpression()), this.semicolon(), this.finishNode(e, 'ThrowStatement');
       }
       parseCatchClauseParam() {
        let e = this.parseBindingAtom();
        return this.scope.enter(this.options.annexB && 'Identifier' === e.type ? 8 : 0), this.checkLVal(e, { in: { type: 'CatchClause' }, binding: 9 }), e;
       }
       parseTryStatement(e) {
        if ((this.next(), (e.block = this.parseBlock()), (e.handler = null), this.match(62))) {
         let t = this.startNode();
         this.next(), this.match(10) ? (this.expect(10), (t.param = this.parseCatchClauseParam()), this.expect(11)) : ((t.param = null), this.scope.enter(0)), (t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))), this.scope.exit(), (e.handler = this.finishNode(t, 'CatchClause'));
        }
        return (e.finalizer = this.eat(67) ? this.parseBlock() : null), !e.handler && !e.finalizer && this.raise(g.NoCatchOrFinally, e), this.finishNode(e, 'TryStatement');
       }
       parseVarStatement(e, t, r = !1) {
        return this.next(), this.parseVar(e, !1, t, r), this.semicolon(), this.finishNode(e, 'VariableDeclaration');
       }
       parseWhileStatement(e) {
        return this.next(), (e.test = this.parseHeaderExpression()), this.state.labels.push(Mt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.finishNode(e, 'WhileStatement');
       }
       parseWithStatement(e) {
        return this.state.strict && this.raise(g.StrictWith, this.state.startLoc), this.next(), (e.object = this.parseHeaderExpression()), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.finishNode(e, 'WithStatement');
       }
       parseEmptyStatement(e) {
        return this.next(), this.finishNode(e, 'EmptyStatement');
       }
       parseLabeledStatement(e, t, r, n) {
        for (let a of this.state.labels) a.name === t && this.raise(g.LabelRedeclaration, r, { labelName: t });
        let s = (i = this.state.type) >= 90 && i <= 92 ? 1 : this.match(71) ? 2 : null;
        var i;
        for (let a = this.state.labels.length - 1; a >= 0; a--) {
         let t = this.state.labels[a];
         if (t.statementStart !== e.start) break;
         (t.statementStart = this.state.start), (t.kind = s);
        }
        return this.state.labels.push({ name: t, kind: s, statementStart: this.state.start }), (e.body = 8 & n ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement()), this.state.labels.pop(), (e.label = r), this.finishNode(e, 'LabeledStatement');
       }
       parseExpressionStatement(e, t, r) {
        return (e.expression = t), this.semicolon(), this.finishNode(e, 'ExpressionStatement');
       }
       parseBlock(e = !1, t = !0, r) {
        let n = this.startNode();
        return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(0), this.parseBlockBody(n, e, !1, 8, r), t && this.scope.exit(), this.finishNode(n, 'BlockStatement');
       }
       isValidDirective(e) {
        return 'ExpressionStatement' === e.type && 'StringLiteral' === e.expression.type && !e.expression.extra.parenthesized;
       }
       parseBlockBody(e, t, r, n, s) {
        let i = (e.body = []),
         a = (e.directives = []);
        this.parseBlockOrModuleBlockBody(i, t ? a : void 0, r, n, s);
       }
       parseBlockOrModuleBlockBody(e, t, r, n, s) {
        let i = this.state.strict,
         a = !1,
         o = !1;
        for (; !this.match(n); ) {
         let n = r ? this.parseModuleItem() : this.parseStatementListItem();
         if (t && !o) {
          if (this.isValidDirective(n)) {
           let e = this.stmtToDirective(n);
           t.push(e), !a && 'use strict' === e.value.value && ((a = !0), this.setStrict(!0));
           continue;
          }
          (o = !0), this.state.strictErrors.clear();
         }
         e.push(n);
        }
        null == s || s.call(this, a), i || this.setStrict(!1), this.next();
       }
       parseFor(e, t) {
        return (e.init = t), this.semicolon(!1), (e.test = this.match(13) ? null : this.parseExpression()), this.semicolon(!1), (e.update = this.match(11) ? null : this.parseExpression()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, 'ForStatement');
       }
       parseForIn(e, t, r) {
        let n = this.match(58);
        return this.next(), n ? null !== r && this.unexpected(r) : (e.await = null !== r), 'VariableDeclaration' === t.type && null != t.declarations[0].init && (!n || !this.options.annexB || this.state.strict || 'var' !== t.kind || 'Identifier' !== t.declarations[0].id.type) && this.raise(g.ForInOfLoopInitializer, t, { type: n ? 'ForInStatement' : 'ForOfStatement' }), 'AssignmentPattern' === t.type && this.raise(g.InvalidLhs, t, { ancestor: { type: 'ForStatement' } }), (e.left = t), (e.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, n ? 'ForInStatement' : 'ForOfStatement');
       }
       parseVar(e, t, r, n = !1) {
        let s = (e.declarations = []);
        for (e.kind = r; ; ) {
         let e = this.startNode();
         if ((this.parseVarId(e, r), (e.init = this.eat(29) ? (t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()) : null), null === e.init && !n && ('Identifier' === e.id.type || (t && (this.match(58) || this.isContextual(102))) ? ('const' === r || 'using' === r || 'await using' === r) && !(this.match(58) || this.isContextual(102)) && this.raise(g.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: r }) : this.raise(g.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: 'destructuring' })), s.push(this.finishNode(e, 'VariableDeclarator')), !this.eat(12))) break;
        }
        return e;
       }
       parseVarId(e, t) {
        let r = this.parseBindingAtom();
        this.checkLVal(r, { in: { type: 'VariableDeclarator' }, binding: 'var' === t ? 5 : 8201 }), (e.id = r);
       }
       parseAsyncFunctionExpression(e) {
        return this.parseFunction(e, 8);
       }
       parseFunction(e, t = 0) {
        let r = 2 & t,
         n = !!(1 & t),
         s = n && !(4 & t),
         i = !!(8 & t);
        this.initFunction(e, i), this.match(55) && (r && this.raise(g.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), (e.generator = !0)), n && (e.id = this.parseFunctionId(s));
        let a = this.state.maybeInArrowParameters;
        return (
         (this.state.maybeInArrowParameters = !1),
         this.scope.enter(2),
         this.prodParam.enter(et(i, e.generator)),
         n || (e.id = this.parseFunctionId()),
         this.parseFunctionParams(e, !1),
         this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(e, n ? 'FunctionDeclaration' : 'FunctionExpression');
         }),
         this.prodParam.exit(),
         this.scope.exit(),
         n && !r && this.registerFunctionStatementId(e),
         (this.state.maybeInArrowParameters = a),
         e
        );
       }
       parseFunctionId(e) {
        return e || $(this.state.type) ? this.parseIdentifier() : null;
       }
       parseFunctionParams(e, t) {
        this.expect(10), this.expressionScope.enter(new Ge(3)), (e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0))), this.expressionScope.exit();
       }
       registerFunctionStatementId(e) {
        e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? (this.scope.treatFunctionsAsVar ? 5 : 8201) : 17, e.id.loc.start);
       }
       parseClass(e, t, r) {
        this.next();
        let n = this.state.strict;
        return (this.state.strict = !0), this.parseClassId(e, t, r), this.parseClassSuper(e), (e.body = this.parseClassBody(!!e.superClass, n)), this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression');
       }
       isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
       }
       isClassMethod() {
        return this.match(10);
       }
       nameIsConstructor(e) {
        return ('Identifier' === e.type && 'constructor' === e.name) || ('StringLiteral' === e.type && 'constructor' === e.value);
       }
       isNonstaticConstructor(e) {
        return !e.computed && !e.static && this.nameIsConstructor(e.key);
       }
       parseClassBody(e, t) {
        this.classScope.enter();
        let r = { hadConstructor: !1, hadSuperClass: e },
         n = [],
         s = this.startNode();
        if (
         ((s.body = []),
         this.expect(5),
         this.withSmartMixTopicForbiddingContext(() => {
          for (; !this.match(8); ) {
           if (this.eat(13)) {
            if (n.length > 0) throw this.raise(g.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
           }
           if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
           }
           let e = this.startNode();
           n.length && ((e.decorators = n), this.resetStartLocationFromNode(e, n[0]), (n = [])), this.parseClassMember(s, e, r), 'constructor' === e.kind && e.decorators && e.decorators.length > 0 && this.raise(g.DecoratorConstructor, e);
          }
         }),
         (this.state.strict = t),
         this.next(),
         n.length)
        )
         throw this.raise(g.TrailingDecorator, this.state.startLoc);
        return this.classScope.exit(), this.finishNode(s, 'ClassBody');
       }
       parseClassMemberFromModifier(e, t) {
        let r = this.parseIdentifier(!0);
        if (this.isClassMethod()) {
         let n = t;
         return (n.kind = 'method'), (n.computed = !1), (n.key = r), (n.static = !1), this.pushClassMethod(e, n, !1, !1, !1, !1), !0;
        }
        if (this.isClassProperty()) {
         let n = t;
         return (n.computed = !1), (n.key = r), (n.static = !1), e.body.push(this.parseClassProperty(n)), !0;
        }
        return this.resetPreviousNodeTrailingComments(r), !1;
       }
       parseClassMember(e, t, r) {
        let n = this.isContextual(106);
        if (n) {
         if (this.parseClassMemberFromModifier(e, t)) return;
         if (this.eat(5)) return void this.parseClassStaticBlock(e, t);
        }
        this.parseClassMemberWithIsStatic(e, t, r, n);
       }
       parseClassMemberWithIsStatic(e, t, r, n) {
        let s = t,
         i = t,
         a = t,
         o = t,
         u = t,
         l = s,
         p = s;
        if (((t.static = n), this.parsePropertyNamePrefixOperator(t), this.eat(55))) {
         l.kind = 'method';
         let t = this.match(138);
         return this.parseClassElementName(l), t ? void this.pushClassPrivateMethod(e, i, !0, !1) : (this.isNonstaticConstructor(s) && this.raise(g.ConstructorIsGenerator, s.key), void this.pushClassMethod(e, s, !0, !1, !1, !1));
        }
        let c = !this.state.containsEsc && $(this.state.type),
         h = this.parseClassElementName(t),
         d = c ? h.name : null,
         f = this.isPrivateName(h),
         m = this.state.startLoc;
        if ((this.parsePostMemberNameModifiers(p), this.isClassMethod())) {
         if (((l.kind = 'method'), f)) return void this.pushClassPrivateMethod(e, i, !1, !1);
         let n = this.isNonstaticConstructor(s),
          a = !1;
         n && ((s.kind = 'constructor'), r.hadConstructor && !this.hasPlugin('typescript') && this.raise(g.DuplicateConstructor, h), n && this.hasPlugin('typescript') && t.override && this.raise(g.OverrideOnConstructor, h), (r.hadConstructor = !0), (a = r.hadSuperClass)), this.pushClassMethod(e, s, !1, !1, n, a);
        } else if (this.isClassProperty()) f ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a);
        else if ('async' !== d || this.isLineTerminator())
         if (('get' !== d && 'set' !== d) || (this.match(55) && this.isLineTerminator()))
          if ('accessor' !== d || this.isLineTerminator()) this.isLineTerminator() ? (f ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a)) : this.unexpected();
          else {
           this.expectPlugin('decoratorAutoAccessors'), this.resetPreviousNodeTrailingComments(h);
           let t = this.match(138);
           this.parseClassElementName(a), this.pushClassAccessorProperty(e, u, t);
          }
         else {
          this.resetPreviousNodeTrailingComments(h), (l.kind = d);
          let t = this.match(138);
          this.parseClassElementName(s), t ? this.pushClassPrivateMethod(e, i, !1, !1) : (this.isNonstaticConstructor(s) && this.raise(g.ConstructorIsAccessor, s.key), this.pushClassMethod(e, s, !1, !1, !1, !1)), this.checkGetterSetterParams(s);
         }
        else {
         this.resetPreviousNodeTrailingComments(h);
         let t = this.eat(55);
         p.optional && this.unexpected(m), (l.kind = 'method');
         let r = this.match(138);
         this.parseClassElementName(l), this.parsePostMemberNameModifiers(p), r ? this.pushClassPrivateMethod(e, i, t, !0) : (this.isNonstaticConstructor(s) && this.raise(g.ConstructorIsAsync, s.key), this.pushClassMethod(e, s, t, !0, !1, !1));
        }
       }
       parseClassElementName(e) {
        let { type: t, value: r } = this.state;
        if (((132 === t || 133 === t) && e.static && 'prototype' === r && this.raise(g.StaticPrototype, this.state.startLoc), 138 === t)) {
         'constructor' === r && this.raise(g.ConstructorClassPrivateField, this.state.startLoc);
         let t = this.parsePrivateName();
         return (e.key = t), t;
        }
        return this.parsePropertyName(e), e.key;
       }
       parseClassStaticBlock(e, t) {
        var r;
        this.scope.enter(208);
        let n = this.state.labels;
        (this.state.labels = []), this.prodParam.enter(0);
        let s = (t.body = []);
        this.parseBlockOrModuleBlockBody(s, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), (this.state.labels = n), e.body.push(this.finishNode(t, 'StaticBlock')), null != (r = t.decorators) && r.length && this.raise(g.DecoratorStaticBlock, t);
       }
       pushClassProperty(e, t) {
        !t.computed && this.nameIsConstructor(t.key) && this.raise(g.ConstructorClassField, t.key), e.body.push(this.parseClassProperty(t));
       }
       pushClassPrivateProperty(e, t) {
        let r = this.parseClassPrivateProperty(t);
        e.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
       }
       pushClassAccessorProperty(e, t, r) {
        !r && !t.computed && this.nameIsConstructor(t.key) && this.raise(g.ConstructorClassField, t.key);
        let n = this.parseClassAccessorProperty(t);
        e.body.push(n), r && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
       }
       pushClassMethod(e, t, r, n, s, i) {
        e.body.push(this.parseMethod(t, r, n, s, i, 'ClassMethod', !0));
       }
       pushClassPrivateMethod(e, t, r, n) {
        let s = this.parseMethod(t, r, n, !1, !1, 'ClassPrivateMethod', !0);
        e.body.push(s);
        let i = 'get' === s.kind ? (s.static ? 6 : 2) : 'set' === s.kind ? (s.static ? 5 : 1) : 0;
        this.declareClassPrivateMethodInScope(s, i);
       }
       declareClassPrivateMethodInScope(e, t) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
       }
       parsePostMemberNameModifiers(e) {}
       parseClassPrivateProperty(e) {
        return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassPrivateProperty');
       }
       parseClassProperty(e) {
        return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassProperty');
       }
       parseClassAccessorProperty(e) {
        return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassAccessorProperty');
       }
       parseInitializer(e) {
        this.scope.enter(80), this.expressionScope.enter(Qe()), this.prodParam.enter(0), (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null), this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
       }
       parseClassId(e, t, r, n = 8331) {
        if ($(this.state.type)) (e.id = this.parseIdentifier()), t && this.declareNameFromIdentifier(e.id, n);
        else {
         if (!r && t) throw this.raise(g.MissingClassName, this.state.startLoc);
         e.id = null;
        }
       }
       parseClassSuper(e) {
        e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
       }
       parseExport(e, t) {
        let r = this.parseMaybeImportPhase(e, !0),
         n = this.maybeParseExportDefaultSpecifier(e, r),
         s = !n || this.eat(12),
         i = s && this.eatExportStar(e),
         a = i && this.maybeParseExportNamespaceSpecifier(e),
         o = s && (!a || this.eat(12)),
         u = n || i;
        if (i && !a) {
         if ((n && this.unexpected(), t)) throw this.raise(g.UnsupportedDecoratorExport, e);
         return this.parseExportFrom(e, !0), this.finishNode(e, 'ExportAllDeclaration');
        }
        let l,
         p = this.maybeParseExportNamedSpecifiers(e);
        if ((n && s && !i && !p && this.unexpected(null, 5), a && o && this.unexpected(null, 98), u || p)) {
         if (((l = !1), t)) throw this.raise(g.UnsupportedDecoratorExport, e);
         this.parseExportFrom(e, u);
        } else l = this.maybeParseExportDeclaration(e);
        if (u || p || l) {
         var c;
         let r = e;
         if ((this.checkExport(r, !0, !1, !!r.source), 'ClassDeclaration' === (null == (c = r.declaration) ? void 0 : c.type))) this.maybeTakeDecorators(t, r.declaration, r);
         else if (t) throw this.raise(g.UnsupportedDecoratorExport, e);
         return this.finishNode(r, 'ExportNamedDeclaration');
        }
        if (this.eat(65)) {
         let r = e,
          n = this.parseExportDefaultExpression();
         if (((r.declaration = n), 'ClassDeclaration' === n.type)) this.maybeTakeDecorators(t, n, r);
         else if (t) throw this.raise(g.UnsupportedDecoratorExport, e);
         return this.checkExport(r, !0, !0), this.finishNode(r, 'ExportDefaultDeclaration');
        }
        this.unexpected(null, 5);
       }
       eatExportStar(e) {
        return this.eat(55);
       }
       maybeParseExportDefaultSpecifier(e, t) {
        if (t || this.isExportDefaultSpecifier()) {
         this.expectPlugin('exportDefaultFrom', null == t ? void 0 : t.loc.start);
         let r = t || this.parseIdentifier(!0),
          n = this.startNodeAtNode(r);
         return (n.exported = r), (e.specifiers = [this.finishNode(n, 'ExportDefaultSpecifier')]), !0;
        }
        return !1;
       }
       maybeParseExportNamespaceSpecifier(e) {
        if (this.isContextual(93)) {
         var t;
         null != (t = e).specifiers || (t.specifiers = []);
         let r = this.startNodeAt(this.state.lastTokStartLoc);
         return this.next(), (r.exported = this.parseModuleExportName()), e.specifiers.push(this.finishNode(r, 'ExportNamespaceSpecifier')), !0;
        }
        return !1;
       }
       maybeParseExportNamedSpecifiers(e) {
        if (this.match(5)) {
         let t = e;
         t.specifiers || (t.specifiers = []);
         let r = 'type' === t.exportKind;
         return t.specifiers.push(...this.parseExportSpecifiers(r)), (t.source = null), (t.declaration = null), this.hasPlugin('importAssertions') && (t.assertions = []), !0;
        }
        return !1;
       }
       maybeParseExportDeclaration(e) {
        return !!this.shouldParseExportDeclaration() && ((e.specifiers = []), (e.source = null), this.hasPlugin('importAssertions') && (e.assertions = []), (e.declaration = this.parseExportDeclaration(e)), !0);
       }
       isAsyncFunction() {
        if (!this.isContextual(95)) return !1;
        let e = this.nextTokenInLineStart();
        return this.isUnparsedContextual(e, 'function');
       }
       parseExportDefaultExpression() {
        let e = this.startNode();
        if (this.match(68)) return this.next(), this.parseFunction(e, 5);
        if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e, 13);
        if (this.match(80)) return this.parseClass(e, !0, !0);
        if (this.match(26)) return this.hasPlugin('decorators') && !0 === this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(g.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
        if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(g.UnsupportedDefaultExport, this.state.startLoc);
        let t = this.parseMaybeAssignAllowIn();
        return this.semicolon(), t;
       }
       parseExportDeclaration(e) {
        return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
       }
       isExportDefaultSpecifier() {
        let { type: e } = this.state;
        if ($(e)) {
         if ((95 === e && !this.state.containsEsc) || 100 === e) return !1;
         if ((130 === e || 129 === e) && !this.state.containsEsc) {
          let { type: e } = this.lookahead();
          if (($(e) && 98 !== e) || 5 === e) return this.expectOnePlugin(['flow', 'typescript']), !1;
         }
        } else if (!this.match(65)) return !1;
        let t = this.nextTokenStart(),
         r = this.isUnparsedContextual(t, 'from');
        if (44 === this.input.charCodeAt(t) || ($(this.state.type) && r)) return !0;
        if (this.match(65) && r) {
         let e = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
         return 34 === e || 39 === e;
        }
        return !1;
       }
       parseExportFrom(e, t) {
        this.eatContextual(98) ? ((e.source = this.parseImportSource()), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(e)) : t && this.unexpected(), this.semicolon();
       }
       shouldParseExportDeclaration() {
        let { type: e } = this.state;
        return 26 === e && (this.expectOnePlugin(['decorators', 'decorators-legacy']), this.hasPlugin('decorators')) ? (!0 === this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(g.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) || (this.isContextual(96) && this.startsAwaitUsing()) ? (this.raise(g.UsingDeclarationExport, this.state.startLoc), !0) : 74 === e || 75 === e || 68 === e || 80 === e || this.isLet() || this.isAsyncFunction();
       }
       checkExport(e, t, r, n) {
        var s;
        if (t)
         if (r) {
          if ((this.checkDuplicateExports(e, 'default'), this.hasPlugin('exportDefaultFrom'))) {
           var i;
           let t = e.declaration;
           'Identifier' === t.type && 'from' === t.name && t.end - t.start == 4 && (null == (i = t.extra) || !i.parenthesized) && this.raise(g.ExportDefaultFromAsIdentifier, t);
          }
         } else if (null != (s = e.specifiers) && s.length)
          for (let a of e.specifiers) {
           let { exported: e } = a,
            t = 'Identifier' === e.type ? e.name : e.value;
           if ((this.checkDuplicateExports(a, t), !n && a.local)) {
            let { local: e } = a;
            'Identifier' !== e.type ? this.raise(g.ExportBindingIsString, a, { localName: e.value, exportName: t }) : (this.checkReservedWord(e.name, e.loc.start, !0, !1), this.scope.checkLocalExport(e));
           }
          }
         else if (e.declaration) {
          let t = e.declaration;
          if ('FunctionDeclaration' === t.type || 'ClassDeclaration' === t.type) {
           let { id: r } = t;
           if (!r) throw new Error('Assertion failure');
           this.checkDuplicateExports(e, r.name);
          } else if ('VariableDeclaration' === t.type) for (let e of t.declarations) this.checkDeclaration(e.id);
         }
       }
       checkDeclaration(e) {
        if ('Identifier' === e.type) this.checkDuplicateExports(e, e.name);
        else if ('ObjectPattern' === e.type) for (let t of e.properties) this.checkDeclaration(t);
        else if ('ArrayPattern' === e.type) for (let t of e.elements) t && this.checkDeclaration(t);
        else 'ObjectProperty' === e.type ? this.checkDeclaration(e.value) : 'RestElement' === e.type ? this.checkDeclaration(e.argument) : 'AssignmentPattern' === e.type && this.checkDeclaration(e.left);
       }
       checkDuplicateExports(e, t) {
        this.exportedIdentifiers.has(t) && ('default' === t ? this.raise(g.DuplicateDefaultExport, e) : this.raise(g.DuplicateExport, e, { exportName: t })), this.exportedIdentifiers.add(t);
       }
       parseExportSpecifiers(e) {
        let t = [],
         r = !0;
        for (this.expect(5); !this.eat(8); ) {
         if (r) r = !1;
         else if ((this.expect(12), this.eat(8))) break;
         let n = this.isContextual(130),
          s = this.match(133),
          i = this.startNode();
         (i.local = this.parseModuleExportName()), t.push(this.parseExportSpecifier(i, s, e, n));
        }
        return t;
       }
       parseExportSpecifier(e, t, r, n) {
        return this.eatContextual(93) ? (e.exported = this.parseModuleExportName()) : t ? (e.exported = at(e.local)) : e.exported || (e.exported = it(e.local)), this.finishNode(e, 'ExportSpecifier');
       }
       parseModuleExportName() {
        if (this.match(133)) {
         let e = this.parseStringLiteral(this.state.value),
          t = e.value.match(Rt);
         return t && this.raise(g.ModuleExportNameHasLoneSurrogate, e, { surrogateCharCode: t[0].charCodeAt(0) }), e;
        }
        return this.parseIdentifier(!0);
       }
       isJSONModuleImport(e) {
        return null != e.assertions && e.assertions.some(({ key: e, value: t }) => 'json' === t.value && ('Identifier' === e.type ? 'type' === e.name : 'type' === e.value));
       }
       checkImportReflection(e) {
        let { specifiers: t } = e,
         r = 1 === t.length ? t[0].type : null;
        if ('source' === e.phase) 'ImportDefaultSpecifier' !== r && this.raise(g.SourcePhaseImportRequiresDefault, t[0].loc.start);
        else if ('defer' === e.phase) 'ImportNamespaceSpecifier' !== r && this.raise(g.DeferImportRequiresNamespace, t[0].loc.start);
        else if (e.module) {
         var n;
         'ImportDefaultSpecifier' !== r && this.raise(g.ImportReflectionNotBinding, t[0].loc.start), (null == (n = e.assertions) ? void 0 : n.length) > 0 && this.raise(g.ImportReflectionHasAssertion, t[0].loc.start);
        }
       }
       checkJSONModuleImport(e) {
        if (this.isJSONModuleImport(e) && 'ExportAllDeclaration' !== e.type) {
         let { specifiers: t } = e;
         if (null != t) {
          let e = t.find((e) => {
           let t;
           if (('ExportSpecifier' === e.type ? (t = e.local) : 'ImportSpecifier' === e.type && (t = e.imported), void 0 !== t)) return 'Identifier' === t.type ? 'default' !== t.name : 'default' !== t.value;
          });
          void 0 !== e && this.raise(g.ImportJSONBindingNotDefault, e.loc.start);
         }
        }
       }
       isPotentialImportPhase(e) {
        return !e && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
       }
       applyImportPhase(e, t, r, n) {
        t || ('module' === r ? (this.expectPlugin('importReflection', n), (e.module = !0)) : this.hasPlugin('importReflection') && (e.module = !1), 'source' === r ? (this.expectPlugin('sourcePhaseImports', n), (e.phase = 'source')) : 'defer' === r ? (this.expectPlugin('deferredImportEvaluation', n), (e.phase = 'defer')) : this.hasPlugin('sourcePhaseImports') && (e.phase = null));
       }
       parseMaybeImportPhase(e, t) {
        if (!this.isPotentialImportPhase(t)) return this.applyImportPhase(e, t, null), null;
        let r = this.parseIdentifier(!0),
         { type: n } = this.state;
        return (H(n) ? 98 !== n || 102 === this.lookaheadCharCode() : 12 !== n) ? (this.resetPreviousIdentifierLeadingComments(r), this.applyImportPhase(e, t, r.name, r.loc.start), null) : (this.applyImportPhase(e, t, null), r);
       }
       isPrecedingIdImportPhase(e) {
        let { type: t } = this.state;
        return $(t) ? 98 !== t || 102 === this.lookaheadCharCode() : 12 !== t;
       }
       parseImport(e) {
        return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
       }
       parseImportSpecifiersAndAfter(e, t) {
        e.specifiers = [];
        let r = !this.maybeParseDefaultImportSpecifier(e, t) || this.eat(12),
         n = r && this.maybeParseStarImportSpecifier(e);
        return r && !n && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
       }
       parseImportSourceAndAttributes(e) {
        return null != e.specifiers || (e.specifiers = []), (e.source = this.parseImportSource()), this.maybeParseImportAttributes(e), this.checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
       }
       parseImportSource() {
        return this.match(133) || this.unexpected(), this.parseExprAtom();
       }
       parseImportSpecifierLocal(e, t, r) {
        (t.local = this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r));
       }
       finishImportSpecifier(e, t, r = 8201) {
        return this.checkLVal(e.local, { in: { type: t }, binding: r }), this.finishNode(e, t);
       }
       parseImportAttributes() {
        this.expect(5);
        let e = [],
         t = new Set();
        do {
         if (this.match(8)) break;
         let r = this.startNode(),
          n = this.state.value;
         if ((t.has(n) && this.raise(g.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: n }), t.add(n), this.match(133) ? (r.key = this.parseStringLiteral(n)) : (r.key = this.parseIdentifier(!0)), this.expect(14), !this.match(133))) throw this.raise(g.ModuleAttributeInvalidValue, this.state.startLoc);
         (r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, 'ImportAttribute'));
        } while (this.eat(12));
        return this.expect(8), e;
       }
       parseModuleAttributes() {
        let e = [],
         t = new Set();
        do {
         let r = this.startNode();
         if (((r.key = this.parseIdentifier(!0)), 'type' !== r.key.name && this.raise(g.ModuleAttributeDifferentFromType, r.key), t.has(r.key.name) && this.raise(g.ModuleAttributesWithDuplicateKeys, r.key, { key: r.key.name }), t.add(r.key.name), this.expect(14), !this.match(133))) throw this.raise(g.ModuleAttributeInvalidValue, this.state.startLoc);
         (r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, 'ImportAttribute'));
        } while (this.eat(12));
        return e;
       }
       maybeParseImportAttributes(e) {
        let t,
         r = !1;
        if (this.match(76)) {
         if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
         this.next(), this.hasPlugin('moduleAttributes') ? (t = this.parseModuleAttributes()) : (this.expectImportAttributesPlugin(), (t = this.parseImportAttributes())), (r = !0);
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin('importAttributes') ? (!0 !== this.getPluginOption('importAttributes', 'deprecatedAssertSyntax') && this.raise(g.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(e, 'deprecatedAssertSyntax', !0)) : this.expectOnePlugin(['importAttributes', 'importAssertions']), this.next(), (t = this.parseImportAttributes());
        else if (this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions')) t = [];
        else {
         if (!this.hasPlugin('moduleAttributes')) return;
         t = [];
        }
        !r && this.hasPlugin('importAssertions') ? (e.assertions = t) : (e.attributes = t);
       }
       maybeParseDefaultImportSpecifier(e, t) {
        if (t) {
         let r = this.startNodeAtNode(t);
         return (r.local = t), e.specifiers.push(this.finishImportSpecifier(r, 'ImportDefaultSpecifier')), !0;
        }
        return !!H(this.state.type) && (this.parseImportSpecifierLocal(e, this.startNode(), 'ImportDefaultSpecifier'), !0);
       }
       maybeParseStarImportSpecifier(e) {
        if (this.match(55)) {
         let t = this.startNode();
         return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, 'ImportNamespaceSpecifier'), !0;
        }
        return !1;
       }
       parseNamedImportSpecifiers(e) {
        let t = !0;
        for (this.expect(5); !this.eat(8); ) {
         if (t) t = !1;
         else {
          if (this.eat(14)) throw this.raise(g.DestructureNamedImport, this.state.startLoc);
          if ((this.expect(12), this.eat(8))) break;
         }
         let r = this.startNode(),
          n = this.match(133),
          s = this.isContextual(130);
         r.imported = this.parseModuleExportName();
         let i = this.parseImportSpecifier(r, n, 'type' === e.importKind || 'typeof' === e.importKind, s, void 0);
         e.specifiers.push(i);
        }
       }
       parseImportSpecifier(e, t, r, n, s) {
        if (this.eatContextual(93)) e.local = this.parseIdentifier();
        else {
         let { imported: r } = e;
         if (t) throw this.raise(g.ImportBindingIsString, e, { importName: r.value });
         this.checkReservedWord(r.name, e.loc.start, !0, !0), e.local || (e.local = it(r));
        }
        return this.finishImportSpecifier(e, 'ImportSpecifier', s);
       }
       isThisParam(e) {
        return 'Identifier' === e.type && 'this' === e.name;
       }
      },
      $t = class extends Ut {
       constructor(e, t) {
        (e = (function (e) {
         if (null == e) return Object.assign({}, Lt);
         if (null != e.annexB && !1 !== e.annexB) throw new Error('The `annexB` option can only be set to `false`.');
         let t = {};
         for (let n of Object.keys(Lt)) {
          var r;
          t[n] = null != (r = e[n]) ? r : Lt[n];
         }
         return t;
        })(e)),
         super(e, t),
         (this.options = e),
         this.initializeScopes(),
         (this.plugins = (function (e) {
          let t = new Map();
          for (let r of e) {
           let [e, n] = Array.isArray(r) ? r : [r, {}];
           t.has(e) || t.set(e, n || {});
          }
          return t;
         })(this.options.plugins)),
         (this.filename = e.sourceFilename);
       }
       getScopeHandler() {
        return De;
       }
       parse() {
        this.enterInitialScopes();
        let e = this.startNode(),
         t = this.startNode();
        return this.nextToken(), (e.errors = null), this.parseTopLevel(e, t), (e.errors = this.state.errors), (e.comments.length = this.state.commentsLen), e;
       }
      };
     var Ht = (function (e) {
      let t = {};
      for (let r of Object.keys(e)) t[r] = Y(e[r]);
      return t;
     })(U);
     function zt(e, t) {
      let r = $t;
      return (
       null != e &&
        e.plugins &&
        ((function (e) {
         if (kt(e, 'decorators')) {
          if (kt(e, 'decorators-legacy')) throw new Error('Cannot use the decorators and decorators-legacy plugin together');
          let t = Pt(e, 'decorators', 'decoratorsBeforeExport');
          if (null != t && 'boolean' != typeof t) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
          let r = Pt(e, 'decorators', 'allowCallParenthesized');
          if (null != r && 'boolean' != typeof r) throw new Error("'allowCallParenthesized' must be a boolean.");
         }
         if (kt(e, 'flow') && kt(e, 'typescript')) throw new Error('Cannot combine flow and typescript plugins.');
         if (kt(e, 'placeholders') && kt(e, 'v8intrinsic')) throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
         if (kt(e, 'pipelineOperator')) {
          let t = Pt(e, 'pipelineOperator', 'proposal');
          if (!It.includes(t)) {
           let e = It.map((e) => `"${e}"`).join(', ');
           throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e}.`);
          }
          let r = ['recordAndTuple', { syntaxType: 'hash' }],
           n = kt(e, r);
          if ('hack' === t) {
           if (kt(e, 'placeholders')) throw new Error('Cannot combine placeholders plugin and Hack-style pipes.');
           if (kt(e, 'v8intrinsic')) throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.');
           let t = Pt(e, 'pipelineOperator', 'topicToken');
           if (!Nt.includes(t)) {
            let e = Nt.map((e) => `"${e}"`).join(', ');
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e}.`);
           }
           if ('#' === t && n) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(r)}\`.`);
          } else if ('smart' === t && n) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(r)}\`.`);
         }
         if (kt(e, 'moduleAttributes')) {
          if (kt(e, 'importAssertions') || kt(e, 'importAttributes')) throw new Error('Cannot combine importAssertions, importAttributes and moduleAttributes plugins.');
          if ('may-2020' !== Pt(e, 'moduleAttributes', 'version')) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
         }
         if (kt(e, 'importAssertions') && kt(e, 'importAttributes')) throw new Error('Cannot combine importAssertions and importAttributes plugins.');
         if (kt(e, 'recordAndTuple')) {
          let t = Pt(e, 'recordAndTuple', 'syntaxType');
          if (null != t) {
           let e = ['hash', 'bar'];
           if (!e.includes(t)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e.map((e) => `'${e}'`).join(', '));
          }
         }
         if (kt(e, 'asyncDoExpressions') && !kt(e, 'doExpressions')) {
          let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          throw ((e.missingPlugins = 'doExpressions'), e);
         }
         if (kt(e, 'optionalChainingAssign') && '2023-07' !== Pt(e, 'optionalChainingAssign', 'version')) throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        })(e.plugins),
        (r = (function (e) {
         let t = _t.filter((t) => kt(e, t)),
          r = t.join('/'),
          n = Vt[r];
         if (!n) {
          n = $t;
          for (let e of t) n = Bt[e](n);
          Vt[r] = n;
         }
         return n;
        })(e.plugins))),
       new r(e, t)
      );
     }
     var Vt = {};
     (e.parse = function (e, t) {
      var r;
      if ('unambiguous' !== (null == (r = t) ? void 0 : r.sourceType)) return zt(t, e).parse();
      t = Object.assign({}, t);
      try {
       t.sourceType = 'module';
       let r = zt(t, e),
        n = r.parse();
       if (r.sawUnambiguousESM) return n;
       if (r.ambiguousScriptDifferentAst)
        try {
         return (t.sourceType = 'script'), zt(t, e).parse();
        } catch {}
       else n.program.sourceType = 'script';
       return n;
      } catch (n) {
       try {
        return (t.sourceType = 'script'), zt(t, e).parse();
       } catch {}
       throw n;
      }
     }),
      (e.parseExpression = function (e, t) {
       let r = zt(t, e);
       return r.options.strictMode && (r.state.strict = !0), r.getExpression();
      }),
      (e.tokTypes = Ht);
    }),
    h = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.extract = function (e) {
       let t = e.match(n);
       return t ? t[0].trimLeft() : '';
      }),
      (e.parse = function (e) {
       return p(e).pragmas;
      }),
      (e.parseWithComments = p),
      (e.print = function ({ comments: e = '', pragmas: t = {} }) {
       let r = '\n',
        n = ' *',
        s = Object.keys(t),
        i = s
         .flatMap((e) => c(e, t[e]))
         .map((e) => `${n} ${e}${r}`)
         .join('');
       if (!e) {
        if (0 === s.length) return '';
        if (1 === s.length && !Array.isArray(t[s[0]])) {
         let e = t[s[0]];
         return `/** ${c(s[0], e)[0]} */`;
        }
       }
       let a =
        e
         .split(r)
         .map((e) => `${n} ${e}`)
         .join(r) + r;
       return '/**\n' + (e ? a : '') + (e && s.length ? n + r : '') + i + ' */';
      }),
      (e.strip = function (e) {
       let t = e.match(n);
       return t && t[0] ? e.substring(t[0].length) : e;
      });
     var t = /\*\/$/,
      r = /^\/\*\*?/,
      n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
      s = /(^|\s+)\/\/([^\r\n]*)/g,
      i = /^(\r?\n)+/,
      a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
      o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
      u = /(\r?\n|^) *\* ?/g,
      l = [];
     function p(e) {
      e = e.replace(r, '').replace(t, '').replace(u, '$1');
      let n = '';
      for (; n !== e; ) (n = e), (e = e.replace(a, '\n$1 $2\n'));
      e = e.replace(i, '').trimRight();
      let p,
       c = Object.create(null),
       h = e.replace(o, '').replace(i, '').trimRight();
      for (; (p = o.exec(e)); ) {
       let e = p[2].replace(s, '');
       'string' == typeof c[p[1]] || Array.isArray(c[p[1]]) ? (c[p[1]] = l.concat(c[p[1]], e)) : (c[p[1]] = e);
      }
      return { comments: h, pragmas: c };
     }
     function c(e, t) {
      return l.concat(t).map((t) => `@${e} ${t}`.trim());
     }
    }),
    d = {};
   ((e, t) => {
    for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
   })(d, { parsers: () => ce });
   var f = p(c(), 1);
   function m(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   m(/\s/);
   var y = m(' \t'),
    g = (m(',; \t'), m(/[^\n\r]/));
   var D = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var x = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ('\r' === e.charAt(t - 1) && '\n' === s) return t - 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t - 1;
    } else {
     if ('\r' === s && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t + 1;
    }
    return t;
   };
   var b = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? g(e, t) : t);
   };
   var v = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = y(e, n)), (n = D(e, n)), (n = b(e, n)), (n = x(e, n));
    return n;
   };
   var E = function (e) {
    let t = [];
    for (let n of e)
     try {
      return n();
     } catch (r) {
      t.push(r);
     }
    throw Object.assign(new Error('All combinations failed'), { errors: t });
   };
   var C = function (e) {
     if (!e.startsWith('#!')) return '';
     let t = e.indexOf('\n');
     return -1 === t ? e : e.slice(0, t);
    },
    T = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var S = function (e) {
    return Array.isArray(e) && e.length > 0;
   };
   function w(e) {
    var t, r, n;
    let s = (null == (t = e.range) ? void 0 : t[0]) ?? e.start,
     i = null == (n = (null == (r = e.declaration) ? void 0 : r.decorators) ?? e.decorators) ? void 0 : n[0];
    return i ? Math.min(w(i), s) : s;
   }
   function A(e) {
    var t;
    return (null == (t = e.range) ? void 0 : t[1]) ?? e.end;
   }
   var F = (function (e) {
    let t = new Set(e);
    return (e) => t.has(null == e ? void 0 : e.type);
   })(['Block', 'CommentBlock', 'MultiLine']);
   var k = function (e) {
    let t = `*${e.value}*`.split('\n');
    return t.length > 1 && t.every((e) => '*' === e.trimStart()[0]);
   };
   var P = function (e) {
     return F(e) && '*' === e.value[0] && /@(?:type|satisfies)\b/.test(e.value);
    },
    I = null;
   function N(e) {
    if (null !== I && (I.property, 1)) {
     let e = I;
     return (I = N.prototype = null), e;
    }
    return (I = N.prototype = e ?? Object.create(null)), new N();
   }
   for (let de = 0; de <= 10; de++) N();
   var B = (function (e, t = 'type') {
    return (
     (function (e) {
      N(e);
     })(e),
     function (r) {
      let n = r[t],
       s = e[n];
      if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
      return s;
     }
    );
   })({ ArrayExpression: ['elements'], AssignmentExpression: ['left', 'right'], BinaryExpression: ['left', 'right'], InterpreterDirective: [], Directive: ['value'], DirectiveLiteral: [], BlockStatement: ['directives', 'body'], BreakStatement: ['label'], CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], CatchClause: ['param', 'body'], ConditionalExpression: ['test', 'consequent', 'alternate'], ContinueStatement: ['label'], DebuggerStatement: [], DoWhileStatement: ['test', 'body'], EmptyStatement: [], ExpressionStatement: ['expression'], File: ['program'], ForInStatement: ['left', 'right', 'body'], ForStatement: ['init', 'test', 'update', 'body'], FunctionDeclaration: ['id', 'params', 'body', 'returnType', 'typeParameters', 'predicate'], FunctionExpression: ['id', 'params', 'body', 'returnType', 'typeParameters'], Identifier: ['typeAnnotation', 'decorators'], IfStatement: ['test', 'consequent', 'alternate'], LabeledStatement: ['label', 'body'], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ['left', 'right'], MemberExpression: ['object', 'property'], NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], Program: ['directives', 'body'], ObjectExpression: ['properties'], ObjectMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'], ObjectProperty: ['key', 'value', 'decorators'], RestElement: ['argument', 'typeAnnotation', 'decorators'], ReturnStatement: ['argument'], SequenceExpression: ['expressions'], ParenthesizedExpression: ['expression'], SwitchCase: ['test', 'consequent'], SwitchStatement: ['discriminant', 'cases'], ThisExpression: [], ThrowStatement: ['argument'], TryStatement: ['block', 'handler', 'finalizer'], UnaryExpression: ['argument'], UpdateExpression: ['argument'], VariableDeclaration: ['declarations'], VariableDeclarator: ['id', 'init'], WhileStatement: ['test', 'body'], WithStatement: ['object', 'body'], AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'], ArrayPattern: ['elements', 'typeAnnotation', 'decorators'], ArrowFunctionExpression: ['params', 'body', 'returnType', 'typeParameters', 'predicate'], ClassBody: ['body'], ClassExpression: ['id', 'body', 'superClass', 'mixins', 'typeParameters', 'superTypeParameters', 'implements', 'decorators', 'superTypeArguments'], ClassDeclaration: ['id', 'body', 'superClass', 'mixins', 'typeParameters', 'superTypeParameters', 'implements', 'decorators', 'superTypeArguments'], ExportAllDeclaration: ['source', 'attributes', 'exported'], ExportDefaultDeclaration: ['declaration'], ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], ExportSpecifier: ['local', 'exported'], ForOfStatement: ['left', 'right', 'body'], ImportDeclaration: ['specifiers', 'source', 'attributes'], ImportDefaultSpecifier: ['local'], ImportNamespaceSpecifier: ['local'], ImportSpecifier: ['local', 'imported'], ImportExpression: ['source', 'options', 'attributes'], MetaProperty: ['meta', 'property'], ClassMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'], ObjectPattern: ['properties', 'typeAnnotation', 'decorators'], SpreadElement: ['argument'], Super: [], TaggedTemplateExpression: ['tag', 'quasi', 'typeParameters', 'typeArguments'], TemplateElement: [], TemplateLiteral: ['quasis', 'expressions'], YieldExpression: ['argument'], AwaitExpression: ['argument'], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ['exported'], OptionalMemberExpression: ['object', 'property'], OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], ClassProperty: ['key', 'value', 'typeAnnotation', 'decorators', 'variance'], ClassAccessorProperty: ['key', 'value', 'typeAnnotation', 'decorators'], ClassPrivateProperty: ['key', 'value', 'decorators', 'typeAnnotation', 'variance'], ClassPrivateMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'], PrivateName: ['id'], StaticBlock: ['body'], AnyTypeAnnotation: [], ArrayTypeAnnotation: ['elementType'], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ['id', 'typeParameters'], DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'], DeclareFunction: ['id', 'predicate'], DeclareInterface: ['id', 'typeParameters', 'extends', 'body'], DeclareModule: ['id', 'body'], DeclareModuleExports: ['typeAnnotation'], DeclareTypeAlias: ['id', 'typeParameters', 'right'], DeclareOpaqueType: ['id', 'typeParameters', 'supertype'], DeclareVariable: ['id'], DeclareExportDeclaration: ['declaration', 'specifiers', 'source'], DeclareExportAllDeclaration: ['source'], DeclaredPredicate: ['value'], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ['typeParameters', 'params', 'rest', 'returnType', 'this'], FunctionTypeParam: ['name', 'typeAnnotation'], GenericTypeAnnotation: ['id', 'typeParameters'], InferredPredicate: [], InterfaceExtends: ['id', 'typeParameters'], InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], InterfaceTypeAnnotation: ['extends', 'body'], IntersectionTypeAnnotation: ['types'], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ['typeAnnotation'], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'], ObjectTypeInternalSlot: ['id', 'value', 'optional', 'static', 'method'], ObjectTypeCallProperty: ['value'], ObjectTypeIndexer: ['id', 'key', 'value', 'variance'], ObjectTypeProperty: ['key', 'value', 'variance'], ObjectTypeSpreadProperty: ['argument'], OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'], QualifiedTypeIdentifier: ['id', 'qualification'], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ['types', 'elementTypes'], TypeofTypeAnnotation: ['argument', 'typeArguments'], TypeAlias: ['id', 'typeParameters', 'right'], TypeAnnotation: ['typeAnnotation'], TypeCastExpression: ['expression', 'typeAnnotation'], TypeParameter: ['bound', 'default', 'variance'], TypeParameterDeclaration: ['params'], TypeParameterInstantiation: ['params'], UnionTypeAnnotation: ['types'], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ['id', 'body'], EnumBooleanBody: ['members'], EnumNumberBody: ['members'], EnumStringBody: ['members'], EnumSymbolBody: ['members'], EnumBooleanMember: ['id', 'init'], EnumNumberMember: ['id', 'init'], EnumStringMember: ['id', 'init'], EnumDefaultedMember: ['id'], IndexedAccessType: ['objectType', 'indexType'], OptionalIndexedAccessType: ['objectType', 'indexType'], JSXAttribute: ['name', 'value'], JSXClosingElement: ['name'], JSXElement: ['openingElement', 'children', 'closingElement'], JSXEmptyExpression: [], JSXExpressionContainer: ['expression'], JSXSpreadChild: ['expression'], JSXIdentifier: [], JSXMemberExpression: ['object', 'property'], JSXNamespacedName: ['namespace', 'name'], JSXOpeningElement: ['name', 'attributes', 'typeArguments', 'typeParameters'], JSXSpreadAttribute: ['argument'], JSXText: [], JSXFragment: ['openingFragment', 'children', 'closingFragment'], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ['object', 'callee'], ImportAttribute: ['key', 'value'], Decorator: ['expression'], DoExpression: ['body'], ExportDefaultSpecifier: ['exported'], RecordExpression: ['properties'], TupleExpression: ['elements'], DecimalLiteral: [], ModuleExpression: ['body'], TopicReference: [], PipelineTopicExpression: ['expression'], PipelineBareFunction: ['callee'], PipelinePrimaryTopicReference: [], TSParameterProperty: ['parameter', 'decorators'], TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'], TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'], TSQualifiedName: ['left', 'right'], TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSPropertySignature: ['key', 'typeAnnotation'], TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSIndexSignature: ['parameters', 'typeAnnotation'], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'], TSTypePredicate: ['parameterName', 'typeAnnotation'], TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'], TSTypeLiteral: ['members'], TSArrayType: ['elementType'], TSTupleType: ['elementTypes'], TSOptionalType: ['typeAnnotation'], TSRestType: ['typeAnnotation'], TSNamedTupleMember: ['label', 'elementType'], TSUnionType: ['types'], TSIntersectionType: ['types'], TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'], TSInferType: ['typeParameter'], TSParenthesizedType: ['typeAnnotation'], TSTypeOperator: ['typeAnnotation'], TSIndexedAccessType: ['objectType', 'indexType'], TSMappedType: ['typeParameter', 'typeAnnotation', 'nameType'], TSLiteralType: ['literal'], TSExpressionWithTypeArguments: ['expression', 'typeParameters'], TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], TSInterfaceBody: ['body'], TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'], TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'], TSAsExpression: ['expression', 'typeAnnotation'], TSSatisfiesExpression: ['expression', 'typeAnnotation'], TSTypeAssertion: ['typeAnnotation', 'expression'], TSEnumDeclaration: ['id', 'members'], TSEnumMember: ['id', 'initializer'], TSModuleDeclaration: ['id', 'body'], TSModuleBlock: ['body'], TSImportType: ['argument', 'qualifier', 'typeParameters', 'typeArguments'], TSImportEqualsDeclaration: ['id', 'moduleReference'], TSExternalModuleReference: ['expression'], TSNonNullExpression: ['expression'], TSExportAssignment: ['expression'], TSNamespaceExportDeclaration: ['id'], TSTypeAnnotation: ['typeAnnotation'], TSTypeParameterInstantiation: ['params'], TSTypeParameterDeclaration: ['params'], TSTypeParameter: ['constraint', 'default', 'name'], ChainExpression: ['expression'], ExperimentalRestProperty: ['argument'], ExperimentalSpreadProperty: ['argument'], Literal: [], MethodDefinition: ['decorators', 'key', 'value'], PrivateIdentifier: [], Property: ['key', 'value'], PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'], AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'], TSAbstractKeyword: [], TSAbstractMethodDefinition: ['key', 'value'], TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'], TSAsyncKeyword: [], TSClassImplements: ['expression', 'typeArguments', 'typeParameters'], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'], TSExportKeyword: [], TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ['quasis', 'types'], AsConstExpression: ['expression'], AsExpression: ['expression', 'typeAnnotation'], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ['id', 'params', 'body', 'typeParameters', 'rendersType'], ComponentParameter: ['name', 'local'], ComponentTypeAnnotation: ['params', 'rest', 'typeParameters', 'rendersType'], ComponentTypeParameter: ['name', 'typeAnnotation'], ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'], DeclareComponent: ['id', 'params', 'rest', 'typeParameters', 'rendersType'], DeclareEnum: ['id', 'body'], DeclareHook: ['id'], DeclareNamespace: ['id', 'body'], EnumBigIntBody: ['members'], EnumBigIntMember: ['id', 'init'], HookDeclaration: ['id', 'params', 'body', 'typeParameters', 'returnType'], HookTypeAnnotation: ['params', 'returnType', 'rest', 'typeParameters'], InferTypeAnnotation: ['typeParameter'], KeyofTypeAnnotation: ['argument'], ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'], QualifiedTypeofIdentifier: ['qualification', 'id'], TupleTypeLabeledElement: ['label', 'elementType', 'variance'], TupleTypeSpreadElement: ['label', 'typeAnnotation'], TypeOperator: ['typeAnnotation'], TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'], NGRoot: ['node'], NGPipeExpression: ['left', 'right', 'arguments'], NGChainedExpression: ['expressions'], NGEmptyExpression: [], NGMicrosyntax: ['body'], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ['expression', 'alias'], NGMicrosyntaxKeyedExpression: ['key', 'expression'], NGMicrosyntaxLet: ['key', 'value'], NGMicrosyntaxAs: ['key', 'alias'], JsExpressionRoot: ['node'], JsonRoot: ['node'], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ['typeAnnotation'], TSJSDocNonNullableType: ['typeAnnotation'], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ['expression', 'typeAnnotation'] });
   var _ = function e(t, r) {
    if (null === t || 'object' != typeof t) return t;
    if (Array.isArray(t)) {
     for (let n = 0; n < t.length; n++) t[n] = e(t[n], r);
     return t;
    }
    let n = B(t);
    for (let s = 0; s < n.length; s++) t[n[s]] = e(t[n[s]], r);
    return r(t) || t;
   };
   function L(e) {
    return 'LogicalExpression' === e.type && 'LogicalExpression' === e.right.type && e.operator === e.right.operator;
   }
   function O(e) {
    return L(e) ? O({ type: 'LogicalExpression', operator: e.operator, left: O({ type: 'LogicalExpression', operator: e.operator, left: e.left, right: e.right.left, range: [w(e.left), A(e.right.left)] }), right: e.right.right, range: [w(e), A(e)] }) : e;
   }
   var M = function (e, t) {
    let { parser: r, text: n } = t;
    if ('File' === e.type && e.program.interpreter) {
     let {
      program: { interpreter: t },
      comments: r,
     } = e;
     delete e.program.interpreter, r.unshift(t);
    }
    if ('babel' === r) {
     let t = new Set();
     (e = _(e, (e) => {
      var r;
      null != (r = e.leadingComments) && r.some(P) && t.add(w(e));
     })),
      (e = _(e, (e) => {
       if ('ParenthesizedExpression' === e.type) {
        let { expression: r } = e;
        if ('TypeCastExpression' === r.type) return (r.range = [...e.range]), r;
        let n = w(e);
        if (!t.has(n)) return (r.extra = { ...r.extra, parenthesized: !0 }), r;
       }
      }));
    }
    if (
     ((e = _(e, (t) => {
      var s;
      switch (t.type) {
       case 'LogicalExpression':
        if (L(t)) return O(t);
        break;
       case 'VariableDeclaration': {
        let e = T(!1, t.declarations, -1);
        null != e && e.init && ';' !== n[A(e)] && (t.range = [w(t), A(e)]);
        break;
       }
       case 'TSParenthesizedType':
        return t.typeAnnotation;
       case 'TSTypeParameter':
        if ('string' == typeof t.name) {
         let e = w(t);
         t.name = { type: 'Identifier', name: t.name, range: [e, e + t.name.length] };
        }
        break;
       case 'TopicReference':
        e.extra = { ...e.extra, __isUsingHackPipeline: !0 };
        break;
       case 'ExportAllDeclaration':
        if ('meriyah' === r && 'Identifier' === (null == (s = t.exported) ? void 0 : s.type)) {
         let { exported: e } = t,
          r = n.slice(w(e), A(e));
         (r.startsWith('"') || r.startsWith("'")) && (t.exported = { ...t.exported, type: 'Literal', value: t.exported.name, raw: r });
        }
        break;
       case 'TSUnionType':
       case 'TSIntersectionType':
        if (1 === t.types.length) return t.types[0];
      }
     })),
     S(e.comments))
    ) {
     let t = T(!1, e.comments, -1);
     for (let r = e.comments.length - 2; r >= 0; r--) {
      let n = e.comments[r];
      A(n) === w(t) && F(n) && F(t) && k(n) && k(t) && (e.comments.splice(r + 1, 1), (n.value += '*//*' + t.value), (n.range = [w(n), A(t)])), (t = n);
     }
    }
    return 'Program' === e.type && (e.range = [0, n.length]), e;
   };
   var j = function (e, t) {
    let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
    return Object.assign(r, t);
   };
   var R = function (e) {
     let {
       message: t,
       loc: { line: r, column: n },
       reasonCode: s,
      } = e,
      i = e;
     ('MissingPlugin' === s || 'MissingOneOfPlugins' === s) && ((t = 'Unexpected token.'), (i = void 0));
     let a = ` (${r}:${n})`;
     return t.endsWith(a) && (t = t.slice(0, -a.length)), j(t, { loc: { start: { line: r, column: n + 1 } }, cause: i });
    },
    q = p(h(), 1);
   function U(e) {
    let { pragmas: t } = (function (e) {
     let t = C(e);
     t && (e = e.slice(t.length + 1));
     let r = (0, q.extract)(e),
      { pragmas: n, comments: s } = (0, q.parseWithComments)(r);
     return { shebang: t, text: e, pragmas: n, comments: s };
    })(e);
    return Object.prototype.hasOwnProperty.call(t, 'prettier') || Object.prototype.hasOwnProperty.call(t, 'format');
   }
   var $ = function (e) {
    return (e = 'function' == typeof e ? { parse: e } : e), { astFormat: 'estree', hasPragma: U, locStart: w, locEnd: A, ...e };
   };
   var H = function (e) {
    let { filepath: t } = e;
    if (t) {
     if (((t = t.toLowerCase()), t.endsWith('.cjs'))) return 'script';
     if (t.endsWith('.mjs')) return 'module';
    }
   };
   var z = function (e, t) {
     let { type: r = 'JsExpressionRoot', rootMarker: n, text: s } = t,
      { tokens: i, comments: a } = e;
     return delete e.tokens, delete e.comments, { tokens: i, comments: a, type: r, node: e, range: [0, s.length], rootMarker: n };
    },
    V = (e) =>
     $(
      (function ({ isExpression: e = !1, optionsCombinations: t }) {
       return (r, n = {}) => {
        if (
         ('babel' === n.parser || '__babel_estree' === n.parser) &&
         (function (e, t) {
          var r;
          if (null != (r = t.filepath) && r.endsWith('.js.flow')) return !0;
          let n = C(e);
          n && (e = e.slice(n.length));
          let s = v(e, 0);
          return !1 !== s && (e = e.slice(0, s)), X.test(e);
         })(r, n)
        )
         return (n.parser = 'babel-flow'), ne.parse(r, n);
        let s = t;
        'script' === (n.__babelSourceType ?? H(n)) && (s = s.map((e) => ({ ...e, sourceType: 'script' })));
        let i = /%[A-Z]/.test(r);
        r.includes('|>') ? (s = (i ? [...K, J] : K).flatMap((e) => s.map((t) => G([e], t)))) : i && (s = s.map((e) => G([J], e)));
        let a,
         o = e ? f.parseExpression : f.parse;
        try {
         a = E(
          s.map(
           (e) => () =>
            (function (e, t, r) {
             let n = e(t, r),
              s = n.errors.find((e) => !Y.has(e.reasonCode));
             if (s) throw s;
             return n;
            })(o, r, e),
          ),
         );
        } catch ({ errors: [u] }) {
         throw R(u);
        }
        return e && (a = z(a, { text: r, rootMarker: n.rootMarker })), M(a, { parser: 'babel', text: r });
       };
      })(e),
     ),
    W = { sourceType: 'module', allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, plugins: ['doExpressions', 'exportDefaultFrom', 'functionBind', 'functionSent', 'throwExpressions', 'partialApplication', 'decorators', 'decimal', 'moduleBlocks', 'asyncDoExpressions', 'regexpUnicodeSets', 'destructuringPrivate', 'decoratorAutoAccessors', 'importReflection', 'explicitResourceManagement', ['importAttributes', { deprecatedAssertSyntax: !0 }], 'sourcePhaseImports', 'deferredImportEvaluation', ['optionalChainingAssign', { version: '2023-07' }], 'recordAndTuple'], tokens: !0, ranges: !0 },
    J = 'v8intrinsic',
    K = [
     ['pipelineOperator', { proposal: 'hack', topicToken: '%' }],
     ['pipelineOperator', { proposal: 'minimal' }],
     ['pipelineOperator', { proposal: 'fsharp' }],
    ],
    G = (e, t = W) => ({ ...t, plugins: [...t.plugins, ...e] }),
    X = /@(?:no)?flow\b/;
   var Y = new Set(['StrictNumericEscape', 'StrictWith', 'StrictOctalLiteral', 'StrictDelete', 'StrictEvalArguments', 'StrictEvalArgumentsBinding', 'StrictFunction', 'EmptyTypeArguments', 'EmptyTypeParameters', 'ConstructorHasTypeParameters', 'UnsupportedParameterPropertyKind', 'DecoratorExportClass', 'ParamDupe', 'InvalidDecimal', 'RestTrailingComma', 'UnsupportedParameterDecorator', 'UnterminatedJsxContent', 'UnexpectedReservedWord', 'ModuleAttributesWithDuplicateKeys', 'LineTerminatorBeforeArrow', 'InvalidEscapeSequenceTemplate', 'NonAbstractClassHasAbstractMethod', 'OptionalTypeBeforeRequired', 'PatternIsOptional', 'OptionalBindingPattern', 'DeclareClassFieldHasInitializer', 'TypeImportCannotSpecifyDefaultAndNamed', 'ConstructorClassField', 'VarRedeclaration', 'InvalidPrivateFieldResolution', 'DuplicateExport']),
    Q = [G(['jsx'])],
    Z = V({ optionsCombinations: Q }),
    ee = V({ optionsCombinations: [G(['jsx', 'typescript']), G(['typescript'])] }),
    te = V({ isExpression: !0, optionsCombinations: [G(['jsx'])] }),
    re = V({ isExpression: !0, optionsCombinations: [G(['typescript'])] }),
    ne = V({ optionsCombinations: [G(['jsx', ['flow', { all: !0, enums: !0 }], 'flowComments'])] }),
    se = V({ optionsCombinations: Q.map((e) => G(['estree'], e)) }),
    ie = { babel: Z, 'babel-flow': ne, 'babel-ts': ee, __js_expression: te, __ts_expression: re, __vue_expression: te, __vue_ts_expression: re, __vue_event_binding: Z, __vue_ts_event_binding: ee, __babel_estree: se },
    ae = p(c(), 1);
   function oe(e = {}) {
    let { allowComments: t = !0 } = e;
    return function (e) {
     let r;
     try {
      r = (0, ae.parseExpression)(e, { tokens: !0, ranges: !0, attachComment: !1 });
     } catch (n) {
      throw R(n);
     }
     if (!t && S(r.comments)) throw ue(r.comments[0], 'Comment');
     return le(r), z(r, { type: 'JsonRoot', text: e });
    };
   }
   function ue(e, t) {
    let [r, n] = [e.loc.start, e.loc.end].map(({ line: e, column: t }) => ({ line: e, column: t + 1 }));
    return j(`${t} is not allowed in JSON.`, { loc: { start: r, end: n } });
   }
   function le(e) {
    switch (e.type) {
     case 'ArrayExpression':
      for (let t of e.elements) null !== t && le(t);
      return;
     case 'ObjectExpression':
      for (let t of e.properties) le(t);
      return;
     case 'ObjectProperty':
      if (e.computed) throw ue(e.key, 'Computed key');
      if (e.shorthand) throw ue(e.key, 'Shorthand property');
      return 'Identifier' !== e.key.type && le(e.key), void le(e.value);
     case 'UnaryExpression': {
      let { operator: t, argument: r } = e;
      if ('+' !== t && '-' !== t) throw ue(e, `Operator '${e.operator}'`);
      if ('NumericLiteral' === r.type || ('Identifier' === r.type && ('Infinity' === r.name || 'NaN' === r.name))) return;
      throw ue(r, `Operator '${t}' before '${r.type}'`);
     }
     case 'Identifier':
      if ('Infinity' !== e.name && 'NaN' !== e.name && 'undefined' !== e.name) throw ue(e, `Identifier '${e.name}'`);
      return;
     case 'TemplateLiteral':
      if (S(e.expressions)) throw ue(e.expressions[0], "'TemplateLiteral' with expression");
      for (let t of e.quasis) le(t);
      return;
     case 'NullLiteral':
     case 'BooleanLiteral':
     case 'NumericLiteral':
     case 'StringLiteral':
     case 'TemplateElement':
      return;
     default:
      throw ue(e, `'${e.type}'`);
    }
   }
   var pe = oe(),
    ce = { ...ie, ...{ json: $({ parse: pe, hasPragma: () => !0 }), json5: $(pe), jsonc: $(pe), 'json-stringify': $({ parse: oe({ allowComments: !1 }), astFormat: 'estree-json' }) } },
    he = d;
  },
  65420: (e, t, r) => {
   r.d(t, { ZP: () => Lo });
   var n,
    s,
    i = Object.create,
    a = Object.defineProperty,
    o = Object.getOwnPropertyDescriptor,
    u = Object.getOwnPropertyNames,
    l = Object.getPrototypeOf,
    p = Object.prototype.hasOwnProperty,
    c = (e) => {
     throw TypeError(e);
    },
    h = (e, t) => {
     for (var r in t) a(e, r, { get: t[r], enumerable: !0 });
    },
    d = (e, t, r) => t.has(e) || c('Cannot ' + r),
    f = (e, t, r) => (d(e, t, 'read from private field'), r ? r.call(e) : t.get(e)),
    m =
     ((n = (e) => {
      Object.defineProperty(e, '__esModule', { value: !0 }),
       (e.extract = function (e) {
        let t = e.match(n);
        return t ? t[0].trimLeft() : '';
       }),
       (e.parse = function (e) {
        return p(e).pragmas;
       }),
       (e.parseWithComments = p),
       (e.print = function ({ comments: e = '', pragmas: t = {} }) {
        let r = '\n',
         n = ' *',
         s = Object.keys(t),
         i = s
          .flatMap((e) => c(e, t[e]))
          .map((e) => `${n} ${e}${r}`)
          .join('');
        if (!e) {
         if (0 === s.length) return '';
         if (1 === s.length && !Array.isArray(t[s[0]])) {
          let e = t[s[0]];
          return `/** ${c(s[0], e)[0]} */`;
         }
        }
        let a =
         e
          .split(r)
          .map((e) => `${n} ${e}`)
          .join(r) + r;
        return '/**\n' + (e ? a : '') + (e && s.length ? n + r : '') + i + ' */';
       }),
       (e.strip = function (e) {
        let t = e.match(n);
        return t && t[0] ? e.substring(t[0].length) : e;
       });
      var t = /\*\/$/,
       r = /^\/\*\*?/,
       n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
       s = /(^|\s+)\/\/([^\r\n]*)/g,
       i = /^(\r?\n)+/,
       a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
       o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
       u = /(\r?\n|^) *\* ?/g,
       l = [];
      function p(e) {
       e = e.replace(r, '').replace(t, '').replace(u, '$1');
       let n = '';
       for (; n !== e; ) (n = e), (e = e.replace(a, '\n$1 $2\n'));
       e = e.replace(i, '').trimRight();
       let p,
        c = Object.create(null),
        h = e.replace(o, '').replace(i, '').trimRight();
       for (; (p = o.exec(e)); ) {
        let e = p[2].replace(s, '');
        'string' == typeof c[p[1]] || Array.isArray(c[p[1]]) ? (c[p[1]] = l.concat(c[p[1]], e)) : (c[p[1]] = e);
       }
       return { comments: h, pragmas: c };
      }
      function c(e, t) {
       return l.concat(t).map((t) => `@${e} ${t}`.trim());
      }
     }),
     () => (s || n((s = { exports: {} }).exports, s), s.exports)),
    y = {};
   h(y, { languages: () => _o, options: () => No, printers: () => Bo });
   var g = {};
   h(g, { canAttachComment: () => vn, embed: () => ns, experimentalFeatures: () => Co, getCommentChildNodes: () => En, getVisitorKeys: () => J, handleComments: () => Er, insertPragma: () => as, isBlockComment: () => G, isGap: () => Tn, massageAstNode: () => gt, print: () => Eo, printComment: () => vr, willPrintOwnComments: () => Cn });
   var D = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    x = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var b = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function* v(e, t) {
    let { getVisitorKeys: r, filter: n = () => !0 } = t,
     s = (e) => b(e) && n(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) s(e) && (yield e);
     else s(t) && (yield t);
    }
   }
   function E(e, { getVisitorKeys: t, predicate: r }) {
    for (let n of (function* (e, t) {
     let r = [e];
     for (let n = 0; n < r.length; n++) {
      let e = r[n];
      for (let n of v(e, t)) yield n, r.push(n);
     }
    })(e, { getVisitorKeys: t }))
     if (r(n)) return !0;
    return !1;
   }
   var C = (e) =>
     !(
      (function (e) {
       return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
      })(e) ||
      (function (e) {
       return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9800 && e <= 9811) || 9855 === e || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12771) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 19903) || (e >= 19968 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || 94192 === e || 94193 === e || (e >= 94208 && e <= 100343) || (e >= 100352 && e <= 101589) || (e >= 101632 && e <= 101640) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128727) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129672) || (e >= 129680 && e <= 129725) || (e >= 129727 && e <= 129733) || (e >= 129742 && e <= 129755) || (e >= 129760 && e <= 129768) || (e >= 129776 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
      })(e)
     ),
    T = /[^\x20-\x7F]/;
   var S = function (e) {
    if (!e) return 0;
    if (!T.test(e)) return e.length;
    e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, '  ');
    let t = 0;
    for (let r of e) {
     let e = r.codePointAt(0);
     e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (t += C(e) ? 1 : 2);
    }
    return t;
   };
   function w(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   w(/\s/);
   var A = w(' \t'),
    F = w(',; \t'),
    k = w(/[^\n\r]/);
   var P = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ('\r' === e.charAt(t - 1) && '\n' === s) return t - 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t - 1;
    } else {
     if ('\r' === s && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t + 1;
    }
    return t;
   };
   var I = function (e, t, r = {}) {
    let n = A(e, r.backwards ? t - 1 : t, r);
    return n !== P(e, n, r);
   };
   var N = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var B = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? k(e, t) : t);
   };
   var _ = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = F(e, n)), (n = N(e, n)), (n = A(e, n));
    return (n = B(e, n)), (n = P(e, n)), !1 !== n && I(e, n);
   };
   var L = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    O = "'";
   var M = function (e, t) {
    let r = !0 === t || t === O ? O : '"',
     n = r === O ? '"' : O,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var j = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = D(!1, e, /\\(.)|(["'])/gs, (e, s, i) => (s === n ? s : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s) ? s : '\\' + s)));
    return t + s + t;
   };
   var R = function (e, t) {
    let r = e.slice(1, -1),
     n = 'json' === t.parser || 'jsonc' === t.parser || ('json5' === t.parser && 'preserve' === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : M(r, t.singleQuote);
    return j(r, n, !('css' === t.parser || 'less' === t.parser || 'scss' === t.parser || t.__embeddedInHtml));
   };
   function q(e) {
    var t, r, n;
    let s = (null == (t = e.range) ? void 0 : t[0]) ?? e.start,
     i = null == (n = (null == (r = e.declaration) ? void 0 : r.decorators) ?? e.decorators) ? void 0 : n[0];
    return i ? Math.min(q(i), s) : s;
   }
   function U(e) {
    var t;
    return (null == (t = e.range) ? void 0 : t[1]) ?? e.end;
   }
   function $(e, t) {
    let r = q(e);
    return Number.isInteger(r) && r === q(t);
   }
   function H(e, t) {
    return (
     $(e, t) &&
     (function (e, t) {
      let r = U(e);
      return Number.isInteger(r) && r === U(t);
     })(e, t)
    );
   }
   var z = null;
   function V(e) {
    if (null !== z && (z.property, 1)) {
     let e = z;
     return (z = V.prototype = null), e;
    }
    return (z = V.prototype = e ?? Object.create(null)), new V();
   }
   for (let Oo = 0; Oo <= 10; Oo++) V();
   var W = function (e, t = 'type') {
     return (
      (function (e) {
       V(e);
      })(e),
      function (r) {
       let n = r[t],
        s = e[n];
       if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
       return s;
      }
     );
    },
    J = W({ ArrayExpression: ['elements'], AssignmentExpression: ['left', 'right'], BinaryExpression: ['left', 'right'], InterpreterDirective: [], Directive: ['value'], DirectiveLiteral: [], BlockStatement: ['directives', 'body'], BreakStatement: ['label'], CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], CatchClause: ['param', 'body'], ConditionalExpression: ['test', 'consequent', 'alternate'], ContinueStatement: ['label'], DebuggerStatement: [], DoWhileStatement: ['test', 'body'], EmptyStatement: [], ExpressionStatement: ['expression'], File: ['program'], ForInStatement: ['left', 'right', 'body'], ForStatement: ['init', 'test', 'update', 'body'], FunctionDeclaration: ['id', 'params', 'body', 'returnType', 'typeParameters', 'predicate'], FunctionExpression: ['id', 'params', 'body', 'returnType', 'typeParameters'], Identifier: ['typeAnnotation', 'decorators'], IfStatement: ['test', 'consequent', 'alternate'], LabeledStatement: ['label', 'body'], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ['left', 'right'], MemberExpression: ['object', 'property'], NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], Program: ['directives', 'body'], ObjectExpression: ['properties'], ObjectMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'], ObjectProperty: ['key', 'value', 'decorators'], RestElement: ['argument', 'typeAnnotation', 'decorators'], ReturnStatement: ['argument'], SequenceExpression: ['expressions'], ParenthesizedExpression: ['expression'], SwitchCase: ['test', 'consequent'], SwitchStatement: ['discriminant', 'cases'], ThisExpression: [], ThrowStatement: ['argument'], TryStatement: ['block', 'handler', 'finalizer'], UnaryExpression: ['argument'], UpdateExpression: ['argument'], VariableDeclaration: ['declarations'], VariableDeclarator: ['id', 'init'], WhileStatement: ['test', 'body'], WithStatement: ['object', 'body'], AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'], ArrayPattern: ['elements', 'typeAnnotation', 'decorators'], ArrowFunctionExpression: ['params', 'body', 'returnType', 'typeParameters', 'predicate'], ClassBody: ['body'], ClassExpression: ['id', 'body', 'superClass', 'mixins', 'typeParameters', 'superTypeParameters', 'implements', 'decorators', 'superTypeArguments'], ClassDeclaration: ['id', 'body', 'superClass', 'mixins', 'typeParameters', 'superTypeParameters', 'implements', 'decorators', 'superTypeArguments'], ExportAllDeclaration: ['source', 'attributes', 'exported'], ExportDefaultDeclaration: ['declaration'], ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], ExportSpecifier: ['local', 'exported'], ForOfStatement: ['left', 'right', 'body'], ImportDeclaration: ['specifiers', 'source', 'attributes'], ImportDefaultSpecifier: ['local'], ImportNamespaceSpecifier: ['local'], ImportSpecifier: ['local', 'imported'], ImportExpression: ['source', 'options', 'attributes'], MetaProperty: ['meta', 'property'], ClassMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'], ObjectPattern: ['properties', 'typeAnnotation', 'decorators'], SpreadElement: ['argument'], Super: [], TaggedTemplateExpression: ['tag', 'quasi', 'typeParameters', 'typeArguments'], TemplateElement: [], TemplateLiteral: ['quasis', 'expressions'], YieldExpression: ['argument'], AwaitExpression: ['argument'], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ['exported'], OptionalMemberExpression: ['object', 'property'], OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], ClassProperty: ['key', 'value', 'typeAnnotation', 'decorators', 'variance'], ClassAccessorProperty: ['key', 'value', 'typeAnnotation', 'decorators'], ClassPrivateProperty: ['key', 'value', 'decorators', 'typeAnnotation', 'variance'], ClassPrivateMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'], PrivateName: ['id'], StaticBlock: ['body'], AnyTypeAnnotation: [], ArrayTypeAnnotation: ['elementType'], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ['id', 'typeParameters'], DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'], DeclareFunction: ['id', 'predicate'], DeclareInterface: ['id', 'typeParameters', 'extends', 'body'], DeclareModule: ['id', 'body'], DeclareModuleExports: ['typeAnnotation'], DeclareTypeAlias: ['id', 'typeParameters', 'right'], DeclareOpaqueType: ['id', 'typeParameters', 'supertype'], DeclareVariable: ['id'], DeclareExportDeclaration: ['declaration', 'specifiers', 'source'], DeclareExportAllDeclaration: ['source'], DeclaredPredicate: ['value'], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ['typeParameters', 'params', 'rest', 'returnType', 'this'], FunctionTypeParam: ['name', 'typeAnnotation'], GenericTypeAnnotation: ['id', 'typeParameters'], InferredPredicate: [], InterfaceExtends: ['id', 'typeParameters'], InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], InterfaceTypeAnnotation: ['extends', 'body'], IntersectionTypeAnnotation: ['types'], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ['typeAnnotation'], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'], ObjectTypeInternalSlot: ['id', 'value', 'optional', 'static', 'method'], ObjectTypeCallProperty: ['value'], ObjectTypeIndexer: ['id', 'key', 'value', 'variance'], ObjectTypeProperty: ['key', 'value', 'variance'], ObjectTypeSpreadProperty: ['argument'], OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'], QualifiedTypeIdentifier: ['id', 'qualification'], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ['types', 'elementTypes'], TypeofTypeAnnotation: ['argument', 'typeArguments'], TypeAlias: ['id', 'typeParameters', 'right'], TypeAnnotation: ['typeAnnotation'], TypeCastExpression: ['expression', 'typeAnnotation'], TypeParameter: ['bound', 'default', 'variance'], TypeParameterDeclaration: ['params'], TypeParameterInstantiation: ['params'], UnionTypeAnnotation: ['types'], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ['id', 'body'], EnumBooleanBody: ['members'], EnumNumberBody: ['members'], EnumStringBody: ['members'], EnumSymbolBody: ['members'], EnumBooleanMember: ['id', 'init'], EnumNumberMember: ['id', 'init'], EnumStringMember: ['id', 'init'], EnumDefaultedMember: ['id'], IndexedAccessType: ['objectType', 'indexType'], OptionalIndexedAccessType: ['objectType', 'indexType'], JSXAttribute: ['name', 'value'], JSXClosingElement: ['name'], JSXElement: ['openingElement', 'children', 'closingElement'], JSXEmptyExpression: [], JSXExpressionContainer: ['expression'], JSXSpreadChild: ['expression'], JSXIdentifier: [], JSXMemberExpression: ['object', 'property'], JSXNamespacedName: ['namespace', 'name'], JSXOpeningElement: ['name', 'attributes', 'typeArguments', 'typeParameters'], JSXSpreadAttribute: ['argument'], JSXText: [], JSXFragment: ['openingFragment', 'children', 'closingFragment'], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ['object', 'callee'], ImportAttribute: ['key', 'value'], Decorator: ['expression'], DoExpression: ['body'], ExportDefaultSpecifier: ['exported'], RecordExpression: ['properties'], TupleExpression: ['elements'], DecimalLiteral: [], ModuleExpression: ['body'], TopicReference: [], PipelineTopicExpression: ['expression'], PipelineBareFunction: ['callee'], PipelinePrimaryTopicReference: [], TSParameterProperty: ['parameter', 'decorators'], TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'], TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'], TSQualifiedName: ['left', 'right'], TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSPropertySignature: ['key', 'typeAnnotation'], TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSIndexSignature: ['parameters', 'typeAnnotation'], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'], TSTypePredicate: ['parameterName', 'typeAnnotation'], TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'], TSTypeLiteral: ['members'], TSArrayType: ['elementType'], TSTupleType: ['elementTypes'], TSOptionalType: ['typeAnnotation'], TSRestType: ['typeAnnotation'], TSNamedTupleMember: ['label', 'elementType'], TSUnionType: ['types'], TSIntersectionType: ['types'], TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'], TSInferType: ['typeParameter'], TSParenthesizedType: ['typeAnnotation'], TSTypeOperator: ['typeAnnotation'], TSIndexedAccessType: ['objectType', 'indexType'], TSMappedType: ['typeParameter', 'typeAnnotation', 'nameType'], TSLiteralType: ['literal'], TSExpressionWithTypeArguments: ['expression', 'typeParameters'], TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], TSInterfaceBody: ['body'], TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'], TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'], TSAsExpression: ['expression', 'typeAnnotation'], TSSatisfiesExpression: ['expression', 'typeAnnotation'], TSTypeAssertion: ['typeAnnotation', 'expression'], TSEnumDeclaration: ['id', 'members'], TSEnumMember: ['id', 'initializer'], TSModuleDeclaration: ['id', 'body'], TSModuleBlock: ['body'], TSImportType: ['argument', 'qualifier', 'typeParameters', 'typeArguments'], TSImportEqualsDeclaration: ['id', 'moduleReference'], TSExternalModuleReference: ['expression'], TSNonNullExpression: ['expression'], TSExportAssignment: ['expression'], TSNamespaceExportDeclaration: ['id'], TSTypeAnnotation: ['typeAnnotation'], TSTypeParameterInstantiation: ['params'], TSTypeParameterDeclaration: ['params'], TSTypeParameter: ['constraint', 'default', 'name'], ChainExpression: ['expression'], ExperimentalRestProperty: ['argument'], ExperimentalSpreadProperty: ['argument'], Literal: [], MethodDefinition: ['decorators', 'key', 'value'], PrivateIdentifier: [], Property: ['key', 'value'], PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'], AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'], TSAbstractKeyword: [], TSAbstractMethodDefinition: ['key', 'value'], TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'], TSAsyncKeyword: [], TSClassImplements: ['expression', 'typeArguments', 'typeParameters'], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'], TSExportKeyword: [], TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ['quasis', 'types'], AsConstExpression: ['expression'], AsExpression: ['expression', 'typeAnnotation'], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ['id', 'params', 'body', 'typeParameters', 'rendersType'], ComponentParameter: ['name', 'local'], ComponentTypeAnnotation: ['params', 'rest', 'typeParameters', 'rendersType'], ComponentTypeParameter: ['name', 'typeAnnotation'], ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'], DeclareComponent: ['id', 'params', 'rest', 'typeParameters', 'rendersType'], DeclareEnum: ['id', 'body'], DeclareHook: ['id'], DeclareNamespace: ['id', 'body'], EnumBigIntBody: ['members'], EnumBigIntMember: ['id', 'init'], HookDeclaration: ['id', 'params', 'body', 'typeParameters', 'returnType'], HookTypeAnnotation: ['params', 'returnType', 'rest', 'typeParameters'], InferTypeAnnotation: ['typeParameter'], KeyofTypeAnnotation: ['argument'], ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'], QualifiedTypeofIdentifier: ['qualification', 'id'], TupleTypeLabeledElement: ['label', 'elementType', 'variance'], TupleTypeSpreadElement: ['label', 'typeAnnotation'], TypeOperator: ['typeAnnotation'], TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'], NGRoot: ['node'], NGPipeExpression: ['left', 'right', 'arguments'], NGChainedExpression: ['expressions'], NGEmptyExpression: [], NGMicrosyntax: ['body'], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ['expression', 'alias'], NGMicrosyntaxKeyedExpression: ['key', 'expression'], NGMicrosyntaxLet: ['key', 'value'], NGMicrosyntaxAs: ['key', 'alias'], JsExpressionRoot: ['node'], JsonRoot: ['node'], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ['typeAnnotation'], TSJSDocNonNullableType: ['typeAnnotation'], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ['expression', 'typeAnnotation'] });
   var K = function (e) {
     let t = new Set(e);
     return (e) => t.has(null == e ? void 0 : e.type);
    },
    G = K(['Block', 'CommentBlock', 'MultiLine']),
    X = K(['AnyTypeAnnotation', 'ThisTypeAnnotation', 'NumberTypeAnnotation', 'VoidTypeAnnotation', 'BooleanTypeAnnotation', 'BigIntTypeAnnotation', 'SymbolTypeAnnotation', 'StringTypeAnnotation', 'NeverTypeAnnotation', 'UndefinedTypeAnnotation', 'UnknownTypeAnnotation', 'EmptyTypeAnnotation', 'MixedTypeAnnotation']);
   var Y = function (e, t) {
    return t.some((t) =>
     (function (e, t) {
      let r = t.split('.');
      for (let n = r.length - 1; n >= 0; n--) {
       let t = r[n];
       if (0 === n) return 'Identifier' === e.type && e.name === t;
       if ('MemberExpression' !== e.type || e.optional || e.computed || 'Identifier' !== e.property.type || e.property.name !== t) return !1;
       e = e.object;
      }
     })(e, t),
    );
   };
   var Q = function ({ type: e }) {
    return e.startsWith('TS') && e.endsWith('Keyword');
   };
   function Z(e, t) {
    return t(e) || E(e, { getVisitorKeys: J, predicate: t });
   }
   function ee(e) {
    return 'AssignmentExpression' === e.type || 'BinaryExpression' === e.type || 'LogicalExpression' === e.type || 'NGPipeExpression' === e.type || 'ConditionalExpression' === e.type || we(e) || Ae(e) || 'SequenceExpression' === e.type || 'TaggedTemplateExpression' === e.type || 'BindExpression' === e.type || ('UpdateExpression' === e.type && !e.prefix) || ct(e) || 'TSNonNullExpression' === e.type || 'ChainExpression' === e.type;
   }
   function te(e) {
    return e.expressions ? e.expressions[0] : e.left ?? e.test ?? e.callee ?? e.object ?? e.tag ?? e.argument ?? e.expression;
   }
   function re(e) {
    if (e.expressions) return ['expressions', 0];
    if (e.left) return ['left'];
    if (e.test) return ['test'];
    if (e.object) return ['object'];
    if (e.callee) return ['callee'];
    if (e.tag) return ['tag'];
    if (e.argument) return ['argument'];
    if (e.expression) return ['expression'];
    throw new Error('Unexpected node has no left side.');
   }
   var ne = K(['Line', 'CommentLine', 'SingleLine', 'HashbangComment', 'HTMLOpen', 'HTMLClose', 'Hashbang', 'InterpreterDirective']),
    se = K(['ExportDefaultDeclaration', 'DeclareExportDeclaration', 'ExportNamedDeclaration', 'ExportAllDeclaration', 'DeclareExportAllDeclaration']),
    ie = K(['ArrayExpression', 'TupleExpression']),
    ae = K(['ObjectExpression', 'RecordExpression']);
   function oe(e) {
    return 'NumericLiteral' === e.type || ('Literal' === e.type && 'number' == typeof e.value);
   }
   function ue(e) {
    return 'UnaryExpression' === e.type && ('+' === e.operator || '-' === e.operator) && oe(e.argument);
   }
   function le(e) {
    return !(!e || ('StringLiteral' !== e.type && ('Literal' !== e.type || 'string' != typeof e.value)));
   }
   function pe(e) {
    return 'RegExpLiteral' === e.type || ('Literal' === e.type && !!e.regex);
   }
   var ce = K(['Literal', 'BooleanLiteral', 'BigIntLiteral', 'DecimalLiteral', 'DirectiveLiteral', 'NullLiteral', 'NumericLiteral', 'RegExpLiteral', 'StringLiteral']),
    he = K(['Identifier', 'ThisExpression', 'Super', 'PrivateName', 'PrivateIdentifier', 'Import']),
    de = K(['ObjectTypeAnnotation', 'TSTypeLiteral', 'TSMappedType']),
    fe = K(['FunctionExpression', 'ArrowFunctionExpression']);
   function me(e) {
    return we(e) && 'Identifier' === e.callee.type && ['async', 'inject', 'fakeAsync', 'waitForAsync'].includes(e.callee.name);
   }
   var ye = K(['JSXElement', 'JSXFragment']);
   function ge(e) {
    return (e.method && 'init' === e.kind) || 'get' === e.kind || 'set' === e.kind;
   }
   function De(e) {
    return !(('ObjectTypeProperty' !== e.type && 'ObjectTypeInternalSlot' !== e.type) || e.static || e.method || 'get' === e.kind || 'set' === e.kind || 'FunctionTypeAnnotation' !== e.value.type);
   }
   var xe = K(['BinaryExpression', 'LogicalExpression', 'NGPipeExpression']);
   function be(e) {
    return Ae(e) || ('BindExpression' === e.type && !!e.object);
   }
   var ve = K(['TSThisType', 'NullLiteralTypeAnnotation', 'BooleanLiteralTypeAnnotation', 'StringLiteralTypeAnnotation', 'BigIntLiteralTypeAnnotation', 'NumberLiteralTypeAnnotation', 'TSLiteralType', 'TSTemplateLiteralType']);
   function Ee(e) {
    return Q(e) || X(e) || ve(e) || (('GenericTypeAnnotation' === e.type || 'TSTypeReference' === e.type) && !e.typeParameters);
   }
   var Ce = ['it', 'it.only', 'it.skip', 'describe', 'describe.only', 'describe.skip', 'test', 'test.only', 'test.skip', 'test.step', 'test.describe', 'test.describe.only', 'test.describe.parallel', 'test.describe.parallel.only', 'test.describe.serial', 'test.describe.serial.only', 'skip', 'xit', 'xdescribe', 'xtest', 'fit', 'fdescribe', 'ftest'];
   function Te(e, t) {
    if ('CallExpression' !== e.type || e.optional) return !1;
    let r = Ze(e);
    if (1 === r.length) {
     if (me(e) && t && Te(t)) return fe(r[0]);
     if (
      (function (e) {
       return 'Identifier' === e.type && ('beforeEach' === e.name || 'beforeAll' === e.name || 'afterEach' === e.name || 'afterAll' === e.name);
      })(e.callee)
     )
      return me(r[0]);
    } else if (
     (2 === r.length || 3 === r.length) &&
     ('TemplateLiteral' === r[0].type || le(r[0])) &&
     (function (e) {
      return Y(e, Ce);
     })(e.callee)
    )
     return (
      !(r[2] && !oe(r[2])) &&
      ((2 === r.length
       ? fe(r[1])
       : (function (e) {
          return 'FunctionExpression' === e.type || ('ArrowFunctionExpression' === e.type && 'BlockStatement' === e.body.type);
         })(r[1]) && Ye(r[1]).length <= 1) ||
       me(r[1]))
     );
    return !1;
   }
   var Se = (e) => (t) => ('ChainExpression' === (null == t ? void 0 : t.type) && (t = t.expression), e(t)),
    we = Se(K(['CallExpression', 'OptionalCallExpression'])),
    Ae = Se(K(['MemberExpression', 'OptionalMemberExpression']));
   function Fe(e, t = 5) {
    return ke(e, t) <= t;
   }
   function ke(e, t) {
    let r = 0;
    for (let n in e) {
     let s = e[n];
     if ((s && 'object' == typeof s && 'string' == typeof s.type && (r++, (r += ke(s, t - r))), r > t)) return r;
    }
    return r;
   }
   var Pe = 0.25;
   function Ie(e, t) {
    let { printWidth: r } = t;
    if (at(e)) return !1;
    let n = r * Pe;
    if ('ThisExpression' === e.type || ('Identifier' === e.type && e.name.length <= n) || (ue(e) && !at(e.argument))) return !0;
    let s = ('Literal' === e.type && 'regex' in e && e.regex.pattern) || ('RegExpLiteral' === e.type && e.pattern);
    return s ? s.length <= n : le(e) ? R(Re(e), t).length <= n : 'TemplateLiteral' === e.type ? 0 === e.expressions.length && e.quasis[0].value.raw.length <= n && !e.quasis[0].value.raw.includes('\n') : 'UnaryExpression' === e.type ? Ie(e.argument, { printWidth: r }) : 'CallExpression' === e.type && 0 === e.arguments.length && 'Identifier' === e.callee.type ? e.callee.name.length <= n - 2 : ce(e);
   }
   function Ne(e, t) {
    return ye(t) ? nt(t) : at(t, st.Leading, (t) => I(e, U(t)));
   }
   function Be(e) {
    return e.quasis.some((e) => e.value.raw.includes('\n'));
   }
   function _e(e, t) {
    return (('TemplateLiteral' === e.type && Be(e)) || ('TaggedTemplateExpression' === e.type && Be(e.quasi))) && !I(t, q(e), { backwards: !0 });
   }
   function Le(e) {
    if (!at(e)) return !1;
    let t = x(!1, ot(e, st.Dangling), -1);
    return t && !G(t);
   }
   function Oe(e) {
    let { node: t, parent: r, key: n } = e;
    return 'callee' === n && we(t) && we(r) && r.arguments.length > 0 && t.arguments.length > r.arguments.length;
   }
   var Me = new Set(['!', '-', '+', '~']);
   function je(e, t = 2) {
    if (t <= 0) return !1;
    if ('ChainExpression' === e.type || 'TSNonNullExpression' === e.type) return je(e.expression, t);
    let r = (e) => je(e, t - 1);
    if (pe(e)) return S(e.pattern ?? e.regex.pattern) <= 5;
    if (ce(e) || he(e) || 'ArgumentPlaceholder' === e.type) return !0;
    if ('TemplateLiteral' === e.type) return e.quasis.every((e) => !e.value.raw.includes('\n')) && e.expressions.every(r);
    if (ae(e)) return e.properties.every((e) => !e.computed && (e.shorthand || (e.value && r(e.value))));
    if (ie(e)) return e.elements.every((e) => null === e || r(e));
    if (lt(e)) {
     if ('ImportExpression' === e.type || je(e.callee, t)) {
      let n = Ze(e);
      return n.length <= t && n.every(r);
     }
     return !1;
    }
    return Ae(e) ? je(e.object, t) && je(e.property, t) : !!(('UnaryExpression' === e.type && Me.has(e.operator)) || 'UpdateExpression' === e.type) && je(e.argument, t);
   }
   function Re(e) {
    var t;
    return (null == (t = e.extra) ? void 0 : t.raw) ?? e.raw;
   }
   function qe(e) {
    return e;
   }
   function Ue(e, t = 'es5') {
    return ('es5' === e.trailingComma && 'es5' === t) || ('all' === e.trailingComma && ('all' === t || 'es5' === t));
   }
   function $e(e, t) {
    switch (e.type) {
     case 'BinaryExpression':
     case 'LogicalExpression':
     case 'AssignmentExpression':
     case 'NGPipeExpression':
      return $e(e.left, t);
     case 'MemberExpression':
     case 'OptionalMemberExpression':
      return $e(e.object, t);
     case 'TaggedTemplateExpression':
      return 'FunctionExpression' !== e.tag.type && $e(e.tag, t);
     case 'CallExpression':
     case 'OptionalCallExpression':
      return 'FunctionExpression' !== e.callee.type && $e(e.callee, t);
     case 'ConditionalExpression':
      return $e(e.test, t);
     case 'UpdateExpression':
      return !e.prefix && $e(e.argument, t);
     case 'BindExpression':
      return e.object && $e(e.object, t);
     case 'SequenceExpression':
      return $e(e.expressions[0], t);
     case 'ChainExpression':
     case 'TSSatisfiesExpression':
     case 'TSAsExpression':
     case 'TSNonNullExpression':
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
      return $e(e.expression, t);
     default:
      return t(e);
    }
   }
   var He = { '==': !0, '!=': !0, '===': !0, '!==': !0 },
    ze = { '*': !0, '/': !0, '%': !0 },
    Ve = { '>>': !0, '>>>': !0, '<<': !0 };
   function We(e, t) {
    return !(Ke(t) !== Ke(e) || '**' === e || (He[e] && He[t]) || ('%' === t && ze[e]) || ('%' === e && ze[t]) || (t !== e && ze[t] && ze[e]) || (Ve[e] && Ve[t]));
   }
   var Je = new Map([['|>'], ['??'], ['||'], ['&&'], ['|'], ['^'], ['&'], ['==', '===', '!=', '!=='], ['<', '>', '<=', '>=', 'in', 'instanceof'], ['>>', '<<', '>>>'], ['+', '-'], ['*', '/', '%'], ['**']].flatMap((e, t) => e.map((e) => [e, t])));
   function Ke(e) {
    return Je.get(e);
   }
   function Ge(e) {
    var t;
    if (e.rest) return !0;
    let r = Ye(e);
    return 'RestElement' === (null == (t = x(!1, r, -1)) ? void 0 : t.type);
   }
   var Xe = new WeakMap();
   function Ye(e) {
    if (Xe.has(e)) return Xe.get(e);
    let t = [];
    return e.this && t.push(e.this), Array.isArray(e.parameters) ? t.push(...e.parameters) : Array.isArray(e.params) && t.push(...e.params), e.rest && t.push(e.rest), Xe.set(e, t), t;
   }
   var Qe = new WeakMap();
   function Ze(e) {
    if (Qe.has(e)) return Qe.get(e);
    if ('ChainExpression' === e.type) return Ze(e.expression);
    let t = e.arguments;
    return 'ImportExpression' === e.type && ((t = [e.source]), e.attributes && t.push(e.attributes), e.options && t.push(e.options)), Qe.set(e, t), t;
   }
   function et(e, t) {
    let { node: r } = e;
    if ('ChainExpression' === r.type) return e.call(() => et(e, t), 'expression');
    'ImportExpression' === r.type ? (e.call((e) => t(e, 0), 'source'), r.attributes && e.call((e) => t(e, 1), 'attributes'), r.options && e.call((e) => t(e, 1), 'options')) : e.each(t, 'arguments');
   }
   function tt(e, t) {
    let r = [];
    if (('ChainExpression' === e.type && ((e = e.expression), r.push('expression')), 'ImportExpression' === e.type)) {
     if (0 === t || t === (e.attributes || e.options ? -2 : -1)) return [...r, 'source'];
     if (e.attributes && (1 === t || -1 === t)) return [...r, 'attributes'];
     if (e.options && (1 === t || -1 === t)) return [...r, 'options'];
     throw new RangeError('Invalid argument index');
    }
    if ((t < 0 && (t = e.arguments.length + t), t < 0 || t >= e.arguments.length)) throw new RangeError('Invalid argument index');
    return [...r, 'arguments', t];
   }
   function rt(e) {
    return 'prettier-ignore' === e.value.trim() && !e.unignore;
   }
   function nt(e) {
    return (null == e ? void 0 : e.prettierIgnore) || at(e, st.PrettierIgnore);
   }
   var st = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 },
    it = (e, t) => {
     if (('function' == typeof e && ((t = e), (e = 0)), e || t)) return (r, n, s) => !((e & st.Leading && !r.leading) || (e & st.Trailing && !r.trailing) || (e & st.Dangling && (r.leading || r.trailing)) || (e & st.Block && !G(r)) || (e & st.Line && !ne(r)) || (e & st.First && 0 !== n) || (e & st.Last && n !== s.length - 1) || (e & st.PrettierIgnore && !rt(r)) || (t && !t(r)));
    };
   function at(e, t, r) {
    if (!L(null == e ? void 0 : e.comments)) return !1;
    let n = it(t, r);
    return !n || e.comments.some(n);
   }
   function ot(e, t, r) {
    if (!Array.isArray(null == e ? void 0 : e.comments)) return [];
    let n = it(t, r);
    return n ? e.comments.filter(n) : e.comments;
   }
   var ut = (e, { originalText: t }) => _(t, U(e));
   function lt(e) {
    return we(e) || 'NewExpression' === e.type || 'ImportExpression' === e.type;
   }
   function pt(e) {
    return e && ('ObjectProperty' === e.type || ('Property' === e.type && !ge(e)));
   }
   var ct = K(['TSAsExpression', 'TSSatisfiesExpression', 'AsExpression', 'AsConstExpression', 'SatisfiesExpression']),
    ht = K(['UnionTypeAnnotation', 'TSUnionType']),
    dt = K(['IntersectionTypeAnnotation', 'TSIntersectionType']),
    ft = new Set(['range', 'raw', 'comments', 'leadingComments', 'trailingComments', 'innerComments', 'extra', 'start', 'end', 'loc', 'flags', 'errors', 'tokens']),
    mt = (e) => {
     for (let t of e.quasis) delete t.value;
    };
   function yt(e, t, r) {
    var n, s;
    if (('Program' === e.type && delete t.sourceType, ('BigIntLiteral' === e.type || 'BigIntLiteralTypeAnnotation' === e.type) && e.value && (t.value = e.value.toLowerCase()), ('BigIntLiteral' === e.type || 'Literal' === e.type) && e.bigint && (t.bigint = e.bigint.toLowerCase()), 'DecimalLiteral' === e.type && (t.value = Number(e.value)), 'Literal' === e.type && t.decimal && (t.decimal = Number(e.decimal)), 'EmptyStatement' === e.type || 'JSXText' === e.type || ('JSXExpressionContainer' === e.type && ('Literal' === e.expression.type || 'StringLiteral' === e.expression.type) && ' ' === e.expression.value))) return null;
    if (('Property' === e.type || 'ObjectProperty' === e.type || 'MethodDefinition' === e.type || 'ClassProperty' === e.type || 'ClassMethod' === e.type || 'PropertyDefinition' === e.type || 'TSDeclareMethod' === e.type || 'TSPropertySignature' === e.type || 'ObjectTypeProperty' === e.type || 'ImportAttribute' === e.type) && e.key && !e.computed) {
     let { key: r } = e;
     le(r) || oe(r) ? (t.key = String(r.value)) : 'Identifier' === r.type && (t.key = r.name);
    }
    if ('JSXElement' === e.type && 'style' === e.openingElement.name.name && e.openingElement.attributes.some((e) => 'JSXAttribute' === e.type && 'jsx' === e.name.name)) for (let { type: a, expression: o } of t.children) 'JSXExpressionContainer' === a && 'TemplateLiteral' === o.type && mt(o);
    'JSXAttribute' === e.type && 'css' === e.name.name && 'JSXExpressionContainer' === e.value.type && 'TemplateLiteral' === e.value.expression.type && mt(t.value.expression), 'JSXAttribute' === e.type && 'Literal' === (null == (n = e.value) ? void 0 : n.type) && /["']|&quot;|&apos;/.test(e.value.value) && (t.value.value = D(!1, e.value.value, /["']|&quot;|&apos;/g, '"'));
    let i = e.expression || e.callee;
    if ('Decorator' === e.type && 'CallExpression' === i.type && 'Component' === i.callee.name && 1 === i.arguments.length) {
     let r = e.expression.arguments[0].properties;
     for (let [e, n] of t.expression.arguments[0].properties.entries())
      switch (r[e].key.name) {
       case 'styles':
        ie(n.value) && mt(n.value.elements[0]);
        break;
       case 'template':
        'TemplateLiteral' === n.value.type && mt(n.value);
      }
    }
    'TaggedTemplateExpression' === e.type && ('MemberExpression' === e.tag.type || ('Identifier' === e.tag.type && ('gql' === e.tag.name || 'graphql' === e.tag.name || 'css' === e.tag.name || 'md' === e.tag.name || 'markdown' === e.tag.name || 'html' === e.tag.name)) || 'CallExpression' === e.tag.type) && mt(t.quasi), 'TemplateLiteral' === e.type && ((null != (s = e.leadingComments) && s.some((e) => G(e) && ['GraphQL', 'HTML'].some((t) => e.value === ` ${t} `))) || ('CallExpression' === r.type && 'graphql' === r.callee.name) || !e.leadingComments) && mt(t), 'ChainExpression' === e.type && 'TSNonNullExpression' === e.expression.type && ((t.type = 'TSNonNullExpression'), (t.expression.type = 'ChainExpression'));
   }
   yt.ignoredProperties = ft;
   var gt = yt,
    Dt = 'string',
    xt = 'array',
    bt = 'cursor',
    vt = 'indent',
    Et = 'align',
    Ct = 'trim',
    Tt = 'group',
    St = 'fill',
    wt = 'if-break',
    At = 'indent-if-break',
    Ft = 'line-suffix',
    kt = 'line-suffix-boundary',
    Pt = 'line',
    It = 'label',
    Nt = 'break-parent',
    Bt = new Set([bt, vt, Et, Ct, Tt, St, wt, At, Ft, kt, Pt, It, Nt]);
   var _t = function (e) {
    if ('string' == typeof e) return Dt;
    if (Array.isArray(e)) return xt;
    if (!e) return;
    let { type: t } = e;
    return Bt.has(t) ? t : void 0;
   };
   function Lt(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (_t(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...Bt].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var Ot = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      super(Lt(e)), (this.doc = e);
     }
    },
    Mt = Ot,
    jt = {};
   var Rt = function (e, t, r, n) {
     let s = [e];
     for (; s.length > 0; ) {
      let e = s.pop();
      if (e === jt) {
       r(s.pop());
       continue;
      }
      r && s.push(e, jt);
      let i = _t(e);
      if (!i) throw new Mt(e);
      if (!1 !== (null == t ? void 0 : t(e)))
       switch (i) {
        case xt:
        case St: {
         let t = i === xt ? e : e.parts;
         for (let e = t.length - 1; e >= 0; --e) s.push(t[e]);
         break;
        }
        case wt:
         s.push(e.flatContents, e.breakContents);
         break;
        case Tt:
         if (n && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) s.push(e.expandedStates[t]);
         else s.push(e.contents);
         break;
        case Et:
        case vt:
        case At:
        case It:
        case Ft:
         s.push(e.contents);
         break;
        case Dt:
        case bt:
        case Ct:
        case kt:
        case Pt:
        case Nt:
         break;
        default:
         throw new Mt(e);
       }
     }
    },
    qt = () => {},
    Ut = qt,
    $t = qt;
   function Ht(e) {
    return Ut(e), { type: vt, contents: e };
   }
   function zt(e, t) {
    return Ut(t), { type: Et, contents: t, n: e };
   }
   function Vt(e, t = {}) {
    return Ut(e), $t(t.expandedStates, !0), { type: Tt, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function Wt(e) {
    return zt(Number.NEGATIVE_INFINITY, e);
   }
   function Jt(e) {
    return zt(-1, e);
   }
   function Kt(e, t) {
    return Vt(e[0], { ...t, expandedStates: e });
   }
   function Gt(e) {
    return $t(e), { type: St, parts: e };
   }
   function Xt(e, t = '', r = {}) {
    return Ut(e), '' !== t && Ut(t), { type: wt, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   function Yt(e, t) {
    return Ut(e), { type: At, contents: e, groupId: t.groupId, negate: t.negate };
   }
   function Qt(e) {
    return Ut(e), { type: Ft, contents: e };
   }
   var Zt = { type: kt },
    er = { type: Nt },
    tr = { type: Pt, hard: !0 },
    rr = { type: Pt },
    nr = { type: Pt, soft: !0 },
    sr = [tr, er],
    ir = [{ type: Pt, hard: !0, literal: !0 }, er],
    ar = { type: bt };
   function or(e, t) {
    Ut(e), $t(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   function ur(e, t) {
    return Ut(t), e ? { type: It, label: e, contents: t } : t;
   }
   function lr(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (_t(e)) {
       case xt:
        return t(e.map(n));
       case St:
        return t({ ...e, parts: e.parts.map(n) });
       case wt:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case Tt: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case Et:
       case vt:
       case At:
       case It:
       case Ft:
        return t({ ...e, contents: n(e.contents) });
       case Dt:
       case bt:
       case Ct:
       case kt:
       case Pt:
       case Nt:
        return t(e);
       default:
        throw new Mt(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function pr(e, t, r) {
    let n = r,
     s = !1;
    return (
     Rt(e, function (e) {
      if (s) return !1;
      let r = t(e);
      void 0 !== r && ((s = !0), (n = r));
     }),
     n
    );
   }
   function cr(e) {
    if ((e.type === Tt && e.break) || (e.type === Pt && e.hard) || e.type === Nt) return !0;
   }
   function hr(e) {
    return pr(e, cr, !1);
   }
   function dr(e) {
    if (e.length > 0) {
     let t = x(!1, e, -1);
     !t.expandedStates && !t.break && (t.break = 'propagated');
    }
    return null;
   }
   function fr(e) {
    return e.type !== Pt || e.hard ? (e.type === wt ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   function mr(e) {
    return lr(e, fr);
   }
   function yr(e) {
    return lr(e, (e) =>
     (function (e) {
      switch (_t(e)) {
       case St:
        if (e.parts.every((e) => '' === e)) return '';
        break;
       case Tt:
        if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
        if (e.contents.type === Tt && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
        break;
       case Et:
       case vt:
       case At:
       case Ft:
        if (!e.contents) return '';
        break;
       case wt:
        if (!e.flatContents && !e.breakContents) return '';
        break;
       case xt: {
        let t = [];
        for (let r of e) {
         if (!r) continue;
         let [e, ...n] = Array.isArray(r) ? r : [r];
         'string' == typeof e && 'string' == typeof x(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...n);
        }
        return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
       }
       case Dt:
       case bt:
       case Ct:
       case kt:
       case Pt:
       case It:
       case Nt:
        break;
       default:
        throw new Mt(e);
      }
      return e;
     })(e),
    );
   }
   function gr(e, t = ir) {
    return lr(e, (e) => ('string' == typeof e ? or(t, e.split('\n')) : e));
   }
   function Dr(e) {
    if (e.type === Pt) return !0;
   }
   function xr(e, t) {
    return e.type === It ? { ...e, contents: t(e.contents) } : t(e);
   }
   var br = function (e) {
    let t = `*${e.value}*`.split('\n');
    return t.length > 1 && t.every((e) => '*' === e.trimStart()[0]);
   };
   function vr(e, t) {
    let r = e.node;
    if (ne(r)) return t.originalText.slice(q(r), U(r)).trimEnd();
    if (G(r))
     return br(r)
      ? (function (e) {
         let t = e.value.split('\n');
         return [
          '/*',
          or(
           sr,
           t.map((e, r) => (0 === r ? e.trimEnd() : ' ' + (r < t.length - 1 ? e.trim() : e.trimStart()))),
          ),
          '*/',
         ];
        })(r)
      : ['/*', gr(r.value), '*/'];
    throw new Error('Not a comment: ' + JSON.stringify(r));
   }
   var Er = {};
   function Cr(e, t) {
    (e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || '(unknown type)',
       r = String(e.name || (e.id && ('object' == typeof e.id ? e.id.name : e.id)) || (e.key && ('object' == typeof e.key ? e.key.name : e.key)) || (e.value && ('object' == typeof e.value ? '' : String(e.value))) || e.operator || '');
      return r.length > 20 && (r = r.slice(0, 19) + '\u2026'), t + (r ? ' ' + r : '');
     })(e));
   }
   function Tr(e, t) {
    (t.leading = !0), (t.trailing = !1), Cr(e, t);
   }
   function Sr(e, t, r) {
    (t.leading = !1), (t.trailing = !1), r && (t.marker = r), Cr(e, t);
   }
   function wr(e, t) {
    (t.leading = !1), (t.trailing = !0), Cr(e, t);
   }
   h(Er, { endOfLine: () => Nr, ownLine: () => Ir, remaining: () => Br });
   var Ar = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = A(e, n)), (n = N(e, n)), (n = B(e, n)), (n = P(e, n));
    return n;
   };
   var Fr = function (e, t) {
    let r = Ar(e, t);
    return !1 === r ? '' : e.charAt(r);
   };
   var kr = function (e, t, r) {
    for (let n = t; n < r; ++n) if ('\n' === e.charAt(n)) return !0;
    return !1;
   };
   var Pr = function (e) {
    return G(e) && '*' === e.value[0] && /@(?:type|satisfies)\b/.test(e.value);
   };
   function Ir(e) {
    return [fn, $r, Zr, Qr, qr, Mr, jr, Rr, Vr, on, nn, an, un, ln, Jr, en, tn, Ur, Dn].some((t) => t(e));
   }
   function Nr(e) {
    return [Or, Zr, $r, un, Mr, jr, Rr, Vr, en, rn, sn, an, hn, tn, yn, gn].some((t) => t(e));
   }
   function Br(e) {
    return [fn, Mr, jr, Hr, Yr, Jr, an, Xr, Gr, mn, tn, dn].some((t) => t(e));
   }
   function _r(e, t) {
    let r = (e.body || e.properties).find(({ type: e }) => 'EmptyStatement' !== e);
    r ? Tr(r, t) : Sr(e, t);
   }
   function Lr(e, t) {
    'BlockStatement' === e.type ? _r(e, t) : Tr(e, t);
   }
   function Or({ comment: e, followingNode: t }) {
    return !(!t || !Pr(e)) && (Tr(t, e), !0);
   }
   function Mr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    if ('IfStatement' !== (null == r ? void 0 : r.type) || !n) return !1;
    if (')' === Fr(s, U(e))) return wr(t, e), !0;
    if (t === r.consequent && n === r.alternate) {
     if ('BlockStatement' === t.type) wr(t, e);
     else {
      let n = ne(e) || e.loc.start.line === e.loc.end.line,
       s = e.loc.start.line === t.loc.start.line;
      n && s ? wr(t, e) : Sr(r, e);
     }
     return !0;
    }
    return 'BlockStatement' === n.type ? (_r(n, e), !0) : 'IfStatement' === n.type ? (Lr(n.consequent, e), !0) : r.consequent === n && (Tr(n, e), !0);
   }
   function jr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    return !('WhileStatement' !== (null == r ? void 0 : r.type) || !n) && (')' === Fr(s, U(e)) ? (wr(t, e), !0) : 'BlockStatement' === n.type ? (_r(n, e), !0) : r.body === n && (Tr(n, e), !0));
   }
   function Rr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return !(('TryStatement' !== (null == r ? void 0 : r.type) && 'CatchClause' !== (null == r ? void 0 : r.type)) || !n) && ('CatchClause' === r.type && t ? (wr(t, e), !0) : 'BlockStatement' === n.type ? (_r(n, e), !0) : 'TryStatement' === n.type ? (Lr(n.finalizer, e), !0) : 'CatchClause' === n.type && (Lr(n.body, e), !0));
   }
   function qr({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!Ae(t) || 'Identifier' !== (null == r ? void 0 : r.type)) && (Tr(t, e), !0);
   }
   function Ur({ comment: e, enclosingNode: t, followingNode: r, options: n }) {
    return !(!n.experimentalTernaries || ('ConditionalExpression' !== (null == t ? void 0 : t.type) && 'ConditionalTypeAnnotation' !== (null == t ? void 0 : t.type) && 'TSConditionalType' !== (null == t ? void 0 : t.type))) && ('ConditionalExpression' === (null == r ? void 0 : r.type) || 'ConditionalTypeAnnotation' === (null == r ? void 0 : r.type) || 'TSConditionalType' === (null == r ? void 0 : r.type)) && (Sr(t, e), !0);
   }
   function $r({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s, options: i }) {
    let a = t && !kr(s, U(t), q(e));
    return !((t && a) || ('ConditionalExpression' !== (null == r ? void 0 : r.type) && 'ConditionalTypeAnnotation' !== (null == r ? void 0 : r.type) && 'TSConditionalType' !== (null == r ? void 0 : r.type)) || !n) && (!i.experimentalTernaries || r.alternate !== n || (G(e) && !kr(i.originalText, q(e), U(e))) ? (Tr(n, e), !0) : (Sr(r, e), !0));
   }
   function Hr({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !(!pt(r) || !r.shorthand || r.key !== t || 'AssignmentPattern' !== r.value.type) && (wr(r.value.left, e), !0);
   }
   var zr = new Set(['ClassDeclaration', 'ClassExpression', 'DeclareClass', 'DeclareInterface', 'InterfaceDeclaration', 'TSInterfaceDeclaration']);
   function Vr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    if (zr.has(null == r ? void 0 : r.type)) {
     if (L(r.decorators) && 'Decorator' !== (null == n ? void 0 : n.type)) return wr(x(!1, r.decorators, -1), e), !0;
     if (r.body && n === r.body) return _r(r.body, e), !0;
     if (n) {
      if (r.superClass && n === r.superClass && t && (t === r.id || t === r.typeParameters)) return wr(t, e), !0;
      for (let s of ['implements', 'extends', 'mixins']) if (r[s] && n === r[s][0]) return !t || (t !== r.id && t !== r.typeParameters && t !== r.superClass) ? Sr(r, e, s) : wr(t, e), !0;
     }
    }
    return !1;
   }
   var Wr = new Set(['ClassMethod', 'ClassProperty', 'PropertyDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractMethodDefinition', 'TSDeclareMethod', 'MethodDefinition', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractAccessorProperty']);
   function Jr({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    return ((r && t && '(' === Fr(n, U(e)) && ('Property' === r.type || 'TSDeclareMethod' === r.type || 'TSAbstractMethodDefinition' === r.type) && 'Identifier' === t.type && r.key === t && ':' !== Fr(n, U(t))) || !('Decorator' !== (null == t ? void 0 : t.type) || !Wr.has(null == r ? void 0 : r.type))) && (wr(t, e), !0);
   }
   var Kr = new Set(['FunctionDeclaration', 'FunctionExpression', 'ClassMethod', 'MethodDefinition', 'ObjectMethod']);
   function Gr({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    return '(' === Fr(n, U(e)) && !(!t || !Kr.has(null == r ? void 0 : r.type)) && (wr(t, e), !0);
   }
   function Xr({ comment: e, enclosingNode: t, text: r }) {
    if ('ArrowFunctionExpression' !== (null == t ? void 0 : t.type)) return !1;
    let n = Ar(r, U(e));
    return !1 !== n && '=>' === r.slice(n, n + 2) && (Sr(t, e), !0);
   }
   function Yr({ comment: e, enclosingNode: t, text: r }) {
    return ')' === Fr(r, U(e)) && (t && ((xn(t) && 0 === Ye(t).length) || (lt(t) && 0 === Ze(t).length)) ? (Sr(t, e), !0) : ('MethodDefinition' === (null == t ? void 0 : t.type) || 'TSAbstractMethodDefinition' === (null == t ? void 0 : t.type)) && 0 === Ye(t.value).length && (Sr(t.value, e), !0));
   }
   function Qr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    return 'ComponentTypeParameter' !== (null == t ? void 0 : t.type) || ('DeclareComponent' !== (null == r ? void 0 : r.type) && 'ComponentTypeAnnotation' !== (null == r ? void 0 : r.type)) || 'ComponentTypeParameter' === (null == n ? void 0 : n.type) ? ('ComponentParameter' === (null == t ? void 0 : t.type) || 'RestElement' === (null == t ? void 0 : t.type)) && 'ComponentDeclaration' === (null == r ? void 0 : r.type) && ')' === Fr(s, U(e)) && (wr(t, e), !0) : (wr(t, e), !0);
   }
   function Zr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    return 'FunctionTypeParam' === (null == t ? void 0 : t.type) && 'FunctionTypeAnnotation' === (null == r ? void 0 : r.type) && 'FunctionTypeParam' !== (null == n ? void 0 : n.type) ? (wr(t, e), !0) : ('Identifier' !== (null == t ? void 0 : t.type) && 'AssignmentPattern' !== (null == t ? void 0 : t.type) && 'ObjectPattern' !== (null == t ? void 0 : t.type) && 'ArrayPattern' !== (null == t ? void 0 : t.type) && 'RestElement' !== (null == t ? void 0 : t.type) && 'TSParameterProperty' !== (null == t ? void 0 : t.type)) || !xn(r) || ')' !== Fr(s, U(e)) ? !(G(e) || ('FunctionDeclaration' !== (null == r ? void 0 : r.type) && 'FunctionExpression' !== (null == r ? void 0 : r.type) && 'ObjectMethod' !== (null == r ? void 0 : r.type)) || 'BlockStatement' !== (null == n ? void 0 : n.type) || r.body !== n || Ar(s, U(e)) !== q(n)) && (_r(n, e), !0) : (wr(t, e), !0);
   }
   function en({ comment: e, enclosingNode: t }) {
    return 'LabeledStatement' === (null == t ? void 0 : t.type) && (Tr(t, e), !0);
   }
   function tn({ comment: e, enclosingNode: t }) {
    return !(('ContinueStatement' !== (null == t ? void 0 : t.type) && 'BreakStatement' !== (null == t ? void 0 : t.type)) || t.label) && (wr(t, e), !0);
   }
   function rn({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !!(we(r) && t && r.callee === t && r.arguments.length > 0) && (Tr(r.arguments[0], e), !0);
   }
   function nn({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return ht(r) ? (rt(e) && ((n.prettierIgnore = !0), (e.unignore = !0)), !!t && (wr(t, e), !0)) : (ht(n) && rt(e) && ((n.types[0].prettierIgnore = !0), (e.unignore = !0)), !1);
   }
   function sn({ comment: e, enclosingNode: t }) {
    return !!pt(t) && (Tr(t, e), !0);
   }
   function an({ comment: e, enclosingNode: t, ast: r, isLastComment: n }) {
    var s;
    return 0 === (null == (s = null == r ? void 0 : r.body) ? void 0 : s.length) ? (n ? Sr(r, e) : Tr(r, e), !0) : 'Program' === (null == t ? void 0 : t.type) && 0 === t.body.length && !L(t.directives) && (n ? Sr(t, e) : Tr(t, e), !0);
   }
   function on({ comment: e, enclosingNode: t }) {
    return ('ForInStatement' === (null == t ? void 0 : t.type) || 'ForOfStatement' === (null == t ? void 0 : t.type)) && (Tr(t, e), !0);
   }
   function un({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    if ('ImportSpecifier' === (null == r ? void 0 : r.type) || 'ExportSpecifier' === (null == r ? void 0 : r.type)) return Tr(r, e), !0;
    let s = 'ImportSpecifier' === (null == t ? void 0 : t.type) && 'ImportDeclaration' === (null == r ? void 0 : r.type),
     i = 'ExportSpecifier' === (null == t ? void 0 : t.type) && 'ExportNamedDeclaration' === (null == r ? void 0 : r.type);
    return !((!s && !i) || !I(n, U(e))) && (wr(t, e), !0);
   }
   function ln({ comment: e, enclosingNode: t }) {
    return 'AssignmentPattern' === (null == t ? void 0 : t.type) && (Tr(t, e), !0);
   }
   var pn = new Set(['VariableDeclarator', 'AssignmentExpression', 'TypeAlias', 'TSTypeAliasDeclaration']),
    cn = new Set(['ObjectExpression', 'RecordExpression', 'ArrayExpression', 'TupleExpression', 'TemplateLiteral', 'TaggedTemplateExpression', 'ObjectTypeAnnotation', 'TSTypeLiteral']);
   function hn({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!pn.has(null == t ? void 0 : t.type) || !r || (!cn.has(r.type) && !G(e))) && (Tr(r, e), !0);
   }
   function dn({ comment: e, enclosingNode: t, followingNode: r, text: n }) {
    return !(r || ('TSMethodSignature' !== (null == t ? void 0 : t.type) && 'TSDeclareFunction' !== (null == t ? void 0 : t.type) && 'TSAbstractMethodDefinition' !== (null == t ? void 0 : t.type)) || ';' !== Fr(n, U(e))) && (wr(t, e), !0);
   }
   function fn({ comment: e, enclosingNode: t, followingNode: r }) {
    if (rt(e) && 'TSMappedType' === (null == t ? void 0 : t.type) && 'TSTypeParameter' === (null == r ? void 0 : r.type) && r.constraint) return (t.prettierIgnore = !0), (e.unignore = !0), !0;
   }
   function mn({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return 'TSMappedType' === (null == r ? void 0 : r.type) && ('TSTypeParameter' === (null == n ? void 0 : n.type) && n.name ? (Tr(n.name, e), !0) : !('TSTypeParameter' !== (null == t ? void 0 : t.type) || !t.constraint) && (wr(t.constraint, e), !0));
   }
   function yn({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!t || 'SwitchCase' !== t.type || t.test || !r || r !== t.consequent[0]) && ('BlockStatement' === r.type && ne(e) ? _r(r, e) : Sr(t, e), !0);
   }
   function gn({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return !(!ht(t) || ((('TSArrayType' !== r.type && 'ArrayTypeAnnotation' !== r.type) || n) && !dt(r))) && (wr(x(!1, t.types, -1), e), !0);
   }
   function Dn({ comment: e, enclosingNode: t, precedingNode: r, followingNode: n }) {
    if (('ObjectPattern' === (null == t ? void 0 : t.type) || 'ArrayPattern' === (null == t ? void 0 : t.type)) && 'TSTypeAnnotation' === (null == n ? void 0 : n.type)) return r ? wr(r, e) : Sr(t, e), !0;
   }
   var xn = K(['ArrowFunctionExpression', 'FunctionExpression', 'FunctionDeclaration', 'ObjectMethod', 'ClassMethod', 'TSDeclareFunction', 'TSCallSignatureDeclaration', 'TSConstructSignatureDeclaration', 'TSMethodSignature', 'TSConstructorType', 'TSFunctionType', 'TSDeclareMethod']),
    bn = new Set(['EmptyStatement', 'TemplateElement', 'Import', 'TSEmptyBodyFunctionExpression', 'ChainExpression']);
   function vn(e) {
    return !bn.has(e.type);
   }
   function En(e, t) {
    var r;
    if (('typescript' === t.parser || 'flow' === t.parser || 'acorn' === t.parser || 'espree' === t.parser || 'meriyah' === t.parser || '__babel_estree' === t.parser) && 'MethodDefinition' === e.type && 'FunctionExpression' === (null == (r = e.value) ? void 0 : r.type) && 0 === Ye(e.value).length && !e.value.returnType && !L(e.value.typeParameters) && e.value.body) return [...(e.decorators || []), e.key, e.value.body];
   }
   function Cn(e) {
    let { node: t, parent: r } = e;
    return (ye(t) || (r && ('JSXSpreadAttribute' === r.type || 'JSXSpreadChild' === r.type || ht(r) || (('ClassDeclaration' === r.type || 'ClassExpression' === r.type) && r.superClass === t)))) && (!nt(t) || ht(r));
   }
   function Tn(e, { parser: t }) {
    if ('flow' === t || 'babel-flow' === t) return '' === (e = D(!1, e, /[\s(]/g, '')) || '/*' === e || '/*::' === e;
   }
   var Sn = Symbol('MODE_BREAK'),
    wn = Symbol('MODE_FLAT'),
    An = Symbol('cursor');
   function Fn(e, t) {
    return Pn(e, { type: 'indent' }, t);
   }
   function kn(e, t, r) {
    return t === Number.NEGATIVE_INFINITY ? e.root || { value: '', length: 0, queue: [] } : t < 0 ? Pn(e, { type: 'dedent' }, r) : t ? ('root' === t.type ? { ...e, root: e } : Pn(e, { type: 'string' == typeof t ? 'stringAlign' : 'numberAlign', n: t }, r)) : e;
   }
   function Pn(e, t, r) {
    let n = 'dedent' === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     s = '',
     i = 0,
     a = 0,
     o = 0;
    for (let d of n)
     switch (d.type) {
      case 'indent':
       p(), r.useTabs ? u(1) : l(r.tabWidth);
       break;
      case 'stringAlign':
       p(), (s += d.n), (i += d.n.length);
       break;
      case 'numberAlign':
       (a += 1), (o += d.n);
       break;
      default:
       throw new Error(`Unexpected type '${d.type}'`);
     }
    return c(), { ...e, value: s, length: i, queue: n };
    function u(e) {
     (s += '\t'.repeat(e)), (i += r.tabWidth * e);
    }
    function l(e) {
     (s += ' '.repeat(e)), (i += e);
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     o > 0 && l(o), h();
    }
    function h() {
     (a = 0), (o = 0);
    }
   }
   function In(e) {
    let t = 0,
     r = 0,
     n = e.length;
    e: for (; n--; ) {
     let s = e[n];
     if (s !== An)
      for (let r = s.length - 1; r >= 0; r--) {
       let i = s[r];
       if (' ' !== i && '\t' !== i) {
        e[n] = s.slice(0, r + 1);
        break e;
       }
       t++;
      }
     else r++;
    }
    if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(An);
    return t;
   }
   function Nn(e, t, r, n, s, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = [e],
     u = [];
    for (; r >= 0; ) {
     if (0 === o.length) {
      if (0 === a) return !0;
      o.push(t[--a]);
      continue;
     }
     let { mode: e, doc: l } = o.pop(),
      p = _t(l);
     switch (p) {
      case Dt:
       u.push(l), (r -= S(l));
       break;
      case xt:
      case St: {
       let t = p === xt ? l : l.parts;
       for (let r = t.length - 1; r >= 0; r--) o.push({ mode: e, doc: t[r] });
       break;
      }
      case vt:
      case Et:
      case At:
      case It:
       o.push({ mode: e, doc: l.contents });
       break;
      case Ct:
       r += In(u);
       break;
      case Tt: {
       if (i && l.break) return !1;
       let t = l.break ? Sn : e,
        r = l.expandedStates && t === Sn ? x(!1, l.expandedStates, -1) : l.contents;
       o.push({ mode: t, doc: r });
       break;
      }
      case wt: {
       let t = (l.groupId ? s[l.groupId] || wn : e) === Sn ? l.breakContents : l.flatContents;
       t && o.push({ mode: e, doc: t });
       break;
      }
      case Pt:
       if (e === Sn || l.hard) return !0;
       l.soft || (u.push(' '), r--);
       break;
      case Ft:
       n = !0;
       break;
      case kt:
       if (n) return !1;
     }
    }
    return !1;
   }
   function Bn(e, t) {
    let r = {},
     n = t.printWidth,
     s = (function (e) {
      switch (e) {
       case 'cr':
        return '\r';
       case 'crlf':
        return '\r\n';
       default:
        return '\n';
      }
     })(t.endOfLine),
     i = 0,
     a = [{ ind: { value: '', length: 0, queue: [] }, mode: Sn, doc: e }],
     o = [],
     u = !1,
     l = [],
     p = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      Rt(
       e,
       function (e) {
        if ((e.type === Nt && dr(r), e.type === Tt)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === Tt && r.pop().break && dr(r);
       },
       !0,
      );
     })(e);
     a.length > 0;

    ) {
     let { ind: e, mode: c, doc: h } = a.pop();
     switch (_t(h)) {
      case Dt: {
       let e = '\n' !== s ? D(!1, h, '\n', s) : h;
       o.push(e), a.length > 0 && (i += S(e));
       break;
      }
      case xt:
       for (let t = h.length - 1; t >= 0; t--) a.push({ ind: e, mode: c, doc: h[t] });
       break;
      case bt:
       if (p >= 2) throw new Error("There are too many 'cursor' in doc.");
       o.push(An), p++;
       break;
      case vt:
       a.push({ ind: Fn(e, t), mode: c, doc: h.contents });
       break;
      case Et:
       a.push({ ind: kn(e, h.n, t), mode: c, doc: h.contents });
       break;
      case Ct:
       i -= In(o);
       break;
      case Tt:
       switch (c) {
        case wn:
         if (!u) {
          a.push({ ind: e, mode: h.break ? Sn : wn, doc: h.contents });
          break;
         }
        case Sn: {
         u = !1;
         let t = { ind: e, mode: wn, doc: h.contents },
          s = n - i,
          o = l.length > 0;
         if (!h.break && Nn(t, a, s, o, r)) a.push(t);
         else if (h.expandedStates) {
          let t = x(!1, h.expandedStates, -1);
          if (h.break) {
           a.push({ ind: e, mode: Sn, doc: t });
           break;
          }
          for (let n = 1; n < h.expandedStates.length + 1; n++) {
           if (n >= h.expandedStates.length) {
            a.push({ ind: e, mode: Sn, doc: t });
            break;
           }
           {
            let t = h.expandedStates[n],
             i = { ind: e, mode: wn, doc: t };
            if (Nn(i, a, s, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ ind: e, mode: Sn, doc: h.contents });
         break;
        }
       }
       h.id && (r[h.id] = x(!1, a, -1).mode);
       break;
      case St: {
       let t = n - i,
        { parts: s } = h;
       if (0 === s.length) break;
       let [o, u] = s,
        p = { ind: e, mode: wn, doc: o },
        d = { ind: e, mode: Sn, doc: o },
        f = Nn(p, [], t, l.length > 0, r, !0);
       if (1 === s.length) {
        f ? a.push(p) : a.push(d);
        break;
       }
       let m = { ind: e, mode: wn, doc: u },
        y = { ind: e, mode: Sn, doc: u };
       if (2 === s.length) {
        f ? a.push(m, p) : a.push(y, d);
        break;
       }
       s.splice(0, 2);
       let g = { ind: e, mode: c, doc: Gt(s) },
        D = s[0];
       Nn({ ind: e, mode: wn, doc: [o, u, D] }, [], t, l.length > 0, r, !0) ? a.push(g, m, p) : f ? a.push(g, y, p) : a.push(g, y, d);
       break;
      }
      case wt:
      case At: {
       let t = h.groupId ? r[h.groupId] : c;
       if (t === Sn) {
        let t = h.type === wt ? h.breakContents : h.negate ? h.contents : Ht(h.contents);
        t && a.push({ ind: e, mode: c, doc: t });
       }
       if (t === wn) {
        let t = h.type === wt ? h.flatContents : h.negate ? Ht(h.contents) : h.contents;
        t && a.push({ ind: e, mode: c, doc: t });
       }
       break;
      }
      case Ft:
       l.push({ ind: e, mode: c, doc: h.contents });
       break;
      case kt:
       l.length > 0 && a.push({ ind: e, mode: c, doc: tr });
       break;
      case Pt:
       switch (c) {
        case wn:
         if (!h.hard) {
          h.soft || (o.push(' '), (i += 1));
          break;
         }
         u = !0;
        case Sn:
         if (l.length > 0) {
          a.push({ ind: e, mode: c, doc: h }, ...l.reverse()), (l.length = 0);
          break;
         }
         h.literal ? (e.root ? (o.push(s, e.root.value), (i = e.root.length)) : (o.push(s), (i = 0))) : ((i -= In(o)), o.push(s + e.value), (i = e.length));
       }
       break;
      case It:
       a.push({ ind: e, mode: c, doc: h.contents });
       break;
      case Nt:
       break;
      default:
       throw new Mt(h);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let c = o.indexOf(An);
    if (-1 !== c) {
     let e = o.indexOf(An, c + 1),
      t = o.slice(0, c).join(''),
      r = o.slice(c + 1, e).join('');
     return { formatted: t + r + o.slice(e + 1).join(''), cursorNodeStart: t.length, cursorNodeText: r };
    }
    return { formatted: o.join('') };
   }
   var _n = function (e, t, r = 0) {
    let n = 0;
    for (let s = r; s < e.length; ++s) '\t' === e[s] ? (n = n + t - (n % t)) : n++;
    return n;
   };
   var Ln = function (e, t) {
    let r = e.lastIndexOf('\n');
    return -1 === r ? 0 : _n(e.slice(r + 1).match(/^[\t ]*/)[0], t);
   };
   function On(e, t, r) {
    let { node: n } = e;
    if (
     'TemplateLiteral' === n.type &&
     (function ({ node: e, parent: t }) {
      let r = /^[fx]?(?:describe|it|test)$/;
      return 'TaggedTemplateExpression' === t.type && t.quasi === e && 'MemberExpression' === t.tag.type && 'Identifier' === t.tag.property.type && 'each' === t.tag.property.name && (('Identifier' === t.tag.object.type && r.test(t.tag.object.name)) || ('MemberExpression' === t.tag.object.type && 'Identifier' === t.tag.object.property.type && ('only' === t.tag.object.property.name || 'skip' === t.tag.object.property.name) && 'Identifier' === t.tag.object.object.type && r.test(t.tag.object.object.name)));
     })(e)
    ) {
     let n = (function (e, t, r) {
      let { node: n } = e,
       s = n.quasis[0].value.raw.trim().split(/\s*\|\s*/);
      if (s.length > 1 || s.some((e) => e.length > 0)) {
       t.__inJestEach = !0;
       let i = e.map(r, 'expressions');
       t.__inJestEach = !1;
       let a = [],
        o = i.map((e) => '${' + Bn(e, { ...t, printWidth: Number.POSITIVE_INFINITY, endOfLine: 'lf' }).formatted + '}'),
        u = [{ hasLineBreak: !1, cells: [] }];
       for (let e = 1; e < n.quasis.length; e++) {
        let t = x(!1, u, -1),
         r = o[e - 1];
        t.cells.push(r), r.includes('\n') && (t.hasLineBreak = !0), n.quasis[e].value.raw.includes('\n') && u.push({ hasLineBreak: !1, cells: [] });
       }
       let l = Math.max(s.length, ...u.map((e) => e.cells.length)),
        p = Array.from({ length: l }).fill(0),
        c = [{ cells: s }, ...u.filter((e) => e.cells.length > 0)];
       for (let { cells: e } of c.filter((e) => !e.hasLineBreak)) for (let [t, r] of e.entries()) p[t] = Math.max(p[t], S(r));
       return (
        a.push(
         Zt,
         '`',
         Ht([
          sr,
          or(
           sr,
           c.map((e) =>
            or(
             ' | ',
             e.cells.map((t, r) => (e.hasLineBreak ? t : t + ' '.repeat(p[r] - S(t)))),
            ),
           ),
          ),
         ]),
         sr,
         '`',
        ),
        a
       );
      }
     })(e, r, t);
     if (n) return n;
    }
    let s = 'expressions';
    'TSTemplateLiteralType' === n.type && (s = 'types');
    let i = [],
     a = e.map(t, s);
    i.push(Zt, '`');
    let o = 0;
    return (
     e.each(({ index: e, node: u }) => {
      if ((i.push(t()), u.tail)) return;
      let { tabWidth: l } = r,
       p = u.value.raw,
       c = p.includes('\n') ? Ln(p, l) : o;
      o = c;
      let h = a[e],
       d = n[s][e],
       f = kr(r.originalText, U(u), q(n.quasis[e + 1]));
      if (!f) {
       let e = Bn(h, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted;
       e.includes('\n') ? (f = !0) : (h = e);
      }
      f && (at(d) || 'Identifier' === d.type || Ae(d) || 'ConditionalExpression' === d.type || 'SequenceExpression' === d.type || ct(d) || xe(d)) && (h = [Ht([nr, h]), nr]);
      let m =
       0 === c && p.endsWith('\n')
        ? zt(Number.NEGATIVE_INFINITY, h)
        : (function (e, t, r) {
           Ut(e);
           let n = e;
           if (t > 0) {
            for (let e = 0; e < Math.floor(t / r); ++e) n = Ht(n);
            (n = zt(t % r, n)), (n = zt(Number.NEGATIVE_INFINITY, n));
           }
           return n;
          })(h, c, l);
      i.push(Vt(['${', m, Zt, '}']));
     }, 'quasis'),
     i.push('`'),
     i
    );
   }
   function Mn(e, t) {
    return e.map(
     (e) =>
      (function (e, t) {
       let { node: r } = e,
        n = t();
       return at(r) && (n = Vt([Ht([nr, n]), nr])), ['${', n, Zt, '}'];
      })(e, t),
     'expressions',
    );
   }
   function jn(e, t) {
    return lr(e, (e) => ('string' == typeof e ? (t ? D(!1, e, /(\\*)`/g, '$1$1\\`') : Rn(e)) : e));
   }
   function Rn(e) {
    return D(!1, e, /([\\`]|\${)/g, String.raw`\$1`);
   }
   var qn = [(e, t) => 'ObjectExpression' === e.type && 'properties' === t, (e, t) => 'CallExpression' === e.type && 'Identifier' === e.callee.type && 'Component' === e.callee.name && 'arguments' === t, (e, t) => 'Decorator' === e.type && 'expression' === t];
   function Un(e, t) {
    return at(e, st.Block | st.Leading, ({ value: e }) => e === ` ${t} `);
   }
   function $n({ node: e, parent: t }, r) {
    return (
     Un(e, r) ||
     ((function (e) {
      return 'AsConstExpression' === e.type || ('TSAsExpression' === e.type && 'TSTypeReference' === e.typeAnnotation.type && 'Identifier' === e.typeAnnotation.typeName.type && 'const' === e.typeAnnotation.typeName.name);
     })(t) &&
      Un(t, r)) ||
     ('ExpressionStatement' === t.type && Un(t, r))
    );
   }
   async function Hn(e, t, r) {
    let { node: n } = r,
     s = n.quasis.map((e) => e.value.raw),
     i = 0,
     a = s.reduce((e, t, r) => (0 === r ? t : e + '@prettier-placeholder-' + i++ + '-id' + t), ''),
     o = (function (e, t) {
      if (!L(t)) return e;
      let r = 0,
       n = lr(yr(e), (e) => ('string' == typeof e && e.includes('@prettier-placeholder') ? e.split(/@prettier-placeholder-(\d+)-id/).map((e, n) => (n % 2 == 0 ? gr(e) : (r++, t[e]))) : e));
      return t.length === r ? n : null;
     })(await e(a, { parser: 'scss' }), Mn(r, t));
    if (!o) throw new Error("Couldn't insert all the expressions");
    return ['`', Ht([sr, o]), nr, '`'];
   }
   function zn(e) {
    return 'Identifier' === e.type && 'styled' === e.name;
   }
   function Vn(e) {
    return /^[A-Z]/.test(e.object.name) && 'extend' === e.property.name;
   }
   var Wn = function (e) {
    if (
     (function ({ node: e, parent: t, grandparent: r }) {
      return (r && e.quasis && 'JSXExpressionContainer' === t.type && 'JSXElement' === r.type && 'style' === r.openingElement.name.name && r.openingElement.attributes.some((e) => 'JSXAttribute' === e.type && 'jsx' === e.name.name)) || ('TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 'Identifier' === t.tag.type && 'css' === t.tag.name) || ('TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 'MemberExpression' === t.tag.type && 'css' === t.tag.object.name && ('global' === t.tag.property.name || 'resolve' === t.tag.property.name));
     })(e) ||
     (function ({ parent: e }) {
      if (!e || 'TaggedTemplateExpression' !== e.type) return !1;
      let t = 'ParenthesizedExpression' === e.tag.type ? e.tag.expression : e.tag;
      switch (t.type) {
       case 'MemberExpression':
        return zn(t.object) || Vn(t);
       case 'CallExpression':
        return zn(t.callee) || ('MemberExpression' === t.callee.type && (('MemberExpression' === t.callee.object.type && (zn(t.callee.object.object) || Vn(t.callee.object))) || ('CallExpression' === t.callee.object.type && zn(t.callee.object.callee))));
       case 'Identifier':
        return 'css' === t.name;
       default:
        return !1;
      }
     })(e) ||
     (function ({ parent: e, grandparent: t }) {
      return 'JSXAttribute' === (null == t ? void 0 : t.type) && 'JSXExpressionContainer' === e.type && 'JSXIdentifier' === t.name.type && 'css' === t.name.name;
     })(e) ||
     (function (e) {
      let t = (e) => 'TemplateLiteral' === e.type,
       r = (e, t) => pt(e) && !e.computed && 'Identifier' === e.key.type && 'styles' === e.key.name && 'value' === t;
      return e.match(t, (e, t) => ie(e) && 'elements' === t, r, ...qn) || e.match(t, r, ...qn);
     })(e)
    )
     return Hn;
   };
   async function Jn(e, t, r) {
    let { node: n } = r,
     s = n.quasis.length,
     i = Mn(r, t),
     a = [];
    for (let o = 0; o < s; o++) {
     let t = 0 === o,
      r = o === s - 1,
      u = n.quasis[o].value.cooked,
      l = u.split('\n'),
      p = l.length,
      c = i[o],
      h = p > 2 && '' === l[0].trim() && '' === l[1].trim(),
      d = p > 2 && '' === l[p - 1].trim() && '' === l[p - 2].trim(),
      f = l.every((e) => /^\s*(?:#[^\n\r]*)?$/.test(e));
     if (!r && /#[^\n\r]*$/.test(l[p - 1])) return null;
     let m = null;
     (m = f ? Kn(l) : await e(u, { parser: 'graphql' })), m ? ((m = jn(m, !1)), !t && h && a.push(''), a.push(m), !r && d && a.push('')) : !t && !r && h && a.push(''), c && a.push(c);
    }
    return ['`', Ht([sr, or(sr, a)]), sr, '`'];
   }
   function Kn(e) {
    let t = [],
     r = !1,
     n = e.map((e) => e.trim());
    for (let [s, i] of n.entries()) '' !== i && ('' === n[s - 1] && r ? t.push([sr, i]) : t.push(i), (r = !0));
    return 0 === t.length ? null : or(sr, t);
   }
   var Gn = function (e) {
     if (
      (function ({ node: e, parent: t }) {
       return $n({ node: e, parent: t }, 'GraphQL') || (t && (('TaggedTemplateExpression' === t.type && (('MemberExpression' === t.tag.type && 'graphql' === t.tag.object.name && 'experimental' === t.tag.property.name) || ('Identifier' === t.tag.type && ('gql' === t.tag.name || 'graphql' === t.tag.name)))) || ('CallExpression' === t.type && 'Identifier' === t.callee.type && 'graphql' === t.callee.name)));
      })(e)
     )
      return Jn;
    },
    Xn = 0;
   async function Yn(e, t, r, n, s) {
    let { node: i } = n,
     a = Xn;
    Xn = (Xn + 1) >>> 0;
    let o = (e) => `PRETTIER_HTML_PLACEHOLDER_${e}_${a}_IN_JS`,
     u = i.quasis.map((e, t, r) => (t === r.length - 1 ? e.value.cooked : e.value.cooked + o(t))).join(''),
     l = Mn(n, r),
     p = new RegExp(o(String.raw`(\d+)`), 'g'),
     c = 0,
     h = lr(
      await t(u, {
       parser: e,
       __onHtmlRoot(e) {
        c = e.children.length;
       },
      }),
      (e) => {
       if ('string' != typeof e) return e;
       let t = [],
        r = e.split(p);
       for (let n = 0; n < r.length; n++) {
        let e = r[n];
        if (n % 2 == 0) {
         e && ((e = Rn(e)), s.__embeddedInHtml && (e = D(!1, e, /<\/(?=script\b)/gi, String.raw`<\/`)), t.push(e));
         continue;
        }
        let i = Number(e);
        t.push(l[i]);
       }
       return t;
      },
     ),
     d = /^\s/.test(u) ? ' ' : '',
     f = /\s$/.test(u) ? ' ' : '',
     m = 'ignore' === s.htmlWhitespaceSensitivity ? sr : d && f ? rr : null;
    return m ? Vt(['`', Ht([m, Vt(h)]), m, '`']) : ur({ hug: !1 }, Vt(['`', d, c > 1 ? Ht(Vt(h)) : Vt(h), f, '`']));
   }
   var Qn = Yn.bind(void 0, 'html'),
    Zn = Yn.bind(void 0, 'angular');
   var es = function (e) {
    return (function (e) {
     return (
      $n(e, 'HTML') ||
      e.match(
       (e) => 'TemplateLiteral' === e.type,
       (e, t) => 'TaggedTemplateExpression' === e.type && 'Identifier' === e.tag.type && 'html' === e.tag.name && 'quasi' === t,
      )
     );
    })(e)
     ? Qn
     : (function (e) {
          return e.match(
           (e) => 'TemplateLiteral' === e.type,
           (e, t) => pt(e) && !e.computed && 'Identifier' === e.key.type && 'template' === e.key.name && 'value' === t,
           ...qn,
          );
         })(e)
       ? Zn
       : void 0;
   };
   async function ts(e, t, r) {
    let { node: n } = r,
     s = D(!1, n.quasis[0].value.raw, /((?:\\\\)*)\\`/g, (e, t) => '\\'.repeat(t.length / 2) + '`'),
     i = (function (e) {
      let t = e.match(/^([^\S\n]*)\S/m);
      return null === t ? '' : t[1];
     })(s),
     a = '' !== i;
    a && (s = D(!1, s, new RegExp(`^${i}`, 'gm'), ''));
    let o = jn(await e(s, { parser: 'markdown', __inJsTemplate: !0 }), !0);
    return ['`', a ? Ht([nr, o]) : [ir, Wt(o)], nr, '`'];
   }
   var rs = function (e) {
    if (
     (function ({ node: e, parent: t }) {
      return 'TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 1 === e.quasis.length && 'Identifier' === t.tag.type && ('md' === t.tag.name || 'markdown' === t.tag.name);
     })(e)
    )
     return ts;
   };
   var ns = function (e) {
     let t,
      { node: r } = e;
     if (
      'TemplateLiteral' === r.type &&
      !(function ({ quasis: e }) {
       return e.some(({ value: { cooked: e } }) => null === e);
      })(r)
     )
      for (let n of [Wn, Gn, es, rs])
       if (((t = n(e)), t))
        return 1 === r.quasis.length && '' === r.quasis[0].value.raw.trim()
         ? '``'
         : async (...e) => {
            let r = await t(...e);
            return r && ur({ embed: !0, ...r.label }, r);
           };
    },
    ss = ((e, t, r) => (
     (r = null != e ? i(l(e)) : {}),
     ((e, t, r, n) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let s of u(t)) !p.call(e, s) && s !== r && a(e, s, { get: () => t[s], enumerable: !(n = o(t, s)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : a(r, 'default', { value: e, enumerable: !0 }), e)
    ))(m(), 1);
   var is = function (e) {
    if (!e.startsWith('#!')) return '';
    let t = e.indexOf('\n');
    return -1 === t ? e : e.slice(0, t);
   };
   function as(e) {
    let {
      shebang: t,
      text: r,
      pragmas: n,
      comments: s,
     } = (function (e) {
      let t = is(e);
      t && (e = e.slice(t.length + 1));
      let r = (0, ss.extract)(e),
       { pragmas: n, comments: s } = (0, ss.parseWithComments)(r);
      return { shebang: t, text: e, pragmas: n, comments: s };
     })(e),
     i = (0, ss.strip)(r);
    return (t ? `${t}\n` : '') + (0, ss.print)({ pragmas: { format: '', ...n }, comments: s.trimStart() }) + (i.startsWith('\n') ? '\n' : '\n\n') + i;
   }
   var os = function (e, t) {
    let { originalText: r, [Symbol.for('comments')]: n, locStart: s, locEnd: i, [Symbol.for('printedComments')]: a } = t,
     { node: o } = e,
     u = s(o),
     l = i(o);
    for (let p of n) s(p) >= u && i(p) <= l && a.add(p);
    return r.slice(u, l);
   };
   function us(e, t) {
    var r, n, s, i, a, o, u, l, p;
    if (e.isRoot) return !1;
    let { node: c, key: h, parent: d } = e;
    if (
     t.__isInHtmlInterpolation &&
     !t.bracketSpacing &&
     (function (e) {
      return ae(e);
     })(c) &&
     ps(e)
    )
     return !0;
    if (ls(c)) return !1;
    if ('Identifier' === c.type) {
     if ((null != (r = c.extra) && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(c.name)) || ('left' === h && (('async' === c.name && !d.await) || 'let' === c.name) && 'ForOfStatement' === d.type)) return !0;
     if ('let' === c.name) {
      let t = null == (n = e.findAncestor((e) => 'ForOfStatement' === e.type)) ? void 0 : n.left;
      if (t && $e(t, (e) => e === c)) return !0;
     }
     if ('object' === h && 'let' === c.name && 'MemberExpression' === d.type && d.computed && !d.optional) {
      let t = e.findAncestor((e) => 'ExpressionStatement' === e.type || 'ForStatement' === e.type || 'ForInStatement' === e.type),
       r = t ? ('ExpressionStatement' === t.type ? t.expression : 'ForStatement' === t.type ? t.init : t.left) : void 0;
      if (r && $e(r, (e) => e === c)) return !0;
     }
     if ('expression' === h)
      switch (c.name) {
       case 'await':
       case 'interface':
       case 'module':
       case 'using':
       case 'yield':
       case 'let':
       case 'component':
       case 'hook':
       case 'type': {
        let t = e.findAncestor((e) => !ct(e));
        if (t !== d && 'ExpressionStatement' === t.type) return !0;
       }
      }
     return !1;
    }
    if ('ObjectExpression' === c.type || 'FunctionExpression' === c.type || 'ClassExpression' === c.type || 'DoExpression' === c.type) {
     let t = null == (s = e.findAncestor((e) => 'ExpressionStatement' === e.type)) ? void 0 : s.expression;
     if (t && $e(t, (e) => e === c)) return !0;
    }
    if ('ObjectExpression' === c.type) {
     let t = null == (i = e.findAncestor((e) => 'ArrowFunctionExpression' === e.type)) ? void 0 : i.body;
     if (t && 'SequenceExpression' !== t.type && 'AssignmentExpression' !== t.type && $e(t, (e) => e === c)) return !0;
    }
    switch (d.type) {
     case 'ParenthesizedExpression':
      return !1;
     case 'ClassDeclaration':
     case 'ClassExpression':
      if ('superClass' === h && ('ArrowFunctionExpression' === c.type || 'AssignmentExpression' === c.type || 'AwaitExpression' === c.type || 'BinaryExpression' === c.type || 'ConditionalExpression' === c.type || 'LogicalExpression' === c.type || 'NewExpression' === c.type || 'ObjectExpression' === c.type || 'SequenceExpression' === c.type || 'TaggedTemplateExpression' === c.type || 'UnaryExpression' === c.type || 'UpdateExpression' === c.type || 'YieldExpression' === c.type || 'TSNonNullExpression' === c.type || ('ClassExpression' === c.type && L(c.decorators)))) return !0;
      break;
     case 'ExportDefaultDeclaration':
      return cs(e, t) || 'SequenceExpression' === c.type;
     case 'Decorator':
      if ('expression' === h) {
       if (Ae(c) && c.computed) return !0;
       let e = !1,
        r = !1,
        n = c;
       for (; n; )
        switch (n.type) {
         case 'MemberExpression':
          (r = !0), (n = n.object);
          break;
         case 'CallExpression':
          if (r || e) return 'typescript' !== t.parser;
          (e = !0), (n = n.callee);
          break;
         case 'Identifier':
          return !1;
         case 'TaggedTemplateExpression':
          return 'typescript' !== t.parser;
         default:
          return !0;
        }
       return !0;
      }
      break;
     case 'TypeAnnotation':
      if (
       e.match(void 0, void 0, (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type) &&
       (function (e) {
        return Z(e, (e) => 'ObjectTypeAnnotation' === e.type && Z(e, (e) => 'FunctionTypeAnnotation' === e.type));
       })(c)
      )
       return !0;
      break;
     case 'BinaryExpression':
      if ('left' === h && ('in' === d.operator || 'instanceof' === d.operator) && 'UnaryExpression' === c.type) return !0;
    }
    switch (c.type) {
     case 'UpdateExpression':
      if ('UnaryExpression' === d.type) return c.prefix && (('++' === c.operator && '+' === d.operator) || ('--' === c.operator && '-' === d.operator));
     case 'UnaryExpression':
      switch (d.type) {
       case 'UnaryExpression':
        return c.operator === d.operator && ('+' === c.operator || '-' === c.operator);
       case 'BindExpression':
       case 'TaggedTemplateExpression':
       case 'TSNonNullExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'BinaryExpression':
        return 'left' === h && '**' === d.operator;
       default:
        return !1;
      }
     case 'BinaryExpression':
      if (
       'UpdateExpression' === d.type ||
       ('in' === c.operator &&
        (function (e) {
         let t = 0,
          { node: r } = e;
         for (; r; ) {
          let n = e.getParentNode(t++);
          if ('ForStatement' === (null == n ? void 0 : n.type) && n.init === r) return !0;
          r = n;
         }
         return !1;
        })(e))
      )
       return !0;
      if ('|>' === c.operator && null != (a = c.extra) && a.parenthesized) {
       let t = e.grandparent;
       if ('BinaryExpression' === t.type && '|>' === t.operator) return !0;
      }
     case 'TSTypeAssertion':
     case 'TSAsExpression':
     case 'TSSatisfiesExpression':
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
     case 'LogicalExpression':
      switch (d.type) {
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
        return !ct(c);
       case 'ConditionalExpression':
        return ct(c);
       case 'CallExpression':
       case 'NewExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ClassExpression':
       case 'ClassDeclaration':
        return 'superClass' === h;
       case 'TSTypeAssertion':
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'JSXSpreadAttribute':
       case 'SpreadElement':
       case 'BindExpression':
       case 'AwaitExpression':
       case 'TSNonNullExpression':
       case 'UpdateExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'AssignmentExpression':
       case 'AssignmentPattern':
        return 'left' === h && ('TSTypeAssertion' === c.type || ct(c));
       case 'LogicalExpression':
        if ('LogicalExpression' === c.type) return d.operator !== c.operator;
       case 'BinaryExpression': {
        let { operator: e, type: t } = c;
        if (!e && 'TSTypeAssertion' !== t) return !0;
        let r = Ke(e),
         n = d.operator,
         s = Ke(n);
        return (
         s > r ||
         ('right' === h && s === r) ||
         (s === r && !We(n, e)) ||
         (s < r && '%' === e
          ? '+' === n || '-' === n
          : !!(function (e) {
             return !!Ve[e] || '|' === e || '^' === e || '&' === e;
            })(n))
        );
       }
       default:
        return !1;
      }
     case 'SequenceExpression':
      switch (d.type) {
       case 'ReturnStatement':
       case 'ForStatement':
        return !1;
       case 'ExpressionStatement':
        return 'expression' !== h;
       case 'ArrowFunctionExpression':
        return 'body' !== h;
       default:
        return !0;
      }
     case 'YieldExpression':
      if ('AwaitExpression' === d.type || 'TSTypeAssertion' === d.type) return !0;
     case 'AwaitExpression':
      switch (d.type) {
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'LogicalExpression':
       case 'SpreadElement':
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'TSNonNullExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'BindExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ConditionalExpression':
        return 'test' === h;
       case 'BinaryExpression':
        return !(!c.argument && '|>' === d.operator);
       default:
        return !1;
      }
     case 'TSFunctionType':
      if (
       e.match(
        (e) => 'TSFunctionType' === e.type,
        (e, t) => 'typeAnnotation' === t && 'TSTypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       )
      )
       return !0;
     case 'TSConditionalType':
     case 'TSConstructorType':
      if ('extendsType' === h && 'TSConditionalType' === d.type) {
       if ('TSConditionalType' === c.type) return !0;
       let { typeAnnotation: e } = c.returnType || c.typeAnnotation;
       if (('TSTypePredicate' === e.type && e.typeAnnotation && (e = e.typeAnnotation.typeAnnotation), 'TSInferType' === e.type && e.typeParameter.constraint)) return !0;
      }
      if ('checkType' === h && 'TSConditionalType' === d.type) return !0;
     case 'TSUnionType':
     case 'TSIntersectionType':
      if (('TSUnionType' === d.type || 'TSIntersectionType' === d.type) && d.types.length > 1 && (!c.types || c.types.length > 1)) return !0;
     case 'TSInferType':
      if ('TSInferType' === c.type) {
       if ('TSRestType' === d.type) return !1;
       if ('types' === h && ('TSUnionType' === d.type || 'TSIntersectionType' === d.type) && 'TSTypeParameter' === c.typeParameter.type && c.typeParameter.constraint) return !0;
      }
     case 'TSTypeOperator':
      return 'TSArrayType' === d.type || 'TSOptionalType' === d.type || 'TSRestType' === d.type || ('objectType' === h && 'TSIndexedAccessType' === d.type) || 'TSTypeOperator' === d.type || ('TSTypeAnnotation' === d.type && e.grandparent.type.startsWith('TSJSDoc'));
     case 'TSTypeQuery':
      return ('objectType' === h && 'TSIndexedAccessType' === d.type) || ('elementType' === h && 'TSArrayType' === d.type);
     case 'TypeOperator':
      return 'ArrayTypeAnnotation' === d.type || 'NullableTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type)) || 'TypeOperator' === d.type;
     case 'TypeofTypeAnnotation':
      return ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type)) || ('elementType' === h && 'ArrayTypeAnnotation' === d.type);
     case 'ArrayTypeAnnotation':
      return 'NullableTypeAnnotation' === d.type;
     case 'IntersectionTypeAnnotation':
     case 'UnionTypeAnnotation':
      return 'TypeOperator' === d.type || 'ArrayTypeAnnotation' === d.type || 'NullableTypeAnnotation' === d.type || 'IntersectionTypeAnnotation' === d.type || 'UnionTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type));
     case 'InferTypeAnnotation':
     case 'NullableTypeAnnotation':
      return 'ArrayTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type));
     case 'ComponentTypeAnnotation':
     case 'FunctionTypeAnnotation': {
      if ('ComponentTypeAnnotation' === c.type && (null === c.rendersType || void 0 === c.rendersType)) return !1;
      if (
       e.match(
        void 0,
        (e, t) => 'typeAnnotation' === t && 'TypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       ) ||
       e.match(
        void 0,
        (e, t) => 'typeAnnotation' === t && 'TypePredicate' === e.type,
        (e, t) => 'typeAnnotation' === t && 'TypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       )
      )
       return !0;
      let t = 'NullableTypeAnnotation' === d.type ? e.grandparent : d;
      return (
       'UnionTypeAnnotation' === t.type ||
       'IntersectionTypeAnnotation' === t.type ||
       'ArrayTypeAnnotation' === t.type ||
       ('objectType' === h && ('IndexedAccessType' === t.type || 'OptionalIndexedAccessType' === t.type)) ||
       ('checkType' === h && 'ConditionalTypeAnnotation' === d.type) ||
       ('extendsType' === h && 'ConditionalTypeAnnotation' === d.type && 'InferTypeAnnotation' === (null == (o = c.returnType) ? void 0 : o.type) && (null == (u = c.returnType) ? void 0 : u.typeParameter.bound)) ||
       'NullableTypeAnnotation' === t.type ||
       ('FunctionTypeParam' === d.type &&
        null === d.name &&
        Ye(c).some((e) => {
         var t;
         return 'NullableTypeAnnotation' === (null == (t = e.typeAnnotation) ? void 0 : t.type);
        }))
      );
     }
     case 'ConditionalTypeAnnotation':
      if (('extendsType' === h && 'ConditionalTypeAnnotation' === d.type && 'ConditionalTypeAnnotation' === c.type) || ('checkType' === h && 'ConditionalTypeAnnotation' === d.type)) return !0;
     case 'OptionalIndexedAccessType':
      return 'objectType' === h && 'IndexedAccessType' === d.type;
     case 'StringLiteral':
     case 'NumericLiteral':
     case 'Literal':
      if ('string' == typeof c.value && 'ExpressionStatement' === d.type && !d.directive) {
       let t = e.grandparent;
       return 'Program' === t.type || 'BlockStatement' === t.type;
      }
      return 'object' === h && 'MemberExpression' === d.type && 'number' == typeof c.value;
     case 'AssignmentExpression': {
      let t = e.grandparent;
      return ('body' === h && 'ArrowFunctionExpression' === d.type) || (('key' !== h || ('ClassProperty' !== d.type && 'PropertyDefinition' !== d.type) || !d.computed) && (('init' !== h && 'update' !== h) || 'ForStatement' !== d.type) && ('ExpressionStatement' === d.type ? 'ObjectPattern' === c.left.type : !(('key' === h && 'TSPropertySignature' === d.type) || 'AssignmentExpression' === d.type || ('SequenceExpression' === d.type && 'ForStatement' === t.type && (t.init === d || t.update === d)) || ('value' === h && 'Property' === d.type && 'ObjectPattern' === t.type && t.properties.includes(d)) || 'NGChainedExpression' === d.type)));
     }
     case 'ConditionalExpression':
      switch (d.type) {
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'SpreadElement':
       case 'BinaryExpression':
       case 'LogicalExpression':
       case 'NGPipeExpression':
       case 'ExportDefaultDeclaration':
       case 'AwaitExpression':
       case 'JSXSpreadAttribute':
       case 'TSTypeAssertion':
       case 'TypeCastExpression':
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'TSNonNullExpression':
        return !0;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ConditionalExpression':
        return !t.experimentalTernaries && 'test' === h;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       default:
        return !1;
      }
     case 'FunctionExpression':
      switch (d.type) {
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'TaggedTemplateExpression':
        return !0;
       default:
        return !1;
      }
     case 'ArrowFunctionExpression':
      switch (d.type) {
       case 'BinaryExpression':
        return '|>' !== d.operator || (null == (l = c.extra) ? void 0 : l.parenthesized);
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'TSNonNullExpression':
       case 'BindExpression':
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'LogicalExpression':
       case 'AwaitExpression':
       case 'TSTypeAssertion':
        return !0;
       case 'ConditionalExpression':
        return 'test' === h;
       default:
        return !1;
      }
     case 'ClassExpression':
      return 'NewExpression' === d.type && 'callee' === h;
     case 'OptionalMemberExpression':
     case 'OptionalCallExpression':
     case 'CallExpression':
     case 'MemberExpression':
      if (
       (function (e) {
        let { node: t, parent: r, grandparent: n, key: s } = e;
        return !!(
         (('OptionalMemberExpression' === t.type || 'OptionalCallExpression' === t.type) && (('object' === s && 'MemberExpression' === r.type) || ('callee' === s && ('CallExpression' === r.type || 'NewExpression' === r.type)) || ('TSNonNullExpression' === r.type && 'MemberExpression' === n.type && n.object === r))) ||
         (e.match(
          () => 'CallExpression' === t.type || 'MemberExpression' === t.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
         ) &&
          (e.match(void 0, void 0, (e, t) => ('callee' === t && (('CallExpression' === e.type && !e.optional) || 'NewExpression' === e.type)) || ('object' === t && 'MemberExpression' === e.type && !e.optional)) ||
           e.match(
            void 0,
            void 0,
            (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
            (e, t) => 'object' === t && 'MemberExpression' === e.type,
           ))) ||
         e.match(
          () => 'CallExpression' === t.type || 'MemberExpression' === t.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'object' === t && 'MemberExpression' === e.type,
         )
        );
       })(e)
      )
       return !0;
     case 'TaggedTemplateExpression':
     case 'TSNonNullExpression':
      if ('callee' === h && ('BindExpression' === d.type || 'NewExpression' === d.type)) {
       let e = c;
       for (; e; )
        switch (e.type) {
         case 'CallExpression':
         case 'OptionalCallExpression':
          return !0;
         case 'MemberExpression':
         case 'OptionalMemberExpression':
         case 'BindExpression':
          e = e.object;
          break;
         case 'TaggedTemplateExpression':
          e = e.tag;
          break;
         case 'TSNonNullExpression':
          e = e.expression;
          break;
         default:
          return !1;
        }
      }
      return !1;
     case 'BindExpression':
      return ('callee' === h && ('BindExpression' === d.type || 'NewExpression' === d.type)) || ('object' === h && Ae(d));
     case 'NGPipeExpression':
      return !('NGRoot' === d.type || 'NGMicrosyntaxExpression' === d.type || ('ObjectProperty' === d.type && (null == (p = c.extra) || !p.parenthesized)) || ie(d) || ('arguments' === h && we(d)) || ('right' === h && 'NGPipeExpression' === d.type) || ('property' === h && 'MemberExpression' === d.type) || 'AssignmentExpression' === d.type);
     case 'JSXFragment':
     case 'JSXElement':
      return 'callee' === h || ('left' === h && 'BinaryExpression' === d.type && '<' === d.operator) || (!ie(d) && 'ArrowFunctionExpression' !== d.type && 'AssignmentExpression' !== d.type && 'AssignmentPattern' !== d.type && 'BinaryExpression' !== d.type && 'NewExpression' !== d.type && 'ConditionalExpression' !== d.type && 'ExpressionStatement' !== d.type && 'JsExpressionRoot' !== d.type && 'JSXAttribute' !== d.type && 'JSXElement' !== d.type && 'JSXExpressionContainer' !== d.type && 'JSXFragment' !== d.type && 'LogicalExpression' !== d.type && !we(d) && !pt(d) && 'ReturnStatement' !== d.type && 'ThrowStatement' !== d.type && 'TypeCastExpression' !== d.type && 'VariableDeclarator' !== d.type && 'YieldExpression' !== d.type);
     case 'TSInstantiationExpression':
      return 'object' === h && Ae(d);
    }
    return !1;
   }
   var ls = K(['BlockStatement', 'BreakStatement', 'ComponentDeclaration', 'ClassBody', 'ClassDeclaration', 'ClassMethod', 'ClassProperty', 'PropertyDefinition', 'ClassPrivateProperty', 'ContinueStatement', 'DebuggerStatement', 'DeclareComponent', 'DeclareClass', 'DeclareExportAllDeclaration', 'DeclareExportDeclaration', 'DeclareFunction', 'DeclareHook', 'DeclareInterface', 'DeclareModule', 'DeclareModuleExports', 'DeclareNamespace', 'DeclareVariable', 'DeclareEnum', 'DoWhileStatement', 'EnumDeclaration', 'ExportAllDeclaration', 'ExportDefaultDeclaration', 'ExportNamedDeclaration', 'ExpressionStatement', 'ForInStatement', 'ForOfStatement', 'ForStatement', 'FunctionDeclaration', 'HookDeclaration', 'IfStatement', 'ImportDeclaration', 'InterfaceDeclaration', 'LabeledStatement', 'MethodDefinition', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'TSDeclareFunction', 'TSEnumDeclaration', 'TSImportEqualsDeclaration', 'TSInterfaceDeclaration', 'TSModuleDeclaration', 'TSNamespaceExportDeclaration', 'TypeAlias', 'VariableDeclaration', 'WhileStatement', 'WithStatement']);
   function ps(e) {
    let { parent: t, key: r } = e;
    switch (t.type) {
     case 'NGPipeExpression':
      if ('arguments' === r && e.isLast) return e.callParent(ps);
      break;
     case 'ObjectProperty':
      if ('value' === r) return e.callParent(() => 'properties' === e.key && e.isLast);
      break;
     case 'BinaryExpression':
     case 'LogicalExpression':
      if ('right' === r) return e.callParent(ps);
      break;
     case 'ConditionalExpression':
      if ('alternate' === r) return e.callParent(ps);
      break;
     case 'UnaryExpression':
      if (t.prefix) return e.callParent(ps);
    }
    return !1;
   }
   function cs(e, t) {
    let { node: r, parent: n } = e;
    return 'FunctionExpression' === r.type || 'ClassExpression' === r.type ? 'ExportDefaultDeclaration' === n.type || !us(e, t) : !(!ee(r) || ('ExportDefaultDeclaration' !== n.type && us(e, t))) && e.call(() => cs(e, t), ...re(r));
   }
   var hs = us;
   var ds = function (e, t) {
     let r = t - 1;
     return (r = A(e, r, { backwards: !0 })), (r = P(e, r, { backwards: !0 })), (r = A(e, r, { backwards: !0 })), r !== P(e, r, { backwards: !0 });
    },
    fs = () => !0;
   function ms(e, t) {
    return (e.node.printed = !0), t.printer.printComment(e, t);
   }
   function ys(e, t, r = {}) {
    let { node: n } = e;
    if (!L(null == n ? void 0 : n.comments)) return '';
    let { indent: s = !1, marker: i, filter: a = fs } = r,
     o = [];
    if (
     (e.each(({ node: r }) => {
      r.leading || r.trailing || r.marker !== i || !a(r) || o.push(ms(e, t));
     }, 'comments'),
     0 === o.length)
    )
     return '';
    let u = or(sr, o);
    return s ? Ht([sr, u]) : u;
   }
   function gs(e, t) {
    let r = e.node;
    if (!r) return {};
    let n = t[Symbol.for('printedComments')];
    if (0 === (r.comments || []).filter((e) => !n.has(e)).length) return { leading: '', trailing: '' };
    let s,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (null != n && n.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           var r;
           let n = e.node,
            s = [ms(e, t)],
            { printer: i, originalText: a, locStart: o, locEnd: u } = t;
           if (null == (r = i.isBlockComment) ? void 0 : r.call(i, n)) {
            let e = I(a, u(n)) ? (I(a, o(n), { backwards: !0 }) ? sr : rr) : ' ';
            s.push(e);
           } else s.push(sr);
           let l = P(a, A(a, u(n)));
           return !1 !== l && I(a, l) && s.push(sr), s;
          })(e, t),
         )
       : u &&
         ((s = (function (e, t, r) {
          var n;
          let s = e.node,
           i = ms(e, t),
           { printer: a, originalText: o, locStart: u } = t,
           l = null == (n = a.isBlockComment) ? void 0 : n.call(a, s);
          if ((null != r && r.hasLineSuffix && (null == r || !r.isBlock)) || I(o, u(s), { backwards: !0 })) {
           let e = ds(o, u(s));
           return { doc: Qt([sr, e ? sr : '', i]), isBlock: l, hasLineSuffix: !0 };
          }
          return !l || (null != r && r.hasLineSuffix) ? { doc: [Qt([' ', i]), er], isBlock: l, hasLineSuffix: !0 } : { doc: [' ', i], isBlock: l, hasLineSuffix: !1 };
         })(e, t, s)),
         a.push(s.doc));
     }, 'comments'),
     { leading: i, trailing: a }
    );
   }
   function Ds(e, t, r) {
    let { leading: n, trailing: s } = gs(e, r);
    return n || s ? xr(t, (e) => [n, e, s]) : t;
   }
   var xs = class extends Error {
     name = 'UnexpectedNodeError';
     constructor(e, t, r = 'type') {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    },
    bs = xs;
   var vs;
   vs = new WeakMap();
   var Es = class {
     constructor(e) {
      ((e, t, r) => {
       t.has(e) ? c('Cannot add the same private member more than once') : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, vs),
       ((e, t, r, n) => {
        d(e, t, 'write to private field'), n ? n.call(e, r) : t.set(e, r);
       })(this, vs, new Set(e));
     }
     getLeadingWhitespaceCount(e) {
      let t = f(this, vs),
       r = 0;
      for (let n = 0; n < e.length && t.has(e.charAt(n)); n++) r++;
      return r;
     }
     getTrailingWhitespaceCount(e) {
      let t = f(this, vs),
       r = 0;
      for (let n = e.length - 1; n >= 0 && t.has(e.charAt(n)); n--) r++;
      return r;
     }
     getLeadingWhitespace(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(0, t);
     }
     getTrailingWhitespace(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(e.length - t);
     }
     hasLeadingWhitespace(e) {
      return f(this, vs).has(e.charAt(0));
     }
     hasTrailingWhitespace(e) {
      return f(this, vs).has(x(!1, e, -1));
     }
     trimStart(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(t);
     }
     trimEnd(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(0, e.length - t);
     }
     trim(e) {
      return this.trimEnd(this.trimStart(e));
     }
     split(e, t = !1) {
      let r = `[${(function (e) {
        if ('string' != typeof e) throw new TypeError('Expected a string');
        return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
       })([...f(this, vs)].join(''))}]+`,
       n = new RegExp(t ? `(${r})` : r);
      return e.split(n);
     }
     hasWhitespaceCharacter(e) {
      let t = f(this, vs);
      return Array.prototype.some.call(e, (e) => t.has(e));
     }
     hasNonWhitespaceCharacter(e) {
      let t = f(this, vs);
      return Array.prototype.some.call(e, (e) => !t.has(e));
     }
     isWhitespaceOnly(e) {
      let t = f(this, vs);
      return Array.prototype.every.call(e, (e) => t.has(e));
     }
    },
    Cs = new Es(' \n\r\t'),
    Ts = (e) => '' === e || e === rr || e === sr || e === nr;
   function Ss(e, t, r) {
    var n, s, i;
    let { node: a } = e;
    if (
     'JSXElement' === a.type &&
     (function (e) {
      if (0 === e.children.length) return !0;
      if (e.children.length > 1) return !1;
      let t = e.children[0];
      return 'JSXText' === t.type && !Ns(t);
     })(a)
    )
     return [r('openingElement'), r('closingElement')];
    let o = 'JSXElement' === a.type ? r('openingElement') : r('openingFragment'),
     u = 'JSXElement' === a.type ? r('closingElement') : r('closingFragment');
    if (1 === a.children.length && 'JSXExpressionContainer' === a.children[0].type && ('TemplateLiteral' === a.children[0].expression.type || 'TaggedTemplateExpression' === a.children[0].expression.type)) return [o, ...e.map(r, 'children'), u];
    a.children = a.children.map((e) =>
     (function (e) {
      return 'JSXExpressionContainer' === e.type && le(e.expression) && ' ' === e.expression.value && !at(e.expression);
     })(e)
      ? { type: 'JSXText', value: ' ', raw: ' ' }
      : e,
    );
    let l = a.children.some(ye),
     p = a.children.filter((e) => 'JSXExpressionContainer' === e.type).length > 1,
     c = 'JSXElement' === a.type && a.openingElement.attributes.length > 1,
     h = hr(o) || l || c || p,
     d = 'mdx' === e.parent.rootMarker,
     f = t.singleQuote ? "{' '}" : '{" "}',
     m = d ? ' ' : Xt([f, nr], ' '),
     y = (function (e, t, r, n, s) {
      let i = [];
      return (
       e.each(({ node: e, next: t }) => {
        if ('JSXText' === e.type) {
         let r = Re(e);
         if (Ns(e)) {
          let a,
           o = Cs.split(r, !0);
          if (('' === o[0] && (i.push(''), o.shift(), /\n/.test(o[0]) ? i.push(As(s, o[1], e, t)) : i.push(n), o.shift()), '' === x(!1, o, -1) && (o.pop(), (a = o.pop())), 0 === o.length)) return;
          for (let [e, t] of o.entries()) e % 2 == 1 ? i.push(rr) : i.push(t);
          void 0 !== a ? (/\n/.test(a) ? i.push(As(s, x(!1, i, -1), e, t)) : i.push(n)) : i.push(ws(s, x(!1, i, -1), e, t));
         } else /\n/.test(r) ? r.match(/\n/g).length > 1 && i.push('', sr) : i.push('', n);
        } else {
         let n = r();
         if ((i.push(n), t && Ns(t))) {
          let r = Cs.trim(Re(t)),
           [n] = Cs.split(r);
          i.push(ws(s, n, e, t));
         } else i.push(sr);
        }
       }, 'children'),
       i
      );
     })(e, 0, r, m, 'fbt' === (null == (s = null == (n = a.openingElement) ? void 0 : n.name) ? void 0 : s.name)),
     g = a.children.some((e) => Ns(e));
    for (let x = y.length - 2; x >= 0; x--) {
     let e = '' === y[x] && '' === y[x + 1],
      t = y[x] === sr && '' === y[x + 1] && y[x + 2] === sr,
      r = (y[x] === nr || y[x] === sr) && '' === y[x + 1] && y[x + 2] === m,
      n = y[x] === m && '' === y[x + 1] && (y[x + 2] === nr || y[x + 2] === sr),
      s = y[x] === m && '' === y[x + 1] && y[x + 2] === m,
      i = (y[x] === nr && '' === y[x + 1] && y[x + 2] === sr) || (y[x] === sr && '' === y[x + 1] && y[x + 2] === nr);
     (t && g) || e || r || s || i ? y.splice(x, 2) : n && y.splice(x + 1, 2);
    }
    for (; y.length > 0 && Ts(x(!1, y, -1)); ) y.pop();
    for (; y.length > 1 && Ts(y[0]) && Ts(y[1]); ) y.shift(), y.shift();
    let D = [];
    for (let [x, E] of y.entries()) {
     if (E === m) {
      if (1 === x && '' === y[x - 1]) {
       if (2 === y.length) {
        D.push(f);
        continue;
       }
       D.push([f, sr]);
       continue;
      }
      if (x === y.length - 1) {
       D.push(f);
       continue;
      }
      if ('' === y[x - 1] && y[x - 2] === sr) {
       D.push(f);
       continue;
      }
     }
     D.push(E), hr(E) && (h = !0);
    }
    let b = g ? Gt(D) : Vt(D, { shouldBreak: !0 });
    if (('JSXText' === (null == (i = t.cursorNode) ? void 0 : i.type) && a.children.includes(t.cursorNode) && (b = [ar, b, ar]), d)) return b;
    let v = Vt([o, Ht([sr, b]), sr, u]);
    return h ? v : Kt([Vt([o, ...y, u]), v]);
   }
   function ws(e, t, r, n) {
    return e ? '' : ('JSXElement' === r.type && !r.closingElement) || ('JSXElement' === (null == n ? void 0 : n.type) && !n.closingElement) ? (1 === t.length ? nr : sr) : nr;
   }
   function As(e, t, r, n) {
    return e ? sr : 1 === t.length ? (('JSXElement' === r.type && !r.closingElement) || ('JSXElement' === (null == n ? void 0 : n.type) && !n.closingElement) ? sr : nr) : sr;
   }
   var Fs = new Set(['ArrayExpression', 'TupleExpression', 'JSXAttribute', 'JSXElement', 'JSXExpressionContainer', 'JSXFragment', 'ExpressionStatement', 'CallExpression', 'OptionalCallExpression', 'ConditionalExpression', 'JsExpressionRoot']);
   function ks(e, t, r) {
    return e.selfClosing
     ? [rr, '/>']
     : (function (e, t, r) {
          let n = e.attributes.length > 0 && at(x(!1, e.attributes, -1), st.Trailing);
          return (0 === e.attributes.length && !r) || ((t.bracketSameLine || t.jsxBracketSameLine) && (!r || e.attributes.length > 0) && !n);
         })(e, t, r)
       ? ['>']
       : [nr, '>'];
   }
   function Ps(e, t, r) {
    return (function (e, t, r) {
     let { parent: n } = e;
     if (Fs.has(n.type)) return t;
     let s = e.match(
       void 0,
       (e) => 'ArrowFunctionExpression' === e.type,
       we,
       (e) => 'JSXExpressionContainer' === e.type,
      ),
      i = hs(e, r);
     return Vt([i ? '' : Xt('('), Ht([nr, t]), nr, i ? '' : Xt(')')], { shouldBreak: s });
    })(e, Ds(e, Ss(e, t, r), t), t);
   }
   function Is(e, t, r) {
    let { node: n } = e;
    if (n.type.startsWith('JSX'))
     switch (n.type) {
      case 'JSXAttribute':
       return (function (e, t, r) {
        let { node: n } = e,
         s = [];
        if ((s.push(r('name')), n.value)) {
         let i;
         if (le(n.value)) {
          let r = Re(n.value),
           s = D(!1, D(!1, r.slice(1, -1), '&apos;', "'"), '&quot;', '"'),
           a = M(s, t.jsxSingleQuote);
          (s = '"' === a ? D(!1, s, '"', '&quot;') : D(!1, s, "'", '&apos;')), (i = e.call(() => Ds(e, gr(a + s + a), t), 'value'));
         } else i = r('value');
         s.push('=', i);
        }
        return s;
       })(e, t, r);
      case 'JSXIdentifier':
       return n.name;
      case 'JSXNamespacedName':
       return or(':', [r('namespace'), r('name')]);
      case 'JSXMemberExpression':
       return or('.', [r('object'), r('property')]);
      case 'JSXSpreadAttribute':
      case 'JSXSpreadChild':
       return (function (e, t, r) {
        let { node: n } = e;
        return [
         '{',
         e.call(
          ({ node: n }) => {
           let s = ['...', r()];
           return at(n) && Cn(e) ? [Ht([nr, Ds(e, s, t)]), nr] : s;
          },
          'JSXSpreadAttribute' === n.type ? 'argument' : 'expression',
         ),
         '}',
        ];
       })(e, t, r);
      case 'JSXExpressionContainer':
       return (function (e, t, r) {
        let { node: n } = e,
         s = (e, t) => 'JSXEmptyExpression' === e.type || (!at(e) && (ie(e) || ae(e) || 'ArrowFunctionExpression' === e.type || ('AwaitExpression' === e.type && (s(e.argument, e) || 'JSXElement' === e.argument.type)) || we(e) || ('ChainExpression' === e.type && we(e.expression)) || 'FunctionExpression' === e.type || 'TemplateLiteral' === e.type || 'TaggedTemplateExpression' === e.type || 'DoExpression' === e.type || (ye(t) && ('ConditionalExpression' === e.type || xe(e)))));
        return s(n.expression, e.parent) ? Vt(['{', r('expression'), Zt, '}']) : Vt(['{', Ht([nr, r('expression')]), nr, Zt, '}']);
       })(e, 0, r);
      case 'JSXFragment':
      case 'JSXElement':
       return Ps(e, t, r);
      case 'JSXOpeningElement':
       return (function (e, t, r) {
        var n, s;
        let { node: i } = e,
         a = at(i.name) || at(i.typeParameters) || at(i.typeArguments);
        if (i.selfClosing && 0 === i.attributes.length && !a) return ['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), ' />'];
        if (1 === (null == (n = i.attributes) ? void 0 : n.length) && le(i.attributes[0].value) && !i.attributes[0].value.value.includes('\n') && !a && !at(i.attributes[0])) return Vt(['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), ' ', ...e.map(r, 'attributes'), i.selfClosing ? ' />' : '>']);
        let o = null == (s = i.attributes) ? void 0 : s.some((e) => le(e.value) && e.value.value.includes('\n')),
         u = t.singleAttributePerLine && i.attributes.length > 1 ? sr : rr;
        return Vt(['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), Ht(e.map(() => [u, r()], 'attributes')), ...ks(i, t, a)], { shouldBreak: o });
       })(e, t, r);
      case 'JSXClosingElement':
       return (function (e, t, r) {
        let { node: n } = e,
         s = [];
        s.push('</');
        let i = r('name');
        return at(n.name, st.Leading | st.Line) ? s.push(Ht([sr, i]), sr) : at(n.name, st.Leading | st.Block) ? s.push(' ', i) : s.push(i), s.push('>'), s;
       })(e, 0, r);
      case 'JSXOpeningFragment':
      case 'JSXClosingFragment':
       return (function (e, t) {
        let { node: r } = e,
         n = at(r),
         s = at(r, st.Line),
         i = 'JSXOpeningFragment' === r.type;
        return [i ? '<' : '</', Ht([s ? sr : n && !i ? ' ' : '', ys(e, t)]), s ? sr : '', '>'];
       })(e, t);
      case 'JSXEmptyExpression':
       return (function (e, t) {
        let { node: r } = e,
         n = at(r, st.Line);
        return [ys(e, t, { indent: n }), n ? sr : ''];
       })(e, t);
      case 'JSXText':
       throw new Error('JSXText should be handled by JSXElement');
      default:
       throw new bs(n, 'JSX');
     }
   }
   function Ns(e) {
    return 'JSXText' === e.type && (Cs.hasNonWhitespaceCharacter(Re(e)) || !/\n/.test(Re(e)));
   }
   var Bs = function (e) {
     return (
      nt(e.node) ||
      (function (e) {
       let { node: t, parent: r } = e;
       if (!ye(t) || !ye(r)) return !1;
       let n,
        { index: s, siblings: i } = e;
       for (let a = s; a > 0; a--) {
        let e = i[a - 1];
        if ('JSXText' !== e.type || Ns(e)) {
         n = e;
         break;
        }
       }
       return 'JSXExpressionContainer' === (null == n ? void 0 : n.type) && 'JSXEmptyExpression' === n.expression.type && nt(n.expression);
      })(e)
     );
    },
    _s = 0;
   function Ls(e, t, r) {
    var n;
    let { node: s, parent: i, grandparent: a, key: o } = e,
     u = 'body' !== o && ('IfStatement' === i.type || 'WhileStatement' === i.type || 'SwitchStatement' === i.type || 'DoWhileStatement' === i.type),
     l = '|>' === s.operator && (null == (n = e.root.extra) ? void 0 : n.__isUsingHackPipeline),
     p = Os(e, r, t, !1, u);
    if (u) return p;
    if (l) return Vt(p);
    if ((we(i) && i.callee === s) || 'UnaryExpression' === i.type || (Ae(i) && !i.computed)) return Vt([Ht([nr, ...p]), nr]);
    let c = 'ReturnStatement' === i.type || 'ThrowStatement' === i.type || ('JSXExpressionContainer' === i.type && 'JSXAttribute' === a.type) || ('|' !== s.operator && 'JsExpressionRoot' === i.type) || ('NGPipeExpression' !== s.type && (('NGRoot' === i.type && '__ng_binding' === t.parser) || ('NGMicrosyntaxExpression' === i.type && 'NGMicrosyntax' === a.type && 1 === a.body.length))) || (s === i.body && 'ArrowFunctionExpression' === i.type) || (s !== i.body && 'ForStatement' === i.type) || ('ConditionalExpression' === i.type && 'ReturnStatement' !== a.type && 'ThrowStatement' !== a.type && !we(a)) || 'TemplateLiteral' === i.type,
     h = 'AssignmentExpression' === i.type || 'VariableDeclarator' === i.type || 'ClassProperty' === i.type || 'PropertyDefinition' === i.type || 'TSAbstractPropertyDefinition' === i.type || 'ClassPrivateProperty' === i.type || pt(i),
     d = xe(s.left) && We(s.operator, s.left.operator);
    if (c || (Ms(s) && !d) || (!Ms(s) && h)) return Vt(p);
    if (0 === p.length) return '';
    let f = ye(s.right),
     m = p.findIndex((e) => 'string' != typeof e && !Array.isArray(e) && e.type === Tt),
     y = p.slice(0, -1 === m ? 1 : m + 1),
     g = p.slice(y.length, f ? -1 : void 0),
     D = Symbol('logicalChain-' + ++_s),
     b = Vt([...y, Ht(g)], { id: D });
    return f ? Vt([b, Yt(x(!1, p, -1), { groupId: D })]) : b;
   }
   function Os(e, t, r, n, s) {
    var i;
    let { node: a } = e;
    if (!xe(a)) return [Vt(t())];
    let o = [];
    We(a.operator, a.left.operator) ? (o = e.call((e) => Os(e, t, r, !0, s), 'left')) : o.push(Vt(t('left')));
    let u,
     l = Ms(a),
     p =
      ('|>' === a.operator ||
       'NGPipeExpression' === a.type ||
       (function (e, t) {
        return ('__vue_expression' === t.parser || '__vue_ts_expression' === t.parser) && js(e.node) && !e.hasAncestor((e) => !js(e) && 'JsExpressionRoot' !== e.type);
       })(e, r)) &&
      !Ne(r.originalText, a.right),
     c = 'NGPipeExpression' === a.type ? '|' : a.operator,
     h =
      'NGPipeExpression' === a.type && a.arguments.length > 0
       ? Vt(
          Ht([
           nr,
           ': ',
           or(
            [rr, ': '],
            e.map(() => zt(2, Vt(t())), 'arguments'),
           ),
          ]),
         )
       : '';
    if (l) u = [c, ' ', t('right'), h];
    else {
     let n = '|>' === c && (null == (i = e.root.extra) ? void 0 : i.__isUsingHackPipeline) ? e.call((e) => Os(e, t, r, !0, s), 'right') : t('right');
     u = [p ? rr : '', c, p ? ' ' : rr, n, h];
    }
    let { parent: d } = e,
     f = at(a.left, st.Trailing | st.Line),
     m = f || (!(s && 'LogicalExpression' === a.type) && d.type !== a.type && a.left.type !== a.type && a.right.type !== a.type);
    if ((o.push(p ? '' : ' ', m ? Vt(u, { shouldBreak: f }) : u), n && at(a))) {
     let t = yr(Ds(e, o, r));
     return t.type === St ? t.parts : Array.isArray(t) ? t : [t];
    }
    return o;
   }
   function Ms(e) {
    return 'LogicalExpression' === e.type && !!((ae(e.right) && e.right.properties.length > 0) || (ie(e.right) && e.right.elements.length > 0) || ye(e.right));
   }
   var js = (e) => 'BinaryExpression' === e.type && '|' === e.operator;
   function Rs(e, t, r) {
    let { node: n } = e;
    if (n.type.startsWith('NG'))
     switch (n.type) {
      case 'NGRoot':
       return [r('node'), at(n.node) ? ' //' + ot(n.node)[0].value.trimEnd() : ''];
      case 'NGPipeExpression':
       return Ls(e, t, r);
      case 'NGChainedExpression':
       return Vt(
        or(
         [';', rr],
         e.map(
          () =>
           (function ({ node: e }) {
            return Z(e, Us);
           })(e)
            ? r()
            : ['(', r(), ')'],
          'expressions',
         ),
        ),
       );
      case 'NGEmptyExpression':
       return '';
      case 'NGMicrosyntax':
       return e.map(() => [e.isFirst ? '' : qs(e) ? ' ' : [';', rr], r()], 'body');
      case 'NGMicrosyntaxKey':
       return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);
      case 'NGMicrosyntaxExpression':
       return [r('expression'), null === n.alias ? '' : [' as ', r('alias')]];
      case 'NGMicrosyntaxKeyedExpression': {
       let { index: t, parent: s } = e,
        i = qs(e) || (((1 === t && ('then' === n.key.name || 'else' === n.key.name || 'as' === n.key.name)) || ((2 === t || 3 === t) && (('else' === n.key.name && 'NGMicrosyntaxKeyedExpression' === s.body[t - 1].type && 'then' === s.body[t - 1].key.name) || 'track' === n.key.name))) && 'NGMicrosyntaxExpression' === s.body[0].type);
       return [r('key'), i ? ' ' : ': ', r('expression')];
      }
      case 'NGMicrosyntaxLet':
       return ['let ', r('key'), null === n.value ? '' : [' = ', r('value')]];
      case 'NGMicrosyntaxAs':
       return [r('key'), ' as ', r('alias')];
      default:
       throw new bs(n, 'Angular');
     }
   }
   function qs({ node: e, index: t }) {
    return 'NGMicrosyntaxKeyedExpression' === e.type && 'of' === e.key.name && 1 === t;
   }
   var Us = K(['CallExpression', 'OptionalCallExpression', 'AssignmentExpression']);
   function $s(e, t, r) {
    let { node: n } = e;
    return Vt([or(rr, e.map(r, 'decorators')), zs(n, t) ? sr : rr]);
   }
   function Hs(e, t, r) {
    return Vs(e.node) ? [or(sr, e.map(r, 'declaration', 'decorators')), sr] : '';
   }
   function zs(e, t) {
    return e.decorators.some((e) => I(t.originalText, U(e)));
   }
   function Vs(e) {
    var t;
    if ('ExportDefaultDeclaration' !== e.type && 'ExportNamedDeclaration' !== e.type && 'DeclareExportDeclaration' !== e.type) return !1;
    let r = null == (t = e.declaration) ? void 0 : t.decorators;
    return L(r) && $(e, r[0]);
   }
   var Ws = class extends Error {
    name = 'ArgExpansionBailout';
   };
   function Js(e, t = !1) {
    return (
     (ae(e) && (e.properties.length > 0 || at(e))) ||
     (ie(e) && (e.elements.length > 0 || at(e))) ||
     ('TSTypeAssertion' === e.type && Js(e.expression)) ||
     (ct(e) && Js(e.expression)) ||
     'FunctionExpression' === e.type ||
     ('ArrowFunctionExpression' === e.type &&
      (!e.returnType ||
       !e.returnType.typeAnnotation ||
       'TSTypeReference' !== e.returnType.typeAnnotation.type ||
       (function (e) {
        return 'BlockStatement' === e.type && (e.body.some((e) => 'EmptyStatement' !== e.type) || at(e, st.Dangling));
       })(e.body)) &&
      ('BlockStatement' === e.body.type || ('ArrowFunctionExpression' === e.body.type && Js(e.body, !0)) || ae(e.body) || ie(e.body) || (!t && (we(e.body) || 'ConditionalExpression' === e.body.type)) || ye(e.body))) ||
     'DoExpression' === e.type ||
     'ModuleExpression' === e.type
    );
   }
   function Ks(e) {
    var t;
    if ('ParenthesizedExpression' === e.type) return Ks(e.expression);
    if (ct(e) || 'TypeCastExpression' === e.type) {
     let { typeAnnotation: r } = e;
     return 'TypeAnnotation' === r.type && (r = r.typeAnnotation), 'TSArrayType' === r.type && ((r = r.elementType), 'TSArrayType' === r.type && (r = r.elementType)), ('GenericTypeAnnotation' === r.type || 'TSTypeReference' === r.type) && 1 === (null == (t = r.typeParameters) ? void 0 : t.params.length) && (r = r.typeParameters.params[0]), Ee(r) && je(e.expression, 1);
    }
    return !(lt(e) && Ze(e).length > 1) && (xe(e) ? je(e.left, 1) && je(e.right, 1) : pe(e) || je(e));
   }
   function Gs(e, t) {
    let r = e[t],
     n = e[t + 1];
    return 'ArrowFunctionExpression' === r.type && 0 === Ye(r).length && 'BlockStatement' === r.body.type && 'ArrayExpression' === n.type && !e.some((e) => at(e));
   }
   var Xs = function (e, t, r) {
     let { node: n } = e,
      s = Ze(n);
     if (0 === s.length) return ['(', ys(e, t), ')'];
     let i = s.length - 1;
     if (
      (function (e) {
       return 2 === e.length ? Gs(e, 0) : 3 === e.length && 'Identifier' === e[0].type && Gs(e, 1);
      })(s)
     ) {
      let t = ['('];
      return (
       et(e, (e, n) => {
        t.push(r()), n !== i && t.push(', ');
       }),
       t.push(')'),
       t
      );
     }
     let a = !1,
      o = [];
     et(e, ({ node: e }, n) => {
      let s = r();
      n === i || (ut(e, t) ? ((a = !0), (s = [s, ',', sr, sr])) : (s = [s, ',', rr])), o.push(s);
     });
     let u = 'ImportExpression' === n.type || 'Import' === n.callee.type,
      l = t.parser.startsWith('__ng_') || u || !Ue(t, 'all') ? '' : ',';
     function p() {
      return Vt(['(', Ht([rr, ...o]), l, rr, ')'], { shouldBreak: !0 });
     }
     if (
      a ||
      ('Decorator' !== e.parent.type &&
       (function (e) {
        if (e.length <= 1) return !1;
        let t = 0;
        for (let r of e)
         if (fe(r)) {
          if (((t += 1), t > 1)) return !0;
         } else if (we(r)) for (let e of Ze(r)) if (fe(e)) return !0;
        return !1;
       })(s))
     )
      return p();
     if (
      (function (e) {
       if (2 !== e.length) return !1;
       let [t, r] = e;
       return (
        !(
         'ModuleExpression' !== t.type ||
         !(function (e) {
          return 'ObjectExpression' === e.type && 1 === e.properties.length && pt(e.properties[0]) && 'Identifier' === e.properties[0].key.type && 'type' === e.properties[0].key.name && le(e.properties[0].value) && 'module' === e.properties[0].value.value;
         })(r)
        ) ||
        (!at(t) && ('FunctionExpression' === t.type || ('ArrowFunctionExpression' === t.type && 'BlockStatement' === t.body.type)) && 'FunctionExpression' !== r.type && 'ArrowFunctionExpression' !== r.type && 'ConditionalExpression' !== r.type && Ks(r) && !Js(r))
       );
      })(s)
     ) {
      let e,
       t = o.slice(1);
      if (t.some(hr)) return p();
      try {
       e = r(tt(n, 0), { expandFirstArg: !0 });
      } catch (h) {
       if (h instanceof Ws) return p();
       throw h;
      }
      return hr(e) ? [er, Kt([['(', Vt(e, { shouldBreak: !0 }), ', ', ...t, ')'], p()])] : Kt([['(', e, ', ', ...t, ')'], ['(', Vt(e, { shouldBreak: !0 }), ', ', ...t, ')'], p()]);
     }
     if (
      (function (e, t, r) {
       var n, s;
       let i = x(!1, e, -1);
       if (1 === e.length) {
        let e = x(!1, t, -1);
        if (null != (n = e.label) && n.embed && !1 !== (null == (s = e.label) ? void 0 : s.hug)) return !0;
       }
       let a = x(!1, e, -2);
       return !at(i, st.Leading) && !at(i, st.Trailing) && Js(i) && (!a || a.type !== i.type) && (2 !== e.length || 'ArrowFunctionExpression' !== a.type || !ie(i)) && !(e.length > 1 && zi(i, r));
      })(s, o, t)
     ) {
      let e,
       t = o.slice(0, -1);
      if (t.some(hr)) return p();
      try {
       e = r(tt(n, -1), { expandLastArg: !0 });
      } catch (h) {
       if (h instanceof Ws) return p();
       throw h;
      }
      return hr(e) ? [er, Kt([['(', ...t, Vt(e, { shouldBreak: !0 }), ')'], p()])] : Kt([['(', ...t, e, ')'], ['(', ...t, Vt(e, { shouldBreak: !0 }), ')'], p()]);
     }
     let c = ['(', Ht([nr, ...o]), Xt(l), nr, ')'];
     return Oe(e) ? c : Vt(c, { shouldBreak: o.some(hr) || a });
    },
    Ys = (e) => (('ChainExpression' === e.type || 'TSNonNullExpression' === e.type) && (e = e.expression), we(e) && Ze(e).length > 0);
   function Qs(e, t, r) {
    let n = r('property'),
     { node: s } = e,
     i = Ni(e);
    return s.computed ? (!s.property || oe(s.property) ? [i, '[', n, ']'] : Vt([i, '[', Ht([nr, n]), nr, ']'])) : [i, '.', n];
   }
   var Zs = function e(t, r, n) {
    if ('ChainExpression' === t.node.type) return t.call(() => e(t, r, n), 'expression');
    let { parent: s } = t,
     i = !s || 'ExpressionStatement' === s.type,
     a = [];
    function o(e) {
     let { originalText: t } = r,
      n = Ar(t, U(e));
     return ')' === t.charAt(n) ? !1 !== n && _(t, n + 1) : ut(e, r);
    }
    function u(e) {
     let { node: t } = e;
     if ('ChainExpression' === t.type) return e.call(() => u(e), 'expression');
     if (we(t) && (be(t.callee) || we(t.callee))) {
      let s = o(t);
      a.unshift({ node: t, hasTrailingEmptyLine: s, printed: [Ds(e, [Ni(e), ji(e, r, n), Xs(e, r, n)], r), s ? sr : ''] }), e.call((e) => u(e), 'callee');
     } else be(t) ? (a.unshift({ node: t, needsParens: hs(e, r), printed: Ds(e, Ae(t) ? Qs(e, 0, n) : Ri(e, r, n), r) }), e.call((e) => u(e), 'object')) : 'TSNonNullExpression' === t.type ? (a.unshift({ node: t, printed: Ds(e, '!', r) }), e.call((e) => u(e), 'expression')) : a.unshift({ node: t, printed: n() });
    }
    let { node: l } = t;
    a.unshift({ node: l, printed: [Ni(t), ji(t, r, n), Xs(t, r, n)] }), l.callee && t.call((e) => u(e), 'callee');
    let p = [],
     c = [a[0]],
     h = 1;
    for (; h < a.length && ('TSNonNullExpression' === a[h].node.type || we(a[h].node) || (Ae(a[h].node) && a[h].node.computed && oe(a[h].node.property))); ++h) c.push(a[h]);
    if (!we(a[0].node)) for (; h + 1 < a.length && be(a[h].node) && be(a[h + 1].node); ++h) c.push(a[h]);
    p.push(c), (c = []);
    let d = !1;
    for (; h < a.length; ++h) {
     if (d && be(a[h].node)) {
      if (a[h].node.computed && oe(a[h].node.property)) {
       c.push(a[h]);
       continue;
      }
      p.push(c), (c = []), (d = !1);
     }
     (we(a[h].node) || 'ImportExpression' === a[h].node.type) && (d = !0), c.push(a[h]), at(a[h].node, st.Trailing) && (p.push(c), (c = []), (d = !1));
    }
    function f(e) {
     return /^[A-Z]|^[$_]+$/.test(e);
    }
    c.length > 0 && p.push(c);
    let m =
     p.length >= 2 &&
     !at(p[1][0].node) &&
     (function (e) {
      var t;
      let n = null == (t = e[1][0]) ? void 0 : t.node.computed;
      if (1 === e[0].length) {
       let t = e[0][0].node;
       return (
        'ThisExpression' === t.type ||
        ('Identifier' === t.type &&
         (f(t.name) ||
          (i &&
           (function (e) {
            return e.length <= r.tabWidth;
           })(t.name)) ||
          n))
       );
      }
      let s = x(!1, e[0], -1).node;
      return Ae(s) && 'Identifier' === s.property.type && (f(s.property.name) || n);
     })(p);
    function y(e) {
     let t = e.map((e) => e.printed);
     return e.length > 0 && x(!1, e, -1).needsParens ? ['(', ...t, ')'] : t;
    }
    let g = p.map(y),
     D = g,
     b = m ? 3 : 2,
     v = p.flat(),
     E = v.slice(1, -1).some((e) => at(e.node, st.Leading)) || v.slice(0, -1).some((e) => at(e.node, st.Trailing)) || (p[b] && at(p[b][0].node, st.Leading));
    if (p.length <= b && !E && !p.some((e) => x(!1, e, -1).hasTrailingEmptyLine)) return Oe(t) ? D : Vt(D);
    let C = x(!1, p[m ? 1 : 0], -1).node,
     T = !we(C) && o(C),
     S = [y(p[0]), m ? p.slice(1, 2).map(y) : '', T ? sr : '', ((A = p.slice(m ? 2 : 1)), 0 === A.length ? '' : Ht([sr, or(sr, A.map(y))]))],
     w = a.map(({ node: e }) => e).filter(we);
    var A;
    let F;
    return (
     (F =
      E ||
      (w.length > 2 && w.some((e) => !e.arguments.every((e) => je(e)))) ||
      g.slice(0, -1).some(hr) ||
      (function () {
       let e = x(!1, x(!1, p, -1), -1).node,
        t = x(!1, g, -1);
       return we(e) && hr(t) && w.slice(0, -1).some((e) => e.arguments.some(fe));
      })()
       ? Vt(S)
       : [hr(D) || T ? er : '', Kt([D, S])]),
     ur({ memberChain: !0 }, F)
    );
   };
   function ei(e, t, r) {
    var n;
    let { node: s, parent: i } = e,
     a = 'NewExpression' === s.type,
     o = 'ImportExpression' === s.type,
     u = Ni(e),
     l = Ze(s),
     p = 1 === l.length && _e(l[0], t.originalText);
    if (
     p ||
     (l.length > 0 &&
      !a &&
      !o &&
      ((function (e, t) {
       if ('Identifier' !== e.callee.type) return !1;
       if ('require' === e.callee.name) {
        let t = Ze(e);
        return (1 === t.length && le(t[0])) || t.length > 1;
       }
       if ('define' === e.callee.name) {
        let r = Ze(e);
        return 'ExpressionStatement' === t.type && (1 === r.length || (2 === r.length && 'ArrayExpression' === r[0].type) || (3 === r.length && le(r[0]) && 'ArrayExpression' === r[1].type));
       }
       return !1;
      })(s, i) ||
       Te(s, i)))
    ) {
     let i = [];
     if (
      (et(e, () => {
       i.push(r());
      }),
      !p || null == (n = i[0].label) || !n.embed)
     )
      return [a ? 'new ' : '', o ? ti(s) : r('callee'), u, ji(e, t, r), '(', or(', ', i), ')'];
    }
    if (!o && !a && be(s.callee) && !e.call((e) => hs(e, t), 'callee', ...('ChainExpression' === s.callee.type ? ['expression'] : []))) return Zs(e, t, r);
    let c = [a ? 'new ' : '', o ? ti(s) : r('callee'), u, ji(e, t, r), Xs(e, t, r)];
    return o || we(s.callee) ? Vt(c) : c;
   }
   function ti(e) {
    return e.phase ? `import.${e.phase}` : 'import';
   }
   function ri(e, t, r, n, s, i) {
    let a = (function (e, t, r, n, s) {
      let { node: i } = e,
       a = i[s];
      if (!a) return 'only-left';
      let o = !ni(a);
      if (e.match(ni, si, (e) => !o || ('ExpressionStatement' !== e.type && 'VariableDeclaration' !== e.type))) return o ? ('ArrowFunctionExpression' === a.type && 'ArrowFunctionExpression' === a.body.type ? 'chain-tail-arrow-chain' : 'chain-tail') : 'chain';
      if ((!o && ni(a.right)) || Ne(t.originalText, a)) return 'break-after-operator';
      if ('ImportAttribute' === i.type || ('CallExpression' === a.type && 'require' === a.callee.name) || 'json5' === t.parser || 'jsonc' === t.parser || 'json' === t.parser) return 'never-break-after-operator';
      let u = (function (e) {
       return pr(e, Dr, !1);
      })(n);
      if (
       (function (e) {
        if (si(e)) {
         let t = e.left || e.id;
         return (
          'ObjectPattern' === t.type &&
          t.properties.length > 2 &&
          t.properties.some((e) => {
           var t;
           return pt(e) && (!e.shorthand || 'AssignmentPattern' === (null == (t = e.value) ? void 0 : t.type));
          })
         );
        }
        return !1;
       })(i) ||
       (function (e) {
        if ('VariableDeclarator' !== e.type) return !1;
        let { typeAnnotation: t } = e.id;
        if (!t || !t.typeAnnotation) return !1;
        let r = ui(t.typeAnnotation);
        return L(r) && r.length > 1 && r.some((e) => L(ui(e)) || 'TSConditionalType' === e.type);
       })(i) ||
       (ai(i) && u)
      )
       return 'break-lhs';
      let l = (function (e, t, r) {
       return !!pt(e) && ((t = yr(t)), 'string' == typeof t && S(t) < r.tabWidth + 3);
      })(i, n, t);
      return e.call(
       () =>
        (function (e, t, r, n) {
         let s = e.node;
         if (xe(s) && !Ms(s)) return !0;
         switch (s.type) {
          case 'StringLiteralTypeAnnotation':
          case 'SequenceExpression':
           return !0;
          case 'TSConditionalType':
          case 'ConditionalTypeAnnotation':
           if (
            !t.experimentalTernaries &&
            !(function (e) {
             function t(e) {
              switch (e.type) {
               case 'FunctionTypeAnnotation':
               case 'GenericTypeAnnotation':
               case 'TSFunctionType':
               case 'TSTypeReference':
                return !!e.typeParameters;
               default:
                return !1;
              }
             }
             return t(e.checkType) || t(e.extendsType);
            })(s)
           )
            break;
           return !0;
          case 'ConditionalExpression': {
           if (!t.experimentalTernaries) {
            let { test: e } = s;
            return xe(e) && !Ms(e);
           }
           let { consequent: e, alternate: r } = s;
           return 'ConditionalExpression' === e.type || 'ConditionalExpression' === r.type;
          }
          case 'ClassExpression':
           return L(s.decorators);
         }
         if (n) return !1;
         let i = s,
          a = [];
         for (;;)
          if ('UnaryExpression' === i.type || 'AwaitExpression' === i.type || ('YieldExpression' === i.type && null !== i.argument)) (i = i.argument), a.push('argument');
          else {
           if ('TSNonNullExpression' !== i.type) break;
           (i = i.expression), a.push('expression');
          }
         return !(!le(i) && !e.call(() => li(e, t, r), ...a));
        })(e, t, r, l),
       s,
      )
       ? 'break-after-operator'
       : (function (e) {
            let t = (function (e) {
             var t;
             if (ii(e)) return null == (t = e.typeParameters) ? void 0 : t.params;
            })(e);
            if (L(t)) {
             let r = 'TSTypeAliasDeclaration' === e.type ? 'constraint' : 'bound';
             if (t.length > 1 && t.some((e) => e[r] || e.default)) return !0;
            }
            return !1;
           })(i)
         ? 'break-lhs'
         : u || (!l && 'TemplateLiteral' !== a.type && 'TaggedTemplateExpression' !== a.type && 'BooleanLiteral' !== a.type && !oe(a) && 'ClassExpression' !== a.type)
           ? 'fluid'
           : 'never-break-after-operator';
     })(e, t, r, n, i),
     o = i ? r(i, { assignmentLayout: a }) : '';
    switch (a) {
     case 'break-after-operator':
      return Vt([Vt(n), s, Vt(Ht([rr, o]))]);
     case 'never-break-after-operator':
      return Vt([Vt(n), s, ' ', o]);
     case 'fluid': {
      let e = Symbol('assignment');
      return Vt([Vt(n), s, Vt(Ht(rr), { id: e }), Zt, Yt(o, { groupId: e })]);
     }
     case 'break-lhs':
      return Vt([n, s, ' ', Vt(o)]);
     case 'chain':
      return [Vt(n), s, rr, o];
     case 'chain-tail':
      return [Vt(n), s, Ht([rr, o])];
     case 'chain-tail-arrow-chain':
      return [Vt(n), s, o];
     case 'only-left':
      return n;
    }
   }
   function ni(e) {
    return 'AssignmentExpression' === e.type;
   }
   function si(e) {
    return ni(e) || 'VariableDeclarator' === e.type;
   }
   var ii = K(['TSTypeAliasDeclaration', 'TypeAlias']);
   function ai(e) {
    var t;
    return 'VariableDeclarator' === e.type && 'ArrowFunctionExpression' === (null == (t = e.init) ? void 0 : t.type);
   }
   var oi = K(['TSTypeReference', 'GenericTypeAnnotation']);
   function ui(e) {
    var t;
    if (oi(e)) return null == (t = e.typeParameters) ? void 0 : t.params;
   }
   function li(e, t, r, n = !1) {
    var s;
    let { node: i } = e,
     a = () => li(e, t, r, !0);
    if ('ChainExpression' === i.type || 'TSNonNullExpression' === i.type) return e.call(a, 'expression');
    if (we(i)) {
     if (null != (s = ei(e, t, r).label) && s.memberChain) return !1;
     let n = Ze(i);
     return (
      !(
       !(0 === n.length || (1 === n.length && Ie(n[0], t))) ||
       (function (e, t) {
        let r = (function (e) {
         var t;
         return null == (t = e.typeParameters ?? e.typeArguments) ? void 0 : t.params;
        })(e);
        if (L(r)) {
         if (r.length > 1) return !0;
         if (1 === r.length) {
          let e = r[0];
          if (ht(e) || dt(e) || 'TSTypeLiteral' === e.type || 'ObjectTypeAnnotation' === e.type) return !0;
         }
         if (hr(t(e.typeParameters ? 'typeParameters' : 'typeArguments'))) return !0;
        }
        return !1;
       })(i, r)
      ) && e.call(a, 'callee')
     );
    }
    return Ae(i) ? e.call(a, 'object') : n && ('Identifier' === i.type || 'ThisExpression' === i.type);
   }
   function pi(e, t, r, n, s) {
    let i = e.node,
     a = Ye(i),
     o = s ? ji(e, r, t) : '';
    if (0 === a.length) return [o, '(', ys(e, r, { filter: (e) => ')' === Fr(r.originalText, U(e)) }), ')'];
    let { parent: u } = e,
     l = Te(u),
     p = ci(i),
     c = [];
    if (
     ((function (e, t) {
      let { node: r } = e,
       n = 0,
       s = (e) => t(e, n++);
      r.this && e.call(s, 'this'), Array.isArray(r.parameters) ? e.each(s, 'parameters') : Array.isArray(r.params) && e.each(s, 'params'), r.rest && e.call(s, 'rest');
     })(e, (e, n) => {
      let s = n === a.length - 1;
      s && i.rest && c.push('...'), c.push(t()), !s && (c.push(','), l || p ? c.push(' ') : ut(a[n], r) ? c.push(sr, sr) : c.push(rr));
     }),
     n &&
      !(function (e) {
       return e.match(
        (e) => 'ArrowFunctionExpression' === e.type && 'BlockStatement' === e.body.type,
        (e, t) => {
         if ('CallExpression' === e.type && 'arguments' === t && 1 === e.arguments.length && 'CallExpression' === e.callee.type) {
          let t = e.callee.callee;
          return 'Identifier' === t.type || ('MemberExpression' === t.type && !t.computed && 'Identifier' === t.object.type && 'Identifier' === t.property.type);
         }
         return !1;
        },
        (e, t) => ('VariableDeclarator' === e.type && 'init' === t) || ('ExportDefaultDeclaration' === e.type && 'declaration' === t) || ('TSExportAssignment' === e.type && 'expression' === t) || ('AssignmentExpression' === e.type && 'right' === t && 'MemberExpression' === e.left.type && 'Identifier' === e.left.object.type && 'module' === e.left.object.name && 'Identifier' === e.left.property.type && 'exports' === e.left.property.name),
        (e) => 'VariableDeclaration' !== e.type || ('const' === e.kind && 1 === e.declarations.length),
       );
      })(e))
    ) {
     if (hr(o) || hr(c)) throw new Ws();
     return Vt([mr(o), '(', mr(c), ')']);
    }
    let h = a.every((e) => !L(e.decorators));
    return (p && h) || l
     ? [o, '(', ...c, ')']
     : (De(u) ||
          (function (e) {
           return !(('TypeAnnotation' !== e.type && 'TSTypeAnnotation' !== e.type) || 'FunctionTypeAnnotation' !== e.typeAnnotation.type || e.static || $(e, e.typeAnnotation));
          })(u) ||
          'TypeAlias' === u.type ||
          'UnionTypeAnnotation' === u.type ||
          'IntersectionTypeAnnotation' === u.type ||
          ('FunctionTypeAnnotation' === u.type && u.returnType === i)) &&
         1 === a.length &&
         null === a[0].name &&
         i.this !== a[0] &&
         a[0].typeAnnotation &&
         null === i.typeParameters &&
         Ee(a[0].typeAnnotation) &&
         !i.rest
       ? 'always' === r.arrowParens || 'HookTypeAnnotation' === i.type
         ? ['(', ...c, ')']
         : c
       : [o, '(', Ht([nr, ...c]), Xt(!Ge(i) && Ue(r, 'all') ? ',' : ''), nr, ')'];
   }
   function ci(e) {
    if (!e) return !1;
    let t = Ye(e);
    if (1 !== t.length) return !1;
    let [r] = t;
    return !at(r) && ('ObjectPattern' === r.type || 'ArrayPattern' === r.type || ('Identifier' === r.type && r.typeAnnotation && ('TypeAnnotation' === r.typeAnnotation.type || 'TSTypeAnnotation' === r.typeAnnotation.type) && de(r.typeAnnotation.typeAnnotation)) || ('FunctionTypeParam' === r.type && de(r.typeAnnotation) && r !== e.rest) || ('AssignmentPattern' === r.type && ('ObjectPattern' === r.left.type || 'ArrayPattern' === r.left.type) && ('Identifier' === r.right.type || (ae(r.right) && 0 === r.right.properties.length) || (ie(r.right) && 0 === r.right.elements.length))));
   }
   function hi(e, t) {
    var r;
    let n = (function (e) {
     let t;
     return e.returnType ? ((t = e.returnType), t.typeAnnotation && (t = t.typeAnnotation)) : e.typeAnnotation && (t = e.typeAnnotation), t;
    })(e);
    if (!n) return !1;
    let s = null == (r = e.typeParameters) ? void 0 : r.params;
    if (s) {
     if (s.length > 1) return !1;
     if (1 === s.length) {
      let e = s[0];
      if (e.constraint || e.default) return !1;
     }
    }
    return 1 === Ye(e).length && (de(n) || hr(t));
   }
   var di = K(['VoidTypeAnnotation', 'TSVoidKeyword', 'NullLiteralTypeAnnotation', 'TSNullKeyword']),
    fi = K(['ObjectTypeAnnotation', 'TSTypeLiteral', 'GenericTypeAnnotation', 'TSTypeReference']);
   function mi(e) {
    return (
     !(!Ee(e) && !de(e)) ||
     (!!ht(e) &&
      (function (e) {
       let { types: t } = e;
       if (t.some((e) => at(e))) return !1;
       let r = t.find((e) => fi(e));
       return !!r && t.every((e) => e === r || di(e));
      })(e))
    );
   }
   function yi(e, t, r) {
    let n = t.semi ? ';' : '',
     { node: s } = e,
     i = [Li(e)];
    return i.push('type ', r('id'), r('typeParameters')), [ri(e, t, r, i, ' =', 'TSTypeAliasDeclaration' === s.type ? 'typeAnnotation' : 'right'), n];
   }
   function gi(e, t, r) {
    let n = !1;
    return Vt(
     e.map(({ isFirst: e, previous: t, node: s, index: i }) => {
      let a = r();
      if (e) return a;
      let o = de(s),
       u = de(t);
      return u && o ? [' & ', n ? Ht(a) : a] : u || o ? (i > 1 && (n = !0), [' & ', i > 1 ? Ht(a) : a]) : Ht([' &', rr, a]);
     }, 'types'),
    );
   }
   function Di(e, t, r) {
    let { node: n } = e,
     { parent: s } = e,
     i = !('TypeParameterInstantiation' === s.type || ('TSConditionalType' === s.type && t.experimentalTernaries) || ('ConditionalTypeAnnotation' === s.type && t.experimentalTernaries) || 'TSTypeParameterInstantiation' === s.type || 'GenericTypeAnnotation' === s.type || 'TSTypeReference' === s.type || 'TSTypeAssertion' === s.type || 'TupleTypeAnnotation' === s.type || 'TSTupleType' === s.type || ('FunctionTypeParam' === s.type && !s.name && e.grandparent.this !== s) || (('TypeAlias' === s.type || 'VariableDeclarator' === s.type || 'TSTypeAliasDeclaration' === s.type) && Ne(t.originalText, n))),
     a = mi(n),
     o = e.map((e) => {
      let n = r();
      return a || (n = zt(2, n)), Ds(e, n, t);
     }, 'types');
    if (a) return or(' | ', o);
    let u = [Xt([i && !Ne(t.originalText, n) ? rr : '', '| ']), or([rr, '| '], o)];
    return hs(e, t) ? Vt([Ht(u), nr]) : ('TupleTypeAnnotation' === s.type || 'TSTupleType' === s.type) && s['TupleTypeAnnotation' === s.type && s.types ? 'types' : 'elementTypes'].length > 1 ? Vt([Ht([Xt(['(', nr]), u]), nr, Xt(')')]) : Vt(i ? Ht(u) : u);
   }
   function xi(e, t, r) {
    let { node: n } = e,
     s = [Mi(e)];
    ('TSConstructorType' === n.type || 'TSConstructSignatureDeclaration' === n.type) && s.push('new ');
    let i = pi(e, r, t, !1, !0),
     a = [];
    return (
     'FunctionTypeAnnotation' === n.type
      ? a.push(
         (function (e) {
          var t;
          let { node: r, parent: n } = e;
          return 'FunctionTypeAnnotation' === r.type && (De(n) || !((('ObjectTypeProperty' === n.type || 'ObjectTypeInternalSlot' === n.type) && !n.variance && !n.optional && $(n, r)) || 'ObjectTypeCallProperty' === n.type || 'DeclareFunction' === (null == (t = e.getParentNode(2)) ? void 0 : t.type)));
         })(e)
          ? ' => '
          : ': ',
         r('returnType'),
        )
      : a.push(wi(e, r, n.returnType ? 'returnType' : 'typeAnnotation')),
     hi(n, a) && (i = Vt(i)),
     s.push(i, a),
     Vt(s)
    );
   }
   function bi(e, t, r) {
    return [r('objectType'), Ni(e), '[', r('indexType'), ']'];
   }
   function vi(e, t, r) {
    return ['infer ', r('typeParameter')];
   }
   function Ei(e, t, r) {
    let { node: n } = e;
    return [n.postfix ? '' : r, wi(e, t), n.postfix ? r : ''];
   }
   function Ci(e, t, r) {
    let { node: n } = e;
    return ['...', ...('TupleTypeSpreadElement' === n.type && n.label ? [r('label'), ': '] : []), r('typeAnnotation')];
   }
   function Ti(e, t, r) {
    let { node: n } = e;
    return [n.variance ? r('variance') : '', r('label'), n.optional ? '?' : '', ': ', r('elementType')];
   }
   var Si = new WeakSet();
   function wi(e, t, r = 'typeAnnotation') {
    let {
     node: { [r]: n },
    } = e;
    if (!n) return '';
    let s = !1;
    if ('TSTypeAnnotation' === n.type || 'TypeAnnotation' === n.type) {
     let t = e.call(Ai, r);
     ('=>' === t || (':' === t && at(n, st.Leading))) && (s = !0), Si.add(n);
    }
    return s ? [' ', t(r)] : t(r);
   }
   var Ai = (e) =>
    e.match(
     (e) => 'TSTypeAnnotation' === e.type,
     (e, t) => !(('returnType' !== t && 'typeAnnotation' !== t) || ('TSFunctionType' !== e.type && 'TSConstructorType' !== e.type)),
    )
     ? '=>'
     : e.match(
          (e) => 'TSTypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && ('TSJSDocNullableType' === e.type || 'TSJSDocNonNullableType' === e.type || 'TSTypePredicate' === e.type),
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && 'Identifier' === e.type,
          (e, t) => 'id' === t && 'DeclareFunction' === e.type,
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && 'Identifier' === e.type,
          (e, t) => 'id' === t && 'DeclareHook' === e.type,
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'bound' === t && 'TypeParameter' === e.type && e.usesExtendsBound,
         )
       ? ''
       : ':';
   function Fi(e, t, r) {
    let n = Ai(e);
    return n ? [n, ' ', r('typeAnnotation')] : r('typeAnnotation');
   }
   function ki(e) {
    return [e('elementType'), '[]'];
   }
   function Pi({ node: e }, t) {
    let r = 'TSTypeQuery' === e.type ? 'exprName' : 'argument',
     n = 'TSTypeQuery' === e.type ? 'typeParameters' : 'typeArguments';
    return ['typeof ', t(r), t(n)];
   }
   function Ii(e, t) {
    let { node: r } = e;
    return ['TSTypePredicate' === r.type && r.asserts ? 'asserts ' : 'TypePredicate' === r.type && r.kind ? `${r.kind} ` : '', t('parameterName'), r.typeAnnotation ? [' is ', wi(e, t)] : ''];
   }
   function Ni(e) {
    let { node: t } = e;
    return !t.optional || ('Identifier' === t.type && t === e.parent.key) ? '' : we(t) || (Ae(t) && t.computed) || 'OptionalIndexedAccessType' === t.type ? '?.' : '?';
   }
   function Bi(e) {
    return e.node.definite || e.match(void 0, (e, t) => 'id' === t && 'VariableDeclarator' === e.type && e.definite) ? '!' : '';
   }
   var _i = new Set(['DeclareClass', 'DeclareComponent', 'DeclareFunction', 'DeclareHook', 'DeclareVariable', 'DeclareExportDeclaration', 'DeclareExportAllDeclaration', 'DeclareOpaqueType', 'DeclareTypeAlias', 'DeclareEnum', 'DeclareInterface']);
   function Li(e) {
    let { node: t } = e;
    return t.declare || (_i.has(t.type) && 'DeclareExportDeclaration' !== e.parent.type) ? 'declare ' : '';
   }
   var Oi = new Set(['TSAbstractMethodDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
   function Mi({ node: e }) {
    return e.abstract || Oi.has(e.type) ? 'abstract ' : '';
   }
   function ji(e, t, r) {
    let n = e.node;
    return n.typeArguments ? r('typeArguments') : n.typeParameters ? r('typeParameters') : '';
   }
   function Ri(e, t, r) {
    return ['::', r('callee')];
   }
   function qi(e, t, r) {
    return 'EmptyStatement' === e.type ? ';' : 'BlockStatement' === e.type || r ? [' ', t] : Ht([rr, t]);
   }
   function Ui(e, t) {
    return ['...', t('argument'), wi(e, t)];
   }
   function $i(e) {
    return e.accessibility ? e.accessibility + ' ' : '';
   }
   function Hi(e, t, r) {
    let { node: n } = e,
     s = [],
     i = 'TupleExpression' === n.type ? '#[' : '[',
     a = 'TupleTypeAnnotation' === n.type && n.types ? 'types' : 'TSTupleType' === n.type || 'TupleTypeAnnotation' === n.type ? 'elementTypes' : 'elements',
     o = n[a];
    if (0 === o.length)
     s.push(
      (function (e, t, r, n) {
       let { node: s } = e,
        i = s.inexact ? '...' : '';
       return at(s, st.Dangling) ? Vt([r, i, ys(e, t, { indent: !0 }), nr, n]) : [r, i, n];
      })(e, t, i, ']'),
     );
    else {
     let u = x(!1, o, -1),
      l = 'RestElement' !== (null == u ? void 0 : u.type) && !n.inexact,
      p = null === u,
      c = Symbol('array'),
      h =
       !t.__inJestEach &&
       o.length > 1 &&
       o.every((e, t, r) => {
        let n = null == e ? void 0 : e.type;
        if (!ie(e) && !ae(e)) return !1;
        let s = r[t + 1];
        if (s && n !== s.type) return !1;
        let i = ie(e) ? 'elements' : 'properties';
        return e[i] && e[i].length > 1;
       }),
      d = zi(n, t),
      f = l ? (p ? ',' : Ue(t) ? (d ? Xt(',', '', { groupId: c }) : Xt(',')) : '') : '';
     s.push(Vt([i, Ht([nr, d ? Ji(e, t, r, f) : [Wi(e, t, a, n.inexact, r), f], ys(e, t)]), nr, ']'], { shouldBreak: h, id: c }));
    }
    return s.push(Ni(e), wi(e, r)), s;
   }
   function zi(e, t) {
    return ie(e) && e.elements.length > 1 && e.elements.every((e) => e && (oe(e) || (ue(e) && !at(e.argument))) && !at(e, st.Trailing | st.Line, (e) => !I(t.originalText, q(e), { backwards: !0 })));
   }
   function Vi({ node: e }, { originalText: t }) {
    let r = (e) => (',' === t[e] ? e : r(((e) => N(t, B(t, e)))(e + 1)));
    return _(t, r(U(e)));
   }
   function Wi(e, t, r, n, s) {
    let i = [];
    return (
     e.each(({ node: r, isLast: a }) => {
      i.push(r ? Vt(s()) : ''), (!a || n) && i.push([',', rr, r && Vi(e, t) ? nr : '']);
     }, r),
     n && i.push('...'),
     i
    );
   }
   function Ji(e, t, r, n) {
    let s = [];
    return (
     e.each(({ isLast: i, next: a }) => {
      s.push([r(), i ? n : ',']), i || s.push(Vi(e, t) ? [sr, sr] : at(a, st.Leading | st.Line) ? sr : rr);
     }, 'elements'),
     Gt(s)
    );
   }
   var Ki = new Proxy(() => {}, { get: () => Ki }),
    Gi = Ki,
    Xi = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/,
    Yi = (e) => Xi.test(e);
   var Qi = function (e) {
     return 1 === e.length
      ? e
      : e
         .toLowerCase()
         .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, '$1$2')
         .replace(/^([+-]?[\d.]+)e[+-]?0+$/, '$1')
         .replace(/^([+-])?\./, '$10.')
         .replace(/(\.\d+?)0+(?=e|$)/, '$1')
         .replace(/\.(?=e|$)/, '');
    },
    Zi = new WeakMap();
   function ea(e) {
    return /^(?:\d+|\d+\.\d+)$/.test(e);
   }
   function ta(e, t) {
    return !('json' === t.parser || 'jsonc' === t.parser || !le(e.key) || R(Re(e.key), t).slice(1, -1) !== e.key.value) && !!((Yi(e.key.value) && !(('babel-ts' === t.parser && 'ClassProperty' === e.type) || ('typescript' === t.parser && 'PropertyDefinition' === e.type))) || (ea(e.key.value) && String(Number(e.key.value)) === e.key.value && 'ImportAttribute' !== e.type && ('babel' === t.parser || 'acorn' === t.parser || 'espree' === t.parser || 'meriyah' === t.parser || '__babel_estree' === t.parser)));
   }
   function ra(e, t, r) {
    let { node: n } = e;
    if (n.computed) return ['[', r('key'), ']'];
    let { parent: s } = e,
     { key: i } = n;
    if ('consistent' === t.quoteProps && !Zi.has(s)) {
     let r = e.siblings.some((e) => !e.computed && le(e.key) && !ta(e, t));
     Zi.set(s, r);
    }
    if (
     (function (e, t) {
      let { key: r } = e.node;
      return ('Identifier' === r.type || (oe(r) && ea(Qi(Re(r))) && String(r.value) === Qi(Re(r)) && !('typescript' === t.parser || 'babel-ts' === t.parser))) && ('json' === t.parser || 'jsonc' === t.parser || ('consistent' === t.quoteProps && Zi.get(e.parent)));
     })(e, t)
    ) {
     let r = R(JSON.stringify('Identifier' === i.type ? i.name : i.value.toString()), t);
     return e.call((e) => Ds(e, r, t), 'key');
    }
    return ta(n, t) && ('as-needed' === t.quoteProps || ('consistent' === t.quoteProps && !Zi.get(s))) ? e.call((e) => Ds(e, /^\d/.test(i.value) ? Qi(i.value) : i.value, t), 'key') : r('key');
   }
   function na(e, t, r) {
    let { node: n } = e;
    return n.shorthand ? r('value') : ri(e, t, r, ra(e, t, r), ':', 'value');
   }
   var sa = ({ node: e, key: t, parent: r }) => 'value' === t && 'FunctionExpression' === e.type && ('ObjectMethod' === r.type || 'ClassMethod' === r.type || 'ClassPrivateMethod' === r.type || 'MethodDefinition' === r.type || 'TSAbstractMethodDefinition' === r.type || 'TSDeclareMethod' === r.type || ('Property' === r.type && ge(r)));
   function ia(e, t, r, n) {
    if (sa(e)) return oa(e, r, t);
    let { node: s } = e,
     i = !1;
    if (('FunctionDeclaration' === s.type || 'FunctionExpression' === s.type) && null != n && n.expandLastArg) {
     let { parent: t } = e;
     we(t) && (Ze(t).length > 1 || Ye(s).every((e) => 'Identifier' === e.type && !e.typeAnnotation)) && (i = !0);
    }
    let a = [Li(e), s.async ? 'async ' : '', `function${s.generator ? '*' : ''} `, s.id ? t('id') : ''],
     o = pi(e, t, r, i),
     u = la(e, t),
     l = hi(s, u);
    return a.push(ji(e, 0, t), Vt([l ? Vt(o) : o, u]), s.body ? ' ' : '', t('body')), r.semi && (s.declare || !s.body) && a.push(';'), a;
   }
   function aa(e, t, r) {
    let { node: n } = e,
     { kind: s } = n,
     i = n.value || n,
     a = [];
    return s && 'init' !== s && 'method' !== s && 'constructor' !== s ? (Gi.ok('get' === s || 'set' === s), a.push(s, ' ')) : i.async && a.push('async '), i.generator && a.push('*'), a.push(ra(e, t, r), n.optional || n.key.optional ? '?' : '', n === i ? oa(e, t, r) : r('value')), a;
   }
   function oa(e, t, r) {
    let { node: n } = e,
     s = pi(e, r, t),
     i = la(e, r),
     a = (function (e) {
      let t = Ye(e);
      return t.length > 1 && t.some((e) => 'TSParameterProperty' === e.type);
     })(n),
     o = hi(n, i),
     u = [ji(e, 0, r), Vt([a ? Vt(s, { shouldBreak: !0 }) : o ? Vt(s) : s, i])];
    return n.body ? u.push(' ', r('body')) : u.push(t.semi ? ';' : ''), u;
   }
   function ua(e, t) {
    if ('always' === t.arrowParens) return !1;
    if ('avoid' === t.arrowParens) {
     let { node: t } = e;
     return (function (e) {
      let t = Ye(e);
      return !(1 !== t.length || e.typeParameters || at(e, st.Dangling) || 'Identifier' !== t[0].type || t[0].typeAnnotation || at(t[0]) || t[0].optional || e.predicate || e.returnType);
     })(t);
    }
    return !1;
   }
   function la(e, t) {
    let { node: r } = e,
     n = [wi(e, t, 'returnType')];
    return r.predicate && n.push(t('predicate')), n;
   }
   function pa(e, t, r) {
    let { node: n } = e,
     s = t.semi ? ';' : '',
     i = [];
    if (n.argument) {
     let e = r('argument');
     !(function (e, t) {
      if (Ne(e.originalText, t) || (at(t, st.Leading, (t) => kr(e.originalText, q(t), U(t))) && !ye(t))) return !0;
      if (ee(t)) {
       let r,
        n = t;
       for (; (r = te(n)); ) if (((n = r), Ne(e.originalText, n))) return !0;
      }
      return !1;
     })(t, n.argument)
      ? (xe(n.argument) || 'SequenceExpression' === n.argument.type || (t.experimentalTernaries && 'ConditionalExpression' === n.argument.type && ('ConditionalExpression' === n.argument.consequent.type || 'ConditionalExpression' === n.argument.alternate.type))) && (e = Vt([Xt('('), Ht([nr, e]), nr, Xt(')')]))
      : (e = ['(', Ht([sr, e]), sr, ')']),
      i.push(' ', e);
    }
    let a = at(n, st.Dangling),
     o = s && a && at(n, st.Last | st.Line);
    return o && i.push(s), a && i.push(' ', ys(e, t)), o || i.push(s), i;
   }
   var ca = new WeakMap();
   function ha(e) {
    return ca.has(e) || ca.set(e, 'ConditionalExpression' === e.type && !$e(e, (e) => 'ObjectExpression' === e.type)), ca.get(e);
   }
   var da = (e) => 'SequenceExpression' === e.type;
   function fa(e, t, r, n = {}) {
    let s,
     i,
     a = [],
     o = [],
     u = !1,
     l = !n.expandLastArg && 'ArrowFunctionExpression' === e.node.body.type;
    !(function p() {
     let { node: c } = e,
      h = (function (e, t, r, n) {
       let { node: s } = e,
        i = [];
       if ((s.async && i.push('async '), ua(e, t))) i.push(r(['params', 0]));
       else {
        let s = n.expandLastArg || n.expandFirstArg,
         a = la(e, r);
        if (s) {
         if (hr(a)) throw new Ws();
         a = Vt(mr(a));
        }
        i.push(Vt([pi(e, r, t, s, !0), a]));
       }
       let a = ys(e, t, {
        filter(e) {
         let r = Ar(t.originalText, U(e));
         return !1 !== r && '=>' === t.originalText.slice(r, r + 2);
        },
       });
       return a && i.push(' ', a), i;
      })(e, t, r, n);
     if (0 === a.length) a.push(h);
     else {
      let { leading: r, trailing: n } = gs(e, t);
      a.push([r, h]), o.unshift(n);
     }
     l && (u || (u = (c.returnType && Ye(c).length > 0) || c.typeParameters || Ye(c).some((e) => 'Identifier' !== e.type))), l && 'ArrowFunctionExpression' === c.body.type ? e.call(p, 'body') : ((s = r('body', n)), (i = c.body));
    })();
    let p,
     c =
      !Ne(t.originalText, i) &&
      (da(i) ||
       (function (e, t, r) {
        var n, s;
        return ie(e) || ae(e) || 'ArrowFunctionExpression' === e.type || 'DoExpression' === e.type || 'BlockStatement' === e.type || ye(e) || (!1 !== (null == (n = t.label) ? void 0 : n.hug) && ((null == (s = t.label) ? void 0 : s.embed) || _e(e, r.originalText)));
       })(i, s, t) ||
       (!u && ha(i))),
     h = 'callee' === e.key && lt(e.parent),
     d = Symbol('arrow-chain'),
     f = (function (e, t, { signatureDocs: r, shouldBreak: n }) {
      if (1 === r.length) return r[0];
      let { parent: s, key: i } = e;
      return ('callee' !== i && lt(s)) || xe(s) ? Vt([r[0], ' =>', Ht([rr, or([' =>', rr], r.slice(1))])], { shouldBreak: n }) : ('callee' === i && lt(s)) || t.assignmentLayout ? Vt(or([' =>', rr], r), { shouldBreak: n }) : Vt(Ht(or([' =>', rr], r)), { shouldBreak: n });
     })(e, n, { signatureDocs: a, shouldBreak: u }),
     m = !1;
    return (
     l && (h || n.assignmentLayout) && ((m = !0), (p = 'chain-tail-arrow-chain' === n.assignmentLayout || (h && !c))),
     (s = (function (e, t, r, { bodyDoc: n, bodyComments: s, functionBody: i, shouldPutBodyOnSameLine: a }) {
      let { node: o, parent: u } = e,
       l = r.expandLastArg && Ue(t, 'all') ? Xt(',') : '',
       p = (!r.expandLastArg && 'JSXExpressionContainer' !== u.type) || at(o) ? '' : nr;
      return a && ha(i) ? [' ', Vt([Xt('', '('), Ht([nr, n]), Xt('', ')'), l, p]), s] : (da(i) && (n = Vt(['(', Ht([nr, n]), nr, ')'])), a ? [' ', n, s] : [Ht([rr, n, s]), l, p]);
     })(e, t, n, { bodyDoc: s, bodyComments: o, functionBody: i, shouldPutBodyOnSameLine: c })),
     Vt([Vt(m ? Ht([nr, f]) : f, { shouldBreak: p, id: d }), ' =>', l ? Yt(s, { groupId: d }) : Vt(s), l && h ? Xt(nr, '', { groupId: d }) : ''])
    );
   }
   var ma = (e, t, r) => {
    if (!e || null != t) {
     if (t.findLast) return t.findLast(r);
     for (let e = t.length - 1; e >= 0; e--) {
      let n = t[e];
      if (r(n, e, t)) return n;
     }
    }
   };
   function ya(e, t, r, n) {
    let { node: s } = e,
     i = [],
     a = ma(!1, s[n], (e) => 'EmptyStatement' !== e.type);
    return (
     e.each(({ node: e }) => {
      'EmptyStatement' !== e.type && (i.push(r()), e !== a && (i.push(sr), ut(e, t) && i.push(sr)));
     }, n),
     i
    );
   }
   function ga(e, t, r) {
    let n = (function (e, t, r) {
      let { node: n } = e,
       s = L(n.directives),
       i = n.body.some((e) => 'EmptyStatement' !== e.type),
       a = at(n, st.Dangling);
      if (!s && !i && !a) return '';
      let o = [];
      return s && (o.push(ya(e, t, r, 'directives')), (i || a) && (o.push(sr), ut(x(!1, n.directives, -1), t) && o.push(sr))), i && o.push(ya(e, t, r, 'body')), a && o.push(ys(e, t)), o;
     })(e, t, r),
     { node: s, parent: i } = e;
    if ('Program' === s.type && 'ModuleExpression' !== (null == i ? void 0 : i.type)) return n ? [n, sr] : '';
    let a = [];
    if (('StaticBlock' === s.type && a.push('static '), a.push('{'), n)) a.push(Ht([sr, n]), sr);
    else {
     let t = e.grandparent;
     'ArrowFunctionExpression' === i.type || 'FunctionExpression' === i.type || 'FunctionDeclaration' === i.type || 'ComponentDeclaration' === i.type || 'HookDeclaration' === i.type || 'ObjectMethod' === i.type || 'ClassMethod' === i.type || 'ClassPrivateMethod' === i.type || 'ForStatement' === i.type || 'WhileStatement' === i.type || 'DoWhileStatement' === i.type || 'DoExpression' === i.type || 'ModuleExpression' === i.type || ('CatchClause' === i.type && !t.finalizer) || 'TSModuleDeclaration' === i.type || 'StaticBlock' === s.type || a.push(sr);
    }
    return a.push('}'), a;
   }
   var Da = function (e) {
    let t = new WeakMap();
    return function (r) {
     return t.has(r) || t.set(r, Symbol(e)), t.get(r);
    };
   };
   function xa(e) {
    switch (e) {
     case null:
      return '';
     case 'PlusOptional':
      return '+?';
     case 'MinusOptional':
      return '-?';
     case 'Optional':
      return '?';
    }
   }
   function ba(e, t) {
    return '+' === e || '-' === e ? e + t : t;
   }
   var va = Da('typeParameters');
   function Ea(e, t, r, n) {
    let { node: s } = e;
    if (!s[n]) return '';
    if (!Array.isArray(s[n])) return r(n);
    let i = e.getNode(2),
     a = i && Te(i),
     o = e.match(
      (e) => !(1 === e[n].length && de(e[n][0])),
      void 0,
      (e, t) => 'typeAnnotation' === t,
      (e) => 'Identifier' === e.type,
      ai,
     );
    if (0 === s[n].length || (!o && (a || (1 === s[n].length && ('NullableTypeAnnotation' === s[n][0].type || mi(s[n][0])))))) return ['<', or(', ', e.map(r, n)), Ca(e, t), '>'];
    let u =
     'TSTypeParameterInstantiation' === s.type
      ? ''
      : (function (e, t, r) {
           let { node: n } = e;
           return 1 === Ye(n).length && n.type.startsWith('TS') && !n[r][0].constraint && 'ArrowFunctionExpression' === e.parent.type && !(t.filepath && /\.ts$/.test(t.filepath));
          })(e, t, n)
        ? ','
        : Ue(t)
          ? Xt(',')
          : '';
    return Vt(['<', Ht([nr, or([',', rr], e.map(r, n))]), u, nr, '>'], { id: va(s) });
   }
   function Ca(e, t) {
    let { node: r } = e;
    if (!at(r, st.Dangling)) return '';
    let n = !at(r, st.Line),
     s = ys(e, t, { indent: !n });
    return n ? s : [s, sr];
   }
   function Ta(e, t, r) {
    let { node: n, parent: s } = e,
     i = ['TSTypeParameter' === n.type && n.const ? 'const ' : ''],
     a = 'TSTypeParameter' === n.type ? r('name') : n.name;
    if ('TSMappedType' === s.type)
     return (
      s.readonly && i.push(ba(s.readonly, 'readonly'), ' '),
      i.push('[', a),
      n.constraint && i.push(' in ', r('constraint')),
      s.nameType &&
       i.push(
        ' as ',
        e.callParent(() => r('nameType')),
       ),
      i.push(']'),
      i
     );
    if ((n.variance && i.push(r('variance')), n.in && i.push('in '), n.out && i.push('out '), i.push(a), n.bound && (n.usesExtendsBound && i.push(' extends '), i.push(wi(e, r, 'bound'))), n.constraint)) {
     let e = Symbol('constraint');
     i.push(' extends', Vt(Ht(rr), { id: e }), Zt, Yt(r('constraint'), { groupId: e }));
    }
    return n.default && i.push(' = ', r('default')), Vt(i);
   }
   var Sa = K(['ClassProperty', 'PropertyDefinition', 'ClassPrivateProperty', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
   function wa(e, t, r) {
    let { node: n } = e,
     s = [Li(e), Mi(e), 'class'],
     i = at(n.id, st.Trailing) || at(n.typeParameters, st.Trailing) || at(n.superClass) || L(n.extends) || L(n.mixins) || L(n.implements),
     a = [],
     o = [];
    if ((n.id && a.push(' ', r('id')), a.push(r('typeParameters')), n.superClass)) {
     let n = [Ia(e, t, r), r('superTypeParameters')],
      s = e.call((e) => ['extends ', Ds(e, n, t)], 'superClass');
     i ? o.push(rr, Vt(s)) : o.push(' ', s);
    } else o.push(Pa(e, t, r, 'extends'));
    if ((o.push(Pa(e, t, r, 'mixins'), Pa(e, t, r, 'implements')), i)) {
     let e;
     (e = ka(n) ? [...a, Ht(o)] : Ht([...a, o])), s.push(Vt(e, { id: Aa(n) }));
    } else s.push(...a, ...o);
    return s.push(' ', r('body')), s;
   }
   var Aa = Da('heritageGroup');
   function Fa(e) {
    return Xt(sr, '', { groupId: Aa(e) });
   }
   function ka(e) {
    return (
     e.typeParameters &&
     !at(e.typeParameters, st.Trailing | st.Line) &&
     !(function (e) {
      return ['extends', 'mixins', 'implements'].reduce((t, r) => t + (Array.isArray(e[r]) ? e[r].length : 0), e.superClass ? 1 : 0) > 1;
     })(e)
    );
   }
   function Pa(e, t, r, n) {
    let { node: s } = e;
    if (!L(s[n])) return '';
    let i = ys(e, t, { marker: n });
    return [ka(s) ? Xt(' ', rr, { groupId: va(s.typeParameters) }) : rr, i, i && sr, n, Vt(Ht([rr, or([',', rr], e.map(r, n))]))];
   }
   function Ia(e, t, r) {
    let n = r('superClass'),
     { parent: s } = e;
    return 'AssignmentExpression' === s.type ? Vt(Xt(['(', Ht([nr, n]), nr, ')'], n)) : n;
   }
   function Na(e, t, r) {
    let { node: n } = e,
     s = [];
    return L(n.decorators) && s.push($s(e, t, r)), s.push($i(n)), n.static && s.push('static '), s.push(Mi(e)), n.override && s.push('override '), s.push(aa(e, t, r)), s;
   }
   function Ba(e, t, r) {
    let { node: n } = e,
     s = [],
     i = t.semi ? ';' : '';
    return L(n.decorators) && s.push($s(e, t, r)), s.push($i(n), Li(e)), n.static && s.push('static '), s.push(Mi(e)), n.override && s.push('override '), n.readonly && s.push('readonly '), n.variance && s.push(r('variance')), ('ClassAccessorProperty' === n.type || 'AccessorProperty' === n.type || 'TSAbstractAccessorProperty' === n.type) && s.push('accessor '), s.push(ra(e, t, r), Ni(e), Bi(e), wi(e, r)), [ri(e, t, r, s, ' =', 'TSAbstractPropertyDefinition' === n.type || 'TSAbstractAccessorProperty' === n.type ? void 0 : 'value'), i];
   }
   function _a(e, t, r) {
    let { node: n } = e,
     s = [];
    return (
     e.each(({ node: e, next: n, isLast: i }) => {
      s.push(r()),
       !t.semi &&
        Sa(e) &&
        (function (e, t) {
         var r;
         let { type: n, name: s } = e.key;
         if (!(e.computed || 'Identifier' !== n || ('static' !== s && 'get' !== s && 'set' !== s) || e.value || e.typeAnnotation)) return !0;
         if (!t || t.static || t.accessibility || t.readonly) return !1;
         if (!t.computed) {
          let e = null == (r = t.key) ? void 0 : r.name;
          if ('in' === e || 'instanceof' === e) return !0;
         }
         if (Sa(t) && t.variance && !t.static && !t.declare) return !0;
         switch (t.type) {
          case 'ClassProperty':
          case 'PropertyDefinition':
          case 'TSAbstractPropertyDefinition':
           return t.computed;
          case 'MethodDefinition':
          case 'TSAbstractMethodDefinition':
          case 'ClassMethod':
          case 'ClassPrivateMethod': {
           if ((t.value ? t.value.async : t.async) || 'get' === t.kind || 'set' === t.kind) return !1;
           let e = t.value ? t.value.generator : t.generator;
           return !(!t.computed && !e);
          }
          case 'TSIndexSignature':
           return !0;
         }
         return !1;
        })(e, n) &&
        s.push(';'),
       i || (s.push(sr), ut(e, t) && s.push(sr));
     }, 'body'),
     at(n, st.Dangling) && s.push(ys(e, t)),
     [L(n.body) ? Fa(e.parent) : '', '{', s.length > 0 ? [Ht([sr, s]), sr] : '', '}']
    );
   }
   function La(e, t) {
    if (t.semi || Ma(e, t) || Ra(e, t)) return !1;
    let { node: r, key: n, parent: s } = e;
    return !('ExpressionStatement' !== r.type || (('body' !== n || ('Program' !== s.type && 'BlockStatement' !== s.type && 'StaticBlock' !== s.type && 'TSModuleBlock' !== s.type)) && ('consequent' !== n || 'SwitchCase' !== s.type)) || !e.call(() => Oa(e, t), 'expression'));
   }
   function Oa(e, t) {
    let { node: r } = e;
    switch (r.type) {
     case 'ParenthesizedExpression':
     case 'TypeCastExpression':
     case 'ArrayExpression':
     case 'ArrayPattern':
     case 'TemplateLiteral':
     case 'TemplateElement':
     case 'RegExpLiteral':
      return !0;
     case 'ArrowFunctionExpression':
      if (!ua(e, t)) return !0;
      break;
     case 'UnaryExpression': {
      let { prefix: e, operator: t } = r;
      if (e && ('+' === t || '-' === t)) return !0;
      break;
     }
     case 'BindExpression':
      if (!r.object) return !0;
      break;
     case 'Literal':
      if (r.regex) return !0;
      break;
     default:
      if (ye(r)) return !0;
    }
    return !!hs(e, t) || (!!ee(r) && e.call(() => Oa(e, t), ...re(r)));
   }
   function Ma({ node: e, parent: t }, r) {
    return ('markdown' === r.parentParser || 'mdx' === r.parentParser) && 'ExpressionStatement' === e.type && ye(e.expression) && 'Program' === t.type && 1 === t.body.length;
   }
   function ja(e) {
    switch (e.type) {
     case 'MemberExpression':
      switch (e.property.type) {
       case 'Identifier':
       case 'NumericLiteral':
       case 'StringLiteral':
        return ja(e.object);
      }
      return !1;
     case 'Identifier':
      return !0;
     default:
      return !1;
    }
   }
   function Ra({ node: e, parent: t }, r) {
    return ('__vue_event_binding' === r.parser || '__vue_ts_event_binding' === r.parser) && 'ExpressionStatement' === e.type && 'Program' === t.type && 1 === t.body.length;
   }
   function qa(e, t, r) {
    let n = [r('expression')];
    return Ra(e, t) ? ja(e.node.expression) && n.push(';') : Ma(e, t) || (t.semi && n.push(';')), n;
   }
   function Ua(e) {
    return e.toLowerCase();
   }
   function $a({ pattern: e, flags: t }) {
    return `/${e}/${(t = [...t].sort().join(''))}`;
   }
   function Ha(e, t) {
    let r = e.slice(1, -1);
    if (r.includes('"') || r.includes("'")) return e;
    let n = t.singleQuote ? "'" : '"';
    return n + r + n;
   }
   var za = function (e, t, r) {
    let n = e.originalText.slice(t, r);
    for (let s of e[Symbol.for('comments')]) {
     let e = q(s);
     if (e > r) break;
     let i = U(s);
     if (i < t) continue;
     let a = i - e;
     n = n.slice(0, e - t) + ' '.repeat(a) + n.slice(i - t);
    }
    return n;
   };
   var Va = (e) => 'ExportDefaultDeclaration' === e.type || ('DeclareExportDeclaration' === e.type && e.default);
   function Wa(e, t, r) {
    let { node: n } = e,
     s = [Hs(e, 0, r), Li(e), 'export', Va(n) ? ' default' : ''],
     { declaration: i, exported: a } = n;
    return (
     at(n, st.Dangling) && (s.push(' ', ys(e, t)), Le(n) && s.push(sr)),
     i
      ? s.push(' ', r('declaration'))
      : (s.push(
         (function (e) {
          return Ka(e.exportKind);
         })(n),
        ),
        'ExportAllDeclaration' === n.type || 'DeclareExportAllDeclaration' === n.type ? (s.push(' *'), a && s.push(' as ', r('exported'))) : s.push(Ya(e, t, r)),
        s.push(Xa(e, t, r), Za(e, t, r))),
     s.push(
      (function (e, t) {
       return t.semi && (!e.declaration || (Va(e) && !Ja(e.declaration))) ? ';' : '';
      })(n, t),
     ),
     s
    );
   }
   var Ja = K(['ClassDeclaration', 'ComponentDeclaration', 'FunctionDeclaration', 'TSInterfaceDeclaration', 'DeclareClass', 'DeclareComponent', 'DeclareFunction', 'DeclareHook', 'HookDeclaration', 'TSDeclareFunction', 'EnumDeclaration']);
   function Ka(e, t = !0) {
    return e && 'value' !== e ? `${t ? ' ' : ''}${e}${t ? '' : ' '}` : '';
   }
   function Ga(e, t) {
    return Ka(e.importKind, t);
   }
   function Xa(e, t, r) {
    let { node: n } = e;
    if (!n.source) return '';
    let s = [];
    return Qa(n, t) && s.push(' from'), s.push(' ', r('source')), s;
   }
   function Ya(e, t, r) {
    let { node: n } = e;
    if (!Qa(n, t)) return '';
    let s = [' '];
    if (L(n.specifiers)) {
     let i = [],
      a = [];
     e.each(() => {
      let t = e.node.type;
      if ('ExportNamespaceSpecifier' === t || 'ExportDefaultSpecifier' === t || 'ImportNamespaceSpecifier' === t || 'ImportDefaultSpecifier' === t) i.push(r());
      else {
       if ('ExportSpecifier' !== t && 'ImportSpecifier' !== t) throw new bs(n, 'specifier');
       a.push(r());
      }
     }, 'specifiers'),
      s.push(or(', ', i)),
      a.length > 0 && (i.length > 0 && s.push(', '), a.length > 1 || i.length > 0 || n.specifiers.some((e) => at(e)) ? s.push(Vt(['{', Ht([t.bracketSpacing ? rr : nr, or([',', rr], a)]), Xt(Ue(t) ? ',' : ''), t.bracketSpacing ? rr : nr, '}'])) : s.push(['{', t.bracketSpacing ? ' ' : '', ...a, t.bracketSpacing ? ' ' : '', '}']));
    } else s.push('{}');
    return s;
   }
   function Qa(e, t) {
    return !('ImportDeclaration' === e.type && !L(e.specifiers) && 'type' !== e.importKind) || za(t, q(e), q(e.source)).trimEnd().endsWith('from');
   }
   function Za(e, t, r) {
    let { node: n } = e;
    if (!n.source) return '';
    let s = (function (e, t) {
     var r, n;
     if (null != (r = e.extra) && r.deprecatedAssertSyntax) return 'assert';
     let s = za(t, U(e.source), null != (n = e.attributes) && n[0] ? q(e.attributes[0]) : U(e)).trimStart();
     return s.startsWith('assert') ? 'assert' : s.startsWith('with') || L(e.attributes) ? 'with' : void 0;
    })(n, t);
    if (!s) return '';
    let i = [` ${s} {`];
    return L(n.attributes) && (t.bracketSpacing && i.push(' '), i.push(or(', ', e.map(r, 'attributes'))), t.bracketSpacing && i.push(' ')), i.push('}'), i;
   }
   function eo(e, t, r) {
    let { node: n } = e,
     { type: s } = n,
     i = s.startsWith('Import'),
     a = i ? 'imported' : 'local',
     o = i ? 'local' : 'exported',
     u = n[a],
     l = n[o],
     p = '',
     c = '';
    return (
     'ExportNamespaceSpecifier' === s || 'ImportNamespaceSpecifier' === s ? (p = '*') : u && (p = r(a)),
     l &&
      !(function (e) {
       if ('ImportSpecifier' !== e.type && 'ExportSpecifier' !== e.type) return !1;
       let { local: t, ['ImportSpecifier' === e.type ? 'imported' : 'exported']: r } = e;
       if (t.type !== r.type || !H(t, r)) return !1;
       if (le(t)) return t.value === r.value && Re(t) === Re(r);
       if ('Identifier' === t.type) return t.name === r.name;
       return !1;
      })(n) &&
      (c = r(o)),
     [Ka('ImportSpecifier' === s ? n.importKind : n.exportKind, !1), p, p && c ? ' as ' : '', c]
    );
   }
   function to(e, t, r) {
    var n;
    let s = t.semi ? ';' : '',
     { node: i } = e,
     a = 'ObjectTypeAnnotation' === i.type,
     o = 'TSEnumDeclaration' === i.type || 'EnumBooleanBody' === i.type || 'EnumNumberBody' === i.type || 'EnumBigIntBody' === i.type || 'EnumStringBody' === i.type || 'EnumSymbolBody' === i.type,
     u = ['TSTypeLiteral' === i.type || o ? 'members' : 'TSInterfaceBody' === i.type ? 'body' : 'properties'];
    a && u.push('indexers', 'callProperties', 'internalSlots');
    let l = u.flatMap((t) => e.map(({ node: e }) => ({ node: e, printed: r(), loc: q(e) }), t));
    u.length > 1 && l.sort((e, t) => e.loc - t.loc);
    let { parent: p, key: c } = e,
     h = a && 'body' === c && ('InterfaceDeclaration' === p.type || 'DeclareInterface' === p.type || 'DeclareClass' === p.type),
     d = 'TSInterfaceBody' === i.type || o || h || ('ObjectPattern' === i.type && 'FunctionDeclaration' !== p.type && 'FunctionExpression' !== p.type && 'ArrowFunctionExpression' !== p.type && 'ObjectMethod' !== p.type && 'ClassMethod' !== p.type && 'ClassPrivateMethod' !== p.type && 'AssignmentPattern' !== p.type && 'CatchClause' !== p.type && i.properties.some((e) => e.value && ('ObjectPattern' === e.value.type || 'ArrayPattern' === e.value.type))) || ('ObjectPattern' !== i.type && l.length > 0 && kr(t.originalText, q(i), l[0].loc)),
     f = h ? ';' : 'TSInterfaceBody' === i.type || 'TSTypeLiteral' === i.type ? Xt(s, ';') : ',',
     m = 'RecordExpression' === i.type ? '#{' : i.exact ? '{|' : '{',
     y = i.exact ? '|}' : '}',
     g = [],
     D = l.map((e) => {
      let r = [...g, Vt(e.printed)];
      return (g = [f, rr]), ('TSPropertySignature' === e.node.type || 'TSMethodSignature' === e.node.type || 'TSConstructSignatureDeclaration' === e.node.type || 'TSCallSignatureDeclaration' === e.node.type) && at(e.node, st.PrettierIgnore) && g.shift(), ut(e.node, t) && g.push(sr), r;
     });
    if (i.inexact || i.hasUnknownMembers) {
     let r;
     if (at(i, st.Dangling)) {
      let n = at(i, st.Line);
      r = [ys(e, t), n || I(t.originalText, U(x(!1, ot(i), -1))) ? sr : rr, '...'];
     } else r = ['...'];
     D.push([...g, ...r]);
    }
    let b,
     v = null == (n = x(!1, l, -1)) ? void 0 : n.node,
     E = !(i.inexact || i.hasUnknownMembers || (v && ('RestElement' === v.type || (('TSPropertySignature' === v.type || 'TSCallSignatureDeclaration' === v.type || 'TSMethodSignature' === v.type || 'TSConstructSignatureDeclaration' === v.type) && at(v, st.PrettierIgnore)))));
    if (0 === D.length) {
     if (!at(i, st.Dangling)) return [m, y, wi(e, r)];
     b = Vt([m, ys(e, t, { indent: !0 }), nr, y, Ni(e), wi(e, r)]);
    } else b = [h && L(i.properties) ? Fa(p) : '', m, Ht([t.bracketSpacing ? rr : nr, ...D]), Xt(E && (',' !== f || Ue(t)) ? f : ''), t.bracketSpacing ? rr : nr, y, Ni(e), wi(e, r)];
    return e.match((e) => 'ObjectPattern' === e.type && !L(e.decorators), ro) ||
     (de(i) &&
      (e.match(
       void 0,
       (e, t) => 'typeAnnotation' === t,
       (e, t) => 'typeAnnotation' === t,
       ro,
      ) ||
       e.match(void 0, (e, t) => 'FunctionTypeParam' === e.type && 'typeAnnotation' === t, ro))) ||
     (!d &&
      e.match(
       (e) => 'ObjectPattern' === e.type,
       (e) => 'AssignmentExpression' === e.type || 'VariableDeclarator' === e.type,
      ))
     ? b
     : Vt(b, { shouldBreak: d });
   }
   function ro(e, t) {
    return ('params' === t || 'parameters' === t || 'this' === t || 'rest' === t) && ci(e);
   }
   function no(e, t, r) {
    let { node: n } = e,
     s = 'ConditionalExpression' === n.type,
     i = s ? 'alternate' : 'falseType',
     { parent: a } = e,
     o = s ? r('test') : [r('checkType'), ' ', 'extends', ' ', r('extendsType')];
    return a.type === n.type && a[i] === n ? zt(2, o) : o;
   }
   var so = new Map([
    ['AssignmentExpression', 'right'],
    ['VariableDeclarator', 'init'],
    ['ReturnStatement', 'argument'],
    ['ThrowStatement', 'argument'],
    ['UnaryExpression', 'argument'],
    ['YieldExpression', 'argument'],
    ['AwaitExpression', 'argument'],
   ]);
   function io(e, t, r) {
    let n,
     s,
     { node: i } = e,
     a = 'ConditionalExpression' === i.type,
     o = a ? 'consequent' : 'trueType',
     u = a ? 'alternate' : 'falseType',
     l = a ? ['test'] : ['checkType', 'extendsType'],
     p = i[o],
     c = i[u],
     h = [],
     d = !1,
     { parent: f } = e,
     m = f.type === i.type && l.some((e) => f[e] === i),
     y = f.type === i.type && !m,
     g = 0;
    do {
     (s = n || i), (n = e.getParentNode(g)), g++;
    } while (n && n.type === i.type && l.every((e) => n[e] !== s));
    let D = n || f,
     x = s;
    if (
     a &&
     (ye(i[l[0]]) ||
      ye(p) ||
      ye(c) ||
      (function (e) {
       let t = [e];
       for (let r = 0; r < t.length; r++) {
        let e = t[r];
        for (let r of ['test', 'consequent', 'alternate']) {
         let n = e[r];
         if (ye(n)) return !0;
         'ConditionalExpression' === n.type && t.push(n);
        }
       }
       return !1;
      })(x))
    ) {
     (d = !0), (y = !0);
     let e = (e) => [Xt('('), Ht([nr, e]), nr, Xt(')')],
      t = (e) => 'NullLiteral' === e.type || ('Literal' === e.type && null === e.value) || ('Identifier' === e.type && 'undefined' === e.name);
     h.push(' ? ', t(p) ? r(o) : e(r(o)), ' : ', c.type === i.type || t(c) ? r(u) : e(r(u)));
    } else {
     let e = (e) => (t.useTabs ? Ht(r(e)) : zt(2, r(e))),
      n = [rr, '? ', p.type === i.type ? Xt('', '(') : '', e(o), p.type === i.type ? Xt('', ')') : '', rr, ': ', e(u)];
     h.push(f.type !== i.type || f[u] === i || m ? n : t.useTabs ? Jt(Ht(n)) : zt(Math.max(0, t.tabWidth - 2), n));
    }
    let b = [o, u, ...l].some((e) => at(i[e], (e) => G(e) && kr(t.originalText, q(e), U(e)))),
     v = !d && (Ae(f) || ('NGPipeExpression' === f.type && f.left === i)) && !f.computed,
     E = (function (e) {
      let { node: t } = e;
      if ('ConditionalExpression' !== t.type) return !1;
      let r,
       n = t;
      for (let s = 0; !r; s++) {
       let t = e.getParentNode(s);
       ('ChainExpression' === t.type && t.expression === n) || (we(t) && t.callee === n) || (Ae(t) && t.object === n) || ('TSNonNullExpression' === t.type && t.expression === n) ? (n = t) : ('NewExpression' === t.type && t.callee === n) || (ct(t) && t.expression === n) ? ((r = e.getParentNode(s + 1)), (n = t)) : (r = t);
      }
      return n !== t && r[so.get(r.type)] === n;
     })(e),
     C = ((T = [no(e, 0, r), y ? h : Ht(h), a && v && !E ? nr : '']), f === D ? Vt(T, { shouldBreak: b }) : b ? [T, er] : T);
    var T;
    return m || E ? Vt([Ht([nr, C]), nr]) : C;
   }
   var ao = new Map([
    ['AssignmentExpression', 'right'],
    ['VariableDeclarator', 'init'],
    ['ReturnStatement', 'argument'],
    ['ThrowStatement', 'argument'],
    ['UnaryExpression', 'argument'],
    ['YieldExpression', 'argument'],
    ['AwaitExpression', 'argument'],
   ]);
   var oo = (e) => [Xt('('), Ht([nr, e]), nr, Xt(')')];
   function uo(e, t, r, n) {
    if (!t.experimentalTernaries) return io(e, t, r);
    let s,
     i,
     { node: a } = e,
     o = 'ConditionalExpression' === a.type,
     u = 'TSConditionalType' === a.type || 'ConditionalTypeAnnotation' === a.type,
     l = o ? 'consequent' : 'trueType',
     p = o ? 'alternate' : 'falseType',
     c = o ? ['test'] : ['checkType', 'extendsType'],
     h = a[l],
     d = a[p],
     f = c.map((e) => a[e]),
     { parent: m } = e,
     y = m.type === a.type,
     g = y && c.some((e) => m[e] === a),
     D = y && m[p] === a,
     x = h.type === a.type,
     b = d.type === a.type,
     v = b || D,
     E = t.tabWidth > 2 || t.useTabs,
     C = 0;
    do {
     (i = s || a), (s = e.getParentNode(C)), C++;
    } while (s && s.type === a.type && c.every((e) => s[e] !== i));
    let T = s || m,
     S = n && n.assignmentLayout && 'break-after-operator' !== n.assignmentLayout && ('AssignmentExpression' === m.type || 'VariableDeclarator' === m.type || 'ClassProperty' === m.type || 'PropertyDefinition' === m.type || 'ClassPrivateProperty' === m.type || 'ObjectProperty' === m.type || 'Property' === m.type),
     w = ('ReturnStatement' === m.type || 'ThrowStatement' === m.type) && !(x || b),
     A = o && 'JSXExpressionContainer' === T.type && 'JSXAttribute' !== e.grandparent.type,
     F = (function (e) {
      let { node: t } = e;
      if ('ConditionalExpression' !== t.type) return !1;
      let r,
       n = t;
      for (let s = 0; !r; s++) {
       let t = e.getParentNode(s);
       ('ChainExpression' === t.type && t.expression === n) || (we(t) && t.callee === n) || (Ae(t) && t.object === n) || ('TSNonNullExpression' === t.type && t.expression === n) ? (n = t) : ('NewExpression' === t.type && t.callee === n) || (ct(t) && t.expression === n) ? ((r = e.getParentNode(s + 1)), (n = t)) : (r = t);
      }
      return n !== t && r[ao.get(r.type)] === n;
     })(e),
     k = (function (e, t) {
      return (Ae(t) || ('NGPipeExpression' === t.type && t.left === e)) && !t.computed;
     })(a, m),
     P = u && hs(e, t),
     I = E ? (t.useTabs ? '\t' : ' '.repeat(t.tabWidth - 1)) : '',
     N =
      (function (e, t, r, n) {
       return [...e.map((e) => ot(e)), ot(t), ot(r)].flat().some((e) => G(e) && kr(n.originalText, q(e), U(e)));
      })(f, h, d, t) ||
      x ||
      b,
     B = !v && !y && !u && (A ? 'NullLiteral' === h.type || ('Literal' === h.type && null === h.value) : Ie(h, t) && Fe(a.test, 3)),
     _ = v || D || (u && !y) || (y && o && Fe(a.test, 1)) || B,
     L = [];
    !x &&
     at(h, st.Dangling) &&
     e.call((e) => {
      L.push(ys(e, t), sr);
     }, 'consequent');
    let O = [];
    at(a.test, st.Dangling) &&
     e.call((e) => {
      O.push(ys(e, t));
     }, 'test'),
     !b &&
      at(d, st.Dangling) &&
      e.call((e) => {
       O.push(ys(e, t));
      }, 'alternate'),
     at(a, st.Dangling) && O.push(ys(e, t));
    let M = Symbol('test'),
     j = Symbol('consequent'),
     R = Symbol('test-and-consequent'),
     $ = o ? [oo(r('test')), 'ConditionalExpression' === a.test.type ? er : ''] : [r('checkType'), ' ', 'extends', ' ', 'TSConditionalType' === a.extendsType.type || 'ConditionalTypeAnnotation' === a.extendsType.type || 'TSMappedType' === a.extendsType.type ? r('extendsType') : Vt(oo(r('extendsType')))],
     H = Vt([$, ' ?'], { id: M }),
     z = r(l),
     V = Ht([x || (A && (ye(h) || y || v)) ? sr : rr, L, z]),
     W = _ ? Vt([H, v ? V : Xt(V, Vt(V, { id: j }), { groupId: M })], { id: R }) : [H, V],
     J = r(p),
     K = B ? Xt(J, Jt(oo(J)), { groupId: R }) : J,
     X = [W, O.length > 0 ? [Ht([sr, O]), sr] : b ? sr : B ? Xt(rr, ' ', { groupId: R }) : rr, ':', b ? ' ' : E ? (_ ? Xt(I, Xt(v || B ? ' ' : I, ' '), { groupId: R }) : Xt(I, ' ')) : ' ', b ? K : Vt([Ht(K), A && !B ? nr : '']), k && !F ? nr : '', N ? er : ''];
    return S && !N ? Vt(Ht([nr, Vt(X)])) : S || w ? Vt(Ht(X)) : F || (u && g) ? Vt([Ht([nr, X]), P ? nr : '']) : m === T ? Vt(X) : X;
   }
   function lo(e, t, r, n) {
    let { node: s } = e;
    if (ce(s))
     return (function (e, t) {
      let { node: r } = e;
      switch (r.type) {
       case 'RegExpLiteral':
        return $a(r);
       case 'BigIntLiteral':
        return Ua(r.extra.raw);
       case 'NumericLiteral':
        return Qi(r.extra.raw);
       case 'StringLiteral':
        return gr(R(r.extra.raw, t));
       case 'NullLiteral':
        return 'null';
       case 'BooleanLiteral':
        return String(r.value);
       case 'DecimalLiteral':
        return Qi(r.value) + 'm';
       case 'DirectiveLiteral':
        return Ha(r.extra.raw, t);
       case 'Literal': {
        if (r.regex) return $a(r.regex);
        if (r.bigint) return Ua(r.raw);
        if (r.decimal) return Qi(r.decimal) + 'm';
        let { value: n } = r;
        return 'number' == typeof n
         ? Qi(r.raw)
         : 'string' == typeof n
           ? (function (e) {
              if ('expression' !== e.key) return;
              let { parent: t } = e;
              return 'ExpressionStatement' === t.type && t.directive;
             })(e)
             ? Ha(r.raw, t)
             : gr(R(r.raw, t))
           : String(n);
       }
      }
     })(e, t);
    let i = t.semi ? ';' : '',
     a = [];
    switch (s.type) {
     case 'JsExpressionRoot':
      return r('node');
     case 'JsonRoot':
      return [r('node'), sr];
     case 'File':
      return (
       (function (e, t, r) {
        if (t.__isVueBindings || t.__isVueForBindingLeft) {
         let n = e.map(r, 'program', 'body', 0, 'params');
         if (1 === n.length) return n[0];
         let s = or([',', rr], n);
         return t.__isVueForBindingLeft ? ['(', Ht([nr, Vt(s)]), nr, ')'] : s;
        }
        if (t.__isEmbeddedTypescriptGenericParameters) {
         let t = e.map(r, 'program', 'body', 0, 'typeParameters', 'params');
         return or([',', rr], t);
        }
       })(e, t, r) ?? r('program')
      );
     case 'EmptyStatement':
      return '';
     case 'ExpressionStatement':
      return qa(e, t, r);
     case 'ChainExpression':
      return r('expression');
     case 'ParenthesizedExpression':
      return at(s.expression) || (!ae(s.expression) && !ie(s.expression)) ? Vt(['(', Ht([nr, r('expression')]), nr, ')']) : ['(', r('expression'), ')'];
     case 'AssignmentExpression':
      return (function (e, t, r) {
       let { node: n } = e;
       return ri(e, t, r, r('left'), [' ', n.operator], 'right');
      })(e, t, r);
     case 'VariableDeclarator':
      return (function (e, t, r) {
       return ri(e, t, r, r('id'), ' =', 'init');
      })(e, t, r);
     case 'BinaryExpression':
     case 'LogicalExpression':
      return Ls(e, t, r);
     case 'AssignmentPattern':
      return [r('left'), ' = ', r('right')];
     case 'OptionalMemberExpression':
     case 'MemberExpression':
      return (function (e, t, r) {
       var n;
       let s = r('object'),
        i = Qs(e, 0, r),
        { node: a } = e,
        o = e.findAncestor((e) => !(Ae(e) || 'TSNonNullExpression' === e.type)),
        u = e.findAncestor((e) => !('ChainExpression' === e.type || 'TSNonNullExpression' === e.type)),
        l = (o && ('NewExpression' === o.type || 'BindExpression' === o.type || ('AssignmentExpression' === o.type && 'Identifier' !== o.left.type))) || a.computed || ('Identifier' === a.object.type && 'Identifier' === a.property.type && !Ae(u)) || (('AssignmentExpression' === u.type || 'VariableDeclarator' === u.type) && (Ys(a.object) || (null == (n = s.label) ? void 0 : n.memberChain)));
       return ur(s.label, [s, l ? i : Vt(Ht([nr, i]))]);
      })(e, 0, r);
     case 'MetaProperty':
      return [r('meta'), '.', r('property')];
     case 'BindExpression':
      return s.object && a.push(r('object')), a.push(Vt(Ht([nr, Ri(0, 0, r)]))), a;
     case 'Identifier':
      return [s.name, Ni(e), Bi(e), wi(e, r)];
     case 'V8IntrinsicIdentifier':
      return ['%', s.name];
     case 'SpreadElement':
     case 'SpreadElementPattern':
     case 'SpreadPropertyPattern':
     case 'RestElement':
      return Ui(e, r);
     case 'FunctionDeclaration':
     case 'FunctionExpression':
      return ia(e, r, t, n);
     case 'ArrowFunctionExpression':
      return fa(e, t, r, n);
     case 'YieldExpression':
      return a.push('yield'), s.delegate && a.push('*'), s.argument && a.push(' ', r('argument')), a;
     case 'AwaitExpression':
      if ((a.push('await'), s.argument)) {
       a.push(' ', r('argument'));
       let { parent: t } = e;
       if ((we(t) && t.callee === s) || (Ae(t) && t.object === s)) {
        a = [Ht([nr, ...a]), nr];
        let t = e.findAncestor((e) => 'AwaitExpression' === e.type || 'BlockStatement' === e.type);
        if ('AwaitExpression' !== (null == t ? void 0 : t.type) || !$e(t.argument, (e) => e === s)) return Vt(a);
       }
      }
      return a;
     case 'ExportDefaultDeclaration':
     case 'ExportNamedDeclaration':
     case 'ExportAllDeclaration':
      return Wa(e, t, r);
     case 'ImportDeclaration':
      return (function (e, t, r) {
       let { node: n } = e;
       return ['import', n.module ? ' module' : '', n.phase ? ` ${n.phase}` : '', Ga(n), Ya(e, t, r), Xa(e, t, r), Za(e, t, r), t.semi ? ';' : ''];
      })(e, t, r);
     case 'ImportSpecifier':
     case 'ExportSpecifier':
     case 'ImportNamespaceSpecifier':
     case 'ExportNamespaceSpecifier':
     case 'ImportDefaultSpecifier':
     case 'ExportDefaultSpecifier':
      return eo(e, 0, r);
     case 'ImportAttribute':
     case 'ObjectProperty':
      return na(e, t, r);
     case 'Import':
      return 'import';
     case 'Program':
     case 'BlockStatement':
     case 'StaticBlock':
      return ga(e, t, r);
     case 'ClassBody':
      return _a(e, t, r);
     case 'ThrowStatement':
      return (function (e, t, r) {
       return ['throw', pa(e, t, r)];
      })(e, t, r);
     case 'ReturnStatement':
      return (function (e, t, r) {
       return ['return', pa(e, t, r)];
      })(e, t, r);
     case 'NewExpression':
     case 'ImportExpression':
     case 'OptionalCallExpression':
     case 'CallExpression':
      return ei(e, t, r);
     case 'ObjectExpression':
     case 'ObjectPattern':
     case 'RecordExpression':
      return to(e, t, r);
     case 'Property':
      return ge(s) ? aa(e, t, r) : na(e, t, r);
     case 'ObjectMethod':
      return aa(e, t, r);
     case 'Decorator':
      return ['@', r('expression')];
     case 'ArrayExpression':
     case 'ArrayPattern':
     case 'TupleExpression':
      return Hi(e, t, r);
     case 'SequenceExpression': {
      let { parent: t } = e;
      if ('ExpressionStatement' === t.type || 'ForStatement' === t.type) {
       let t = [];
       return (
        e.each(({ isFirst: e }) => {
         e ? t.push(r()) : t.push(',', Ht([rr, r()]));
        }, 'expressions'),
        Vt(t)
       );
      }
      return Vt(or([',', rr], e.map(r, 'expressions')));
     }
     case 'ThisExpression':
      return 'this';
     case 'Super':
      return 'super';
     case 'Directive':
      return [r('value'), i];
     case 'UnaryExpression':
      return a.push(s.operator), /[a-z]$/.test(s.operator) && a.push(' '), at(s.argument) ? a.push(Vt(['(', Ht([nr, r('argument')]), nr, ')'])) : a.push(r('argument')), a;
     case 'UpdateExpression':
      return [s.prefix ? s.operator : '', r('argument'), s.prefix ? '' : s.operator];
     case 'ConditionalExpression':
      return uo(e, t, r, n);
     case 'VariableDeclaration': {
      let t,
       n = e.map(r, 'declarations'),
       o = e.parent,
       u = 'ForStatement' === o.type || 'ForInStatement' === o.type || 'ForOfStatement' === o.type,
       l = s.declarations.some((e) => e.init);
      return 1 !== n.length || at(s.declarations[0]) ? n.length > 0 && (t = Ht(n[0])) : (t = n[0]), (a = [Li(e), s.kind, t ? [' ', t] : '', Ht(n.slice(1).map((e) => [',', l && !u ? sr : rr, e]))]), (u && o.body !== s) || a.push(i), Vt(a);
     }
     case 'WithStatement':
      return Vt(['with (', r('object'), ')', qi(s.body, r('body'))]);
     case 'IfStatement': {
      let n = qi(s.consequent, r('consequent')),
       i = Vt(['if (', Vt([Ht([nr, r('test')]), nr]), ')', n]);
      if ((a.push(i), s.alternate)) {
       let n = at(s.consequent, st.Trailing | st.Line) || Le(s),
        i = 'BlockStatement' === s.consequent.type && !n;
       a.push(i ? ' ' : sr), at(s, st.Dangling) && a.push(ys(e, t), n ? sr : ' '), a.push('else', Vt(qi(s.alternate, r('alternate'), 'IfStatement' === s.alternate.type)));
      }
      return a;
     }
     case 'ForStatement': {
      let n = qi(s.body, r('body')),
       i = ys(e, t),
       a = i ? [i, nr] : '';
      return s.init || s.test || s.update ? [a, Vt(['for (', Vt([Ht([nr, r('init'), ';', rr, r('test'), ';', rr, r('update')]), nr]), ')', n])] : [a, Vt(['for (;;)', n])];
     }
     case 'WhileStatement':
      return Vt(['while (', Vt([Ht([nr, r('test')]), nr]), ')', qi(s.body, r('body'))]);
     case 'ForInStatement':
      return Vt(['for (', r('left'), ' in ', r('right'), ')', qi(s.body, r('body'))]);
     case 'ForOfStatement':
      return Vt(['for', s.await ? ' await' : '', ' (', r('left'), ' of ', r('right'), ')', qi(s.body, r('body'))]);
     case 'DoWhileStatement':
      return (a = [Vt(['do', qi(s.body, r('body'))])]), 'BlockStatement' === s.body.type ? a.push(' ') : a.push(sr), a.push('while (', Vt([Ht([nr, r('test')]), nr]), ')', i), a;
     case 'DoExpression':
      return [s.async ? 'async ' : '', 'do ', r('body')];
     case 'BreakStatement':
     case 'ContinueStatement':
      return a.push('BreakStatement' === s.type ? 'break' : 'continue'), s.label && a.push(' ', r('label')), a.push(i), a;
     case 'LabeledStatement':
      return 'EmptyStatement' === s.body.type ? [r('label'), ':;'] : [r('label'), ': ', r('body')];
     case 'TryStatement':
      return ['try ', r('block'), s.handler ? [' ', r('handler')] : '', s.finalizer ? [' finally ', r('finalizer')] : ''];
     case 'CatchClause':
      if (s.param) {
       let e = at(s.param, (e) => !G(e) || (e.leading && I(t.originalText, U(e))) || (e.trailing && I(t.originalText, q(e), { backwards: !0 }))),
        n = r('param');
       return ['catch ', e ? ['(', Ht([nr, n]), nr, ') '] : ['(', n, ') '], r('body')];
      }
      return ['catch ', r('body')];
     case 'SwitchStatement':
      return [
       Vt(['switch (', Ht([nr, r('discriminant')]), nr, ')']),
       ' {',
       s.cases.length > 0
        ? Ht([
           sr,
           or(
            sr,
            e.map(({ node: e, isLast: n }) => [r(), !n && ut(e, t) ? sr : ''], 'cases'),
           ),
          ])
        : '',
       sr,
       '}',
      ];
     case 'SwitchCase': {
      s.test ? a.push('case ', r('test'), ':') : a.push('default:'), at(s, st.Dangling) && a.push(' ', ys(e, t));
      let n = s.consequent.filter((e) => 'EmptyStatement' !== e.type);
      if (n.length > 0) {
       let s = ya(e, t, r, 'consequent');
       a.push(1 === n.length && 'BlockStatement' === n[0].type ? [' ', s] : Ht([sr, s]));
      }
      return a;
     }
     case 'DebuggerStatement':
      return ['debugger', i];
     case 'ClassDeclaration':
     case 'ClassExpression':
      return wa(e, t, r);
     case 'ClassMethod':
     case 'ClassPrivateMethod':
     case 'MethodDefinition':
      return Na(e, t, r);
     case 'ClassProperty':
     case 'PropertyDefinition':
     case 'ClassPrivateProperty':
     case 'ClassAccessorProperty':
     case 'AccessorProperty':
      return Ba(e, t, r);
     case 'TemplateElement':
      return gr(s.value.raw);
     case 'TemplateLiteral':
      return On(e, r, t);
     case 'TaggedTemplateExpression':
      return (function (e) {
       let t = e('quasi');
       return ur(t.label && { tagged: !0, ...t.label }, [e('tag'), e('typeParameters'), Zt, t]);
      })(r);
     case 'PrivateIdentifier':
      return ['#', s.name];
     case 'PrivateName':
      return ['#', r('id')];
     case 'TopicReference':
      return '%';
     case 'ArgumentPlaceholder':
      return '?';
     case 'ModuleExpression':
      return ['module ', r('body')];
     default:
      throw new bs(s, 'ESTree');
    }
   }
   function po(e, t, r) {
    let { parent: n, node: s, key: i } = e,
     a = [r('expression')];
    switch (s.type) {
     case 'AsConstExpression':
      a.push(' as const');
      break;
     case 'AsExpression':
     case 'TSAsExpression':
      a.push(' as ', r('typeAnnotation'));
      break;
     case 'SatisfiesExpression':
     case 'TSSatisfiesExpression':
      a.push(' satisfies ', r('typeAnnotation'));
    }
    return ('callee' === i && we(n)) || ('object' === i && Ae(n)) ? Vt([Ht([nr, ...a]), nr]) : a;
   }
   function co(e, t, r) {
    let { node: n } = e,
     s = [Li(e), 'component'];
    n.id && s.push(' ', r('id')), s.push(r('typeParameters'));
    let i = (function (e, t, r) {
     let { node: n } = e,
      s = n.params;
     if ((n.rest && (s = [...s, n.rest]), 0 === s.length)) return ['(', ys(e, r, { filter: (e) => ')' === Fr(r.originalText, U(e)) }), ')'];
     let i = [];
     return (
      (function (e, t) {
       let { node: r } = e,
        n = 0,
        s = (e) => t(e, n++);
       e.each(s, 'params'), r.rest && e.call(s, 'rest');
      })(e, (e, a) => {
       let o = a === s.length - 1;
       o && n.rest && i.push('...'), i.push(t()), !o && (i.push(','), ut(s[a], r) ? i.push(sr, sr) : i.push(rr));
      }),
      ['(', Ht([nr, ...i]), Xt(Ue(r, 'all') && !ho(n, s) ? ',' : ''), nr, ')']
     );
    })(e, r, t);
    return n.rendersType ? s.push(Vt([i, ' ', r('rendersType')])) : s.push(Vt([i])), n.body && s.push(' ', r('body')), t.semi && 'DeclareComponent' === n.type && s.push(';'), s;
   }
   function ho(e, t) {
    var r;
    return e.rest || 'RestElement' === (null == (r = x(!1, t, -1)) ? void 0 : r.type);
   }
   function fo(e, t, r) {
    return to(e, r, t);
   }
   function mo(e, t) {
    let { node: r } = e,
     n = t('id');
    r.computed && (n = ['[', n, ']']);
    let s = '';
    return r.initializer && (s = t('initializer')), r.init && (s = t('init')), s ? [n, ' = ', s] : n;
   }
   function yo(e, t, r) {
    let { node: n } = e;
    return [Li(e), n.const ? 'const ' : '', 'enum ', t('id'), ' ', 'TSEnumDeclaration' === n.type ? fo(e, t, r) : t('body')];
   }
   function go(e) {
    var t;
    let { node: r } = e;
    return 'HookTypeAnnotation' === r.type && 'DeclareHook' === (null == (t = e.getParentNode(2)) ? void 0 : t.type);
   }
   function Do(e, t, r) {
    let { node: n } = e,
     s = [Li(e), 'interface'],
     i = [],
     a = [];
    'InterfaceTypeAnnotation' !== n.type && i.push(' ', r('id'), r('typeParameters'));
    let o = n.typeParameters && !at(n.typeParameters, st.Trailing | st.Line);
    return L(n.extends) && a.push(o ? Xt(' ', rr, { groupId: va(n.typeParameters) }) : rr, 'extends ', (1 === n.extends.length ? qe : Ht)(or([',', rr], e.map(r, 'extends')))), at(n.id, st.Trailing) || L(n.extends) ? (o ? s.push(Vt([...i, Ht(a)])) : s.push(Vt(Ht([...i, ...a])))) : s.push(...i, ...a), s.push(' ', r('body')), Vt(s);
   }
   function xo(e, t, r) {
    let { node: n } = e;
    if (X(n)) return n.type.slice(0, -14).toLowerCase();
    let s = t.semi ? ';' : '';
    switch (n.type) {
     case 'ComponentDeclaration':
     case 'DeclareComponent':
     case 'ComponentTypeAnnotation':
      return co(e, t, r);
     case 'ComponentParameter':
      return (function (e, t, r) {
       let { node: n } = e;
       return n.shorthand ? r('local') : [r('name'), ' as ', r('local')];
      })(e, 0, r);
     case 'ComponentTypeParameter':
      return (function (e, t, r) {
       let { node: n } = e,
        s = [];
       return n.name && s.push(r('name'), n.optional ? '?: ' : ': '), s.push(r('typeAnnotation')), s;
      })(e, 0, r);
     case 'HookDeclaration':
      return (function (e, t, r) {
       let { node: n } = e,
        s = ['hook'];
       n.id && s.push(' ', r('id'));
       let i = pi(e, r, t, !1, !0),
        a = la(e, r),
        o = hi(n, a);
       return s.push(Vt([o ? Vt(i) : i, a]), n.body ? ' ' : '', r('body')), s;
      })(e, t, r);
     case 'DeclareHook':
      return (function (e, t, r) {
       let { node: n } = e,
        s = [Li(e), 'hook'];
       return n.id && s.push(' ', r('id')), t.semi && s.push(';'), s;
      })(e, t, r);
     case 'HookTypeAnnotation':
      return (function (e, t, r) {
       let { node: n } = e,
        s = [];
       s.push(go(e) ? '' : 'hook ');
       let i = pi(e, r, t, !1, !0),
        a = [];
       return a.push(go(e) ? ': ' : ' => ', r('returnType')), hi(n, a) && (i = Vt(i)), s.push(i, a), Vt(s);
      })(e, t, r);
     case 'DeclareClass':
      return wa(e, t, r);
     case 'DeclareFunction':
      return [Li(e), 'function ', r('id'), r('predicate'), s];
     case 'DeclareModule':
      return ['declare module ', r('id'), ' ', r('body')];
     case 'DeclareModuleExports':
      return ['declare module.exports', wi(e, r), s];
     case 'DeclareNamespace':
      return ['declare namespace ', r('id'), ' ', r('body')];
     case 'DeclareVariable':
      return [Li(e), n.kind ?? 'var', ' ', r('id'), s];
     case 'DeclareExportDeclaration':
     case 'DeclareExportAllDeclaration':
      return Wa(e, t, r);
     case 'DeclareOpaqueType':
     case 'OpaqueType':
      return (function (e, t, r) {
       let n = t.semi ? ';' : '',
        { node: s } = e,
        i = [Li(e), 'opaque type ', r('id'), r('typeParameters')];
       return s.supertype && i.push(': ', r('supertype')), s.impltype && i.push(' = ', r('impltype')), i.push(n), i;
      })(e, t, r);
     case 'DeclareTypeAlias':
     case 'TypeAlias':
      return yi(e, t, r);
     case 'IntersectionTypeAnnotation':
      return gi(e, 0, r);
     case 'UnionTypeAnnotation':
      return Di(e, t, r);
     case 'ConditionalTypeAnnotation':
      return uo(e, t, r);
     case 'InferTypeAnnotation':
      return vi(0, 0, r);
     case 'FunctionTypeAnnotation':
      return xi(e, t, r);
     case 'TupleTypeAnnotation':
      return Hi(e, t, r);
     case 'TupleTypeLabeledElement':
      return Ti(e, 0, r);
     case 'TupleTypeSpreadElement':
      return Ci(e, 0, r);
     case 'GenericTypeAnnotation':
      return [r('id'), Ea(e, t, r, 'typeParameters')];
     case 'IndexedAccessType':
     case 'OptionalIndexedAccessType':
      return bi(e, 0, r);
     case 'TypeAnnotation':
      return Fi(e, 0, r);
     case 'TypeParameter':
      return Ta(e, 0, r);
     case 'TypeofTypeAnnotation':
      return Pi(e, r);
     case 'ExistsTypeAnnotation':
      return '*';
     case 'ArrayTypeAnnotation':
      return ki(r);
     case 'DeclareEnum':
     case 'EnumDeclaration':
      return yo(e, r, t);
     case 'EnumBooleanBody':
     case 'EnumNumberBody':
     case 'EnumBigIntBody':
     case 'EnumStringBody':
     case 'EnumSymbolBody':
      return (function (e, t, r) {
       let n,
        { node: s } = e;
       if ('EnumSymbolBody' === s.type || s.explicitType)
        switch (s.type) {
         case 'EnumBooleanBody':
          n = 'boolean';
          break;
         case 'EnumNumberBody':
          n = 'number';
          break;
         case 'EnumBigIntBody':
          n = 'bigint';
          break;
         case 'EnumStringBody':
          n = 'string';
          break;
         case 'EnumSymbolBody':
          n = 'symbol';
        }
       return [n ? `of ${n} ` : '', fo(e, t, r)];
      })(e, r, t);
     case 'EnumBooleanMember':
     case 'EnumNumberMember':
     case 'EnumBigIntMember':
     case 'EnumStringMember':
     case 'EnumDefaultedMember':
      return mo(e, r);
     case 'FunctionTypeParam': {
      let t = n.name ? r('name') : e.parent.this === n ? 'this' : '';
      return [t, Ni(e), t ? ': ' : '', r('typeAnnotation')];
     }
     case 'DeclareInterface':
     case 'InterfaceDeclaration':
     case 'InterfaceTypeAnnotation':
      return Do(e, 0, r);
     case 'ClassImplements':
     case 'InterfaceExtends':
      return [r('id'), r('typeParameters')];
     case 'NullableTypeAnnotation':
      return ['?', r('typeAnnotation')];
     case 'Variance': {
      let { kind: e } = n;
      return Gi.ok('plus' === e || 'minus' === e), 'plus' === e ? '+' : '-';
     }
     case 'KeyofTypeAnnotation':
      return ['keyof ', r('argument')];
     case 'ObjectTypeCallProperty':
      return [n.static ? 'static ' : '', r('value')];
     case 'ObjectTypeMappedTypeProperty':
      return (function (e, t, r) {
       let { node: n } = e;
       return Vt([n.variance ? r('variance') : '', '[', Ht([r('keyTparam'), ' in ', r('sourceType')]), ']', xa(n.optional), ': ', r('propType')]);
      })(e, 0, r);
     case 'ObjectTypeIndexer':
      return [n.static ? 'static ' : '', n.variance ? r('variance') : '', '[', r('id'), n.id ? ': ' : '', r('key'), ']: ', r('value')];
     case 'ObjectTypeProperty': {
      let s = '';
      return n.proto ? (s = 'proto ') : n.static && (s = 'static '), [s, 'init' !== n.kind ? n.kind + ' ' : '', n.variance ? r('variance') : '', ra(e, t, r), Ni(e), ge(n) ? '' : ': ', r('value')];
     }
     case 'ObjectTypeAnnotation':
      return to(e, t, r);
     case 'ObjectTypeInternalSlot':
      return [n.static ? 'static ' : '', '[[', r('id'), ']]', Ni(e), n.method ? '' : ': ', r('value')];
     case 'ObjectTypeSpreadProperty':
      return Ui(e, r);
     case 'QualifiedTypeofIdentifier':
     case 'QualifiedTypeIdentifier':
      return [r('qualification'), '.', r('id')];
     case 'NullLiteralTypeAnnotation':
      return 'null';
     case 'BooleanLiteralTypeAnnotation':
      return String(n.value);
     case 'StringLiteralTypeAnnotation':
      return gr(R(Re(n), t));
     case 'NumberLiteralTypeAnnotation':
      return Qi(n.raw ?? n.extra.raw);
     case 'BigIntLiteralTypeAnnotation':
      return Ua(n.raw ?? n.extra.raw);
     case 'TypeCastExpression':
      return ['(', r('expression'), wi(e, r), ')'];
     case 'TypePredicate':
      return Ii(e, r);
     case 'TypeOperator':
      return [n.operator, ' ', r('typeAnnotation')];
     case 'TypeParameterDeclaration':
     case 'TypeParameterInstantiation':
      return Ea(e, t, r, 'params');
     case 'InferredPredicate':
     case 'DeclaredPredicate':
      return ['predicate' !== e.key || 'DeclareFunction' === e.parent.type || e.parent.returnType ? ' ' : ': ', '%checks', ...('DeclaredPredicate' === n.type ? ['(', r('value'), ')'] : [])];
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
      return po(e, 0, r);
    }
   }
   function bo(e, t, r) {
    var n;
    let { node: s } = e;
    if (!s.type.startsWith('TS')) return;
    if (Q(s)) return s.type.slice(2, -7).toLowerCase();
    let i = t.semi ? ';' : '',
     a = [];
    switch (s.type) {
     case 'TSThisType':
      return 'this';
     case 'TSTypeAssertion': {
      let e = !(ie(s.expression) || ae(s.expression)),
       t = Vt(['<', Ht([nr, r('typeAnnotation')]), nr, '>']),
       n = [Xt('('), Ht([nr, r('expression')]), nr, Xt(')')];
      return e
       ? Kt([
          [t, r('expression')],
          [t, Vt(n, { shouldBreak: !0 })],
          [t, r('expression')],
         ])
       : Vt([t, r('expression')]);
     }
     case 'TSDeclareFunction':
      return ia(e, r, t);
     case 'TSExportAssignment':
      return ['export = ', r('expression'), i];
     case 'TSModuleBlock':
      return ga(e, t, r);
     case 'TSInterfaceBody':
     case 'TSTypeLiteral':
      return to(e, t, r);
     case 'TSTypeAliasDeclaration':
      return yi(e, t, r);
     case 'TSQualifiedName':
      return [r('left'), '.', r('right')];
     case 'TSAbstractMethodDefinition':
     case 'TSDeclareMethod':
      return Na(e, t, r);
     case 'TSAbstractAccessorProperty':
     case 'TSAbstractPropertyDefinition':
      return Ba(e, t, r);
     case 'TSInterfaceHeritage':
     case 'TSClassImplements':
     case 'TSExpressionWithTypeArguments':
     case 'TSInstantiationExpression':
      return [r('expression'), r('typeParameters')];
     case 'TSTemplateLiteralType':
      return On(e, r, t);
     case 'TSNamedTupleMember':
      return Ti(e, 0, r);
     case 'TSRestType':
      return Ci(e, 0, r);
     case 'TSOptionalType':
      return [r('typeAnnotation'), '?'];
     case 'TSInterfaceDeclaration':
      return Do(e, 0, r);
     case 'TSTypeParameterDeclaration':
     case 'TSTypeParameterInstantiation':
      return Ea(e, t, r, 'params');
     case 'TSTypeParameter':
      return Ta(e, 0, r);
     case 'TSAsExpression':
     case 'TSSatisfiesExpression':
      return po(e, 0, r);
     case 'TSArrayType':
      return ki(r);
     case 'TSPropertySignature':
      return [s.readonly ? 'readonly ' : '', ra(e, t, r), Ni(e), wi(e, r)];
     case 'TSParameterProperty':
      return [$i(s), s.static ? 'static ' : '', s.override ? 'override ' : '', s.readonly ? 'readonly ' : '', r('parameter')];
     case 'TSTypeQuery':
      return Pi(e, r);
     case 'TSIndexSignature': {
      let n = s.parameters.length > 1 ? Xt(Ue(t) ? ',' : '') : '',
       a = Vt([Ht([nr, or([', ', nr], e.map(r, 'parameters'))]), n, nr]),
       o = 'ClassBody' === e.parent.type && 'body' === e.key;
      return [o && s.static ? 'static ' : '', s.readonly ? 'readonly ' : '', '[', s.parameters ? a : '', ']', wi(e, r), o ? i : ''];
     }
     case 'TSTypePredicate':
      return Ii(e, r);
     case 'TSNonNullExpression':
      return [r('expression'), '!'];
     case 'TSImportType':
      return [s.isTypeOf ? 'typeof ' : '', 'import(', r('argument'), ')', s.qualifier ? ['.', r('qualifier')] : '', Ea(e, t, r, s.typeArguments ? 'typeArguments' : 'typeParameters')];
     case 'TSLiteralType':
      return r('literal');
     case 'TSIndexedAccessType':
      return bi(e, 0, r);
     case 'TSTypeOperator':
      return [s.operator, ' ', r('typeAnnotation')];
     case 'TSMappedType':
      return (function (e, t, r) {
       let { node: n } = e,
        s = kr(t.originalText, q(n), q(n.typeParameter));
       return Vt(['{', Ht([t.bracketSpacing ? rr : nr, Vt([r('typeParameter'), n.optional ? ba(n.optional, '?') : '', n.typeAnnotation ? ': ' : '', r('typeAnnotation')]), t.semi ? Xt(';') : '']), ys(e, t), t.bracketSpacing ? rr : nr, '}'], { shouldBreak: s });
      })(e, t, r);
     case 'TSMethodSignature': {
      let n = s.kind && 'method' !== s.kind ? `${s.kind} ` : '';
      a.push($i(s), n, s.computed ? '[' : '', r('key'), s.computed ? ']' : '', Ni(e));
      let i = pi(e, r, t, !1, !0),
       o = s.returnType ? 'returnType' : 'typeAnnotation',
       u = s[o],
       l = u ? wi(e, r, o) : '',
       p = hi(s, l);
      return a.push(p ? Vt(i) : i), u && a.push(Vt(l)), Vt(a);
     }
     case 'TSNamespaceExportDeclaration':
      return ['export as namespace ', r('id'), t.semi ? ';' : ''];
     case 'TSEnumDeclaration':
      return yo(e, r, t);
     case 'TSEnumMember':
      return mo(e, r);
     case 'TSImportEqualsDeclaration':
      return [s.isExport ? 'export ' : '', 'import ', Ga(s, !1), r('id'), ' = ', r('moduleReference'), t.semi ? ';' : ''];
     case 'TSExternalModuleReference':
      return ['require(', r('expression'), ')'];
     case 'TSModuleDeclaration': {
      let { parent: o } = e,
       u = 'TSModuleDeclaration' === o.type,
       l = 'TSModuleDeclaration' === (null == (n = s.body) ? void 0 : n.type);
      if (u) a.push('.');
      else if ((a.push(Li(e)), 'global' !== s.kind && !s.global)) {
       let e = s.kind ?? (le(s.id) || za(t, q(s), q(s.id)).trim().endsWith('module') ? 'module' : 'namespace');
       a.push(e, ' ');
      }
      return a.push(r('id')), l ? a.push(r('body')) : s.body ? a.push(' ', Vt(r('body'))) : a.push(i), a;
     }
     case 'TSConditionalType':
      return uo(e, t, r);
     case 'TSInferType':
      return vi(0, 0, r);
     case 'TSIntersectionType':
      return gi(e, 0, r);
     case 'TSUnionType':
      return Di(e, t, r);
     case 'TSFunctionType':
     case 'TSCallSignatureDeclaration':
     case 'TSConstructorType':
     case 'TSConstructSignatureDeclaration':
      return xi(e, t, r);
     case 'TSTupleType':
      return Hi(e, t, r);
     case 'TSTypeReference':
      return [r('typeName'), Ea(e, t, r, 'typeParameters')];
     case 'TSTypeAnnotation':
      return Fi(e, 0, r);
     case 'TSEmptyBodyFunctionExpression':
      return oa(e, t, r);
     case 'TSJSDocAllType':
      return '*';
     case 'TSJSDocUnknownType':
      return '?';
     case 'TSJSDocNullableType':
      return Ei(e, r, '?');
     case 'TSJSDocNonNullableType':
      return Ei(e, r, '!');
     default:
      throw new bs(s, 'TypeScript');
    }
   }
   var vo = K(['ClassMethod', 'ClassPrivateMethod', 'ClassProperty', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractAccessorProperty', 'PropertyDefinition', 'TSAbstractPropertyDefinition', 'ClassPrivateProperty', 'MethodDefinition', 'TSAbstractMethodDefinition', 'TSDeclareMethod']);
   var Eo = function (e, t, r, n) {
     var s;
     e.isRoot && (null == (s = t.__onHtmlBindingRoot) || s.call(t, e.node, t));
     let i = (function (e, t, r, n) {
      if (Bs(e)) return os(e, t);
      for (let s of [Rs, Is, xo, bo, lo]) {
       let i = s(e, t, r, n);
       if (void 0 !== i) return i;
      }
     })(e, t, r, n);
     if (!i) return '';
     let { node: a } = e;
     if (vo(a)) return i;
     let o = L(a.decorators),
      u = (function (e, t, r) {
       let { node: n, parent: s } = e,
        { decorators: i } = n;
       if (!L(i) || Vs(s) || Bs(e)) return '';
       let a = 'ClassExpression' === n.type || 'ClassDeclaration' === n.type || zs(n, t);
       return ['declaration' === e.key && se(s) ? sr : a ? er : '', or(rr, e.map(r, 'decorators')), rr];
      })(e, t, r),
      l = 'ClassExpression' === a.type;
     if (o && !l) return xr(i, (e) => Vt([u, e]));
     let p = hs(e, t),
      c = La(e, t);
     return u || p || c ? xr(i, (e) => [c ? ';' : '', p ? '(' : '', p && l && o ? [Ht([rr, u, e]), rr] : [u, e], p ? ')' : '']) : i;
    },
    Co = { avoidAstMutation: !0 },
    To = {};
   h(To, { getVisitorKeys: () => So, massageAstNode: () => ko, print: () => wo });
   var So = W({ JsonRoot: ['node'], ArrayExpression: ['elements'], ObjectExpression: ['properties'], ObjectProperty: ['key', 'value'], UnaryExpression: ['argument'], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ['quasis'], TemplateElement: [] });
   function wo(e, t, r) {
    let { node: n } = e;
    switch (n.type) {
     case 'JsonRoot':
      return [r('node'), sr];
     case 'ArrayExpression': {
      if (0 === n.elements.length) return '[]';
      let t = e.map(() => (null === e.node ? 'null' : r()), 'elements');
      return ['[', Ht([sr, or([',', sr], t)]), sr, ']'];
     }
     case 'ObjectExpression':
      return 0 === n.properties.length ? '{}' : ['{', Ht([sr, or([',', sr], e.map(r, 'properties'))]), sr, '}'];
     case 'ObjectProperty':
      return [r('key'), ': ', r('value')];
     case 'UnaryExpression':
      return ['+' === n.operator ? '' : n.operator, r('argument')];
     case 'NullLiteral':
      return 'null';
     case 'BooleanLiteral':
      return n.value ? 'true' : 'false';
     case 'StringLiteral':
      return JSON.stringify(n.value);
     case 'NumericLiteral':
      return Ao(e) ? JSON.stringify(String(n.value)) : JSON.stringify(n.value);
     case 'Identifier':
      return Ao(e) ? JSON.stringify(n.name) : n.name;
     case 'TemplateLiteral':
      return r(['quasis', 0]);
     case 'TemplateElement':
      return JSON.stringify(n.value.cooked);
     default:
      throw new bs(n, 'JSON');
    }
   }
   function Ao(e) {
    return 'key' === e.key && 'ObjectProperty' === e.parent.type;
   }
   var Fo = new Set(['start', 'end', 'extra', 'loc', 'comments', 'leadingComments', 'trailingComments', 'innerComments', 'errors', 'range', 'tokens']);
   function ko(e, t) {
    let { type: r } = e;
    if ('ObjectProperty' !== r) {
     if ('UnaryExpression' === r && '+' === e.operator) return t.argument;
     if ('ArrayExpression' !== r) return 'TemplateLiteral' === r ? { type: 'StringLiteral', value: e.quasis[0].value.cooked } : void 0;
     for (let [r, n] of e.elements.entries()) null === n && t.elements.splice(r, 0, { type: 'NullLiteral' });
    } else {
     let { key: r } = e;
     'Identifier' === r.type ? (t.key = { type: 'StringLiteral', value: r.name }) : 'NumericLiteral' === r.type && (t.key = { type: 'StringLiteral', value: String(r.value) });
    }
   }
   ko.ignoredProperties = Fo;
   var Po = {
     bracketSpacing: { category: 'Common', type: 'boolean', default: !0, description: 'Print spaces between brackets.', oppositeDescription: 'Do not print spaces between brackets.' },
     singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' },
     proseWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap prose.',
      choices: [
       { value: 'always', description: 'Wrap prose if it exceeds the print width.' },
       { value: 'never', description: 'Do not wrap prose.' },
       { value: 'preserve', description: 'Wrap prose as-is.' },
      ],
     },
     bracketSameLine: { category: 'Common', type: 'boolean', default: !1, description: 'Put > of opening tags on the last line instead of on a new line.' },
     singleAttributePerLine: { category: 'Common', type: 'boolean', default: !1, description: 'Enforce single attribute per line in HTML, Vue and JSX.' },
    },
    Io = 'JavaScript',
    No = {
     arrowParens: {
      category: Io,
      type: 'choice',
      default: 'always',
      description: 'Include parentheses around a sole arrow function parameter.',
      choices: [
       { value: 'always', description: 'Always include parens. Example: `(x) => x`' },
       { value: 'avoid', description: 'Omit parens when possible. Example: `x => x`' },
      ],
     },
     bracketSameLine: Po.bracketSameLine,
     bracketSpacing: Po.bracketSpacing,
     jsxBracketSameLine: { category: Io, type: 'boolean', description: 'Put > on the last line instead of at a new line.', deprecated: '2.4.0' },
     semi: { category: Io, type: 'boolean', default: !0, description: 'Print semicolons.', oppositeDescription: 'Do not print semicolons, except at the beginning of lines which may need them.' },
     experimentalTernaries: { category: Io, type: 'boolean', default: !1, description: 'Use curious ternaries, with the question mark after the condition.', oppositeDescription: 'Default behavior of ternaries; keep question marks on the same line as the consequent.' },
     singleQuote: Po.singleQuote,
     jsxSingleQuote: { category: Io, type: 'boolean', default: !1, description: 'Use single quotes in JSX.' },
     quoteProps: {
      category: Io,
      type: 'choice',
      default: 'as-needed',
      description: 'Change when properties in objects are quoted.',
      choices: [
       { value: 'as-needed', description: 'Only add quotes around object properties where required.' },
       { value: 'consistent', description: 'If at least one property in an object requires quotes, quote all properties.' },
       { value: 'preserve', description: 'Respect the input use of quotes in object properties.' },
      ],
     },
     trailingComma: {
      category: Io,
      type: 'choice',
      default: 'all',
      description: 'Print trailing commas wherever possible when multi-line.',
      choices: [
       { value: 'all', description: 'Trailing commas wherever possible (including function arguments).' },
       { value: 'es5', description: 'Trailing commas where valid in ES5 (objects, arrays, etc.)' },
       { value: 'none', description: 'No trailing commas.' },
      ],
     },
     singleAttributePerLine: Po.singleAttributePerLine,
    },
    Bo = { estree: g, 'estree-json': To },
    _o = [
     { linguistLanguageId: 183, name: 'JavaScript', type: 'programming', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', color: '#f1e05a', aliases: ['js', 'node'], extensions: ['.js', '._js', '.bones', '.cjs', '.es', '.es6', '.frag', '.gs', '.jake', '.javascript', '.jsb', '.jscad', '.jsfl', '.jslib', '.jsm', '.jspre', '.jss', '.mjs', '.njs', '.pac', '.sjs', '.ssjs', '.xsjs', '.xsjslib', '.wxs'], filenames: ['Jakefile'], interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell', 'zx'], parsers: ['babel', 'acorn', 'espree', 'meriyah', 'babel-flow', 'babel-ts', 'flow', 'typescript'], vscodeLanguageIds: ['javascript', 'mongo'] },
     { linguistLanguageId: 183, name: 'Flow', type: 'programming', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', color: '#f1e05a', aliases: [], extensions: ['.js.flow'], filenames: [], interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell'], parsers: ['flow', 'babel-flow'], vscodeLanguageIds: ['javascript'] },
     { linguistLanguageId: 183, name: 'JSX', type: 'programming', tmScope: 'source.js.jsx', aceMode: 'javascript', codemirrorMode: 'jsx', codemirrorMimeType: 'text/jsx', color: void 0, aliases: void 0, extensions: ['.jsx'], filenames: void 0, interpreters: void 0, parsers: ['babel', 'babel-flow', 'babel-ts', 'flow', 'typescript', 'espree', 'meriyah'], vscodeLanguageIds: ['javascriptreact'], group: 'JavaScript' },
     { linguistLanguageId: 378, name: 'TypeScript', type: 'programming', color: '#3178c6', aliases: ['ts'], interpreters: ['deno', 'ts-node'], extensions: ['.ts', '.cts', '.mts'], tmScope: 'source.ts', aceMode: 'typescript', codemirrorMode: 'javascript', codemirrorMimeType: 'application/typescript', parsers: ['typescript', 'babel-ts'], vscodeLanguageIds: ['typescript'] },
     { linguistLanguageId: 94901924, name: 'TSX', type: 'programming', color: '#3178c6', group: 'TypeScript', extensions: ['.tsx'], tmScope: 'source.tsx', aceMode: 'javascript', codemirrorMode: 'jsx', codemirrorMimeType: 'text/jsx', parsers: ['typescript', 'babel-ts'], vscodeLanguageIds: ['typescriptreact'] },
     { linguistLanguageId: 174, name: 'JSON.stringify', type: 'data', color: '#292929', tmScope: 'source.json', aceMode: 'json', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', aliases: ['geojson', 'jsonl', 'topojson'], extensions: ['.importmap'], filenames: ['package.json', 'package-lock.json', 'composer.json'], parsers: ['json-stringify'], vscodeLanguageIds: ['json'] },
     { linguistLanguageId: 174, name: 'JSON', type: 'data', color: '#292929', tmScope: 'source.json', aceMode: 'json', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', aliases: ['geojson', 'jsonl', 'topojson'], extensions: ['.json', '.4DForm', '.4DProject', '.avsc', '.geojson', '.gltf', '.har', '.ice', '.JSON-tmLanguage', '.mcmeta', '.tfstate', '.tfstate.backup', '.topojson', '.webapp', '.webmanifest', '.yy', '.yyp'], filenames: ['.all-contributorsrc', '.arcconfig', '.auto-changelog', '.c8rc', '.htmlhintrc', '.imgbotconfig', '.nycrc', '.tern-config', '.tern-project', '.watchmanconfig', 'Pipfile.lock', 'composer.lock', 'flake.lock', 'mcmod.info', '.babelrc', '.jscsrc', '.jshintrc', '.jslintrc', '.swcrc'], parsers: ['json'], vscodeLanguageIds: ['json'] },
     { linguistLanguageId: 423, name: 'JSON with Comments', type: 'data', color: '#292929', group: 'JSON', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', aliases: ['jsonc'], extensions: ['.jsonc', '.code-snippets', '.code-workspace', '.sublime-build', '.sublime-commands', '.sublime-completions', '.sublime-keymap', '.sublime-macro', '.sublime-menu', '.sublime-mousemap', '.sublime-project', '.sublime-settings', '.sublime-theme', '.sublime-workspace', '.sublime_metrics', '.sublime_session'], filenames: [], parsers: ['jsonc'], vscodeLanguageIds: ['jsonc'] },
     { linguistLanguageId: 175, name: 'JSON5', type: 'data', color: '#267CB9', extensions: ['.json5'], tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', parsers: ['json5'], vscodeLanguageIds: ['json5'] },
    ],
    Lo = y;
  },
  58243: (e, t, r) => {
   r.d(t, { ZP: () => ms });
   var n = Object.defineProperty,
    s = (e) => {
     throw TypeError(e);
    },
    i = (e, t) => {
     for (var r in t) n(e, r, { get: t[r], enumerable: !0 });
    },
    a = (e, t, r) => t.has(e) || s('Cannot ' + r),
    o = (e, t, r) => (a(e, t, 'read from private field'), r ? r.call(e) : t.get(e)),
    u = {};
   i(u, { languages: () => Ar, options: () => Pr, parsers: () => Ir, printers: () => fs });
   var l = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    p = 'string',
    c = 'array',
    h = 'cursor',
    d = 'indent',
    f = 'align',
    m = 'trim',
    y = 'group',
    g = 'fill',
    D = 'if-break',
    x = 'indent-if-break',
    b = 'line-suffix',
    v = 'line-suffix-boundary',
    E = 'line',
    C = 'label',
    T = 'break-parent',
    S = new Set([h, d, f, m, y, g, D, x, b, v, E, C, T]);
   var w = function (e) {
    if ('string' == typeof e) return p;
    if (Array.isArray(e)) return c;
    if (!e) return;
    let { type: t } = e;
    return S.has(t) ? t : void 0;
   };
   function A(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (w(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...S].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var F = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      super(A(e)), (this.doc = e);
     }
    },
    k = () => {},
    P = k,
    I = k;
   function N(e) {
    return P(e), { type: d, contents: e };
   }
   function B(e, t) {
    return P(t), { type: f, contents: t, n: e };
   }
   function _(e, t = {}) {
    return P(e), I(t.expandedStates, !0), { type: y, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function L(e) {
    return I(e), { type: g, parts: e };
   }
   function O(e, t = '', r = {}) {
    return P(e), '' !== t && P(t), { type: D, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   var M = { type: T },
    j = { type: E },
    R = { type: E, soft: !0 },
    q = [{ type: E, hard: !0 }, M],
    U = [{ type: E, hard: !0, literal: !0 }, M];
   function $(e, t) {
    P(e), I(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   var H = (e, t, r) => {
    if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
   };
   function z(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (w(e)) {
       case c:
        return t(e.map(n));
       case g:
        return t({ ...e, parts: e.parts.map(n) });
       case D:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case y: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case f:
       case d:
       case x:
       case C:
       case b:
        return t({ ...e, contents: n(e.contents) });
       case p:
       case h:
       case m:
       case v:
       case E:
       case T:
        return t(e);
       default:
        throw new F(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function V(e) {
    return z(e, (e) =>
     (function (e) {
      switch (w(e)) {
       case g:
        if (e.parts.every((e) => '' === e)) return '';
        break;
       case y:
        if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
        if (e.contents.type === y && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
        break;
       case f:
       case d:
       case x:
       case b:
        if (!e.contents) return '';
        break;
       case D:
        if (!e.flatContents && !e.breakContents) return '';
        break;
       case c: {
        let t = [];
        for (let r of e) {
         if (!r) continue;
         let [e, ...n] = Array.isArray(r) ? r : [r];
         'string' == typeof e && 'string' == typeof H(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...n);
        }
        return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
       }
       case p:
       case h:
       case m:
       case v:
       case E:
       case C:
       case T:
        break;
       default:
        throw new F(e);
      }
      return e;
     })(e),
    );
   }
   function W(e, t = U) {
    return z(e, (e) => ('string' == typeof e ? $(t, e.split('\n')) : e));
   }
   var J = "'";
   var K = function (e, t) {
    let r = !0 === t || t === J ? J : '"',
     n = r === J ? '"' : J,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var G;
   G = new WeakMap();
   var X = class {
     constructor(e) {
      ((e, t, r) => {
       t.has(e) ? s('Cannot add the same private member more than once') : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, G),
       ((e, t, r, n) => {
        a(e, t, 'write to private field'), n ? n.call(e, r) : t.set(e, r);
       })(this, G, new Set(e));
     }
     getLeadingWhitespaceCount(e) {
      let t = o(this, G),
       r = 0;
      for (let n = 0; n < e.length && t.has(e.charAt(n)); n++) r++;
      return r;
     }
     getTrailingWhitespaceCount(e) {
      let t = o(this, G),
       r = 0;
      for (let n = e.length - 1; n >= 0 && t.has(e.charAt(n)); n--) r++;
      return r;
     }
     getLeadingWhitespace(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(0, t);
     }
     getTrailingWhitespace(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(e.length - t);
     }
     hasLeadingWhitespace(e) {
      return o(this, G).has(e.charAt(0));
     }
     hasTrailingWhitespace(e) {
      return o(this, G).has(H(!1, e, -1));
     }
     trimStart(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(t);
     }
     trimEnd(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(0, e.length - t);
     }
     trim(e) {
      return this.trimEnd(this.trimStart(e));
     }
     split(e, t = !1) {
      let r = `[${(function (e) {
        if ('string' != typeof e) throw new TypeError('Expected a string');
        return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
       })([...o(this, G)].join(''))}]+`,
       n = new RegExp(t ? `(${r})` : r);
      return e.split(n);
     }
     hasWhitespaceCharacter(e) {
      let t = o(this, G);
      return Array.prototype.some.call(e, (e) => t.has(e));
     }
     hasNonWhitespaceCharacter(e) {
      let t = o(this, G);
      return Array.prototype.some.call(e, (e) => !t.has(e));
     }
     isWhitespaceOnly(e) {
      let t = o(this, G);
      return Array.prototype.every.call(e, (e) => t.has(e));
     }
    },
    Y = new X(['\t', '\n', '\f', '\r', ' ']),
    Q = class extends Error {
     name = 'UnexpectedNodeError';
     constructor(e, t, r = 'type') {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    };
   var Z = function (e) {
     return 'front-matter' === (null == e ? void 0 : e.type);
    },
    ee = new Set(['sourceSpan', 'startSourceSpan', 'endSourceSpan', 'nameSpan', 'valueSpan', 'keySpan', 'tagDefinition', 'tokens', 'valueTokens', 'switchValueSourceSpan', 'expSourceSpan', 'valueSourceSpan']),
    te = new Set(['if', 'else if', 'for', 'switch', 'case']);
   function re(e, t) {
    var r;
    if ('text' === e.type || 'comment' === e.type || Z(e) || 'yaml' === e.type || 'toml' === e.type) return null;
    if (('attribute' === e.type && delete t.value, 'docType' === e.type && delete t.value, 'angularControlFlowBlock' === e.type && null != (r = e.parameters) && r.children)) for (let n of t.parameters.children) te.has(e.name) ? delete n.expression : (n.expression = n.expression.trim());
    'angularIcuExpression' === e.type && (t.switchValue = e.switchValue.trim());
   }
   re.ignoredProperties = ee;
   var ne = re;
   var se = async function (e, t) {
    if ('yaml' === e.language) {
     let r = e.value.trim(),
      n = r ? await t(r, { parser: 'yaml' }) : '';
     return (function (e) {
      return B({ type: 'root' }, e);
     })([e.startDelimiter, e.explicitLanguage, q, n, n ? q : '', e.endDelimiter]);
    }
   };
   function ie(e, t = !0) {
    return [N([R, e]), t ? R : ''];
   }
   function ae(e, t) {
    let r = 'NGRoot' === e.type ? ('NGMicrosyntax' === e.node.type && 1 === e.node.body.length && 'NGMicrosyntaxExpression' === e.node.body[0].type ? e.node.body[0].expression : e.node) : 'JsExpressionRoot' === e.type ? e.node : e;
    return r && ('ObjectExpression' === r.type || 'ArrayExpression' === r.type || (('__vue_expression' === t.parser || '__vue_ts_expression' === t.parser) && ('TemplateLiteral' === r.type || 'StringLiteral' === r.type)));
   }
   async function oe(e, t, r, n) {
    r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
    let s = !0;
    n &&
     (r.__onHtmlBindingRoot = (e, t) => {
      s = n(e, t);
     });
    let i = await t(e, r, t);
    return s ? _(i) : ie(i);
   }
   var ue = function (e, t, r, n) {
     let { node: s } = r,
      i = n.originalText.slice(s.sourceSpan.start.offset, s.sourceSpan.end.offset);
     return /^\s*$/.test(i) ? '' : oe(i, e, { parser: '__ng_directive', __isInHtmlAttribute: !1 }, ae);
    },
    le = (e) => String(e).split(/[/\\]/).pop();
   function pe(e, t) {
    if (!t) return;
    let r = le(t).toLowerCase();
    return e.find(({ filenames: e }) => (null == e ? void 0 : e.some((e) => e.toLowerCase() === r))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.some((e) => r.endsWith(e))));
   }
   var ce = function (e, t) {
     let r = e.plugins.flatMap((e) => e.languages ?? []),
      n =
       (function (e, t) {
        if (t) return e.find(({ name: e }) => e.toLowerCase() === t) ?? e.find(({ aliases: e }) => (null == e ? void 0 : e.includes(t))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.includes(`.${t}`)));
       })(r, t.language) ??
       pe(r, t.physicalFile) ??
       pe(r, t.file) ??
       void t.physicalFile;
     return null == n ? void 0 : n.parsers[0];
    },
    he = 'inline',
    de = { area: 'none', base: 'none', basefont: 'none', datalist: 'none', head: 'none', link: 'none', meta: 'none', noembed: 'none', noframes: 'none', param: 'block', rp: 'none', script: 'block', style: 'none', template: 'inline', title: 'none', html: 'block', body: 'block', address: 'block', blockquote: 'block', center: 'block', dialog: 'block', div: 'block', figure: 'block', figcaption: 'block', footer: 'block', form: 'block', header: 'block', hr: 'block', legend: 'block', listing: 'block', main: 'block', p: 'block', plaintext: 'block', pre: 'block', search: 'block', xmp: 'block', slot: 'contents', ruby: 'ruby', rt: 'ruby-text', article: 'block', aside: 'block', h1: 'block', h2: 'block', h3: 'block', h4: 'block', h5: 'block', h6: 'block', hgroup: 'block', nav: 'block', section: 'block', dir: 'block', dd: 'block', dl: 'block', dt: 'block', menu: 'block', ol: 'block', ul: 'block', li: 'list-item', table: 'table', caption: 'table-caption', colgroup: 'table-column-group', col: 'table-column', thead: 'table-header-group', tbody: 'table-row-group', tfoot: 'table-footer-group', tr: 'table-row', td: 'table-cell', th: 'table-cell', input: 'inline-block', button: 'inline-block', fieldset: 'block', marquee: 'inline-block', source: 'block', track: 'block', details: 'block', summary: 'block', meter: 'inline-block', progress: 'inline-block', object: 'inline-block', video: 'inline-block', audio: 'inline-block', select: 'inline-block', option: 'block', optgroup: 'block' },
    fe = 'normal',
    me = { listing: 'pre', plaintext: 'pre', pre: 'pre', xmp: 'pre', nobr: 'nowrap', table: 'initial', textarea: 'pre-wrap' };
   var ye = function (e) {
     return 'element' === e.type && !e.hasExplicitNamespace && !['html', 'svg'].includes(e.namespace);
    },
    ge = (e) => ((e) => l(!1, e, /^[\t\f\r ]*\n/g, ''))(Y.trimEnd(e)),
    De = (e) => {
     let t = e,
      r = Y.getLeadingWhitespace(t);
     r && (t = t.slice(r.length));
     let n = Y.getTrailingWhitespace(t);
     return n && (t = t.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: t };
    };
   function xe(e, t) {
    return !!(('ieConditionalComment' === e.type && e.lastChild && !e.lastChild.isSelfClosing && !e.lastChild.endSourceSpan) || ('ieConditionalComment' === e.type && !e.complete) || (Re(e) && e.children.some((e) => 'text' !== e.type && 'interpolation' !== e.type)) || (Je(e, t) && !Ee(e) && 'interpolation' !== e.type));
   }
   function be(e) {
    return (
     !('attribute' === e.type || !e.parent || !e.prev) &&
     (function (e) {
      return 'comment' === e.type && 'prettier-ignore' === e.value.trim();
     })(e.prev)
    );
   }
   function ve(e) {
    return 'text' === e.type || 'comment' === e.type;
   }
   function Ee(e) {
    return 'element' === e.type && ('script' === e.fullName || 'style' === e.fullName || 'svg:style' === e.fullName || 'svg:script' === e.fullName || (ye(e) && ('script' === e.name || 'style' === e.name)));
   }
   function Ce(e) {
    return qe(e).startsWith('pre');
   }
   function Te(e, t) {
    var r, n;
    let s = !(
     Z(e) ||
     'angularControlFlowBlock' === e.type ||
     ((('text' !== e.type && 'interpolation' !== e.type) || !e.prev || ('text' !== e.prev.type && 'interpolation' !== e.prev.type)) &&
      (!e.parent ||
       'none' === e.parent.cssDisplay ||
       (!Re(e.parent) &&
        ((!e.prev &&
         ('root' === e.parent.type ||
          (Re(e) && e.parent) ||
          Ee(e.parent) ||
          Ve(e.parent, t) ||
          !(function (e) {
           return !je(e) && 'inline-block' !== e;
          })(e.parent.cssDisplay))) ||
         (e.prev &&
          !(function (e) {
           return !je(e);
          })(e.prev.cssDisplay))))))
    );
    return s && !e.prev && null != (n = null == (r = e.parent) ? void 0 : r.tagDefinition) && n.ignoreFirstLf ? 'interpolation' === e.type : s;
   }
   function Se(e, t) {
    return (
     !Z(e) &&
     'angularControlFlowBlock' !== e.type &&
     (!(('text' !== e.type && 'interpolation' !== e.type) || !e.next || ('text' !== e.next.type && 'interpolation' !== e.next.type)) ||
      (!(!e.parent || 'none' === e.parent.cssDisplay) &&
       (!!Re(e.parent) ||
        !(
         (!e.next &&
          ('root' === e.parent.type ||
           (Re(e) && e.parent) ||
           Ee(e.parent) ||
           Ve(e.parent, t) ||
           !(function (e) {
            return !je(e) && 'inline-block' !== e;
           })(e.parent.cssDisplay))) ||
         (e.next &&
          !(function (e) {
           return !je(e);
          })(e.next.cssDisplay))
        ))))
    );
   }
   function we(e) {
    return (
     (function (e) {
      return !je(e) && 'inline-block' !== e;
     })(e.cssDisplay) && !Ee(e)
    );
   }
   function Ae(e) {
    return Z(e) || (e.next && e.sourceSpan.end && e.sourceSpan.end.line + 1 < e.next.sourceSpan.start.line);
   }
   function Fe(e) {
    return (
     ke(e) ||
     ('element' === e.type &&
      e.children.length > 0 &&
      (['body', 'script', 'style'].includes(e.name) ||
       e.children.some((e) =>
        (function (e) {
         var t;
         return null == (t = e.children) ? void 0 : t.some((e) => 'text' !== e.type);
        })(e),
       ))) ||
     (e.firstChild && e.firstChild === e.lastChild && 'text' !== e.firstChild.type && Ne(e.firstChild) && (!e.lastChild.isTrailingSpaceSensitive || Be(e.lastChild)))
    );
   }
   function ke(e) {
    return 'element' === e.type && e.children.length > 0 && (['html', 'head', 'ul', 'ol', 'select'].includes(e.name) || (e.cssDisplay.startsWith('table') && 'table-cell' !== e.cssDisplay));
   }
   function Pe(e) {
    return (
     _e(e) ||
     (e.prev &&
      (function (e) {
       return _e(e) || ('element' === e.type && 'br' === e.fullName) || Ie(e);
      })(e.prev)) ||
     Ie(e)
    );
   }
   function Ie(e) {
    return Ne(e) && Be(e);
   }
   function Ne(e) {
    return e.hasLeadingSpaces && (e.prev ? e.prev.sourceSpan.end.line < e.sourceSpan.start.line : 'root' === e.parent.type || e.parent.startSourceSpan.end.line < e.sourceSpan.start.line);
   }
   function Be(e) {
    return e.hasTrailingSpaces && (e.next ? e.next.sourceSpan.start.line > e.sourceSpan.end.line : 'root' === e.parent.type || (e.parent.endSourceSpan && e.parent.endSourceSpan.start.line > e.sourceSpan.end.line));
   }
   function _e(e) {
    switch (e.type) {
     case 'ieConditionalComment':
     case 'comment':
     case 'directive':
      return !0;
     case 'element':
      return ['script', 'select'].includes(e.name);
    }
    return !1;
   }
   function Le(e) {
    return e.lastChild ? Le(e.lastChild) : e;
   }
   function Oe(e) {
    if (e)
     switch (e) {
      case 'module':
      case 'text/javascript':
      case 'text/babel':
      case 'application/javascript':
       return 'babel';
      case 'application/x-typescript':
       return 'typescript';
      case 'text/markdown':
       return 'markdown';
      case 'text/html':
       return 'html';
      case 'text/x-handlebars-template':
       return 'glimmer';
      default:
       if (e.endsWith('json') || e.endsWith('importmap') || 'speculationrules' === e) return 'json';
     }
   }
   function Me(e, t) {
    return (
     (function (e, t) {
      let { name: r, attrMap: n } = e;
      if ('script' !== r || Object.prototype.hasOwnProperty.call(n, 'src')) return;
      let { type: s, lang: i } = e.attrMap;
      return i || s ? ce(t, { language: i }) ?? Oe(s) : 'babel';
     })(e, t) ??
     (function (e, t) {
      if ('style' !== e.name) return;
      let { lang: r } = e.attrMap;
      return r ? ce(t, { language: r }) : 'css';
     })(e, t) ??
     (function (e, t) {
      if (!Je(e, t)) return;
      let { attrMap: r } = e;
      if (Object.prototype.hasOwnProperty.call(r, 'src')) return;
      let { type: n, lang: s } = r;
      return ce(t, { language: s }) ?? Oe(n);
     })(e, t)
    );
   }
   function je(e) {
    return 'block' === e || 'list-item' === e || e.startsWith('table');
   }
   function Re(e) {
    return qe(e).startsWith('pre');
   }
   function qe(e) {
    return ('element' === e.type && (!e.namespace || ye(e)) && me[e.name]) || fe;
   }
   function Ue(
    e,
    t = (function (e) {
     let t = Number.POSITIVE_INFINITY;
     for (let r of e.split('\n')) {
      if (0 === r.length) continue;
      let e = Y.getLeadingWhitespaceCount(r);
      if (0 === e) return 0;
      r.length !== e && e < t && (t = e);
     }
     return t === Number.POSITIVE_INFINITY ? 0 : t;
    })(e),
   ) {
    return 0 === t
     ? e
     : e
        .split('\n')
        .map((e) => e.slice(t))
        .join('\n');
   }
   function $e(e) {
    return l(!1, l(!1, e, '&apos;', "'"), '&quot;', '"');
   }
   function He(e) {
    return $e(e.value);
   }
   var ze = new Set(['template', 'style', 'script']);
   function Ve(e, t) {
    return We(e, t) && !ze.has(e.fullName);
   }
   function We(e, t) {
    return 'vue' === t.parser && 'element' === e.type && 'root' === e.parent.type && 'html' !== e.fullName.toLowerCase();
   }
   function Je(e, t) {
    return We(e, t) && (Ve(e, t) || (e.attrMap.lang && 'html' !== e.attrMap.lang));
   }
   function Ke(e, t = e.value) {
    return e.parent.isWhitespaceSensitive ? (e.parent.isIndentationSensitive ? W(t) : W(Ue(ge(t)), q)) : $(j, Y.split(t));
   }
   function Ge(e, t) {
    return We(e, t) && 'script' === e.name;
   }
   var Xe = /{{(.+?)}}/s;
   function Ye({ parser: e }) {
    return (t, r, n) => oe(He(n.node), t, { parser: e }, ae);
   }
   var Qe = Ye({ parser: '__ng_action' }),
    Ze = Ye({ parser: '__ng_binding' }),
    et = Ye({ parser: '__ng_directive' });
   var tt = function (e, t) {
    if ('angular' !== t.parser) return;
    let { node: r } = e,
     n = r.fullName;
    if ((n.startsWith('(') && n.endsWith(')')) || n.startsWith('on-')) return Qe;
    if ((n.startsWith('[') && n.endsWith(']')) || /^bind(?:on)?-/.test(n) || /^ng-(?:if|show|hide|class|style)$/.test(n)) return Ze;
    if (n.startsWith('*')) return et;
    let s = He(r);
    return /^i18n(?:-.+)?$/.test(n)
     ? () => ie(L(Ke(r, s.trim())), !s.includes('@@'))
     : Xe.test(s)
       ? (e) =>
          (async function (e, t) {
           let r = [];
           for (let [n, s] of e.split(Xe).entries())
            if (n % 2 == 0) r.push(W(s));
            else
             try {
              r.push(_(['{{', N([j, await oe(s, t, { parser: '__ng_interpolation', __isInHtmlInterpolation: !0 })]), j, '}}']));
             } catch {
              r.push('{{', W(s), '}}');
             }
           return r;
          })(s, e)
       : void 0;
   };
   var rt = function (e, t) {
    let { node: r } = e,
     n = He(r);
    if ('class' === r.fullName && !t.parentParser && !n.includes('{{')) return () => n.trim().split(/\s+/).join(' ');
   };
   function nt(e) {
    return '\t' === e || '\n' === e || '\f' === e || '\r' === e || ' ' === e;
   }
   var st = /^[ \t\n\r\u000c]+/,
    it = /^[, \t\n\r\u000c]+/,
    at = /^[^ \t\n\r\u000c]+/,
    ot = /[,]+$/,
    ut = /^\d+$/,
    lt = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
   var pt = function (e) {
    let t,
     r,
     n,
     s,
     i,
     a,
     o = e.length,
     u = 0;
    function l(t) {
     let r,
      n = t.exec(e.substring(u));
     if (n) return ([r] = n), (u += r.length), r;
    }
    let p = [];
    for (;;) {
     if ((l(it), u >= o)) {
      if (0 === p.length) throw new Error('Must contain one or more image candidate strings.');
      return p;
     }
     (a = u), (t = l(at)), (r = []), ',' === t.slice(-1) ? ((t = t.replace(ot, '')), h()) : c();
    }
    function c() {
     for (l(st), n = '', s = 'in descriptor'; ; ) {
      if (((i = e.charAt(u)), 'in descriptor' === s))
       if (nt(i)) n && (r.push(n), (n = ''), (s = 'after descriptor'));
       else {
        if (',' === i) return (u += 1), n && r.push(n), void h();
        if ('(' === i) (n += i), (s = 'in parens');
        else {
         if ('' === i) return n && r.push(n), void h();
         n += i;
        }
       }
      else if ('in parens' === s)
       if (')' === i) (n += i), (s = 'in descriptor');
       else {
        if ('' === i) return r.push(n), void h();
        n += i;
       }
      else if ('after descriptor' === s && !nt(i)) {
       if ('' === i) return void h();
       (s = 'in descriptor'), (u -= 1);
      }
      u += 1;
     }
    }
    function h() {
     let n,
      s,
      i,
      o,
      u,
      l,
      c,
      h,
      d,
      f = !1,
      m = {};
     for (o = 0; o < r.length; o++) (u = r[o]), (l = u[u.length - 1]), (c = u.substring(0, u.length - 1)), (h = parseInt(c, 10)), (d = parseFloat(c)), ut.test(c) && 'w' === l ? ((n || s) && (f = !0), 0 === h ? (f = !0) : (n = h)) : lt.test(c) && 'x' === l ? ((n || s || i) && (f = !0), d < 0 ? (f = !0) : (s = d)) : ut.test(c) && 'h' === l ? ((i || s) && (f = !0), 0 === h ? (f = !0) : (i = h)) : (f = !0);
     if (f) throw new Error(`Invalid srcset descriptor found in "${e}" at "${u}".`);
     (m.source = { value: t, startOffset: a }), n && (m.width = { value: n }), s && (m.density = { value: s }), i && (m.height = { value: i }), p.push(m);
    }
   };
   var ct = { width: 'w', height: 'h', density: 'x' },
    ht = Object.keys(ct);
   var dt = function (e) {
    if ('srcset' === e.node.fullName && ('img' === e.parent.fullName || 'source' === e.parent.fullName))
     return () =>
      (function (e) {
       let t = pt(e),
        r = ht.filter((e) => t.some((t) => Object.prototype.hasOwnProperty.call(t, e)));
       if (r.length > 1) throw new Error('Mixed descriptor in srcset is not supported');
       let [n] = r,
        s = ct[n],
        i = t.map((e) => e.source.value),
        a = Math.max(...i.map((e) => e.length)),
        o = t.map((e) => (e[n] ? String(e[n].value) : '')),
        u = o.map((e) => {
         let t = e.indexOf('.');
         return -1 === t ? e.length : t;
        }),
        l = Math.max(...u);
       return ie(
        $(
         [',', j],
         i.map((e, t) => {
          let r = [e],
           n = o[t];
          if (n) {
           let i = a - e.length + 1,
            o = l - u[t],
            p = ' '.repeat(i + o);
           r.push(O(p, ' '), n + s);
          }
          return r;
         }),
        ),
       );
      })(He(e.node));
   };
   function ft(e, t) {
    let { node: r } = e,
     n = He(e.node).trim();
    if ('style' === r.fullName && !t.parentParser && !n.includes('{{')) return async (e) => ie(await e(n, { parser: 'css', __isHTMLStyleAttribute: !0 }));
   }
   var mt = new WeakMap();
   var yt = function (e, t) {
    let { root: r } = e;
    return (
     mt.has(r) ||
      mt.set(
       r,
       r.children.some((e) => Ge(e, t) && ['ts', 'typescript'].includes(e.attrMap.lang)),
      ),
     mt.get(r)
    );
   };
   function gt(e, t, r) {
    let { node: n } = r;
    return oe(`type T<${He(n)}> = any`, e, { parser: 'babel-ts', __isEmbeddedTypescriptGenericParameters: !0 }, ae);
   }
   async function Dt(e, t, r, n) {
    let s = He(r.node),
     {
      left: i,
      operator: a,
      right: o,
     } = (function (e) {
      let t = /(.*?)\s+(in|of)\s+(.*)/s,
       r = /,([^,\]}]*)(?:,([^,\]}]*))?$/,
       n = /^\(|\)$/g,
       s = e.match(t);
      if (!s) return;
      let i = {};
      if (((i.for = s[3].trim()), !i.for)) return;
      let a = l(!1, s[1].trim(), n, ''),
       o = a.match(r);
      o ? ((i.alias = a.replace(r, '')), (i.iterator1 = o[1].trim()), o[2] && (i.iterator2 = o[2].trim())) : (i.alias = a);
      let u = [i.alias, i.iterator1, i.iterator2];
      if (!u.some((e, t) => !e && (0 === t || u.slice(t + 1).some(Boolean)))) return { left: u.filter(Boolean).join(','), operator: s[2], right: i.for };
     })(s),
     u = yt(r, n);
    return [_(await oe(`function _(${i}) {}`, e, { parser: u ? 'babel-ts' : 'babel', __isVueForBindingLeft: !0 })), ' ', a, ' ', await oe(o, e, { parser: u ? '__ts_expression' : '__js_expression' })];
   }
   function xt(e, t, { parseWithTs: r }) {
    return oe(e, t, { parser: r ? '__ts_expression' : '__js_expression' }, ae);
   }
   var bt = function (e, t) {
    if ('vue' !== t.parser) return;
    let { node: r } = e,
     n = r.fullName;
    if ('v-for' === n) return Dt;
    if ('generic' === n && Ge(r.parent, t)) return gt;
    let s = He(r),
     i = yt(e, t);
    return (function (e) {
     let t = e.fullName;
     return '#' === t.charAt(0) || 'slot-scope' === t || 'v-slot' === t || t.startsWith('v-slot:');
    })(r) ||
     (function (e, t) {
      let r = e.parent;
      if (!We(r, t)) return !1;
      let n = r.fullName,
       s = e.fullName;
      return ('script' === n && 'setup' === s) || ('style' === n && 'vars' === s);
     })(r, t)
     ? (e) =>
        (function (e, t, { parseWithTs: r }) {
         return oe(`function _(${e}) {}`, t, { parser: r ? 'babel-ts' : 'babel', __isVueBindings: !0 });
        })(s, e, { parseWithTs: i })
     : n.startsWith('@') || n.startsWith('v-on:')
       ? (e) =>
          (function (e, t, { parseWithTs: r }) {
           return (function (e) {
            let t = e.trim();
            return /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/.test(t) || /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$_a-z][\w$]*])*$/i.test(t);
           })(e)
            ? xt(e, t, { parseWithTs: r })
            : oe(e, t, { parser: r ? '__vue_ts_event_binding' : '__vue_event_binding' }, ae);
          })(s, e, { parseWithTs: i })
       : n.startsWith(':') || n.startsWith('v-bind:')
         ? (e) =>
            (function (e, t, { parseWithTs: r }) {
             return oe(e, t, { parser: r ? '__vue_ts_expression' : '__vue_expression' }, ae);
            })(s, e, { parseWithTs: i })
         : n.startsWith('v-')
           ? (e) => xt(s, e, { parseWithTs: i })
           : void 0;
   };
   function vt(e) {
    return async (t, r, n, s) => {
     let i = await e(t, r, n, s);
     if (i) return (i = z(i, (e) => ('string' == typeof e ? l(!1, e, '"', '&quot;') : e))), [n.node.rawName, '="', _(i), '"'];
    };
   }
   var Et = function (e, t) {
     let { node: r } = e;
     if (r.value) {
      if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(t.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || ('lwc' === t.parser && r.value.startsWith('{') && r.value.endsWith('}'))) return [r.rawName, '=', r.value];
      for (let r of [dt, ft, rt, bt, tt]) {
       let n = r(e, t);
       if (n) return vt(n);
      }
     }
    },
    Ct = new Proxy(() => {}, { get: () => Ct }),
    Tt = Ct;
   var St = function (e) {
    return Array.isArray(e) && e.length > 0;
   };
   function wt(e) {
    return e.sourceSpan.start.offset;
   }
   function At(e) {
    return e.sourceSpan.end.offset;
   }
   function Ft(e, t) {
    return [e.isSelfClosing ? '' : kt(e, t), Pt(e, t)];
   }
   function kt(e, t) {
    return e.lastChild && jt(e.lastChild) ? '' : [It(e, t), Bt(e, t)];
   }
   function Pt(e, t) {
    return (e.next ? Ot(e.next) : Mt(e.parent)) ? '' : [_t(e, t), Nt(e, t)];
   }
   function It(e, t) {
    return Mt(e) ? _t(e.lastChild, t) : '';
   }
   function Nt(e, t) {
    return jt(e) ? Bt(e.parent, t) : Rt(e) ? Wt(e.next) : '';
   }
   function Bt(e, t) {
    if ((Tt(!e.isSelfClosing), Lt(e, t))) return '';
    switch (e.type) {
     case 'ieConditionalComment':
      return '<!';
     case 'element':
      if (e.hasHtmComponentClosingTag) return '<//';
     default:
      return `</${e.rawName}`;
    }
   }
   function _t(e, t) {
    if (Lt(e, t)) return '';
    switch (e.type) {
     case 'ieConditionalComment':
     case 'ieConditionalEndComment':
      return '[endif]--\x3e';
     case 'ieConditionalStartComment':
      return ']>\x3c!--\x3e';
     case 'interpolation':
      return '}}';
     case 'angularIcuExpression':
      return '}';
     case 'element':
      if (e.isSelfClosing) return '/>';
     default:
      return '>';
    }
   }
   function Lt(e, t) {
    return !e.isSelfClosing && !e.endSourceSpan && (be(e) || xe(e.parent, t));
   }
   function Ot(e) {
    return e.prev && 'docType' !== e.prev.type && 'angularControlFlowBlock' !== e.type && !ve(e.prev) && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
   }
   function Mt(e) {
    var t;
    return (null == (t = e.lastChild) ? void 0 : t.isTrailingSpaceSensitive) && !e.lastChild.hasTrailingSpaces && !ve(Le(e.lastChild)) && !Re(e);
   }
   function jt(e) {
    return !e.next && !e.hasTrailingSpaces && e.isTrailingSpaceSensitive && ve(Le(e));
   }
   function Rt(e) {
    return e.next && !ve(e.next) && ve(e) && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces;
   }
   function qt(e) {
    return !e.prev && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
   }
   function Ut(e, t, r) {
    var n;
    let { node: s } = e;
    if (!St(s.attrs)) return s.isSelfClosing ? ' ' : '';
    let i =
      'comment' === (null == (n = s.prev) ? void 0 : n.type) &&
      (function (e) {
       let t = e.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
       return !!t && (!t[1] || t[1].split(/\s+/));
      })(s.prev.value),
     a = 'boolean' == typeof i ? () => i : Array.isArray(i) ? (e) => i.includes(e.rawName) : () => !1,
     o = e.map(({ node: e }) => (a(e) ? W(t.originalText.slice(wt(e), At(e))) : r()), 'attrs'),
     u = 'element' === s.type && 'script' === s.fullName && 1 === s.attrs.length && 'src' === s.attrs[0].fullName && 0 === s.children.length,
     l = t.singleAttributePerLine && s.attrs.length > 1 && !We(s, t) ? q : j,
     p = [N([u ? ' ' : j, $(l, o)])];
    return (s.firstChild && qt(s.firstChild)) || (s.isSelfClosing && Mt(s.parent)) || u ? p.push(s.isSelfClosing ? ' ' : '') : p.push(t.bracketSameLine ? (s.isSelfClosing ? ' ' : '') : s.isSelfClosing ? j : R), p;
   }
   function $t(e) {
    return e.firstChild && qt(e.firstChild) ? '' : Jt(e);
   }
   function Ht(e, t, r) {
    let { node: n } = e;
    return [zt(n, t), Ut(e, t, r), n.isSelfClosing ? '' : $t(n)];
   }
   function zt(e, t) {
    return e.prev && Rt(e.prev) ? '' : [Vt(e, t), Wt(e)];
   }
   function Vt(e, t) {
    return qt(e) ? Jt(e.parent) : Ot(e) ? _t(e.prev, t) : '';
   }
   function Wt(e) {
    switch (e.type) {
     case 'ieConditionalComment':
     case 'ieConditionalStartComment':
      return `\x3c!--[if ${e.condition}`;
     case 'ieConditionalEndComment':
      return '\x3c!--<!';
     case 'interpolation':
      return '{{';
     case 'docType':
      return 'html' === e.value ? '<!doctype' : '<!DOCTYPE';
     case 'angularIcuExpression':
      return '{';
     case 'element':
      if (e.condition) return `\x3c!--[if ${e.condition}]>\x3c!--\x3e<${e.rawName}`;
     default:
      return `<${e.rawName}`;
    }
   }
   function Jt(e) {
    switch ((Tt(!e.isSelfClosing), e.type)) {
     case 'ieConditionalComment':
      return ']>';
     case 'element':
      if (e.condition) return '>\x3c!--<![endif]--\x3e';
     default:
      return '>';
    }
   }
   var Kt = function (e, t) {
     if (!e.endSourceSpan) return '';
     let r = e.startSourceSpan.end.offset;
     e.firstChild && qt(e.firstChild) && (r -= Jt(e).length);
     let n = e.endSourceSpan.start.offset;
     return e.lastChild && jt(e.lastChild) ? (n += Bt(e, t).length) : Mt(e) && (n -= _t(e.lastChild, t).length), t.originalText.slice(r, n);
    },
    Gt = new Set(['if', 'else if', 'for', 'switch', 'case']);
   var Xt = function (e, t) {
     let { node: r } = e;
     switch (r.type) {
      case 'element':
       if (Ee(r) || 'interpolation' === r.type) return;
       if (!r.isSelfClosing && Je(r, t)) {
        let n = Me(r, t);
        return n
         ? async (s, i) => {
            let a = Kt(r, t),
             o = /^\s*$/.test(a),
             u = '';
            return o || ((u = await s(ge(a), { parser: n, __embeddedInHtml: !0 })), (o = '' === u)), [Vt(r, t), _(Ht(e, t, i)), o ? '' : q, u, o ? '' : q, Ft(r, t), Nt(r, t)];
           }
         : void 0;
       }
       break;
      case 'text':
       if (Ee(r.parent)) {
        let e = Me(r.parent, t);
        if (e)
         return async (n) => {
          let s = 'markdown' === e ? Ue(r.value.replace(/^[^\S\n]*\n/, '')) : r.value,
           i = { parser: e, __embeddedInHtml: !0 };
          if ('html' === t.parser && 'babel' === e) {
           let e = 'script',
            { attrMap: t } = r.parent;
           t && ('module' === t.type || ('text/babel' === t.type && 'module' === t['data-type'])) && (e = 'module'), (i.__babelSourceType = e);
          }
          return [M, Vt(r, t), await n(s, i), Nt(r, t)];
         };
       } else if ('interpolation' === r.parent.type)
        return async (n) => {
         let s = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
         return 'angular' === t.parser ? (s.parser = '__ng_interpolation') : 'vue' === t.parser ? (s.parser = yt(e, t) ? '__vue_ts_expression' : '__vue_expression') : (s.parser = '__js_expression'), [N([j, await n(r.value, s)]), r.parent.next && Ot(r.parent.next) ? ' ' : j];
        };
       break;
      case 'attribute':
       return Et(e, t);
      case 'front-matter':
       return (e) => se(r, e);
      case 'angularControlFlowBlockParameters':
       return Gt.has(e.parent.name) ? ue : void 0;
     }
    },
    Yt = null;
   function Qt(e) {
    if (null !== Yt && (Yt.property, 1)) {
     let e = Yt;
     return (Yt = Qt.prototype = null), e;
    }
    return (Yt = Qt.prototype = e ?? Object.create(null)), new Qt();
   }
   for (let ys = 0; ys <= 10; ys++) Qt();
   var Zt = function (e, t = 'type') {
     return (
      (function (e) {
       Qt(e);
      })(e),
      function (r) {
       let n = r[t],
        s = e[n];
       if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
       return s;
      }
     );
    },
    er = Zt({ 'front-matter': [], root: ['children'], element: ['attrs', 'children'], ieConditionalComment: ['children'], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ['children'], text: ['children'], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ['children', 'parameters'], angularControlFlowBlockParameters: ['children'], angularControlFlowBlockParameter: [], angularIcuExpression: ['cases'], angularIcuCase: ['expression'] });
   function tr(e) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e);
   }
   var rr = new Map([
    ['if', new Set(['else if', 'else'])],
    ['else if', new Set(['else if', 'else'])],
    ['for', new Set(['empty'])],
    ['defer', new Set(['placeholder', 'error', 'loading'])],
    ['placeholder', new Set(['placeholder', 'error', 'loading'])],
    ['error', new Set(['placeholder', 'error', 'loading'])],
    ['loading', new Set(['placeholder', 'error', 'loading'])],
   ]);
   function nr(e) {
    let t = At(e);
    return 'element' === e.type && !e.endSourceSpan && St(e.children) ? Math.max(t, nr(H(!1, e.children, -1))) : t;
   }
   function sr(e, t, r) {
    let n = e.node;
    if (be(n)) {
     let e = nr(n);
     return [Vt(n, t), W(Y.trimEnd(t.originalText.slice(wt(n) + (n.prev && Rt(n.prev) ? Wt(n).length : 0), e - (n.next && Ot(n.next) ? _t(n, t).length : 0)))), Nt(n, t)];
    }
    return r();
   }
   function ir(e, t) {
    return ve(e) && ve(t) ? (e.isTrailingSpaceSensitive ? (e.hasTrailingSpaces ? (Pe(t) ? q : j) : '') : Pe(t) ? q : R) : (Rt(e) && (be(t) || t.firstChild || t.isSelfClosing || ('element' === t.type && t.attrs.length > 0))) || ('element' === e.type && e.isSelfClosing && Ot(t)) ? '' : !t.isLeadingSpaceSensitive || Pe(t) || (Ot(t) && e.lastChild && jt(e.lastChild) && e.lastChild.lastChild && jt(e.lastChild.lastChild)) ? q : t.hasLeadingSpaces ? j : R;
   }
   function ar(e, t, r) {
    let { node: n } = e;
    if (ke(n))
     return [
      M,
      ...e.map((e) => {
       let n = e.node,
        s = n.prev ? ir(n.prev, n) : '';
       return [s ? [s, Ae(n.prev) ? q : ''] : '', sr(e, t, r)];
      }, 'children'),
     ];
    let s = n.children.map(() => Symbol(''));
    return e.map((e, n) => {
     let i = e.node;
     if (ve(i)) {
      if (i.prev && ve(i.prev)) {
       let n = ir(i.prev, i);
       if (n) return Ae(i.prev) ? [q, q, sr(e, t, r)] : [n, sr(e, t, r)];
      }
      return sr(e, t, r);
     }
     let a = [],
      o = [],
      u = [],
      l = [],
      p = i.prev ? ir(i.prev, i) : '',
      c = i.next ? ir(i, i.next) : '';
     return p && (Ae(i.prev) ? a.push(q, q) : p === q ? a.push(q) : ve(i.prev) ? o.push(p) : o.push(O('', R, { groupId: s[n - 1] }))), c && (Ae(i) ? ve(i.next) && l.push(q, q) : c === q ? ve(i.next) && l.push(q) : u.push(c)), [...a, _([...o, _([sr(e, t, r), ...u], { id: s[n] })]), ...l];
    }, 'children');
   }
   function or(e, t, r) {
    let { node: n } = e,
     s = [];
    (function (e) {
     let { previous: t } = e;
     return 'angularControlFlowBlock' === (null == t ? void 0 : t.type) && !be(t) && !ur(t);
    })(e) && s.push('} '),
     s.push('@', n.name),
     n.parameters && s.push(' (', _(r('parameters')), ')'),
     s.push(' {');
    let i = ur(n);
    return n.children.length > 0 ? ((n.firstChild.hasLeadingSpaces = !0), (n.lastChild.hasTrailingSpaces = !0), s.push(N([q, ar(e, t, r)])), i && s.push(q, '}')) : i && s.push('}'), _(s, { shouldBreak: !0 });
   }
   function ur(e) {
    var t, r;
    return !('angularControlFlowBlock' === (null == (t = e.next) ? void 0 : t.type) && null != (r = rr.get(e.name)) && r.has(e.next.name));
   }
   function lr(e, t, r) {
    let { node: n } = e;
    if (xe(n, t)) return [Vt(n, t), _(Ht(e, t, r)), W(Kt(n, t)), ...Ft(n, t), Nt(n, t)];
    let s = 1 === n.children.length && ('interpolation' === n.firstChild.type || 'angularIcuExpression' === n.firstChild.type) && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces,
     i = Symbol('element-attr-group-id'),
     a = (s) => _([_(Ht(e, t, r), { id: i }), s, Ft(n, t)]);
    return 0 === n.children.length
     ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? j : '')
     : a([
        Fe(n) ? M : '',
        ((o = [
         s
          ? O(R, '', { groupId: i })
          : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive
            ? j
            : 'text' === n.firstChild.type && n.isWhitespaceSensitive && n.isIndentationSensitive
              ? (function (e) {
                 return B(Number.NEGATIVE_INFINITY, e);
                })(R)
              : R,
         ar(e, t, r),
        ]),
        s
         ? (function (e, t) {
            return P(e), { type: x, contents: e, groupId: t.groupId, negate: t.negate };
           })(o, { groupId: i })
         : (!Ee(n) && !Ve(n, t)) || 'root' !== n.parent.type || 'vue' !== t.parser || t.vueIndentScriptAndStyle
           ? N(o)
           : o),
        (n.next ? Ot(n.next) : Mt(n.parent)) ? (n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? ' ' : '') : s ? O(R, '', { groupId: i }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? j : ('comment' === n.lastChild.type || ('text' === n.lastChild.type && n.isWhitespaceSensitive && n.isIndentationSensitive)) && new RegExp(`\\n[\\t ]{${t.tabWidth * (e.ancestors.length - 1)}}$`).test(n.lastChild.value) ? '' : R,
       ]);
    var o;
   }
   function pr(e) {
    return (e >= 9 && e <= 32) || 160 == e;
   }
   function cr(e) {
    return 48 <= e && e <= 57;
   }
   function hr(e) {
    return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
   }
   function dr(e) {
    return 10 === e || 13 === e;
   }
   function fr(e) {
    return 48 <= e && e <= 55;
   }
   function mr(e) {
    return 39 === e || 34 === e || 96 === e;
   }
   var yr = /-+([a-z0-9])/g;
   var gr,
    Dr,
    xr = class e {
     constructor(e, t, r, n) {
      (this.file = e), (this.offset = t), (this.line = r), (this.col = n);
     }
     toString() {
      return null != this.offset ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
     }
     moveBy(t) {
      let r = this.file.content,
       n = r.length,
       s = this.offset,
       i = this.line,
       a = this.col;
      for (; s > 0 && t < 0; )
       if ((s--, t++, 10 == r.charCodeAt(s))) {
        i--;
        let e = r.substring(0, s - 1).lastIndexOf(String.fromCharCode(10));
        a = e > 0 ? s - e : s;
       } else a--;
      for (; s < n && t > 0; ) {
       let e = r.charCodeAt(s);
       s++, t--, 10 == e ? (i++, (a = 0)) : a++;
      }
      return new e(this.file, s, i, a);
     }
     getContext(e, t) {
      let r = this.file.content,
       n = this.offset;
      if (null != n) {
       n > r.length - 1 && (n = r.length - 1);
       let s = n,
        i = 0,
        a = 0;
       for (; i < e && n > 0 && (n--, i++, '\n' != r[n] || ++a != t); );
       for (i = 0, a = 0; i < e && s < r.length - 1 && (s++, i++, '\n' != r[s] || ++a != t); );
       return { before: r.substring(n, this.offset), after: r.substring(this.offset, s + 1) };
      }
      return null;
     }
    },
    br = class {
     constructor(e, t) {
      (this.content = e), (this.url = t);
     }
    },
    vr = class {
     constructor(e, t, r = e, n = null) {
      (this.start = e), (this.end = t), (this.fullStart = r), (this.details = n);
     }
     toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
     }
    };
   ((Dr = gr || (gr = {}))[(Dr.WARNING = 0)] = 'WARNING'), (Dr[(Dr.ERROR = 1)] = 'ERROR');
   var Er = class {
     constructor(e, t, r = gr.ERROR) {
      (this.span = e), (this.msg = t), (this.level = r);
     }
     contextualMessage() {
      let e = this.span.start.getContext(100, 3);
      return e ? `${this.msg} ("${e.before}[${gr[this.level]} ->]${e.after}")` : this.msg;
     }
     toString() {
      let e = this.span.details ? `, ${this.span.details}` : '';
      return `${this.contextualMessage()}: ${this.span.start}${e}`;
     }
    },
    Cr = [
     function (e) {
      e.walk((e) => {
       if ('element' === e.type && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && 'text' === e.children[0].type && '\n' === e.children[0].value[0]) {
        let t = e.children[0];
        1 === t.value.length ? e.removeChild(t) : (t.value = t.value.slice(1));
       }
      });
     },
     function (e) {
      let t = (e) => {
       var t, r;
       return 'element' === e.type && 'ieConditionalStartComment' === (null == (t = e.prev) ? void 0 : t.type) && e.prev.sourceSpan.end.offset === e.startSourceSpan.start.offset && 'ieConditionalEndComment' === (null == (r = e.firstChild) ? void 0 : r.type) && e.firstChild.sourceSpan.start.offset === e.startSourceSpan.end.offset;
      };
      e.walk((e) => {
       if (e.children)
        for (let r = 0; r < e.children.length; r++) {
         let n = e.children[r];
         if (!t(n)) continue;
         let s = n.prev,
          i = n.firstChild;
         e.removeChild(s), r--;
         let a = new vr(s.sourceSpan.start, i.sourceSpan.end),
          o = new vr(a.start, n.sourceSpan.end);
         (n.condition = s.condition), (n.sourceSpan = o), (n.startSourceSpan = a), n.removeChild(i);
        }
      });
     },
     function (e) {
      return (function (e, t, r) {
       e.walk((e) => {
        if (e.children)
         for (let n = 0; n < e.children.length; n++) {
          let s = e.children[n];
          if ('text' !== s.type && !t(s)) continue;
          'text' !== s.type && ((s.type = 'text'), (s.value = r(s)));
          let i = s.prev;
          !i || 'text' !== i.type || ((i.value += s.value), (i.sourceSpan = new vr(i.sourceSpan.start, s.sourceSpan.end)), e.removeChild(s), n--);
         }
       });
      })(
       e,
       (e) => 'cdata' === e.type,
       (e) => `<![CDATA[${e.value}]]>`,
      );
     },
     function (e, t) {
      if ('html' === t.parser) return;
      let r = /{{(.+?)}}/s;
      e.walk((e) => {
       if (
        (function (e) {
         return e.children && !Ee(e);
        })(e)
       )
        for (let t of e.children) {
         if ('text' !== t.type) continue;
         let n = t.sourceSpan.start,
          s = null,
          i = t.value.split(r);
         for (let r = 0; r < i.length; r++, n = s) {
          let a = i[r];
          r % 2 != 0 ? ((s = n.moveBy(a.length + 4)), e.insertChildBefore(t, { type: 'interpolation', sourceSpan: new vr(n, s), children: 0 === a.length ? [] : [{ type: 'text', value: a, sourceSpan: new vr(n.moveBy(2), s.moveBy(-2)) }] })) : ((s = n.moveBy(a.length)), a.length > 0 && e.insertChildBefore(t, { type: 'text', value: a, sourceSpan: new vr(n, s) }));
         }
         e.removeChild(t);
        }
      });
     },
     function (e) {
      e.walk((e) => {
       if (!e.children) return;
       if (0 === e.children.length || (1 === e.children.length && 'text' === e.children[0].type && 0 === Y.trim(e.children[0].value).length)) return (e.hasDanglingSpaces = e.children.length > 0), void (e.children = []);
       let t = (function (e) {
         return Ee(e) || 'interpolation' === e.type || Ce(e);
        })(e),
        r = Ce(e);
       if (!t)
        for (let n = 0; n < e.children.length; n++) {
         let t = e.children[n];
         if ('text' !== t.type) continue;
         let { leadingWhitespace: r, text: s, trailingWhitespace: i } = De(t.value),
          a = t.prev,
          o = t.next;
         s ? ((t.value = s), (t.sourceSpan = new vr(t.sourceSpan.start.moveBy(r.length), t.sourceSpan.end.moveBy(-i.length))), r && (a && (a.hasTrailingSpaces = !0), (t.hasLeadingSpaces = !0)), i && ((t.hasTrailingSpaces = !0), o && (o.hasLeadingSpaces = !0))) : (e.removeChild(t), n--, (r || i) && (a && (a.hasTrailingSpaces = !0), o && (o.hasLeadingSpaces = !0)));
        }
       (e.isWhitespaceSensitive = t), (e.isIndentationSensitive = r);
      });
     },
     function (e, t) {
      e.walk((e) => {
       e.cssDisplay = (function (e, t) {
        var r;
        if (We(e, t)) return 'block';
        if ('comment' === (null == (r = e.prev) ? void 0 : r.type)) {
         let t = e.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
         if (t) return t[1];
        }
        let n = !1;
        if ('element' === e.type && 'svg' === e.namespace) {
         if (
          !(function (e, t) {
           let r = e;
           for (; r; ) {
            if (t(r)) return !0;
            r = r.parent;
           }
           return !1;
          })(e, (e) => 'svg:foreignObject' === e.fullName)
         )
          return 'svg' === e.name ? 'inline-block' : 'block';
         n = !0;
        }
        switch (t.htmlWhitespaceSensitivity) {
         case 'strict':
          return 'inline';
         case 'ignore':
          return 'block';
         default:
          return ('element' === e.type && (!e.namespace || n || ye(e)) && de[e.name]) || he;
        }
       })(e, t);
      });
     },
     function (e) {
      e.walk((e) => {
       e.isSelfClosing = !e.children || ('element' === e.type && (e.tagDefinition.isVoid || (e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end)));
      });
     },
     function (e, t) {
      e.walk((e) => {
       'element' === e.type && (e.hasHtmComponentClosingTag = e.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t.originalText.slice(e.endSourceSpan.start.offset, e.endSourceSpan.end.offset)));
      });
     },
     function (e, t) {
      e.walk((e) => {
       let { children: r } = e;
       if (r) {
        if (0 === r.length) return void (e.isDanglingSpaceSensitive = we(e));
        for (let e of r) (e.isLeadingSpaceSensitive = Te(e, t)), (e.isTrailingSpaceSensitive = Se(e, t));
        for (let e = 0; e < r.length; e++) {
         let t = r[e];
         (t.isLeadingSpaceSensitive = (0 === e || t.prev.isTrailingSpaceSensitive) && t.isLeadingSpaceSensitive), (t.isTrailingSpaceSensitive = (e === r.length - 1 || t.next.isLeadingSpaceSensitive) && t.isTrailingSpaceSensitive);
        }
       }
      });
     },
     function (e) {
      let t = (e) => {
       var t, r;
       return 'element' === e.type && 0 === e.attrs.length && 1 === e.children.length && 'text' === e.firstChild.type && !Y.hasWhitespaceCharacter(e.children[0].value) && !e.firstChild.hasLeadingSpaces && !e.firstChild.hasTrailingSpaces && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces && 'text' === (null == (t = e.prev) ? void 0 : t.type) && 'text' === (null == (r = e.next) ? void 0 : r.type);
      };
      e.walk((e) => {
       if (e.children)
        for (let r = 0; r < e.children.length; r++) {
         let n = e.children[r];
         if (!t(n)) continue;
         let s = n.prev,
          i = n.next;
         (s.value += `<${n.rawName}>` + n.firstChild.value + `</${n.rawName}>` + i.value), (s.sourceSpan = new vr(s.sourceSpan.start, i.sourceSpan.end)), (s.isTrailingSpaceSensitive = i.isTrailingSpaceSensitive), (s.hasTrailingSpaces = i.hasTrailingSpaces), e.removeChild(n), r--, e.removeChild(i);
        }
      });
     },
    ];
   var Tr = function (e, t) {
    for (let r of Cr) r(e, t);
    return e;
   };
   var Sr = {
     preprocess: Tr,
     print: function (e, t, r) {
      let { node: n } = e;
      switch (n.type) {
       case 'front-matter':
        return W(n.raw);
       case 'root':
        return t.__onHtmlRoot && t.__onHtmlRoot(n), [_(ar(e, t, r)), q];
       case 'element':
       case 'ieConditionalComment':
        return lr(e, t, r);
       case 'angularControlFlowBlock':
        return or(e, t, r);
       case 'angularControlFlowBlockParameters':
        return (function (e, t, r) {
         return [N([R, $([';', j], e.map(r, 'children'))]), R];
        })(e, 0, r);
       case 'angularControlFlowBlockParameter':
        return Y.trim(n.expression);
       case 'angularIcuExpression':
        return (function (e, t, r) {
         let { node: n } = e;
         return [zt(n, t), _([n.switchValue.trim(), ', ', n.clause, n.cases.length > 0 ? [',', N([j, $(j, e.map(r, 'cases'))])] : '', R]), Pt(n, t)];
        })(e, t, r);
       case 'angularIcuCase':
        return (function (e, t, r) {
         let { node: n } = e;
         return [n.value, ' {', _([N([R, e.map(({ node: e }) => ('text' !== e.type || Y.trim(e.value) ? r() : ''), 'expression')]), R]), '}'];
        })(e, 0, r);
       case 'ieConditionalStartComment':
       case 'ieConditionalEndComment':
        return [zt(n), Pt(n)];
       case 'interpolation':
        return [zt(n, t), ...e.map(r, 'children'), Pt(n, t)];
       case 'text': {
        if ('interpolation' === n.parent.type) {
         let e = /\n[^\S\n]*$/,
          t = e.test(n.value);
         return [W(t ? n.value.replace(e, '') : n.value), t ? q : ''];
        }
        let e = V([Vt(n, t), ...Ke(n), Nt(n, t)]);
        return Array.isArray(e) ? L(e) : e;
       }
       case 'docType':
        return [_([zt(n, t), ' ', l(!1, n.value.replace(/^html\b/i, 'html'), /\s+/g, ' ')]), Pt(n, t)];
       case 'comment':
        return [Vt(n, t), W(t.originalText.slice(wt(n), At(n))), Nt(n, t)];
       case 'attribute': {
        if (null === n.value) return n.rawName;
        let e = $e(n.value),
         t = K(e, '"');
        return [n.rawName, '=', t, W('"' === t ? l(!1, e, '"', '&quot;') : l(!1, e, "'", '&apos;')), t];
       }
       default:
        throw new Q(n, 'HTML');
      }
     },
     insertPragma: function (e) {
      return '\x3c!-- @format --\x3e\n\n' + e;
     },
     massageAstNode: ne,
     embed: Xt,
     getVisitorKeys: er,
    },
    wr = Sr,
    Ar = [
     { linguistLanguageId: 146, name: 'Angular', type: 'markup', tmScope: 'text.html.basic', aceMode: 'html', codemirrorMode: 'htmlmixed', codemirrorMimeType: 'text/html', color: '#e34c26', aliases: ['xhtml'], extensions: ['.component.html'], parsers: ['angular'], vscodeLanguageIds: ['html'], filenames: [] },
     { linguistLanguageId: 146, name: 'HTML', type: 'markup', tmScope: 'text.html.basic', aceMode: 'html', codemirrorMode: 'htmlmixed', codemirrorMimeType: 'text/html', color: '#e34c26', aliases: ['xhtml'], extensions: ['.html', '.hta', '.htm', '.html.hl', '.inc', '.xht', '.xhtml', '.mjml'], parsers: ['html'], vscodeLanguageIds: ['html'] },
     { linguistLanguageId: 146, name: 'Lightning Web Components', type: 'markup', tmScope: 'text.html.basic', aceMode: 'html', codemirrorMode: 'htmlmixed', codemirrorMimeType: 'text/html', color: '#e34c26', aliases: ['xhtml'], extensions: [], parsers: ['lwc'], vscodeLanguageIds: ['html'], filenames: [] },
     { linguistLanguageId: 391, name: 'Vue', type: 'markup', color: '#41b883', extensions: ['.vue'], tmScope: 'text.html.vue', aceMode: 'html', parsers: ['vue'], vscodeLanguageIds: ['vue'] },
    ],
    Fr = {
     bracketSpacing: { category: 'Common', type: 'boolean', default: !0, description: 'Print spaces between brackets.', oppositeDescription: 'Do not print spaces between brackets.' },
     singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' },
     proseWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap prose.',
      choices: [
       { value: 'always', description: 'Wrap prose if it exceeds the print width.' },
       { value: 'never', description: 'Do not wrap prose.' },
       { value: 'preserve', description: 'Wrap prose as-is.' },
      ],
     },
     bracketSameLine: { category: 'Common', type: 'boolean', default: !1, description: 'Put > of opening tags on the last line instead of on a new line.' },
     singleAttributePerLine: { category: 'Common', type: 'boolean', default: !1, description: 'Enforce single attribute per line in HTML, Vue and JSX.' },
    },
    kr = 'HTML',
    Pr = {
     bracketSameLine: Fr.bracketSameLine,
     htmlWhitespaceSensitivity: {
      category: kr,
      type: 'choice',
      default: 'css',
      description: 'How to handle whitespaces in HTML.',
      choices: [
       { value: 'css', description: 'Respect the default value of CSS display property.' },
       { value: 'strict', description: 'Whitespaces are considered sensitive.' },
       { value: 'ignore', description: 'Whitespaces are considered insensitive.' },
      ],
     },
     singleAttributePerLine: Fr.singleAttributePerLine,
     vueIndentScriptAndStyle: { category: kr, type: 'boolean', default: !1, description: 'Indent script and style tags in Vue files.' },
    },
    Ir = {};
   i(Ir, { angular: () => cs, html: () => ps, lwc: () => ds, vue: () => hs });
   var Nr, Br;
   !(function (e) {
    (e[(e.Emulated = 0)] = 'Emulated'), (e[(e.None = 2)] = 'None'), (e[(e.ShadowDom = 3)] = 'ShadowDom');
   })(Nr || (Nr = {})),
    (function (e) {
     (e[(e.OnPush = 0)] = 'OnPush'), (e[(e.Default = 1)] = 'Default');
    })(Br || (Br = {}));
   var _r,
    Lr,
    Or,
    Mr,
    jr = 'custom-elements',
    Rr = 'no-errors-schema';
   function qr(e) {
    if (':' != e[0]) return [null, e];
    let t = e.indexOf(':', 1);
    if (-1 === t) throw new Error(`Unsupported format "${e}" expecting ":namespace:name"`);
    return [e.slice(1, t), e.slice(t + 1)];
   }
   function Ur(e) {
    return 'ng-container' === qr(e)[1];
   }
   function $r(e) {
    return 'ng-content' === qr(e)[1];
   }
   function Hr(e) {
    return null === e ? null : qr(e)[0];
   }
   function zr(e, t) {
    return e ? `:${e}:${t}` : t;
   }
   function Vr() {
    return Mr || ((Mr = {}), Wr(_r.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']), Wr(_r.STYLE, ['*|style']), Wr(_r.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'track|src', 'video|poster', 'video|src']), Wr(_r.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src'])), Mr;
   }
   function Wr(e, t) {
    for (let r of t) Mr[r.toLowerCase()] = e;
   }
   !(function (e) {
    (e[(e.NONE = 0)] = 'NONE'), (e[(e.HTML = 1)] = 'HTML'), (e[(e.STYLE = 2)] = 'STYLE'), (e[(e.SCRIPT = 3)] = 'SCRIPT'), (e[(e.URL = 4)] = 'URL'), (e[(e.RESOURCE_URL = 5)] = 'RESOURCE_URL');
   })(_r || (_r = {})),
    (function (e) {
     (e[(e.Error = 0)] = 'Error'), (e[(e.Warning = 1)] = 'Warning'), (e[(e.Ignore = 2)] = 'Ignore');
    })(Lr || (Lr = {})),
    (function (e) {
     (e[(e.RAW_TEXT = 0)] = 'RAW_TEXT'), (e[(e.ESCAPABLE_RAW_TEXT = 1)] = 'ESCAPABLE_RAW_TEXT'), (e[(e.PARSABLE_DATA = 2)] = 'PARSABLE_DATA');
    })(Or || (Or = {}));
   var Jr = class {},
    Kr = ['[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume', ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'data^[HTMLElement]|value', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,media,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type', 'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'time^[HTMLElement]|dateTime', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|decoding', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|'],
    Gr = new Map(Object.entries({ class: 'className', for: 'htmlFor', formaction: 'formAction', innerHtml: 'innerHTML', readonly: 'readOnly', tabindex: 'tabIndex' })),
    Xr = Array.from(Gr).reduce((e, [t, r]) => (e.set(t, r), e), new Map()),
    Yr = class extends Jr {
     constructor() {
      super(),
       (this._schema = new Map()),
       (this._eventSchema = new Map()),
       Kr.forEach((e) => {
        let t = new Map(),
         r = new Set(),
         [n, s] = e.split('|'),
         i = s.split(','),
         [a, o] = n.split('^');
        a.split(',').forEach((e) => {
         this._schema.set(e.toLowerCase(), t), this._eventSchema.set(e.toLowerCase(), r);
        });
        let u = o && this._schema.get(o.toLowerCase());
        if (u) {
         for (let [e, r] of u) t.set(e, r);
         for (let e of this._eventSchema.get(o.toLowerCase())) r.add(e);
        }
        i.forEach((e) => {
         if (e.length > 0)
          switch (e[0]) {
           case '*':
            r.add(e.substring(1));
            break;
           case '!':
            t.set(e.substring(1), 'boolean');
            break;
           case '#':
            t.set(e.substring(1), 'number');
            break;
           case '%':
            t.set(e.substring(1), 'object');
            break;
           default:
            t.set(e, 'string');
          }
        });
       });
     }
     hasProperty(e, t, r) {
      if (r.some((e) => e.name === Rr)) return !0;
      if (e.indexOf('-') > -1) {
       if (Ur(e) || $r(e)) return !1;
       if (r.some((e) => e.name === jr)) return !0;
      }
      return (this._schema.get(e.toLowerCase()) || this._schema.get('unknown')).has(t);
     }
     hasElement(e, t) {
      return !!(t.some((e) => e.name === Rr) || (e.indexOf('-') > -1 && (Ur(e) || $r(e) || t.some((e) => e.name === jr)))) || this._schema.has(e.toLowerCase());
     }
     securityContext(e, t, r) {
      r && (t = this.getMappedPropName(t)), (e = e.toLowerCase()), (t = t.toLowerCase());
      let n = Vr()[e + '|' + t];
      return n || ((n = Vr()['*|' + t]), n || _r.NONE);
     }
     getMappedPropName(e) {
      return Gr.get(e) ?? e;
     }
     getDefaultComponentElementName() {
      return 'ng-component';
     }
     validateProperty(e) {
      return e.toLowerCase().startsWith('on') ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...\nIf '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
     }
     validateAttribute(e) {
      return e.toLowerCase().startsWith('on') ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
     }
     allKnownElementNames() {
      return Array.from(this._schema.keys());
     }
     allKnownAttributesOfElement(e) {
      let t = this._schema.get(e.toLowerCase()) || this._schema.get('unknown');
      return Array.from(t.keys()).map((e) => Xr.get(e) ?? e);
     }
     allKnownEventsOfElement(e) {
      return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
     }
     normalizeAnimationStyleProperty(e) {
      return (function (e) {
       return e.replace(yr, (...e) => e[1].toUpperCase());
      })(e);
     }
     normalizeAnimationStyleValue(e, t, r) {
      let n = '',
       s = r.toString().trim(),
       i = null;
      if (
       (function (e) {
        switch (e) {
         case 'width':
         case 'height':
         case 'minWidth':
         case 'minHeight':
         case 'maxWidth':
         case 'maxHeight':
         case 'left':
         case 'top':
         case 'bottom':
         case 'right':
         case 'fontSize':
         case 'outlineWidth':
         case 'outlineOffset':
         case 'paddingTop':
         case 'paddingLeft':
         case 'paddingBottom':
         case 'paddingRight':
         case 'marginTop':
         case 'marginLeft':
         case 'marginBottom':
         case 'marginRight':
         case 'borderRadius':
         case 'borderWidth':
         case 'borderTopWidth':
         case 'borderLeftWidth':
         case 'borderRightWidth':
         case 'borderBottomWidth':
         case 'textIndent':
          return !0;
         default:
          return !1;
        }
       })(e) &&
       0 !== r &&
       '0' !== r
      )
       if ('number' == typeof r) n = 'px';
       else {
        let e = r.match(/^[+-]?[\d\.]+([a-z]*)$/);
        e && 0 == e[1].length && (i = `Please provide a CSS unit value for ${t}:${r}`);
       }
      return { error: i, value: s + n };
     }
    };
   var Qr,
    Zr,
    en = class {
     constructor({ closedByChildren: e, implicitNamespacePrefix: t, contentType: r = Or.PARSABLE_DATA, closedByParent: n = !1, isVoid: s = !1, ignoreFirstLf: i = !1, preventNamespaceInheritance: a = !1, canSelfClose: o = !1 } = {}) {
      (this.closedByChildren = {}), (this.closedByParent = !1), e && e.length > 0 && e.forEach((e) => (this.closedByChildren[e] = !0)), (this.isVoid = s), (this.closedByParent = n || s), (this.implicitNamespacePrefix = t || null), (this.contentType = r), (this.ignoreFirstLf = i), (this.preventNamespaceInheritance = a), (this.canSelfClose = o ?? s);
     }
     isClosedByChild(e) {
      return this.isVoid || e.toLowerCase() in this.closedByChildren;
     }
     getContentType(e) {
      return 'object' == typeof this.contentType ? (void 0 === e ? void 0 : this.contentType[e]) ?? this.contentType.default : this.contentType;
     }
    };
   function tn(e) {
    return (
     Zr ||
      ((Qr = new en({ canSelfClose: !0 })),
      (Zr = Object.assign(Object.create(null), { base: new en({ isVoid: !0 }), meta: new en({ isVoid: !0 }), area: new en({ isVoid: !0 }), embed: new en({ isVoid: !0 }), link: new en({ isVoid: !0 }), img: new en({ isVoid: !0 }), input: new en({ isVoid: !0 }), param: new en({ isVoid: !0 }), hr: new en({ isVoid: !0 }), br: new en({ isVoid: !0 }), source: new en({ isVoid: !0 }), track: new en({ isVoid: !0 }), wbr: new en({ isVoid: !0 }), p: new en({ closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'], closedByParent: !0 }), thead: new en({ closedByChildren: ['tbody', 'tfoot'] }), tbody: new en({ closedByChildren: ['tbody', 'tfoot'], closedByParent: !0 }), tfoot: new en({ closedByChildren: ['tbody'], closedByParent: !0 }), tr: new en({ closedByChildren: ['tr'], closedByParent: !0 }), td: new en({ closedByChildren: ['td', 'th'], closedByParent: !0 }), th: new en({ closedByChildren: ['td', 'th'], closedByParent: !0 }), col: new en({ isVoid: !0 }), svg: new en({ implicitNamespacePrefix: 'svg' }), foreignObject: new en({ implicitNamespacePrefix: 'svg', preventNamespaceInheritance: !0 }), math: new en({ implicitNamespacePrefix: 'math' }), li: new en({ closedByChildren: ['li'], closedByParent: !0 }), dt: new en({ closedByChildren: ['dt', 'dd'] }), dd: new en({ closedByChildren: ['dt', 'dd'], closedByParent: !0 }), rb: new en({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: !0 }), rt: new en({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: !0 }), rtc: new en({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: !0 }), rp: new en({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: !0 }), optgroup: new en({ closedByChildren: ['optgroup'], closedByParent: !0 }), option: new en({ closedByChildren: ['option', 'optgroup'], closedByParent: !0 }), pre: new en({ ignoreFirstLf: !0 }), listing: new en({ ignoreFirstLf: !0 }), style: new en({ contentType: Or.RAW_TEXT }), script: new en({ contentType: Or.RAW_TEXT }), title: new en({ contentType: { default: Or.ESCAPABLE_RAW_TEXT, svg: Or.PARSABLE_DATA } }), textarea: new en({ contentType: Or.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) })),
      new Yr().allKnownElementNames().forEach((e) => {
       !Zr[e] && null === Hr(e) && (Zr[e] = new en({ canSelfClose: !1 }));
      })),
     Zr[e] ?? Qr
    );
   }
   var rn = class {
     constructor(e, t) {
      (this.sourceSpan = e), (this.i18n = t);
     }
    },
    nn = class extends rn {
     constructor(e, t, r, n) {
      super(t, n), (this.value = e), (this.tokens = r), (this.type = 'text');
     }
     visit(e, t) {
      return e.visitText(this, t);
     }
    },
    sn = class extends rn {
     constructor(e, t, r, n) {
      super(t, n), (this.value = e), (this.tokens = r), (this.type = 'cdata');
     }
     visit(e, t) {
      return e.visitCdata(this, t);
     }
    },
    an = class extends rn {
     constructor(e, t, r, n, s, i) {
      super(n, i), (this.switchValue = e), (this.type = t), (this.cases = r), (this.switchValueSourceSpan = s);
     }
     visit(e, t) {
      return e.visitExpansion(this, t);
     }
    },
    on = class {
     constructor(e, t, r, n, s) {
      (this.value = e), (this.expression = t), (this.sourceSpan = r), (this.valueSourceSpan = n), (this.expSourceSpan = s), (this.type = 'expansionCase');
     }
     visit(e, t) {
      return e.visitExpansionCase(this, t);
     }
    },
    un = class extends rn {
     constructor(e, t, r, n, s, i, a) {
      super(r, a), (this.name = e), (this.value = t), (this.keySpan = n), (this.valueSpan = s), (this.valueTokens = i), (this.type = 'attribute');
     }
     visit(e, t) {
      return e.visitAttribute(this, t);
     }
     get nameSpan() {
      return this.keySpan;
     }
    },
    ln = class extends rn {
     constructor(e, t, r, n, s, i = null, a = null, o) {
      super(n, o), (this.name = e), (this.attrs = t), (this.children = r), (this.startSourceSpan = s), (this.endSourceSpan = i), (this.nameSpan = a), (this.type = 'element');
     }
     visit(e, t) {
      return e.visitElement(this, t);
     }
    },
    pn = class {
     constructor(e, t) {
      (this.value = e), (this.sourceSpan = t), (this.type = 'comment');
     }
     visit(e, t) {
      return e.visitComment(this, t);
     }
    },
    cn = class {
     constructor(e, t) {
      (this.value = e), (this.sourceSpan = t), (this.type = 'docType');
     }
     visit(e, t) {
      return e.visitDocType(this, t);
     }
    },
    hn = class {
     constructor(e, t, r, n, s, i = null) {
      (this.name = e), (this.parameters = t), (this.children = r), (this.sourceSpan = n), (this.startSourceSpan = s), (this.endSourceSpan = i), (this.type = 'block');
     }
     visit(e, t) {
      return e.visitBlock(this, t);
     }
    },
    dn = class {
     constructor(e, t) {
      (this.expression = e), (this.sourceSpan = t), (this.type = 'blockParameter'), (this.startSourceSpan = null), (this.endSourceSpan = null);
     }
     visit(e, t) {
      return e.visitBlockParameter(this, t);
     }
    };
   function fn(e, t, r = null) {
    let n = [],
     s = e.visit ? (t) => e.visit(t, r) || t.visit(e, r) : (t) => t.visit(e, r);
    return (
     t.forEach((e) => {
      let t = s(e);
      t && n.push(t);
     }),
     n
    );
   }
   var mn = class {
     constructor() {}
     visitElement(e, t) {
      this.visitChildren(t, (t) => {
       t(e.attrs), t(e.children);
      });
     }
     visitAttribute(e, t) {}
     visitText(e, t) {}
     visitCdata(e, t) {}
     visitComment(e, t) {}
     visitDocType(e, t) {}
     visitExpansion(e, t) {
      return this.visitChildren(t, (t) => {
       t(e.cases);
      });
     }
     visitExpansionCase(e, t) {}
     visitBlock(e, t) {
      this.visitChildren(t, (t) => {
       t(e.parameters), t(e.children);
      });
     }
     visitBlockParameter(e, t) {}
     visitChildren(e, t) {
      let r = [],
       n = this;
      return (
       t(function (t) {
        t && r.push(fn(n, t, e));
       }),
       Array.prototype.concat.apply([], r)
      );
     }
    },
    yn = { AElig: '\xc6', AMP: '&', amp: '&', Aacute: '\xc1', Abreve: '\u0102', Acirc: '\xc2', Acy: '\u0410', Afr: '\ud835\udd04', Agrave: '\xc0', Alpha: '\u0391', Amacr: '\u0100', And: '\u2a53', Aogon: '\u0104', Aopf: '\ud835\udd38', ApplyFunction: '\u2061', af: '\u2061', Aring: '\xc5', angst: '\xc5', Ascr: '\ud835\udc9c', Assign: '\u2254', colone: '\u2254', coloneq: '\u2254', Atilde: '\xc3', Auml: '\xc4', Backslash: '\u2216', setminus: '\u2216', setmn: '\u2216', smallsetminus: '\u2216', ssetmn: '\u2216', Barv: '\u2ae7', Barwed: '\u2306', doublebarwedge: '\u2306', Bcy: '\u0411', Because: '\u2235', becaus: '\u2235', because: '\u2235', Bernoullis: '\u212c', Bscr: '\u212c', bernou: '\u212c', Beta: '\u0392', Bfr: '\ud835\udd05', Bopf: '\ud835\udd39', Breve: '\u02d8', breve: '\u02d8', Bumpeq: '\u224e', HumpDownHump: '\u224e', bump: '\u224e', CHcy: '\u0427', COPY: '\xa9', copy: '\xa9', Cacute: '\u0106', Cap: '\u22d2', CapitalDifferentialD: '\u2145', DD: '\u2145', Cayleys: '\u212d', Cfr: '\u212d', Ccaron: '\u010c', Ccedil: '\xc7', Ccirc: '\u0108', Cconint: '\u2230', Cdot: '\u010a', Cedilla: '\xb8', cedil: '\xb8', CenterDot: '\xb7', centerdot: '\xb7', middot: '\xb7', Chi: '\u03a7', CircleDot: '\u2299', odot: '\u2299', CircleMinus: '\u2296', ominus: '\u2296', CirclePlus: '\u2295', oplus: '\u2295', CircleTimes: '\u2297', otimes: '\u2297', ClockwiseContourIntegral: '\u2232', cwconint: '\u2232', CloseCurlyDoubleQuote: '\u201d', rdquo: '\u201d', rdquor: '\u201d', CloseCurlyQuote: '\u2019', rsquo: '\u2019', rsquor: '\u2019', Colon: '\u2237', Proportion: '\u2237', Colone: '\u2a74', Congruent: '\u2261', equiv: '\u2261', Conint: '\u222f', DoubleContourIntegral: '\u222f', ContourIntegral: '\u222e', conint: '\u222e', oint: '\u222e', Copf: '\u2102', complexes: '\u2102', Coproduct: '\u2210', coprod: '\u2210', CounterClockwiseContourIntegral: '\u2233', awconint: '\u2233', Cross: '\u2a2f', Cscr: '\ud835\udc9e', Cup: '\u22d3', CupCap: '\u224d', asympeq: '\u224d', DDotrahd: '\u2911', DJcy: '\u0402', DScy: '\u0405', DZcy: '\u040f', Dagger: '\u2021', ddagger: '\u2021', Darr: '\u21a1', Dashv: '\u2ae4', DoubleLeftTee: '\u2ae4', Dcaron: '\u010e', Dcy: '\u0414', Del: '\u2207', nabla: '\u2207', Delta: '\u0394', Dfr: '\ud835\udd07', DiacriticalAcute: '\xb4', acute: '\xb4', DiacriticalDot: '\u02d9', dot: '\u02d9', DiacriticalDoubleAcute: '\u02dd', dblac: '\u02dd', DiacriticalGrave: '`', grave: '`', DiacriticalTilde: '\u02dc', tilde: '\u02dc', Diamond: '\u22c4', diam: '\u22c4', diamond: '\u22c4', DifferentialD: '\u2146', dd: '\u2146', Dopf: '\ud835\udd3b', Dot: '\xa8', DoubleDot: '\xa8', die: '\xa8', uml: '\xa8', DotDot: '\u20dc', DotEqual: '\u2250', doteq: '\u2250', esdot: '\u2250', DoubleDownArrow: '\u21d3', Downarrow: '\u21d3', dArr: '\u21d3', DoubleLeftArrow: '\u21d0', Leftarrow: '\u21d0', lArr: '\u21d0', DoubleLeftRightArrow: '\u21d4', Leftrightarrow: '\u21d4', hArr: '\u21d4', iff: '\u21d4', DoubleLongLeftArrow: '\u27f8', Longleftarrow: '\u27f8', xlArr: '\u27f8', DoubleLongLeftRightArrow: '\u27fa', Longleftrightarrow: '\u27fa', xhArr: '\u27fa', DoubleLongRightArrow: '\u27f9', Longrightarrow: '\u27f9', xrArr: '\u27f9', DoubleRightArrow: '\u21d2', Implies: '\u21d2', Rightarrow: '\u21d2', rArr: '\u21d2', DoubleRightTee: '\u22a8', vDash: '\u22a8', DoubleUpArrow: '\u21d1', Uparrow: '\u21d1', uArr: '\u21d1', DoubleUpDownArrow: '\u21d5', Updownarrow: '\u21d5', vArr: '\u21d5', DoubleVerticalBar: '\u2225', par: '\u2225', parallel: '\u2225', shortparallel: '\u2225', spar: '\u2225', DownArrow: '\u2193', ShortDownArrow: '\u2193', darr: '\u2193', downarrow: '\u2193', DownArrowBar: '\u2913', DownArrowUpArrow: '\u21f5', duarr: '\u21f5', DownBreve: '\u0311', DownLeftRightVector: '\u2950', DownLeftTeeVector: '\u295e', DownLeftVector: '\u21bd', leftharpoondown: '\u21bd', lhard: '\u21bd', DownLeftVectorBar: '\u2956', DownRightTeeVector: '\u295f', DownRightVector: '\u21c1', rhard: '\u21c1', rightharpoondown: '\u21c1', DownRightVectorBar: '\u2957', DownTee: '\u22a4', top: '\u22a4', DownTeeArrow: '\u21a7', mapstodown: '\u21a7', Dscr: '\ud835\udc9f', Dstrok: '\u0110', ENG: '\u014a', ETH: '\xd0', Eacute: '\xc9', Ecaron: '\u011a', Ecirc: '\xca', Ecy: '\u042d', Edot: '\u0116', Efr: '\ud835\udd08', Egrave: '\xc8', Element: '\u2208', in: '\u2208', isin: '\u2208', isinv: '\u2208', Emacr: '\u0112', EmptySmallSquare: '\u25fb', EmptyVerySmallSquare: '\u25ab', Eogon: '\u0118', Eopf: '\ud835\udd3c', Epsilon: '\u0395', Equal: '\u2a75', EqualTilde: '\u2242', eqsim: '\u2242', esim: '\u2242', Equilibrium: '\u21cc', rightleftharpoons: '\u21cc', rlhar: '\u21cc', Escr: '\u2130', expectation: '\u2130', Esim: '\u2a73', Eta: '\u0397', Euml: '\xcb', Exists: '\u2203', exist: '\u2203', ExponentialE: '\u2147', ee: '\u2147', exponentiale: '\u2147', Fcy: '\u0424', Ffr: '\ud835\udd09', FilledSmallSquare: '\u25fc', FilledVerySmallSquare: '\u25aa', blacksquare: '\u25aa', squarf: '\u25aa', squf: '\u25aa', Fopf: '\ud835\udd3d', ForAll: '\u2200', forall: '\u2200', Fouriertrf: '\u2131', Fscr: '\u2131', GJcy: '\u0403', GT: '>', gt: '>', Gamma: '\u0393', Gammad: '\u03dc', Gbreve: '\u011e', Gcedil: '\u0122', Gcirc: '\u011c', Gcy: '\u0413', Gdot: '\u0120', Gfr: '\ud835\udd0a', Gg: '\u22d9', ggg: '\u22d9', Gopf: '\ud835\udd3e', GreaterEqual: '\u2265', ge: '\u2265', geq: '\u2265', GreaterEqualLess: '\u22db', gel: '\u22db', gtreqless: '\u22db', GreaterFullEqual: '\u2267', gE: '\u2267', geqq: '\u2267', GreaterGreater: '\u2aa2', GreaterLess: '\u2277', gl: '\u2277', gtrless: '\u2277', GreaterSlantEqual: '\u2a7e', geqslant: '\u2a7e', ges: '\u2a7e', GreaterTilde: '\u2273', gsim: '\u2273', gtrsim: '\u2273', Gscr: '\ud835\udca2', Gt: '\u226b', NestedGreaterGreater: '\u226b', gg: '\u226b', HARDcy: '\u042a', Hacek: '\u02c7', caron: '\u02c7', Hat: '^', Hcirc: '\u0124', Hfr: '\u210c', Poincareplane: '\u210c', HilbertSpace: '\u210b', Hscr: '\u210b', hamilt: '\u210b', Hopf: '\u210d', quaternions: '\u210d', HorizontalLine: '\u2500', boxh: '\u2500', Hstrok: '\u0126', HumpEqual: '\u224f', bumpe: '\u224f', bumpeq: '\u224f', IEcy: '\u0415', IJlig: '\u0132', IOcy: '\u0401', Iacute: '\xcd', Icirc: '\xce', Icy: '\u0418', Idot: '\u0130', Ifr: '\u2111', Im: '\u2111', image: '\u2111', imagpart: '\u2111', Igrave: '\xcc', Imacr: '\u012a', ImaginaryI: '\u2148', ii: '\u2148', Int: '\u222c', Integral: '\u222b', int: '\u222b', Intersection: '\u22c2', bigcap: '\u22c2', xcap: '\u22c2', InvisibleComma: '\u2063', ic: '\u2063', InvisibleTimes: '\u2062', it: '\u2062', Iogon: '\u012e', Iopf: '\ud835\udd40', Iota: '\u0399', Iscr: '\u2110', imagline: '\u2110', Itilde: '\u0128', Iukcy: '\u0406', Iuml: '\xcf', Jcirc: '\u0134', Jcy: '\u0419', Jfr: '\ud835\udd0d', Jopf: '\ud835\udd41', Jscr: '\ud835\udca5', Jsercy: '\u0408', Jukcy: '\u0404', KHcy: '\u0425', KJcy: '\u040c', Kappa: '\u039a', Kcedil: '\u0136', Kcy: '\u041a', Kfr: '\ud835\udd0e', Kopf: '\ud835\udd42', Kscr: '\ud835\udca6', LJcy: '\u0409', LT: '<', lt: '<', Lacute: '\u0139', Lambda: '\u039b', Lang: '\u27ea', Laplacetrf: '\u2112', Lscr: '\u2112', lagran: '\u2112', Larr: '\u219e', twoheadleftarrow: '\u219e', Lcaron: '\u013d', Lcedil: '\u013b', Lcy: '\u041b', LeftAngleBracket: '\u27e8', lang: '\u27e8', langle: '\u27e8', LeftArrow: '\u2190', ShortLeftArrow: '\u2190', larr: '\u2190', leftarrow: '\u2190', slarr: '\u2190', LeftArrowBar: '\u21e4', larrb: '\u21e4', LeftArrowRightArrow: '\u21c6', leftrightarrows: '\u21c6', lrarr: '\u21c6', LeftCeiling: '\u2308', lceil: '\u2308', LeftDoubleBracket: '\u27e6', lobrk: '\u27e6', LeftDownTeeVector: '\u2961', LeftDownVector: '\u21c3', dharl: '\u21c3', downharpoonleft: '\u21c3', LeftDownVectorBar: '\u2959', LeftFloor: '\u230a', lfloor: '\u230a', LeftRightArrow: '\u2194', harr: '\u2194', leftrightarrow: '\u2194', LeftRightVector: '\u294e', LeftTee: '\u22a3', dashv: '\u22a3', LeftTeeArrow: '\u21a4', mapstoleft: '\u21a4', LeftTeeVector: '\u295a', LeftTriangle: '\u22b2', vartriangleleft: '\u22b2', vltri: '\u22b2', LeftTriangleBar: '\u29cf', LeftTriangleEqual: '\u22b4', ltrie: '\u22b4', trianglelefteq: '\u22b4', LeftUpDownVector: '\u2951', LeftUpTeeVector: '\u2960', LeftUpVector: '\u21bf', uharl: '\u21bf', upharpoonleft: '\u21bf', LeftUpVectorBar: '\u2958', LeftVector: '\u21bc', leftharpoonup: '\u21bc', lharu: '\u21bc', LeftVectorBar: '\u2952', LessEqualGreater: '\u22da', leg: '\u22da', lesseqgtr: '\u22da', LessFullEqual: '\u2266', lE: '\u2266', leqq: '\u2266', LessGreater: '\u2276', lessgtr: '\u2276', lg: '\u2276', LessLess: '\u2aa1', LessSlantEqual: '\u2a7d', leqslant: '\u2a7d', les: '\u2a7d', LessTilde: '\u2272', lesssim: '\u2272', lsim: '\u2272', Lfr: '\ud835\udd0f', Ll: '\u22d8', Lleftarrow: '\u21da', lAarr: '\u21da', Lmidot: '\u013f', LongLeftArrow: '\u27f5', longleftarrow: '\u27f5', xlarr: '\u27f5', LongLeftRightArrow: '\u27f7', longleftrightarrow: '\u27f7', xharr: '\u27f7', LongRightArrow: '\u27f6', longrightarrow: '\u27f6', xrarr: '\u27f6', Lopf: '\ud835\udd43', LowerLeftArrow: '\u2199', swarr: '\u2199', swarrow: '\u2199', LowerRightArrow: '\u2198', searr: '\u2198', searrow: '\u2198', Lsh: '\u21b0', lsh: '\u21b0', Lstrok: '\u0141', Lt: '\u226a', NestedLessLess: '\u226a', ll: '\u226a', Map: '\u2905', Mcy: '\u041c', MediumSpace: '\u205f', Mellintrf: '\u2133', Mscr: '\u2133', phmmat: '\u2133', Mfr: '\ud835\udd10', MinusPlus: '\u2213', mnplus: '\u2213', mp: '\u2213', Mopf: '\ud835\udd44', Mu: '\u039c', NJcy: '\u040a', Nacute: '\u0143', Ncaron: '\u0147', Ncedil: '\u0145', Ncy: '\u041d', NegativeMediumSpace: '\u200b', NegativeThickSpace: '\u200b', NegativeThinSpace: '\u200b', NegativeVeryThinSpace: '\u200b', ZeroWidthSpace: '\u200b', NewLine: '\n', Nfr: '\ud835\udd11', NoBreak: '\u2060', NonBreakingSpace: '\xa0', nbsp: '\xa0', Nopf: '\u2115', naturals: '\u2115', Not: '\u2aec', NotCongruent: '\u2262', nequiv: '\u2262', NotCupCap: '\u226d', NotDoubleVerticalBar: '\u2226', npar: '\u2226', nparallel: '\u2226', nshortparallel: '\u2226', nspar: '\u2226', NotElement: '\u2209', notin: '\u2209', notinva: '\u2209', NotEqual: '\u2260', ne: '\u2260', NotEqualTilde: '\u2242\u0338', nesim: '\u2242\u0338', NotExists: '\u2204', nexist: '\u2204', nexists: '\u2204', NotGreater: '\u226f', ngt: '\u226f', ngtr: '\u226f', NotGreaterEqual: '\u2271', nge: '\u2271', ngeq: '\u2271', NotGreaterFullEqual: '\u2267\u0338', ngE: '\u2267\u0338', ngeqq: '\u2267\u0338', NotGreaterGreater: '\u226b\u0338', nGtv: '\u226b\u0338', NotGreaterLess: '\u2279', ntgl: '\u2279', NotGreaterSlantEqual: '\u2a7e\u0338', ngeqslant: '\u2a7e\u0338', nges: '\u2a7e\u0338', NotGreaterTilde: '\u2275', ngsim: '\u2275', NotHumpDownHump: '\u224e\u0338', nbump: '\u224e\u0338', NotHumpEqual: '\u224f\u0338', nbumpe: '\u224f\u0338', NotLeftTriangle: '\u22ea', nltri: '\u22ea', ntriangleleft: '\u22ea', NotLeftTriangleBar: '\u29cf\u0338', NotLeftTriangleEqual: '\u22ec', nltrie: '\u22ec', ntrianglelefteq: '\u22ec', NotLess: '\u226e', nless: '\u226e', nlt: '\u226e', NotLessEqual: '\u2270', nle: '\u2270', nleq: '\u2270', NotLessGreater: '\u2278', ntlg: '\u2278', NotLessLess: '\u226a\u0338', nLtv: '\u226a\u0338', NotLessSlantEqual: '\u2a7d\u0338', nleqslant: '\u2a7d\u0338', nles: '\u2a7d\u0338', NotLessTilde: '\u2274', nlsim: '\u2274', NotNestedGreaterGreater: '\u2aa2\u0338', NotNestedLessLess: '\u2aa1\u0338', NotPrecedes: '\u2280', npr: '\u2280', nprec: '\u2280', NotPrecedesEqual: '\u2aaf\u0338', npre: '\u2aaf\u0338', npreceq: '\u2aaf\u0338', NotPrecedesSlantEqual: '\u22e0', nprcue: '\u22e0', NotReverseElement: '\u220c', notni: '\u220c', notniva: '\u220c', NotRightTriangle: '\u22eb', nrtri: '\u22eb', ntriangleright: '\u22eb', NotRightTriangleBar: '\u29d0\u0338', NotRightTriangleEqual: '\u22ed', nrtrie: '\u22ed', ntrianglerighteq: '\u22ed', NotSquareSubset: '\u228f\u0338', NotSquareSubsetEqual: '\u22e2', nsqsube: '\u22e2', NotSquareSuperset: '\u2290\u0338', NotSquareSupersetEqual: '\u22e3', nsqsupe: '\u22e3', NotSubset: '\u2282\u20d2', nsubset: '\u2282\u20d2', vnsub: '\u2282\u20d2', NotSubsetEqual: '\u2288', nsube: '\u2288', nsubseteq: '\u2288', NotSucceeds: '\u2281', nsc: '\u2281', nsucc: '\u2281', NotSucceedsEqual: '\u2ab0\u0338', nsce: '\u2ab0\u0338', nsucceq: '\u2ab0\u0338', NotSucceedsSlantEqual: '\u22e1', nsccue: '\u22e1', NotSucceedsTilde: '\u227f\u0338', NotSuperset: '\u2283\u20d2', nsupset: '\u2283\u20d2', vnsup: '\u2283\u20d2', NotSupersetEqual: '\u2289', nsupe: '\u2289', nsupseteq: '\u2289', NotTilde: '\u2241', nsim: '\u2241', NotTildeEqual: '\u2244', nsime: '\u2244', nsimeq: '\u2244', NotTildeFullEqual: '\u2247', ncong: '\u2247', NotTildeTilde: '\u2249', nap: '\u2249', napprox: '\u2249', NotVerticalBar: '\u2224', nmid: '\u2224', nshortmid: '\u2224', nsmid: '\u2224', Nscr: '\ud835\udca9', Ntilde: '\xd1', Nu: '\u039d', OElig: '\u0152', Oacute: '\xd3', Ocirc: '\xd4', Ocy: '\u041e', Odblac: '\u0150', Ofr: '\ud835\udd12', Ograve: '\xd2', Omacr: '\u014c', Omega: '\u03a9', ohm: '\u03a9', Omicron: '\u039f', Oopf: '\ud835\udd46', OpenCurlyDoubleQuote: '\u201c', ldquo: '\u201c', OpenCurlyQuote: '\u2018', lsquo: '\u2018', Or: '\u2a54', Oscr: '\ud835\udcaa', Oslash: '\xd8', Otilde: '\xd5', Otimes: '\u2a37', Ouml: '\xd6', OverBar: '\u203e', oline: '\u203e', OverBrace: '\u23de', OverBracket: '\u23b4', tbrk: '\u23b4', OverParenthesis: '\u23dc', PartialD: '\u2202', part: '\u2202', Pcy: '\u041f', Pfr: '\ud835\udd13', Phi: '\u03a6', Pi: '\u03a0', PlusMinus: '\xb1', plusmn: '\xb1', pm: '\xb1', Popf: '\u2119', primes: '\u2119', Pr: '\u2abb', Precedes: '\u227a', pr: '\u227a', prec: '\u227a', PrecedesEqual: '\u2aaf', pre: '\u2aaf', preceq: '\u2aaf', PrecedesSlantEqual: '\u227c', prcue: '\u227c', preccurlyeq: '\u227c', PrecedesTilde: '\u227e', precsim: '\u227e', prsim: '\u227e', Prime: '\u2033', Product: '\u220f', prod: '\u220f', Proportional: '\u221d', prop: '\u221d', propto: '\u221d', varpropto: '\u221d', vprop: '\u221d', Pscr: '\ud835\udcab', Psi: '\u03a8', QUOT: '"', quot: '"', Qfr: '\ud835\udd14', Qopf: '\u211a', rationals: '\u211a', Qscr: '\ud835\udcac', RBarr: '\u2910', drbkarow: '\u2910', REG: '\xae', circledR: '\xae', reg: '\xae', Racute: '\u0154', Rang: '\u27eb', Rarr: '\u21a0', twoheadrightarrow: '\u21a0', Rarrtl: '\u2916', Rcaron: '\u0158', Rcedil: '\u0156', Rcy: '\u0420', Re: '\u211c', Rfr: '\u211c', real: '\u211c', realpart: '\u211c', ReverseElement: '\u220b', SuchThat: '\u220b', ni: '\u220b', niv: '\u220b', ReverseEquilibrium: '\u21cb', leftrightharpoons: '\u21cb', lrhar: '\u21cb', ReverseUpEquilibrium: '\u296f', duhar: '\u296f', Rho: '\u03a1', RightAngleBracket: '\u27e9', rang: '\u27e9', rangle: '\u27e9', RightArrow: '\u2192', ShortRightArrow: '\u2192', rarr: '\u2192', rightarrow: '\u2192', srarr: '\u2192', RightArrowBar: '\u21e5', rarrb: '\u21e5', RightArrowLeftArrow: '\u21c4', rightleftarrows: '\u21c4', rlarr: '\u21c4', RightCeiling: '\u2309', rceil: '\u2309', RightDoubleBracket: '\u27e7', robrk: '\u27e7', RightDownTeeVector: '\u295d', RightDownVector: '\u21c2', dharr: '\u21c2', downharpoonright: '\u21c2', RightDownVectorBar: '\u2955', RightFloor: '\u230b', rfloor: '\u230b', RightTee: '\u22a2', vdash: '\u22a2', RightTeeArrow: '\u21a6', map: '\u21a6', mapsto: '\u21a6', RightTeeVector: '\u295b', RightTriangle: '\u22b3', vartriangleright: '\u22b3', vrtri: '\u22b3', RightTriangleBar: '\u29d0', RightTriangleEqual: '\u22b5', rtrie: '\u22b5', trianglerighteq: '\u22b5', RightUpDownVector: '\u294f', RightUpTeeVector: '\u295c', RightUpVector: '\u21be', uharr: '\u21be', upharpoonright: '\u21be', RightUpVectorBar: '\u2954', RightVector: '\u21c0', rharu: '\u21c0', rightharpoonup: '\u21c0', RightVectorBar: '\u2953', Ropf: '\u211d', reals: '\u211d', RoundImplies: '\u2970', Rrightarrow: '\u21db', rAarr: '\u21db', Rscr: '\u211b', realine: '\u211b', Rsh: '\u21b1', rsh: '\u21b1', RuleDelayed: '\u29f4', SHCHcy: '\u0429', SHcy: '\u0428', SOFTcy: '\u042c', Sacute: '\u015a', Sc: '\u2abc', Scaron: '\u0160', Scedil: '\u015e', Scirc: '\u015c', Scy: '\u0421', Sfr: '\ud835\udd16', ShortUpArrow: '\u2191', UpArrow: '\u2191', uarr: '\u2191', uparrow: '\u2191', Sigma: '\u03a3', SmallCircle: '\u2218', compfn: '\u2218', Sopf: '\ud835\udd4a', Sqrt: '\u221a', radic: '\u221a', Square: '\u25a1', squ: '\u25a1', square: '\u25a1', SquareIntersection: '\u2293', sqcap: '\u2293', SquareSubset: '\u228f', sqsub: '\u228f', sqsubset: '\u228f', SquareSubsetEqual: '\u2291', sqsube: '\u2291', sqsubseteq: '\u2291', SquareSuperset: '\u2290', sqsup: '\u2290', sqsupset: '\u2290', SquareSupersetEqual: '\u2292', sqsupe: '\u2292', sqsupseteq: '\u2292', SquareUnion: '\u2294', sqcup: '\u2294', Sscr: '\ud835\udcae', Star: '\u22c6', sstarf: '\u22c6', Sub: '\u22d0', Subset: '\u22d0', SubsetEqual: '\u2286', sube: '\u2286', subseteq: '\u2286', Succeeds: '\u227b', sc: '\u227b', succ: '\u227b', SucceedsEqual: '\u2ab0', sce: '\u2ab0', succeq: '\u2ab0', SucceedsSlantEqual: '\u227d', sccue: '\u227d', succcurlyeq: '\u227d', SucceedsTilde: '\u227f', scsim: '\u227f', succsim: '\u227f', Sum: '\u2211', sum: '\u2211', Sup: '\u22d1', Supset: '\u22d1', Superset: '\u2283', sup: '\u2283', supset: '\u2283', SupersetEqual: '\u2287', supe: '\u2287', supseteq: '\u2287', THORN: '\xde', TRADE: '\u2122', trade: '\u2122', TSHcy: '\u040b', TScy: '\u0426', Tab: '\t', Tau: '\u03a4', Tcaron: '\u0164', Tcedil: '\u0162', Tcy: '\u0422', Tfr: '\ud835\udd17', Therefore: '\u2234', there4: '\u2234', therefore: '\u2234', Theta: '\u0398', ThickSpace: '\u205f\u200a', ThinSpace: '\u2009', thinsp: '\u2009', Tilde: '\u223c', sim: '\u223c', thicksim: '\u223c', thksim: '\u223c', TildeEqual: '\u2243', sime: '\u2243', simeq: '\u2243', TildeFullEqual: '\u2245', cong: '\u2245', TildeTilde: '\u2248', ap: '\u2248', approx: '\u2248', asymp: '\u2248', thickapprox: '\u2248', thkap: '\u2248', Topf: '\ud835\udd4b', TripleDot: '\u20db', tdot: '\u20db', Tscr: '\ud835\udcaf', Tstrok: '\u0166', Uacute: '\xda', Uarr: '\u219f', Uarrocir: '\u2949', Ubrcy: '\u040e', Ubreve: '\u016c', Ucirc: '\xdb', Ucy: '\u0423', Udblac: '\u0170', Ufr: '\ud835\udd18', Ugrave: '\xd9', Umacr: '\u016a', UnderBar: '_', lowbar: '_', UnderBrace: '\u23df', UnderBracket: '\u23b5', bbrk: '\u23b5', UnderParenthesis: '\u23dd', Union: '\u22c3', bigcup: '\u22c3', xcup: '\u22c3', UnionPlus: '\u228e', uplus: '\u228e', Uogon: '\u0172', Uopf: '\ud835\udd4c', UpArrowBar: '\u2912', UpArrowDownArrow: '\u21c5', udarr: '\u21c5', UpDownArrow: '\u2195', updownarrow: '\u2195', varr: '\u2195', UpEquilibrium: '\u296e', udhar: '\u296e', UpTee: '\u22a5', bot: '\u22a5', bottom: '\u22a5', perp: '\u22a5', UpTeeArrow: '\u21a5', mapstoup: '\u21a5', UpperLeftArrow: '\u2196', nwarr: '\u2196', nwarrow: '\u2196', UpperRightArrow: '\u2197', nearr: '\u2197', nearrow: '\u2197', Upsi: '\u03d2', upsih: '\u03d2', Upsilon: '\u03a5', Uring: '\u016e', Uscr: '\ud835\udcb0', Utilde: '\u0168', Uuml: '\xdc', VDash: '\u22ab', Vbar: '\u2aeb', Vcy: '\u0412', Vdash: '\u22a9', Vdashl: '\u2ae6', Vee: '\u22c1', bigvee: '\u22c1', xvee: '\u22c1', Verbar: '\u2016', Vert: '\u2016', VerticalBar: '\u2223', mid: '\u2223', shortmid: '\u2223', smid: '\u2223', VerticalLine: '|', verbar: '|', vert: '|', VerticalSeparator: '\u2758', VerticalTilde: '\u2240', wr: '\u2240', wreath: '\u2240', VeryThinSpace: '\u200a', hairsp: '\u200a', Vfr: '\ud835\udd19', Vopf: '\ud835\udd4d', Vscr: '\ud835\udcb1', Vvdash: '\u22aa', Wcirc: '\u0174', Wedge: '\u22c0', bigwedge: '\u22c0', xwedge: '\u22c0', Wfr: '\ud835\udd1a', Wopf: '\ud835\udd4e', Wscr: '\ud835\udcb2', Xfr: '\ud835\udd1b', Xi: '\u039e', Xopf: '\ud835\udd4f', Xscr: '\ud835\udcb3', YAcy: '\u042f', YIcy: '\u0407', YUcy: '\u042e', Yacute: '\xdd', Ycirc: '\u0176', Ycy: '\u042b', Yfr: '\ud835\udd1c', Yopf: '\ud835\udd50', Yscr: '\ud835\udcb4', Yuml: '\u0178', ZHcy: '\u0416', Zacute: '\u0179', Zcaron: '\u017d', Zcy: '\u0417', Zdot: '\u017b', Zeta: '\u0396', Zfr: '\u2128', zeetrf: '\u2128', Zopf: '\u2124', integers: '\u2124', Zscr: '\ud835\udcb5', aacute: '\xe1', abreve: '\u0103', ac: '\u223e', mstpos: '\u223e', acE: '\u223e\u0333', acd: '\u223f', acirc: '\xe2', acy: '\u0430', aelig: '\xe6', afr: '\ud835\udd1e', agrave: '\xe0', alefsym: '\u2135', aleph: '\u2135', alpha: '\u03b1', amacr: '\u0101', amalg: '\u2a3f', and: '\u2227', wedge: '\u2227', andand: '\u2a55', andd: '\u2a5c', andslope: '\u2a58', andv: '\u2a5a', ang: '\u2220', angle: '\u2220', ange: '\u29a4', angmsd: '\u2221', measuredangle: '\u2221', angmsdaa: '\u29a8', angmsdab: '\u29a9', angmsdac: '\u29aa', angmsdad: '\u29ab', angmsdae: '\u29ac', angmsdaf: '\u29ad', angmsdag: '\u29ae', angmsdah: '\u29af', angrt: '\u221f', angrtvb: '\u22be', angrtvbd: '\u299d', angsph: '\u2222', angzarr: '\u237c', aogon: '\u0105', aopf: '\ud835\udd52', apE: '\u2a70', apacir: '\u2a6f', ape: '\u224a', approxeq: '\u224a', apid: '\u224b', apos: "'", aring: '\xe5', ascr: '\ud835\udcb6', ast: '*', midast: '*', atilde: '\xe3', auml: '\xe4', awint: '\u2a11', bNot: '\u2aed', backcong: '\u224c', bcong: '\u224c', backepsilon: '\u03f6', bepsi: '\u03f6', backprime: '\u2035', bprime: '\u2035', backsim: '\u223d', bsim: '\u223d', backsimeq: '\u22cd', bsime: '\u22cd', barvee: '\u22bd', barwed: '\u2305', barwedge: '\u2305', bbrktbrk: '\u23b6', bcy: '\u0431', bdquo: '\u201e', ldquor: '\u201e', bemptyv: '\u29b0', beta: '\u03b2', beth: '\u2136', between: '\u226c', twixt: '\u226c', bfr: '\ud835\udd1f', bigcirc: '\u25ef', xcirc: '\u25ef', bigodot: '\u2a00', xodot: '\u2a00', bigoplus: '\u2a01', xoplus: '\u2a01', bigotimes: '\u2a02', xotime: '\u2a02', bigsqcup: '\u2a06', xsqcup: '\u2a06', bigstar: '\u2605', starf: '\u2605', bigtriangledown: '\u25bd', xdtri: '\u25bd', bigtriangleup: '\u25b3', xutri: '\u25b3', biguplus: '\u2a04', xuplus: '\u2a04', bkarow: '\u290d', rbarr: '\u290d', blacklozenge: '\u29eb', lozf: '\u29eb', blacktriangle: '\u25b4', utrif: '\u25b4', blacktriangledown: '\u25be', dtrif: '\u25be', blacktriangleleft: '\u25c2', ltrif: '\u25c2', blacktriangleright: '\u25b8', rtrif: '\u25b8', blank: '\u2423', blk12: '\u2592', blk14: '\u2591', blk34: '\u2593', block: '\u2588', bne: '=\u20e5', bnequiv: '\u2261\u20e5', bnot: '\u2310', bopf: '\ud835\udd53', bowtie: '\u22c8', boxDL: '\u2557', boxDR: '\u2554', boxDl: '\u2556', boxDr: '\u2553', boxH: '\u2550', boxHD: '\u2566', boxHU: '\u2569', boxHd: '\u2564', boxHu: '\u2567', boxUL: '\u255d', boxUR: '\u255a', boxUl: '\u255c', boxUr: '\u2559', boxV: '\u2551', boxVH: '\u256c', boxVL: '\u2563', boxVR: '\u2560', boxVh: '\u256b', boxVl: '\u2562', boxVr: '\u255f', boxbox: '\u29c9', boxdL: '\u2555', boxdR: '\u2552', boxdl: '\u2510', boxdr: '\u250c', boxhD: '\u2565', boxhU: '\u2568', boxhd: '\u252c', boxhu: '\u2534', boxminus: '\u229f', minusb: '\u229f', boxplus: '\u229e', plusb: '\u229e', boxtimes: '\u22a0', timesb: '\u22a0', boxuL: '\u255b', boxuR: '\u2558', boxul: '\u2518', boxur: '\u2514', boxv: '\u2502', boxvH: '\u256a', boxvL: '\u2561', boxvR: '\u255e', boxvh: '\u253c', boxvl: '\u2524', boxvr: '\u251c', brvbar: '\xa6', bscr: '\ud835\udcb7', bsemi: '\u204f', bsol: '\\', bsolb: '\u29c5', bsolhsub: '\u27c8', bull: '\u2022', bullet: '\u2022', bumpE: '\u2aae', cacute: '\u0107', cap: '\u2229', capand: '\u2a44', capbrcup: '\u2a49', capcap: '\u2a4b', capcup: '\u2a47', capdot: '\u2a40', caps: '\u2229\ufe00', caret: '\u2041', ccaps: '\u2a4d', ccaron: '\u010d', ccedil: '\xe7', ccirc: '\u0109', ccups: '\u2a4c', ccupssm: '\u2a50', cdot: '\u010b', cemptyv: '\u29b2', cent: '\xa2', cfr: '\ud835\udd20', chcy: '\u0447', check: '\u2713', checkmark: '\u2713', chi: '\u03c7', cir: '\u25cb', cirE: '\u29c3', circ: '\u02c6', circeq: '\u2257', cire: '\u2257', circlearrowleft: '\u21ba', olarr: '\u21ba', circlearrowright: '\u21bb', orarr: '\u21bb', circledS: '\u24c8', oS: '\u24c8', circledast: '\u229b', oast: '\u229b', circledcirc: '\u229a', ocir: '\u229a', circleddash: '\u229d', odash: '\u229d', cirfnint: '\u2a10', cirmid: '\u2aef', cirscir: '\u29c2', clubs: '\u2663', clubsuit: '\u2663', colon: ':', comma: ',', commat: '@', comp: '\u2201', complement: '\u2201', congdot: '\u2a6d', copf: '\ud835\udd54', copysr: '\u2117', crarr: '\u21b5', cross: '\u2717', cscr: '\ud835\udcb8', csub: '\u2acf', csube: '\u2ad1', csup: '\u2ad0', csupe: '\u2ad2', ctdot: '\u22ef', cudarrl: '\u2938', cudarrr: '\u2935', cuepr: '\u22de', curlyeqprec: '\u22de', cuesc: '\u22df', curlyeqsucc: '\u22df', cularr: '\u21b6', curvearrowleft: '\u21b6', cularrp: '\u293d', cup: '\u222a', cupbrcap: '\u2a48', cupcap: '\u2a46', cupcup: '\u2a4a', cupdot: '\u228d', cupor: '\u2a45', cups: '\u222a\ufe00', curarr: '\u21b7', curvearrowright: '\u21b7', curarrm: '\u293c', curlyvee: '\u22ce', cuvee: '\u22ce', curlywedge: '\u22cf', cuwed: '\u22cf', curren: '\xa4', cwint: '\u2231', cylcty: '\u232d', dHar: '\u2965', dagger: '\u2020', daleth: '\u2138', dash: '\u2010', hyphen: '\u2010', dbkarow: '\u290f', rBarr: '\u290f', dcaron: '\u010f', dcy: '\u0434', ddarr: '\u21ca', downdownarrows: '\u21ca', ddotseq: '\u2a77', eDDot: '\u2a77', deg: '\xb0', delta: '\u03b4', demptyv: '\u29b1', dfisht: '\u297f', dfr: '\ud835\udd21', diamondsuit: '\u2666', diams: '\u2666', digamma: '\u03dd', gammad: '\u03dd', disin: '\u22f2', div: '\xf7', divide: '\xf7', divideontimes: '\u22c7', divonx: '\u22c7', djcy: '\u0452', dlcorn: '\u231e', llcorner: '\u231e', dlcrop: '\u230d', dollar: '$', dopf: '\ud835\udd55', doteqdot: '\u2251', eDot: '\u2251', dotminus: '\u2238', minusd: '\u2238', dotplus: '\u2214', plusdo: '\u2214', dotsquare: '\u22a1', sdotb: '\u22a1', drcorn: '\u231f', lrcorner: '\u231f', drcrop: '\u230c', dscr: '\ud835\udcb9', dscy: '\u0455', dsol: '\u29f6', dstrok: '\u0111', dtdot: '\u22f1', dtri: '\u25bf', triangledown: '\u25bf', dwangle: '\u29a6', dzcy: '\u045f', dzigrarr: '\u27ff', eacute: '\xe9', easter: '\u2a6e', ecaron: '\u011b', ecir: '\u2256', eqcirc: '\u2256', ecirc: '\xea', ecolon: '\u2255', eqcolon: '\u2255', ecy: '\u044d', edot: '\u0117', efDot: '\u2252', fallingdotseq: '\u2252', efr: '\ud835\udd22', eg: '\u2a9a', egrave: '\xe8', egs: '\u2a96', eqslantgtr: '\u2a96', egsdot: '\u2a98', el: '\u2a99', elinters: '\u23e7', ell: '\u2113', els: '\u2a95', eqslantless: '\u2a95', elsdot: '\u2a97', emacr: '\u0113', empty: '\u2205', emptyset: '\u2205', emptyv: '\u2205', varnothing: '\u2205', emsp13: '\u2004', emsp14: '\u2005', emsp: '\u2003', eng: '\u014b', ensp: '\u2002', eogon: '\u0119', eopf: '\ud835\udd56', epar: '\u22d5', eparsl: '\u29e3', eplus: '\u2a71', epsi: '\u03b5', epsilon: '\u03b5', epsiv: '\u03f5', straightepsilon: '\u03f5', varepsilon: '\u03f5', equals: '=', equest: '\u225f', questeq: '\u225f', equivDD: '\u2a78', eqvparsl: '\u29e5', erDot: '\u2253', risingdotseq: '\u2253', erarr: '\u2971', escr: '\u212f', eta: '\u03b7', eth: '\xf0', euml: '\xeb', euro: '\u20ac', excl: '!', fcy: '\u0444', female: '\u2640', ffilig: '\ufb03', fflig: '\ufb00', ffllig: '\ufb04', ffr: '\ud835\udd23', filig: '\ufb01', fjlig: 'fj', flat: '\u266d', fllig: '\ufb02', fltns: '\u25b1', fnof: '\u0192', fopf: '\ud835\udd57', fork: '\u22d4', pitchfork: '\u22d4', forkv: '\u2ad9', fpartint: '\u2a0d', frac12: '\xbd', half: '\xbd', frac13: '\u2153', frac14: '\xbc', frac15: '\u2155', frac16: '\u2159', frac18: '\u215b', frac23: '\u2154', frac25: '\u2156', frac34: '\xbe', frac35: '\u2157', frac38: '\u215c', frac45: '\u2158', frac56: '\u215a', frac58: '\u215d', frac78: '\u215e', frasl: '\u2044', frown: '\u2322', sfrown: '\u2322', fscr: '\ud835\udcbb', gEl: '\u2a8c', gtreqqless: '\u2a8c', gacute: '\u01f5', gamma: '\u03b3', gap: '\u2a86', gtrapprox: '\u2a86', gbreve: '\u011f', gcirc: '\u011d', gcy: '\u0433', gdot: '\u0121', gescc: '\u2aa9', gesdot: '\u2a80', gesdoto: '\u2a82', gesdotol: '\u2a84', gesl: '\u22db\ufe00', gesles: '\u2a94', gfr: '\ud835\udd24', gimel: '\u2137', gjcy: '\u0453', glE: '\u2a92', gla: '\u2aa5', glj: '\u2aa4', gnE: '\u2269', gneqq: '\u2269', gnap: '\u2a8a', gnapprox: '\u2a8a', gne: '\u2a88', gneq: '\u2a88', gnsim: '\u22e7', gopf: '\ud835\udd58', gscr: '\u210a', gsime: '\u2a8e', gsiml: '\u2a90', gtcc: '\u2aa7', gtcir: '\u2a7a', gtdot: '\u22d7', gtrdot: '\u22d7', gtlPar: '\u2995', gtquest: '\u2a7c', gtrarr: '\u2978', gvertneqq: '\u2269\ufe00', gvnE: '\u2269\ufe00', hardcy: '\u044a', harrcir: '\u2948', harrw: '\u21ad', leftrightsquigarrow: '\u21ad', hbar: '\u210f', hslash: '\u210f', planck: '\u210f', plankv: '\u210f', hcirc: '\u0125', hearts: '\u2665', heartsuit: '\u2665', hellip: '\u2026', mldr: '\u2026', hercon: '\u22b9', hfr: '\ud835\udd25', hksearow: '\u2925', searhk: '\u2925', hkswarow: '\u2926', swarhk: '\u2926', hoarr: '\u21ff', homtht: '\u223b', hookleftarrow: '\u21a9', larrhk: '\u21a9', hookrightarrow: '\u21aa', rarrhk: '\u21aa', hopf: '\ud835\udd59', horbar: '\u2015', hscr: '\ud835\udcbd', hstrok: '\u0127', hybull: '\u2043', iacute: '\xed', icirc: '\xee', icy: '\u0438', iecy: '\u0435', iexcl: '\xa1', ifr: '\ud835\udd26', igrave: '\xec', iiiint: '\u2a0c', qint: '\u2a0c', iiint: '\u222d', tint: '\u222d', iinfin: '\u29dc', iiota: '\u2129', ijlig: '\u0133', imacr: '\u012b', imath: '\u0131', inodot: '\u0131', imof: '\u22b7', imped: '\u01b5', incare: '\u2105', infin: '\u221e', infintie: '\u29dd', intcal: '\u22ba', intercal: '\u22ba', intlarhk: '\u2a17', intprod: '\u2a3c', iprod: '\u2a3c', iocy: '\u0451', iogon: '\u012f', iopf: '\ud835\udd5a', iota: '\u03b9', iquest: '\xbf', iscr: '\ud835\udcbe', isinE: '\u22f9', isindot: '\u22f5', isins: '\u22f4', isinsv: '\u22f3', itilde: '\u0129', iukcy: '\u0456', iuml: '\xef', jcirc: '\u0135', jcy: '\u0439', jfr: '\ud835\udd27', jmath: '\u0237', jopf: '\ud835\udd5b', jscr: '\ud835\udcbf', jsercy: '\u0458', jukcy: '\u0454', kappa: '\u03ba', kappav: '\u03f0', varkappa: '\u03f0', kcedil: '\u0137', kcy: '\u043a', kfr: '\ud835\udd28', kgreen: '\u0138', khcy: '\u0445', kjcy: '\u045c', kopf: '\ud835\udd5c', kscr: '\ud835\udcc0', lAtail: '\u291b', lBarr: '\u290e', lEg: '\u2a8b', lesseqqgtr: '\u2a8b', lHar: '\u2962', lacute: '\u013a', laemptyv: '\u29b4', lambda: '\u03bb', langd: '\u2991', lap: '\u2a85', lessapprox: '\u2a85', laquo: '\xab', larrbfs: '\u291f', larrfs: '\u291d', larrlp: '\u21ab', looparrowleft: '\u21ab', larrpl: '\u2939', larrsim: '\u2973', larrtl: '\u21a2', leftarrowtail: '\u21a2', lat: '\u2aab', latail: '\u2919', late: '\u2aad', lates: '\u2aad\ufe00', lbarr: '\u290c', lbbrk: '\u2772', lbrace: '{', lcub: '{', lbrack: '[', lsqb: '[', lbrke: '\u298b', lbrksld: '\u298f', lbrkslu: '\u298d', lcaron: '\u013e', lcedil: '\u013c', lcy: '\u043b', ldca: '\u2936', ldrdhar: '\u2967', ldrushar: '\u294b', ldsh: '\u21b2', le: '\u2264', leq: '\u2264', leftleftarrows: '\u21c7', llarr: '\u21c7', leftthreetimes: '\u22cb', lthree: '\u22cb', lescc: '\u2aa8', lesdot: '\u2a7f', lesdoto: '\u2a81', lesdotor: '\u2a83', lesg: '\u22da\ufe00', lesges: '\u2a93', lessdot: '\u22d6', ltdot: '\u22d6', lfisht: '\u297c', lfr: '\ud835\udd29', lgE: '\u2a91', lharul: '\u296a', lhblk: '\u2584', ljcy: '\u0459', llhard: '\u296b', lltri: '\u25fa', lmidot: '\u0140', lmoust: '\u23b0', lmoustache: '\u23b0', lnE: '\u2268', lneqq: '\u2268', lnap: '\u2a89', lnapprox: '\u2a89', lne: '\u2a87', lneq: '\u2a87', lnsim: '\u22e6', loang: '\u27ec', loarr: '\u21fd', longmapsto: '\u27fc', xmap: '\u27fc', looparrowright: '\u21ac', rarrlp: '\u21ac', lopar: '\u2985', lopf: '\ud835\udd5d', loplus: '\u2a2d', lotimes: '\u2a34', lowast: '\u2217', loz: '\u25ca', lozenge: '\u25ca', lpar: '(', lparlt: '\u2993', lrhard: '\u296d', lrm: '\u200e', lrtri: '\u22bf', lsaquo: '\u2039', lscr: '\ud835\udcc1', lsime: '\u2a8d', lsimg: '\u2a8f', lsquor: '\u201a', sbquo: '\u201a', lstrok: '\u0142', ltcc: '\u2aa6', ltcir: '\u2a79', ltimes: '\u22c9', ltlarr: '\u2976', ltquest: '\u2a7b', ltrPar: '\u2996', ltri: '\u25c3', triangleleft: '\u25c3', lurdshar: '\u294a', luruhar: '\u2966', lvertneqq: '\u2268\ufe00', lvnE: '\u2268\ufe00', mDDot: '\u223a', macr: '\xaf', strns: '\xaf', male: '\u2642', malt: '\u2720', maltese: '\u2720', marker: '\u25ae', mcomma: '\u2a29', mcy: '\u043c', mdash: '\u2014', mfr: '\ud835\udd2a', mho: '\u2127', micro: '\xb5', midcir: '\u2af0', minus: '\u2212', minusdu: '\u2a2a', mlcp: '\u2adb', models: '\u22a7', mopf: '\ud835\udd5e', mscr: '\ud835\udcc2', mu: '\u03bc', multimap: '\u22b8', mumap: '\u22b8', nGg: '\u22d9\u0338', nGt: '\u226b\u20d2', nLeftarrow: '\u21cd', nlArr: '\u21cd', nLeftrightarrow: '\u21ce', nhArr: '\u21ce', nLl: '\u22d8\u0338', nLt: '\u226a\u20d2', nRightarrow: '\u21cf', nrArr: '\u21cf', nVDash: '\u22af', nVdash: '\u22ae', nacute: '\u0144', nang: '\u2220\u20d2', napE: '\u2a70\u0338', napid: '\u224b\u0338', napos: '\u0149', natur: '\u266e', natural: '\u266e', ncap: '\u2a43', ncaron: '\u0148', ncedil: '\u0146', ncongdot: '\u2a6d\u0338', ncup: '\u2a42', ncy: '\u043d', ndash: '\u2013', neArr: '\u21d7', nearhk: '\u2924', nedot: '\u2250\u0338', nesear: '\u2928', toea: '\u2928', nfr: '\ud835\udd2b', nharr: '\u21ae', nleftrightarrow: '\u21ae', nhpar: '\u2af2', nis: '\u22fc', nisd: '\u22fa', njcy: '\u045a', nlE: '\u2266\u0338', nleqq: '\u2266\u0338', nlarr: '\u219a', nleftarrow: '\u219a', nldr: '\u2025', nopf: '\ud835\udd5f', not: '\xac', notinE: '\u22f9\u0338', notindot: '\u22f5\u0338', notinvb: '\u22f7', notinvc: '\u22f6', notnivb: '\u22fe', notnivc: '\u22fd', nparsl: '\u2afd\u20e5', npart: '\u2202\u0338', npolint: '\u2a14', nrarr: '\u219b', nrightarrow: '\u219b', nrarrc: '\u2933\u0338', nrarrw: '\u219d\u0338', nscr: '\ud835\udcc3', nsub: '\u2284', nsubE: '\u2ac5\u0338', nsubseteqq: '\u2ac5\u0338', nsup: '\u2285', nsupE: '\u2ac6\u0338', nsupseteqq: '\u2ac6\u0338', ntilde: '\xf1', nu: '\u03bd', num: '#', numero: '\u2116', numsp: '\u2007', nvDash: '\u22ad', nvHarr: '\u2904', nvap: '\u224d\u20d2', nvdash: '\u22ac', nvge: '\u2265\u20d2', nvgt: '>\u20d2', nvinfin: '\u29de', nvlArr: '\u2902', nvle: '\u2264\u20d2', nvlt: '<\u20d2', nvltrie: '\u22b4\u20d2', nvrArr: '\u2903', nvrtrie: '\u22b5\u20d2', nvsim: '\u223c\u20d2', nwArr: '\u21d6', nwarhk: '\u2923', nwnear: '\u2927', oacute: '\xf3', ocirc: '\xf4', ocy: '\u043e', odblac: '\u0151', odiv: '\u2a38', odsold: '\u29bc', oelig: '\u0153', ofcir: '\u29bf', ofr: '\ud835\udd2c', ogon: '\u02db', ograve: '\xf2', ogt: '\u29c1', ohbar: '\u29b5', olcir: '\u29be', olcross: '\u29bb', olt: '\u29c0', omacr: '\u014d', omega: '\u03c9', omicron: '\u03bf', omid: '\u29b6', oopf: '\ud835\udd60', opar: '\u29b7', operp: '\u29b9', or: '\u2228', vee: '\u2228', ord: '\u2a5d', order: '\u2134', orderof: '\u2134', oscr: '\u2134', ordf: '\xaa', ordm: '\xba', origof: '\u22b6', oror: '\u2a56', orslope: '\u2a57', orv: '\u2a5b', oslash: '\xf8', osol: '\u2298', otilde: '\xf5', otimesas: '\u2a36', ouml: '\xf6', ovbar: '\u233d', para: '\xb6', parsim: '\u2af3', parsl: '\u2afd', pcy: '\u043f', percnt: '%', period: '.', permil: '\u2030', pertenk: '\u2031', pfr: '\ud835\udd2d', phi: '\u03c6', phiv: '\u03d5', straightphi: '\u03d5', varphi: '\u03d5', phone: '\u260e', pi: '\u03c0', piv: '\u03d6', varpi: '\u03d6', planckh: '\u210e', plus: '+', plusacir: '\u2a23', pluscir: '\u2a22', plusdu: '\u2a25', pluse: '\u2a72', plussim: '\u2a26', plustwo: '\u2a27', pointint: '\u2a15', popf: '\ud835\udd61', pound: '\xa3', prE: '\u2ab3', prap: '\u2ab7', precapprox: '\u2ab7', precnapprox: '\u2ab9', prnap: '\u2ab9', precneqq: '\u2ab5', prnE: '\u2ab5', precnsim: '\u22e8', prnsim: '\u22e8', prime: '\u2032', profalar: '\u232e', profline: '\u2312', profsurf: '\u2313', prurel: '\u22b0', pscr: '\ud835\udcc5', psi: '\u03c8', puncsp: '\u2008', qfr: '\ud835\udd2e', qopf: '\ud835\udd62', qprime: '\u2057', qscr: '\ud835\udcc6', quatint: '\u2a16', quest: '?', rAtail: '\u291c', rHar: '\u2964', race: '\u223d\u0331', racute: '\u0155', raemptyv: '\u29b3', rangd: '\u2992', range: '\u29a5', raquo: '\xbb', rarrap: '\u2975', rarrbfs: '\u2920', rarrc: '\u2933', rarrfs: '\u291e', rarrpl: '\u2945', rarrsim: '\u2974', rarrtl: '\u21a3', rightarrowtail: '\u21a3', rarrw: '\u219d', rightsquigarrow: '\u219d', ratail: '\u291a', ratio: '\u2236', rbbrk: '\u2773', rbrace: '}', rcub: '}', rbrack: ']', rsqb: ']', rbrke: '\u298c', rbrksld: '\u298e', rbrkslu: '\u2990', rcaron: '\u0159', rcedil: '\u0157', rcy: '\u0440', rdca: '\u2937', rdldhar: '\u2969', rdsh: '\u21b3', rect: '\u25ad', rfisht: '\u297d', rfr: '\ud835\udd2f', rharul: '\u296c', rho: '\u03c1', rhov: '\u03f1', varrho: '\u03f1', rightrightarrows: '\u21c9', rrarr: '\u21c9', rightthreetimes: '\u22cc', rthree: '\u22cc', ring: '\u02da', rlm: '\u200f', rmoust: '\u23b1', rmoustache: '\u23b1', rnmid: '\u2aee', roang: '\u27ed', roarr: '\u21fe', ropar: '\u2986', ropf: '\ud835\udd63', roplus: '\u2a2e', rotimes: '\u2a35', rpar: ')', rpargt: '\u2994', rppolint: '\u2a12', rsaquo: '\u203a', rscr: '\ud835\udcc7', rtimes: '\u22ca', rtri: '\u25b9', triangleright: '\u25b9', rtriltri: '\u29ce', ruluhar: '\u2968', rx: '\u211e', sacute: '\u015b', scE: '\u2ab4', scap: '\u2ab8', succapprox: '\u2ab8', scaron: '\u0161', scedil: '\u015f', scirc: '\u015d', scnE: '\u2ab6', succneqq: '\u2ab6', scnap: '\u2aba', succnapprox: '\u2aba', scnsim: '\u22e9', succnsim: '\u22e9', scpolint: '\u2a13', scy: '\u0441', sdot: '\u22c5', sdote: '\u2a66', seArr: '\u21d8', sect: '\xa7', semi: ';', seswar: '\u2929', tosa: '\u2929', sext: '\u2736', sfr: '\ud835\udd30', sharp: '\u266f', shchcy: '\u0449', shcy: '\u0448', shy: '\xad', sigma: '\u03c3', sigmaf: '\u03c2', sigmav: '\u03c2', varsigma: '\u03c2', simdot: '\u2a6a', simg: '\u2a9e', simgE: '\u2aa0', siml: '\u2a9d', simlE: '\u2a9f', simne: '\u2246', simplus: '\u2a24', simrarr: '\u2972', smashp: '\u2a33', smeparsl: '\u29e4', smile: '\u2323', ssmile: '\u2323', smt: '\u2aaa', smte: '\u2aac', smtes: '\u2aac\ufe00', softcy: '\u044c', sol: '/', solb: '\u29c4', solbar: '\u233f', sopf: '\ud835\udd64', spades: '\u2660', spadesuit: '\u2660', sqcaps: '\u2293\ufe00', sqcups: '\u2294\ufe00', sscr: '\ud835\udcc8', star: '\u2606', sub: '\u2282', subset: '\u2282', subE: '\u2ac5', subseteqq: '\u2ac5', subdot: '\u2abd', subedot: '\u2ac3', submult: '\u2ac1', subnE: '\u2acb', subsetneqq: '\u2acb', subne: '\u228a', subsetneq: '\u228a', subplus: '\u2abf', subrarr: '\u2979', subsim: '\u2ac7', subsub: '\u2ad5', subsup: '\u2ad3', sung: '\u266a', sup1: '\xb9', sup2: '\xb2', sup3: '\xb3', supE: '\u2ac6', supseteqq: '\u2ac6', supdot: '\u2abe', supdsub: '\u2ad8', supedot: '\u2ac4', suphsol: '\u27c9', suphsub: '\u2ad7', suplarr: '\u297b', supmult: '\u2ac2', supnE: '\u2acc', supsetneqq: '\u2acc', supne: '\u228b', supsetneq: '\u228b', supplus: '\u2ac0', supsim: '\u2ac8', supsub: '\u2ad4', supsup: '\u2ad6', swArr: '\u21d9', swnwar: '\u292a', szlig: '\xdf', target: '\u2316', tau: '\u03c4', tcaron: '\u0165', tcedil: '\u0163', tcy: '\u0442', telrec: '\u2315', tfr: '\ud835\udd31', theta: '\u03b8', thetasym: '\u03d1', thetav: '\u03d1', vartheta: '\u03d1', thorn: '\xfe', times: '\xd7', timesbar: '\u2a31', timesd: '\u2a30', topbot: '\u2336', topcir: '\u2af1', topf: '\ud835\udd65', topfork: '\u2ada', tprime: '\u2034', triangle: '\u25b5', utri: '\u25b5', triangleq: '\u225c', trie: '\u225c', tridot: '\u25ec', triminus: '\u2a3a', triplus: '\u2a39', trisb: '\u29cd', tritime: '\u2a3b', trpezium: '\u23e2', tscr: '\ud835\udcc9', tscy: '\u0446', tshcy: '\u045b', tstrok: '\u0167', uHar: '\u2963', uacute: '\xfa', ubrcy: '\u045e', ubreve: '\u016d', ucirc: '\xfb', ucy: '\u0443', udblac: '\u0171', ufisht: '\u297e', ufr: '\ud835\udd32', ugrave: '\xf9', uhblk: '\u2580', ulcorn: '\u231c', ulcorner: '\u231c', ulcrop: '\u230f', ultri: '\u25f8', umacr: '\u016b', uogon: '\u0173', uopf: '\ud835\udd66', upsi: '\u03c5', upsilon: '\u03c5', upuparrows: '\u21c8', uuarr: '\u21c8', urcorn: '\u231d', urcorner: '\u231d', urcrop: '\u230e', uring: '\u016f', urtri: '\u25f9', uscr: '\ud835\udcca', utdot: '\u22f0', utilde: '\u0169', uuml: '\xfc', uwangle: '\u29a7', vBar: '\u2ae8', vBarv: '\u2ae9', vangrt: '\u299c', varsubsetneq: '\u228a\ufe00', vsubne: '\u228a\ufe00', varsubsetneqq: '\u2acb\ufe00', vsubnE: '\u2acb\ufe00', varsupsetneq: '\u228b\ufe00', vsupne: '\u228b\ufe00', varsupsetneqq: '\u2acc\ufe00', vsupnE: '\u2acc\ufe00', vcy: '\u0432', veebar: '\u22bb', veeeq: '\u225a', vellip: '\u22ee', vfr: '\ud835\udd33', vopf: '\ud835\udd67', vscr: '\ud835\udccb', vzigzag: '\u299a', wcirc: '\u0175', wedbar: '\u2a5f', wedgeq: '\u2259', weierp: '\u2118', wp: '\u2118', wfr: '\ud835\udd34', wopf: '\ud835\udd68', wscr: '\ud835\udccc', xfr: '\ud835\udd35', xi: '\u03be', xnis: '\u22fb', xopf: '\ud835\udd69', xscr: '\ud835\udccd', yacute: '\xfd', yacy: '\u044f', ycirc: '\u0177', ycy: '\u044b', yen: '\xa5', yfr: '\ud835\udd36', yicy: '\u0457', yopf: '\ud835\udd6a', yscr: '\ud835\udcce', yucy: '\u044e', yuml: '\xff', zacute: '\u017a', zcaron: '\u017e', zcy: '\u0437', zdot: '\u017c', zeta: '\u03b6', zfr: '\ud835\udd37', zhcy: '\u0436', zigrarr: '\u21dd', zopf: '\ud835\udd6b', zscr: '\ud835\udccf', zwj: '\u200d', zwnj: '\u200c' };
   yn.ngsp = '\ue500';
   var gn = null;
   var Dn = new (class e {
     static fromArray(t) {
      return t
       ? ((function (e, t) {
          if (null != t && (!Array.isArray(t) || 2 != t.length)) throw new Error(`Expected '${e}' to be an array, [start, end].`);
          if (null != t) {
           let e = t[0],
            r = t[1];
           gn.forEach((t) => {
            if (t.test(e) || t.test(r)) throw new Error(`['${e}', '${r}'] contains unusable interpolation symbol.`);
           });
          }
         })('interpolation', t),
         new e(t[0], t[1]))
       : Dn;
     }
     constructor(e, t) {
      (this.start = e), (this.end = t);
     }
    })('{{', '}}'),
    xn = class extends Er {
     constructor(e, t, r) {
      super(r, e), (this.tokenType = t);
     }
    },
    bn = class {
     constructor(e, t, r) {
      (this.tokens = e), (this.errors = t), (this.nonNormalizedIcuExpressions = r);
     }
    };
   var vn,
    En = /\r\n?/g;
   function Cn(e) {
    return `Unexpected character "${0 === e ? 'EOF' : String.fromCharCode(e)}"`;
   }
   function Tn(e) {
    return `Unknown entity "${e}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
   }
   !(function (e) {
    (e.HEX = 'hexadecimal'), (e.DEC = 'decimal');
   })(vn || (vn = {}));
   var Sn = class {
     constructor(e) {
      this.error = e;
     }
    },
    wn = class {
     constructor(e, t, r) {
      (this._getTagContentType = t), (this._currentTokenStart = null), (this._currentTokenType = null), (this._expansionCaseStack = []), (this._inInterpolation = !1), (this._fullNameStack = []), (this.tokens = []), (this.errors = []), (this.nonNormalizedIcuExpressions = []), (this._tokenizeIcu = r.tokenizeExpansionForms || !1), (this._interpolationConfig = r.interpolationConfig || Dn), (this._leadingTriviaCodePoints = r.leadingTriviaChars && r.leadingTriviaChars.map((e) => e.codePointAt(0) || 0)), (this._canSelfClose = r.canSelfClose || !1), (this._allowHtmComponentClosingTags = r.allowHtmComponentClosingTags || !1);
      let n = r.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
      (this._cursor = r.escapedString ? new On(e, n) : new Ln(e, n)), (this._preserveLineEndings = r.preserveLineEndings || !1), (this._i18nNormalizeLineEndingsInICUs = r.i18nNormalizeLineEndingsInICUs || !1), (this._tokenizeBlocks = r.tokenizeBlocks ?? !0);
      try {
       this._cursor.init();
      } catch (s) {
       this.handleError(s);
      }
     }
     _processCarriageReturns(e) {
      return this._preserveLineEndings ? e : e.replace(En, '\n');
     }
     tokenize() {
      for (; 0 !== this._cursor.peek(); ) {
       let t = this._cursor.clone();
       try {
        if (this._attemptCharCode(60))
         if (this._attemptCharCode(33)) this._attemptStr('[CDATA[') ? this._consumeCdata(t) : this._attemptStr('--') ? this._consumeComment(t) : this._attemptStrCaseInsensitive('doctype') ? this._consumeDocType(t) : this._consumeBogusComment(t);
         else if (this._attemptCharCode(47)) this._consumeTagClose(t);
         else {
          let e = this._cursor.clone();
          this._attemptCharCode(63) ? ((this._cursor = e), this._consumeBogusComment(t)) : this._consumeTagOpen(t);
         }
        else
         this._tokenizeBlocks && this._attemptCharCode(64)
          ? this._consumeBlockStart(t)
          : !this._tokenizeBlocks || this._inInterpolation || this._isInExpansionCase() || this._isInExpansionForm() || !this._attemptCharCode(125)
            ? (this._tokenizeIcu && this._tokenizeExpansionForm()) ||
              this._consumeWithInterpolation(
               5,
               8,
               () => this._isTextEnd(),
               () => this._isTagStart(),
              )
            : this._consumeBlockEnd(t);
       } catch (e) {
        this.handleError(e);
       }
      }
      this._beginToken(30), this._endToken([]);
     }
     _getBlockName() {
      let e = !1,
       t = this._cursor.clone();
      return this._attemptCharCodeUntilFn((t) => (pr(t) ? !e : !Bn(t) || ((e = !0), !1))), this._cursor.getChars(t).trim();
     }
     _consumeBlockStart(e) {
      this._beginToken(25, e);
      let t = this._endToken([this._getBlockName()]);
      if (40 === this._cursor.peek()) {
       if ((this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(An), !this._attemptCharCode(41))) return void (t.type = 29);
       this._attemptCharCodeUntilFn(An);
      }
      this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : (t.type = 29);
     }
     _consumeBlockEnd(e) {
      this._beginToken(27, e), this._endToken([]);
     }
     _consumeBlockParameters() {
      for (this._attemptCharCodeUntilFn(_n); 41 !== this._cursor.peek() && 0 !== this._cursor.peek(); ) {
       this._beginToken(28);
       let e = this._cursor.clone(),
        t = null,
        r = 0;
       for (; (59 !== this._cursor.peek() && 0 !== this._cursor.peek()) || null !== t; ) {
        let e = this._cursor.peek();
        if (92 === e) this._cursor.advance();
        else if (e === t) t = null;
        else if (null === t && mr(e)) t = e;
        else if (40 === e && null === t) r++;
        else if (41 === e && null === t) {
         if (0 === r) break;
         r > 0 && r--;
        }
        this._cursor.advance();
       }
       this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(_n);
      }
     }
     _tokenizeExpansionForm() {
      if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), !0;
      if (
       (function (e) {
        return 125 !== e;
       })(this._cursor.peek()) &&
       this._isInExpansionForm()
      )
       return this._consumeExpansionCaseStart(), !0;
      if (125 === this._cursor.peek()) {
       if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), !0;
       if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), !0;
      }
      return !1;
     }
     _beginToken(e, t = this._cursor.clone()) {
      (this._currentTokenStart = t), (this._currentTokenType = e);
     }
     _endToken(e, t) {
      if (null === this._currentTokenStart) throw new xn('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(t));
      if (null === this._currentTokenType) throw new xn('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));
      let r = { type: this._currentTokenType, parts: e, sourceSpan: (t ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
      return this.tokens.push(r), (this._currentTokenStart = null), (this._currentTokenType = null), r;
     }
     _createError(e, t) {
      this._isInExpansionForm() && (e += ' (Do you have an unescaped "{" in your template? Use "{{ \'{\' }}") to escape it.)');
      let r = new xn(e, this._currentTokenType, t);
      return (this._currentTokenStart = null), (this._currentTokenType = null), new Sn(r);
     }
     handleError(e) {
      if ((e instanceof Mn && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), !(e instanceof Sn))) throw e;
      this.errors.push(e.error);
     }
     _attemptCharCode(e) {
      return this._cursor.peek() === e && (this._cursor.advance(), !0);
     }
     _attemptCharCodeCaseInsensitive(e) {
      return (
       !!(function (e, t) {
        return Nn(e) === Nn(t);
       })(this._cursor.peek(), e) && (this._cursor.advance(), !0)
      );
     }
     _requireCharCode(e) {
      let t = this._cursor.clone();
      if (!this._attemptCharCode(e)) throw this._createError(Cn(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _attemptStr(e) {
      let t = e.length;
      if (this._cursor.charsLeft() < t) return !1;
      let r = this._cursor.clone();
      for (let n = 0; n < t; n++) if (!this._attemptCharCode(e.charCodeAt(n))) return (this._cursor = r), !1;
      return !0;
     }
     _attemptStrCaseInsensitive(e) {
      for (let t = 0; t < e.length; t++) if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t))) return !1;
      return !0;
     }
     _requireStr(e) {
      let t = this._cursor.clone();
      if (!this._attemptStr(e)) throw this._createError(Cn(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _requireStrCaseInsensitive(e) {
      let t = this._cursor.clone();
      if (!this._attemptStrCaseInsensitive(e)) throw this._createError(Cn(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _attemptCharCodeUntilFn(e) {
      for (; !e(this._cursor.peek()); ) this._cursor.advance();
     }
     _requireCharCodeUntilFn(e, t) {
      let r = this._cursor.clone();
      if ((this._attemptCharCodeUntilFn(e), this._cursor.diff(r) < t)) throw this._createError(Cn(this._cursor.peek()), this._cursor.getSpan(r));
     }
     _attemptUntilChar(e) {
      for (; this._cursor.peek() !== e; ) this._cursor.advance();
     }
     _readChar() {
      let e = String.fromCodePoint(this._cursor.peek());
      return this._cursor.advance(), e;
     }
     _consumeEntity(e) {
      this._beginToken(9);
      let t = this._cursor.clone();
      if ((this._cursor.advance(), this._attemptCharCode(35))) {
       let e = this._attemptCharCode(120) || this._attemptCharCode(88),
        r = this._cursor.clone();
       if ((this._attemptCharCodeUntilFn(Pn), 59 != this._cursor.peek())) {
        this._cursor.advance();
        let r = e ? vn.HEX : vn.DEC;
        throw this._createError(
         (function (e, t) {
          return `Unable to parse entity "${t}" - ${e} character reference entities must end with ";"`;
         })(r, this._cursor.getChars(t)),
         this._cursor.getSpan(),
        );
       }
       let n = this._cursor.getChars(r);
       this._cursor.advance();
       try {
        let r = parseInt(n, e ? 16 : 10);
        this._endToken([String.fromCharCode(r), this._cursor.getChars(t)]);
       } catch {
        throw this._createError(Tn(this._cursor.getChars(t)), this._cursor.getSpan());
       }
      } else {
       let r = this._cursor.clone();
       if ((this._attemptCharCodeUntilFn(In), 59 != this._cursor.peek())) this._beginToken(e, t), (this._cursor = r), this._endToken(['&']);
       else {
        let e = this._cursor.getChars(r);
        this._cursor.advance();
        let n = yn[e];
        if (!n) throw this._createError(Tn(e), this._cursor.getSpan(t));
        this._endToken([n, `&${e};`]);
       }
      }
     }
     _consumeRawText(e, t) {
      this._beginToken(e ? 6 : 7);
      let r = [];
      for (;;) {
       let n = this._cursor.clone(),
        s = t();
       if (((this._cursor = n), s)) break;
       e && 38 === this._cursor.peek() ? (this._endToken([this._processCarriageReturns(r.join(''))]), (r.length = 0), this._consumeEntity(6), this._beginToken(6)) : r.push(this._readChar());
      }
      this._endToken([this._processCarriageReturns(r.join(''))]);
     }
     _consumeComment(e) {
      this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr('--\x3e')), this._beginToken(11), this._requireStr('--\x3e'), this._endToken([]);
     }
     _consumeBogusComment(e) {
      this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => 62 === this._cursor.peek()), this._beginToken(11), this._cursor.advance(), this._endToken([]);
     }
     _consumeCdata(e) {
      this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr(']]>')), this._beginToken(13), this._requireStr(']]>'), this._endToken([]);
     }
     _consumeDocType(e) {
      this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => 62 === this._cursor.peek()), this._beginToken(19), this._cursor.advance(), this._endToken([]);
     }
     _consumePrefixAndName() {
      let e,
       t = this._cursor.clone(),
       r = '';
      for (; 58 !== this._cursor.peek() && !kn(this._cursor.peek()); ) this._cursor.advance();
      return 58 === this._cursor.peek() ? ((r = this._cursor.getChars(t)), this._cursor.advance(), (e = this._cursor.clone())) : (e = t), this._requireCharCodeUntilFn(Fn, '' === r ? 0 : 1), [r, this._cursor.getChars(e)];
     }
     _consumeTagOpen(e) {
      let t,
       r,
       n,
       s = [];
      try {
       if (!hr(this._cursor.peek())) throw this._createError(Cn(this._cursor.peek()), this._cursor.getSpan(e));
       for (n = this._consumeTagOpenStart(e), r = n.parts[0], t = n.parts[1], this._attemptCharCodeUntilFn(An); 47 !== this._cursor.peek() && 62 !== this._cursor.peek() && 60 !== this._cursor.peek() && 0 !== this._cursor.peek(); ) {
        let [e, t] = this._consumeAttributeName();
        if ((this._attemptCharCodeUntilFn(An), this._attemptCharCode(61))) {
         this._attemptCharCodeUntilFn(An);
         let r = this._consumeAttributeValue();
         s.push({ prefix: e, name: t, value: r });
        } else s.push({ prefix: e, name: t });
        this._attemptCharCodeUntilFn(An);
       }
       this._consumeTagOpenEnd();
      } catch (a) {
       if (a instanceof Sn) return void (n ? (n.type = 4) : (this._beginToken(5, e), this._endToken(['<'])));
       throw a;
      }
      if (this._canSelfClose && 2 === this.tokens[this.tokens.length - 1].type) return;
      let i = this._getTagContentType(t, r, this._fullNameStack.length > 0, s);
      this._handleFullNameStackForTagOpen(r, t), i === Or.RAW_TEXT ? this._consumeRawTextWithTagClose(r, t, !1) : i === Or.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r, t, !0);
     }
     _consumeRawTextWithTagClose(e, t, r) {
      this._consumeRawText(r, () => !!(this._attemptCharCode(60) && this._attemptCharCode(47) && (this._attemptCharCodeUntilFn(An), this._attemptStrCaseInsensitive(e ? `${e}:${t}` : t))) && (this._attemptCharCodeUntilFn(An), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((e) => 62 === e, 3), this._cursor.advance(), this._endToken([e, t]), this._handleFullNameStackForTagClose(e, t);
     }
     _consumeTagOpenStart(e) {
      this._beginToken(0, e);
      let t = this._consumePrefixAndName();
      return this._endToken(t);
     }
     _consumeAttributeName() {
      let e = this._cursor.peek();
      if (39 === e || 34 === e) throw this._createError(Cn(e), this._cursor.getSpan());
      this._beginToken(14);
      let t = this._consumePrefixAndName();
      return this._endToken(t), t;
     }
     _consumeAttributeValue() {
      let e;
      if (39 === this._cursor.peek() || 34 === this._cursor.peek()) {
       let t = this._cursor.peek();
       this._consumeQuote(t);
       let r = () => this._cursor.peek() === t;
       (e = this._consumeWithInterpolation(16, 17, r, r)), this._consumeQuote(t);
      } else {
       let t = () => Fn(this._cursor.peek());
       e = this._consumeWithInterpolation(16, 17, t, t);
      }
      return e;
     }
     _consumeQuote(e) {
      this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
     }
     _consumeTagOpenEnd() {
      let e = this._attemptCharCode(47) ? 2 : 1;
      this._beginToken(e), this._requireCharCode(62), this._endToken([]);
     }
     _consumeTagClose(e) {
      if ((this._beginToken(3, e), this._attemptCharCodeUntilFn(An), this._allowHtmComponentClosingTags && this._attemptCharCode(47))) this._attemptCharCodeUntilFn(An), this._requireCharCode(62), this._endToken([]);
      else {
       let [e, t] = this._consumePrefixAndName();
       this._attemptCharCodeUntilFn(An), this._requireCharCode(62), this._endToken([e, t]), this._handleFullNameStackForTagClose(e, t);
      }
     }
     _consumeExpansionFormStart() {
      this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
      let e = this._readUntil(44),
       t = this._processCarriageReturns(e);
      if (this._i18nNormalizeLineEndingsInICUs) this._endToken([t]);
      else {
       let r = this._endToken([e]);
       t !== e && this.nonNormalizedIcuExpressions.push(r);
      }
      this._requireCharCode(44), this._attemptCharCodeUntilFn(An), this._beginToken(7);
      let r = this._readUntil(44);
      this._endToken([r]), this._requireCharCode(44), this._attemptCharCodeUntilFn(An);
     }
     _consumeExpansionCaseStart() {
      this._beginToken(21);
      let e = this._readUntil(123).trim();
      this._endToken([e]), this._attemptCharCodeUntilFn(An), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(An), this._expansionCaseStack.push(22);
     }
     _consumeExpansionCaseEnd() {
      this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(An), this._expansionCaseStack.pop();
     }
     _consumeExpansionFormEnd() {
      this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
     }
     _consumeWithInterpolation(e, t, r, n) {
      this._beginToken(e);
      let s = [];
      for (; !r(); ) {
       let r = this._cursor.clone();
       this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(s.join(''))], r), (s.length = 0), this._consumeInterpolation(t, r, n), this._beginToken(e)) : 38 === this._cursor.peek() ? (this._endToken([this._processCarriageReturns(s.join(''))]), (s.length = 0), this._consumeEntity(e), this._beginToken(e)) : s.push(this._readChar());
      }
      this._inInterpolation = !1;
      let i = this._processCarriageReturns(s.join(''));
      return this._endToken([i]), i;
     }
     _consumeInterpolation(e, t, r) {
      let n = [];
      this._beginToken(e, t), n.push(this._interpolationConfig.start);
      let s = this._cursor.clone(),
       i = null,
       a = !1;
      for (; 0 !== this._cursor.peek() && (null === r || !r()); ) {
       let e = this._cursor.clone();
       if (this._isTagStart()) return (this._cursor = e), n.push(this._getProcessedChars(s, e)), void this._endToken(n);
       if (null === i) {
        if (this._attemptStr(this._interpolationConfig.end)) return n.push(this._getProcessedChars(s, e)), n.push(this._interpolationConfig.end), void this._endToken(n);
        this._attemptStr('//') && (a = !0);
       }
       let t = this._cursor.peek();
       this._cursor.advance(), 92 === t ? this._cursor.advance() : t === i ? (i = null) : !a && null === i && mr(t) && (i = t);
      }
      n.push(this._getProcessedChars(s, this._cursor)), this._endToken(n);
     }
     _getProcessedChars(e, t) {
      return this._processCarriageReturns(t.getChars(e));
     }
     _isTextEnd() {
      return !!(this._isTagStart() || 0 === this._cursor.peek() || (this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || (125 === this._cursor.peek() && this._isInExpansionCase()))) || (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || 125 === this._cursor.peek())));
     }
     _isTagStart() {
      if (60 === this._cursor.peek()) {
       let e = this._cursor.clone();
       e.advance();
       let t = e.peek();
       if ((97 <= t && t <= 122) || (65 <= t && t <= 90) || 47 === t || 33 === t) return !0;
      }
      return !1;
     }
     _isBlockStart() {
      if (this._tokenizeBlocks && 64 === this._cursor.peek()) {
       let e = this._cursor.clone();
       if ((e.advance(), Bn(e.peek()))) return !0;
      }
      return !1;
     }
     _readUntil(e) {
      let t = this._cursor.clone();
      return this._attemptUntilChar(e), this._cursor.getChars(t);
     }
     _isInExpansion() {
      return this._isInExpansionCase() || this._isInExpansionForm();
     }
     _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && 22 === this._expansionCaseStack[this._expansionCaseStack.length - 1];
     }
     _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && 20 === this._expansionCaseStack[this._expansionCaseStack.length - 1];
     }
     isExpansionFormStart() {
      if (123 !== this._cursor.peek()) return !1;
      if (this._interpolationConfig) {
       let e = this._cursor.clone(),
        t = this._attemptStr(this._interpolationConfig.start);
       return (this._cursor = e), !t;
      }
      return !0;
     }
     _handleFullNameStackForTagOpen(e, t) {
      let r = zr(e, t);
      (0 === this._fullNameStack.length || this._fullNameStack[this._fullNameStack.length - 1] === r) && this._fullNameStack.push(r);
     }
     _handleFullNameStackForTagClose(e, t) {
      let r = zr(e, t);
      0 !== this._fullNameStack.length && this._fullNameStack[this._fullNameStack.length - 1] === r && this._fullNameStack.pop();
     }
    };
   function An(e) {
    return !pr(e) || 0 === e;
   }
   function Fn(e) {
    return pr(e) || 62 === e || 60 === e || 47 === e || 39 === e || 34 === e || 61 === e || 0 === e;
   }
   function kn(e) {
    return (e < 97 || 122 < e) && (e < 65 || 90 < e) && (e < 48 || e > 57);
   }
   function Pn(e) {
    return (
     59 === e ||
     0 === e ||
     !(function (e) {
      return (e >= 97 && e <= 102) || (e >= 65 && e <= 70) || cr(e);
     })(e)
    );
   }
   function In(e) {
    return 59 === e || 0 === e || !hr(e);
   }
   function Nn(e) {
    return e >= 97 && e <= 122 ? e - 97 + 65 : e;
   }
   function Bn(e) {
    return hr(e) || cr(e) || 95 === e;
   }
   function _n(e) {
    return 59 !== e && An(e);
   }
   var Ln = class e {
     constructor(t, r) {
      if (t instanceof e) {
       (this.file = t.file), (this.input = t.input), (this.end = t.end);
       let e = t.state;
       this.state = { peek: e.peek, offset: e.offset, line: e.line, column: e.column };
      } else {
       if (!r) throw new Error('Programming error: the range argument must be provided with a file argument.');
       (this.file = t), (this.input = t.content), (this.end = r.endPos), (this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol });
      }
     }
     clone() {
      return new e(this);
     }
     peek() {
      return this.state.peek;
     }
     charsLeft() {
      return this.end - this.state.offset;
     }
     diff(e) {
      return this.state.offset - e.state.offset;
     }
     advance() {
      this.advanceState(this.state);
     }
     init() {
      this.updatePeek(this.state);
     }
     getSpan(e, t) {
      let r = (e = e || this);
      if (t) for (; this.diff(e) > 0 && -1 !== t.indexOf(e.peek()); ) r === e && (e = e.clone()), e.advance();
      let n = this.locationFromCursor(e),
       s = this.locationFromCursor(this),
       i = r !== e ? this.locationFromCursor(r) : n;
      return new vr(n, s, i);
     }
     getChars(e) {
      return this.input.substring(e.state.offset, this.state.offset);
     }
     charAt(e) {
      return this.input.charCodeAt(e);
     }
     advanceState(e) {
      if (e.offset >= this.end) throw ((this.state = e), new Mn('Unexpected character "EOF"', this));
      let t = this.charAt(e.offset);
      10 === t ? (e.line++, (e.column = 0)) : dr(t) || e.column++, e.offset++, this.updatePeek(e);
     }
     updatePeek(e) {
      e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
     }
     locationFromCursor(e) {
      return new xr(e.file, e.state.offset, e.state.line, e.state.column);
     }
    },
    On = class e extends Ln {
     constructor(t, r) {
      t instanceof e ? (super(t), (this.internalState = { ...t.internalState })) : (super(t, r), (this.internalState = this.state));
     }
     advance() {
      (this.state = this.internalState), super.advance(), this.processEscapeSequence();
     }
     init() {
      super.init(), this.processEscapeSequence();
     }
     clone() {
      return new e(this);
     }
     getChars(e) {
      let t = e.clone(),
       r = '';
      for (; t.internalState.offset < this.internalState.offset; ) (r += String.fromCodePoint(t.peek())), t.advance();
      return r;
     }
     processEscapeSequence() {
      let e = () => this.internalState.peek;
      if (92 === e())
       if (((this.internalState = { ...this.state }), this.advanceState(this.internalState), 110 === e())) this.state.peek = 10;
       else if (114 === e()) this.state.peek = 13;
       else if (118 === e()) this.state.peek = 11;
       else if (116 === e()) this.state.peek = 9;
       else if (98 === e()) this.state.peek = 8;
       else if (102 === e()) this.state.peek = 12;
       else if (117 === e())
        if ((this.advanceState(this.internalState), 123 === e())) {
         this.advanceState(this.internalState);
         let t = this.clone(),
          r = 0;
         for (; 125 !== e(); ) this.advanceState(this.internalState), r++;
         this.state.peek = this.decodeHexDigits(t, r);
        } else {
         let e = this.clone();
         this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), (this.state.peek = this.decodeHexDigits(e, 4));
        }
       else if (120 === e()) {
        this.advanceState(this.internalState);
        let e = this.clone();
        this.advanceState(this.internalState), (this.state.peek = this.decodeHexDigits(e, 2));
       } else if (fr(e())) {
        let t = '',
         r = 0,
         n = this.clone();
        for (; fr(e()) && r < 3; ) (n = this.clone()), (t += String.fromCodePoint(e())), this.advanceState(this.internalState), r++;
        (this.state.peek = parseInt(t, 8)), (this.internalState = n.internalState);
       } else dr(this.internalState.peek) ? (this.advanceState(this.internalState), (this.state = this.internalState)) : (this.state.peek = this.internalState.peek);
     }
     decodeHexDigits(e, t) {
      let r = this.input.slice(e.internalState.offset, e.internalState.offset + t),
       n = parseInt(r, 16);
      if (isNaN(n)) throw ((e.state = e.internalState), new Mn('Invalid hexadecimal escape sequence', e));
      return n;
     }
    },
    Mn = class {
     constructor(e, t) {
      (this.msg = e), (this.cursor = t);
     }
    },
    jn = class e extends Er {
     static create(t, r, n) {
      return new e(t, r, n);
     }
     constructor(e, t, r) {
      super(t, r), (this.elementName = e);
     }
    },
    Rn = class {
     constructor(e, t) {
      (this.rootNodes = e), (this.errors = t);
     }
    },
    qn = class {
     constructor(e) {
      this.getTagDefinition = e;
     }
     parse(e, t, r, n = !1, s) {
      let i =
        (e) =>
        (t, ...r) =>
         e(t.toLowerCase(), ...r),
       a = n ? this.getTagDefinition : i(this.getTagDefinition),
       o = (e) => a(e).getContentType(),
       u = n ? s : i(s),
       l = (function (e, t, r, n = {}) {
        let s = new wn(new br(e, t), r, n);
        return (
         s.tokenize(),
         new bn(
          (function (e) {
           let t,
            r = [];
           for (let n = 0; n < e.length; n++) {
            let s = e[n];
            (t && 5 === t.type && 5 === s.type) || (t && 16 === t.type && 16 === s.type) ? ((t.parts[0] += s.parts[0]), (t.sourceSpan.end = s.sourceSpan.end)) : ((t = s), r.push(t));
           }
           return r;
          })(s.tokens),
          s.errors,
          s.nonNormalizedIcuExpressions,
         )
        );
       })(
        e,
        t,
        s
         ? (e, t, r, n) => {
            let s = u(e, t, r, n);
            return void 0 !== s ? s : o(e);
           }
         : o,
        r,
       ),
       p = (r && r.canSelfClose) || !1,
       c = (r && r.allowHtmComponentClosingTags) || !1,
       h = new Un(l.tokens, a, p, c, n);
      return h.build(), new Rn(h.rootNodes, l.errors.concat(h.errors));
     }
    },
    Un = class e {
     constructor(e, t, r, n, s) {
      (this.tokens = e), (this.getTagDefinition = t), (this.canSelfClose = r), (this.allowHtmComponentClosingTags = n), (this.isTagNameCaseSensitive = s), (this._index = -1), (this._containerStack = []), (this.rootNodes = []), (this.errors = []), this._advance();
     }
     build() {
      for (; 30 !== this._peek.type; ) 0 === this._peek.type || 4 === this._peek.type ? this._consumeStartTag(this._advance()) : 3 === this._peek.type ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : 12 === this._peek.type ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : 10 === this._peek.type ? (this._closeVoidElement(), this._consumeComment(this._advance())) : 5 === this._peek.type || 7 === this._peek.type || 6 === this._peek.type ? (this._closeVoidElement(), this._consumeText(this._advance())) : 20 === this._peek.type ? this._consumeExpansion(this._advance()) : 25 === this._peek.type ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : 27 === this._peek.type ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : 29 === this._peek.type ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : 18 === this._peek.type ? this._consumeDocType(this._advance()) : this._advance();
      for (let e of this._containerStack) e instanceof hn && this.errors.push(jn.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
     }
     _advance() {
      let e = this._peek;
      return this._index < this.tokens.length - 1 && this._index++, (this._peek = this.tokens[this._index]), e;
     }
     _advanceIf(e) {
      return this._peek.type === e ? this._advance() : null;
     }
     _consumeCdata(e) {
      let t = this._advance(),
       r = this._getText(t),
       n = this._advanceIf(13);
      this._addToParent(new sn(r, new vr(e.sourceSpan.start, (n || t).sourceSpan.end), [t]));
     }
     _consumeComment(e) {
      let t = this._advanceIf(7),
       r = this._advanceIf(11),
       n = null != t ? t.parts[0].trim() : null,
       s = new vr(e.sourceSpan.start, (r || t || e).sourceSpan.end);
      this._addToParent(new pn(n, s));
     }
     _consumeDocType(e) {
      let t = this._advanceIf(7),
       r = this._advanceIf(19),
       n = null != t ? t.parts[0].trim() : null,
       s = new vr(e.sourceSpan.start, (r || t || e).sourceSpan.end);
      this._addToParent(new cn(n, s));
     }
     _consumeExpansion(e) {
      let t = this._advance(),
       r = this._advance(),
       n = [];
      for (; 21 === this._peek.type; ) {
       let e = this._parseExpansionCase();
       if (!e) return;
       n.push(e);
      }
      if (24 !== this._peek.type) return void this.errors.push(jn.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      let s = new vr(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
      this._addToParent(new an(t.parts[0], r.parts[0], n, s, t.sourceSpan)), this._advance();
     }
     _parseExpansionCase() {
      let t = this._advance();
      if (22 !== this._peek.type) return this.errors.push(jn.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
      let r = this._advance(),
       n = this._collectExpansionExpTokens(r);
      if (!n) return null;
      let s = this._advance();
      n.push({ type: 30, parts: [], sourceSpan: s.sourceSpan });
      let i = new e(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
      if ((i.build(), i.errors.length > 0)) return (this.errors = this.errors.concat(i.errors)), null;
      let a = new vr(t.sourceSpan.start, s.sourceSpan.end, t.sourceSpan.fullStart),
       o = new vr(r.sourceSpan.start, s.sourceSpan.end, r.sourceSpan.fullStart);
      return new on(t.parts[0], i.rootNodes, a, t.sourceSpan, o);
     }
     _collectExpansionExpTokens(e) {
      let t = [],
       r = [22];
      for (;;) {
       if (((20 === this._peek.type || 22 === this._peek.type) && r.push(this._peek.type), 23 === this._peek.type)) {
        if (!$n(r, 22)) return this.errors.push(jn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if ((r.pop(), 0 === r.length)) return t;
       }
       if (24 === this._peek.type) {
        if (!$n(r, 20)) return this.errors.push(jn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        r.pop();
       }
       if (30 === this._peek.type) return this.errors.push(jn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
       t.push(this._advance());
      }
     }
     _getText(e) {
      let t = e.parts[0];
      if (t.length > 0 && '\n' == t[0]) {
       let e = this._getClosestParentElement();
       null != e && 0 == e.children.length && this.getTagDefinition(e.name).ignoreFirstLf && (t = t.substring(1));
      }
      return t;
     }
     _consumeText(e) {
      let t = [e],
       r = e.sourceSpan,
       n = e.parts[0];
      if (n.length > 0 && '\n' === n[0]) {
       let r = this._getContainer();
       null != r && 0 === r.children.length && this.getTagDefinition(r.name).ignoreFirstLf && ((n = n.substring(1)), (t[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [n] }));
      }
      for (; 8 === this._peek.type || 5 === this._peek.type || 9 === this._peek.type; ) (e = this._advance()), t.push(e), 8 === e.type ? (n += e.parts.join('').replace(/&([^;]+);/g, Hn)) : 9 === e.type ? (n += e.parts[0]) : (n += e.parts.join(''));
      if (n.length > 0) {
       let s = e.sourceSpan;
       this._addToParent(new nn(n, new vr(r.start, s.end, r.fullStart, r.details), t));
      }
     }
     _closeVoidElement() {
      let e = this._getContainer();
      e instanceof ln && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
     }
     _consumeStartTag(e) {
      let [t, r] = e.parts,
       n = [];
      for (; 14 === this._peek.type; ) n.push(this._consumeAttr(this._advance()));
      let s = this._getElementFullName(t, r, this._getClosestParentElement()),
       i = !1;
      if (2 === this._peek.type) {
       this._advance(), (i = !0);
       let t = this.getTagDefinition(s);
       this.canSelfClose || t.canSelfClose || null !== Hr(s) || t.isVoid || this.errors.push(jn.create(s, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
      } else 1 === this._peek.type && (this._advance(), (i = !1));
      let a = this._peek.sourceSpan.fullStart,
       o = new vr(e.sourceSpan.start, a, e.sourceSpan.fullStart),
       u = new vr(e.sourceSpan.start, a, e.sourceSpan.fullStart),
       l = new vr(e.sourceSpan.start.moveBy(1), e.sourceSpan.end),
       p = new ln(s, n, [], o, u, void 0, l),
       c = this._getContainer();
      this._pushContainer(p, c instanceof ln && this.getTagDefinition(c.name).isClosedByChild(p.name)), i ? this._popContainer(s, ln, o) : 4 === e.type && (this._popContainer(s, ln, null), this.errors.push(jn.create(s, o, `Opening tag "${s}" not terminated.`)));
     }
     _pushContainer(e, t) {
      t && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
     }
     _consumeEndTag(e) {
      let t = this.allowHtmComponentClosingTags && 0 === e.parts.length ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
      if (t && this.getTagDefinition(t).isVoid) this.errors.push(jn.create(t, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
      else if (!this._popContainer(t, ln, e.sourceSpan)) {
       let r = `Unexpected closing tag "${t}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
       this.errors.push(jn.create(t, e.sourceSpan, r));
      }
     }
     _popContainer(e, t, r) {
      let n = !1;
      for (let s = this._containerStack.length - 1; s >= 0; s--) {
       let i = this._containerStack[s];
       if (Hr(i.name) ? i.name === e : (null == e || i.name.toLowerCase() === e.toLowerCase()) && i instanceof t) return (i.endSourceSpan = r), (i.sourceSpan.end = null !== r ? r.end : i.sourceSpan.end), this._containerStack.splice(s, this._containerStack.length - s), !n;
       (i instanceof hn || (i instanceof ln && !this.getTagDefinition(i.name).closedByParent)) && (n = !0);
      }
      return !1;
     }
     _consumeAttr(e) {
      let t,
       r = zr(e.parts[0], e.parts[1]),
       n = e.sourceSpan.end;
      15 === this._peek.type && (t = this._advance());
      let s,
       i,
       a = '',
       o = [];
      if (16 === this._peek.type)
       for (s = this._peek.sourceSpan, i = this._peek.sourceSpan.end; 16 === this._peek.type || 17 === this._peek.type || 9 === this._peek.type; ) {
        let e = this._advance();
        o.push(e), 17 === e.type ? (a += e.parts.join('').replace(/&([^;]+);/g, Hn)) : 9 === e.type ? (a += e.parts[0]) : (a += e.parts.join('')), (i = n = e.sourceSpan.end);
       }
      15 === this._peek.type && (i = n = this._advance().sourceSpan.end);
      let u = s && i && new vr((null == t ? void 0 : t.sourceSpan.start) ?? s.start, i, (null == t ? void 0 : t.sourceSpan.fullStart) ?? s.fullStart);
      return new un(r, a, new vr(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, u, o.length > 0 ? o : void 0, void 0);
     }
     _consumeBlockOpen(e) {
      let t = [];
      for (; 28 === this._peek.type; ) {
       let e = this._advance();
       t.push(new dn(e.parts[0], e.sourceSpan));
      }
      26 === this._peek.type && this._advance();
      let r = this._peek.sourceSpan.fullStart,
       n = new vr(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       s = new vr(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       i = new hn(e.parts[0], t, [], n, s);
      this._pushContainer(i, !1);
     }
     _consumeBlockClose(e) {
      this._popContainer(null, hn, e.sourceSpan) || this.errors.push(jn.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
     }
     _consumeIncompleteBlock(e) {
      let t = [];
      for (; 28 === this._peek.type; ) {
       let e = this._advance();
       t.push(new dn(e.parts[0], e.sourceSpan));
      }
      let r = this._peek.sourceSpan.fullStart,
       n = new vr(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       s = new vr(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       i = new hn(e.parts[0], t, [], n, s);
      this._pushContainer(i, !1), this._popContainer(null, hn, null), this.errors.push(jn.create(e.parts[0], n, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
     }
     _getContainer() {
      return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
     }
     _getClosestParentElement() {
      for (let e = this._containerStack.length - 1; e > -1; e--) if (this._containerStack[e] instanceof ln) return this._containerStack[e];
      return null;
     }
     _addToParent(e) {
      let t = this._getContainer();
      null === t ? this.rootNodes.push(e) : t.children.push(e);
     }
     _getElementFullName(e, t, r) {
      if ('' === e && '' === (e = this.getTagDefinition(t).implicitNamespacePrefix || '') && null != r) {
       let t = qr(r.name)[1];
       this.getTagDefinition(t).preventNamespaceInheritance || (e = Hr(r.name));
      }
      return zr(e, t);
     }
    };
   function $n(e, t) {
    return e.length > 0 && e[e.length - 1] === t;
   }
   function Hn(e, t) {
    return void 0 !== yn[t] ? yn[t] || e : /^#x[a-f0-9]+$/i.test(t) ? String.fromCodePoint(parseInt(t.slice(2), 16)) : /^#\d+$/.test(t) ? String.fromCodePoint(parseInt(t.slice(1), 10)) : e;
   }
   var zn = class extends qn {
     constructor() {
      super(tn);
     }
     parse(e, t, r, n = !1, s) {
      return super.parse(e, t, r, n, s);
     }
    },
    Vn = null,
    Wn = () => (Vn || (Vn = new zn()), Vn);
   function Jn(e, t = {}) {
    let { canSelfClose: r = !1, allowHtmComponentClosingTags: n = !1, isTagNameCaseSensitive: s = !1, getTagContentType: i, tokenizeAngularBlocks: a = !1 } = t;
    return Wn().parse(e, 'angular-html-parser', { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: a }, s, i);
   }
   var Kn = function (e, t) {
     let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
     return Object.assign(r, t);
    },
    Gn = 3;
   var Xn = function (e) {
     let t = (function (e) {
      let t = e.slice(0, Gn);
      if ('---' !== t && '+++' !== t) return;
      let r = e.indexOf('\n', Gn);
      if (-1 === r) return;
      let n = e.slice(Gn, r).trim(),
       s = e.indexOf(`\n${t}`, r),
       i = n;
      if ((i || (i = '+++' === t ? 'toml' : 'yaml'), -1 === s && '---' === t && 'yaml' === i && (s = e.indexOf('\n...', r)), -1 === s)) return;
      let a = s + 1 + Gn,
       o = e.charAt(a + 1);
      if (!/\s?/.test(o)) return;
      let u = e.slice(0, a);
      return { type: 'front-matter', language: i, explicitLanguage: n, value: e.slice(r + 1, s), startDelimiter: t, endDelimiter: u.slice(-Gn), raw: u };
     })(e);
     if (!t) return { content: e };
     let { raw: r } = t;
     return { frontMatter: t, content: l(!1, r, /[^\n]/g, ' ') + e.slice(r.length) };
    },
    Yn = { attrs: !0, children: !0, cases: !0, expression: !0 },
    Qn = new Set(['parent']),
    Zn = class e {
     constructor(e = {}) {
      for (let t of new Set([...Qn, ...Object.keys(e)])) this.setProperty(t, e[t]);
     }
     setProperty(e, t) {
      if (this[e] !== t) {
       if ((e in Yn && (t = t.map((e) => this.createChild(e))), !Qn.has(e))) return void (this[e] = t);
       Object.defineProperty(this, e, { value: t, enumerable: !1, configurable: !0 });
      }
     }
     map(t) {
      let r;
      for (let n in Yn) {
       let s = this[n];
       if (s) {
        let i = es(s, (e) => e.map(t));
        r !== s && (r || (r = new e({ parent: this.parent })), r.setProperty(n, i));
       }
      }
      if (r) for (let e in this) e in Yn || (r[e] = this[e]);
      return t(r || this);
     }
     walk(e) {
      for (let t in Yn) {
       let r = this[t];
       if (r) for (let t = 0; t < r.length; t++) r[t].walk(e);
      }
      e(this);
     }
     createChild(t) {
      let r = t instanceof e ? t.clone() : new e(t);
      return r.setProperty('parent', this), r;
     }
     insertChildBefore(e, t) {
      this.children.splice(this.children.indexOf(e), 0, this.createChild(t));
     }
     removeChild(e) {
      this.children.splice(this.children.indexOf(e), 1);
     }
     replaceChild(e, t) {
      this.children[this.children.indexOf(e)] = this.createChild(t);
     }
     clone() {
      return new e(this);
     }
     get firstChild() {
      var e;
      return null == (e = this.children) ? void 0 : e[0];
     }
     get lastChild() {
      var e;
      return null == (e = this.children) ? void 0 : e[this.children.length - 1];
     }
     get prev() {
      var e, t;
      return null == (t = null == (e = this.parent) ? void 0 : e.children) ? void 0 : t[this.parent.children.indexOf(this) - 1];
     }
     get next() {
      var e, t;
      return null == (t = null == (e = this.parent) ? void 0 : e.children) ? void 0 : t[this.parent.children.indexOf(this) + 1];
     }
     get rawName() {
      return this.hasExplicitNamespace ? this.fullName : this.name;
     }
     get fullName() {
      return this.namespace ? this.namespace + ':' + this.name : this.name;
     }
     get attrMap() {
      return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
     }
    };
   function es(e, t) {
    let r = e.map(t);
    return r.some((t, r) => t !== e[r]) ? r : e;
   }
   var ts = [
    {
     regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s,
     parse: function (e, t, r) {
      let [, n, s, i] = r,
       a = 4 + n.length,
       o = e.sourceSpan.start.moveBy(a),
       u = o.moveBy(i.length),
       [p, c] = (() => {
        try {
         return [!0, t(i, o).children];
        } catch {
         return [!1, [{ type: 'text', value: i, sourceSpan: new vr(o, u) }]];
        }
       })();
      return { type: 'ieConditionalComment', complete: p, children: c, condition: l(!1, s.trim(), /\s+/g, ' '), sourceSpan: e.sourceSpan, startSourceSpan: new vr(e.sourceSpan.start, o), endSourceSpan: new vr(u, e.sourceSpan.end) };
     },
    },
    {
     regex: /^\[if([^\]]*)]><!$/,
     parse: function (e, t, r) {
      let [, n] = r;
      return { type: 'ieConditionalStartComment', condition: l(!1, n.trim(), /\s+/g, ' '), sourceSpan: e.sourceSpan };
     },
    },
    {
     regex: /^<!\s*\[endif]$/,
     parse: function (e) {
      return { type: 'ieConditionalEndComment', sourceSpan: e.sourceSpan };
     },
    },
   ];
   var rs = new Map([
     ['*', new Set(['accesskey', 'autocapitalize', 'autofocus', 'class', 'contenteditable', 'dir', 'draggable', 'enterkeyhint', 'hidden', 'id', 'inert', 'inputmode', 'is', 'itemid', 'itemprop', 'itemref', 'itemscope', 'itemtype', 'lang', 'nonce', 'popover', 'slot', 'spellcheck', 'style', 'tabindex', 'title', 'translate', 'writingsuggestions'])],
     ['a', new Set(['charset', 'coords', 'download', 'href', 'hreflang', 'name', 'ping', 'referrerpolicy', 'rel', 'rev', 'shape', 'target', 'type'])],
     ['applet', new Set(['align', 'alt', 'archive', 'code', 'codebase', 'height', 'hspace', 'name', 'object', 'vspace', 'width'])],
     ['area', new Set(['alt', 'coords', 'download', 'href', 'hreflang', 'nohref', 'ping', 'referrerpolicy', 'rel', 'shape', 'target', 'type'])],
     ['audio', new Set(['autoplay', 'controls', 'crossorigin', 'loop', 'muted', 'preload', 'src'])],
     ['base', new Set(['href', 'target'])],
     ['basefont', new Set(['color', 'face', 'size'])],
     ['blockquote', new Set(['cite'])],
     ['body', new Set(['alink', 'background', 'bgcolor', 'link', 'text', 'vlink'])],
     ['br', new Set(['clear'])],
     ['button', new Set(['disabled', 'form', 'formaction', 'formenctype', 'formmethod', 'formnovalidate', 'formtarget', 'name', 'popovertarget', 'popovertargetaction', 'type', 'value'])],
     ['canvas', new Set(['height', 'width'])],
     ['caption', new Set(['align'])],
     ['col', new Set(['align', 'char', 'charoff', 'span', 'valign', 'width'])],
     ['colgroup', new Set(['align', 'char', 'charoff', 'span', 'valign', 'width'])],
     ['data', new Set(['value'])],
     ['del', new Set(['cite', 'datetime'])],
     ['details', new Set(['name', 'open'])],
     ['dialog', new Set(['open'])],
     ['dir', new Set(['compact'])],
     ['div', new Set(['align'])],
     ['dl', new Set(['compact'])],
     ['embed', new Set(['height', 'src', 'type', 'width'])],
     ['fieldset', new Set(['disabled', 'form', 'name'])],
     ['font', new Set(['color', 'face', 'size'])],
     ['form', new Set(['accept', 'accept-charset', 'action', 'autocomplete', 'enctype', 'method', 'name', 'novalidate', 'target'])],
     ['frame', new Set(['frameborder', 'longdesc', 'marginheight', 'marginwidth', 'name', 'noresize', 'scrolling', 'src'])],
     ['frameset', new Set(['cols', 'rows'])],
     ['h1', new Set(['align'])],
     ['h2', new Set(['align'])],
     ['h3', new Set(['align'])],
     ['h4', new Set(['align'])],
     ['h5', new Set(['align'])],
     ['h6', new Set(['align'])],
     ['head', new Set(['profile'])],
     ['hr', new Set(['align', 'noshade', 'size', 'width'])],
     ['html', new Set(['manifest', 'version'])],
     ['iframe', new Set(['align', 'allow', 'allowfullscreen', 'allowpaymentrequest', 'allowusermedia', 'frameborder', 'height', 'loading', 'longdesc', 'marginheight', 'marginwidth', 'name', 'referrerpolicy', 'sandbox', 'scrolling', 'src', 'srcdoc', 'width'])],
     ['img', new Set(['align', 'alt', 'border', 'crossorigin', 'decoding', 'fetchpriority', 'height', 'hspace', 'ismap', 'loading', 'longdesc', 'name', 'referrerpolicy', 'sizes', 'src', 'srcset', 'usemap', 'vspace', 'width'])],
     ['input', new Set(['accept', 'align', 'alt', 'autocomplete', 'checked', 'dirname', 'disabled', 'form', 'formaction', 'formenctype', 'formmethod', 'formnovalidate', 'formtarget', 'height', 'ismap', 'list', 'max', 'maxlength', 'min', 'minlength', 'multiple', 'name', 'pattern', 'placeholder', 'popovertarget', 'popovertargetaction', 'readonly', 'required', 'size', 'src', 'step', 'type', 'usemap', 'value', 'width'])],
     ['ins', new Set(['cite', 'datetime'])],
     ['isindex', new Set(['prompt'])],
     ['label', new Set(['for', 'form'])],
     ['legend', new Set(['align'])],
     ['li', new Set(['type', 'value'])],
     ['link', new Set(['as', 'blocking', 'charset', 'color', 'crossorigin', 'disabled', 'fetchpriority', 'href', 'hreflang', 'imagesizes', 'imagesrcset', 'integrity', 'media', 'referrerpolicy', 'rel', 'rev', 'sizes', 'target', 'type'])],
     ['map', new Set(['name'])],
     ['menu', new Set(['compact'])],
     ['meta', new Set(['charset', 'content', 'http-equiv', 'media', 'name', 'scheme'])],
     ['meter', new Set(['high', 'low', 'max', 'min', 'optimum', 'value'])],
     ['object', new Set(['align', 'archive', 'border', 'classid', 'codebase', 'codetype', 'data', 'declare', 'form', 'height', 'hspace', 'name', 'standby', 'type', 'typemustmatch', 'usemap', 'vspace', 'width'])],
     ['ol', new Set(['compact', 'reversed', 'start', 'type'])],
     ['optgroup', new Set(['disabled', 'label'])],
     ['option', new Set(['disabled', 'label', 'selected', 'value'])],
     ['output', new Set(['for', 'form', 'name'])],
     ['p', new Set(['align'])],
     ['param', new Set(['name', 'type', 'value', 'valuetype'])],
     ['pre', new Set(['width'])],
     ['progress', new Set(['max', 'value'])],
     ['q', new Set(['cite'])],
     ['script', new Set(['async', 'blocking', 'charset', 'crossorigin', 'defer', 'fetchpriority', 'integrity', 'language', 'nomodule', 'referrerpolicy', 'src', 'type'])],
     ['select', new Set(['autocomplete', 'disabled', 'form', 'multiple', 'name', 'required', 'size'])],
     ['slot', new Set(['name'])],
     ['source', new Set(['height', 'media', 'sizes', 'src', 'srcset', 'type', 'width'])],
     ['style', new Set(['blocking', 'media', 'type'])],
     ['table', new Set(['align', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'frame', 'rules', 'summary', 'width'])],
     ['tbody', new Set(['align', 'char', 'charoff', 'valign'])],
     ['td', new Set(['abbr', 'align', 'axis', 'bgcolor', 'char', 'charoff', 'colspan', 'headers', 'height', 'nowrap', 'rowspan', 'scope', 'valign', 'width'])],
     ['template', new Set(['shadowrootclonable', 'shadowrootdelegatesfocus', 'shadowrootmode'])],
     ['textarea', new Set(['autocomplete', 'cols', 'dirname', 'disabled', 'form', 'maxlength', 'minlength', 'name', 'placeholder', 'readonly', 'required', 'rows', 'wrap'])],
     ['tfoot', new Set(['align', 'char', 'charoff', 'valign'])],
     ['th', new Set(['abbr', 'align', 'axis', 'bgcolor', 'char', 'charoff', 'colspan', 'headers', 'height', 'nowrap', 'rowspan', 'scope', 'valign', 'width'])],
     ['thead', new Set(['align', 'char', 'charoff', 'valign'])],
     ['time', new Set(['datetime'])],
     ['tr', new Set(['align', 'bgcolor', 'char', 'charoff', 'valign'])],
     ['track', new Set(['default', 'kind', 'label', 'src', 'srclang'])],
     ['ul', new Set(['compact', 'type'])],
     ['video', new Set(['autoplay', 'controls', 'crossorigin', 'height', 'loop', 'muted', 'playsinline', 'poster', 'preload', 'src', 'width'])],
    ]),
    ns = new Set(['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'math', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nextid', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rb', 'rbc', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'search', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp']);
   function ss(e, t, r) {
    let { name: n, canSelfClose: s = !0, normalizeTagName: i = !1, normalizeAttributeName: a = !1, allowHtmComponentClosingTags: o = !1, isTagNameCaseSensitive: u = !1, shouldParseAsRawText: l } = t,
     { rootNodes: p, errors: c } = Jn(e, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u, getTagContentType: l ? (...e) => (l(...e) ? Or.RAW_TEXT : void 0) : void 0, tokenizeAngularBlocks: 'angular' === n || void 0 });
    if ('vue' === n) {
     if (p.some((e) => ('docType' === e.type && 'html' === e.value) || ('element' === e.type && 'html' === e.name.toLowerCase()))) return ss(e, ls, r);
     let t,
      n = () => t ?? (t = Jn(e, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u })),
      i = (e) => n().rootNodes.find(({ startSourceSpan: t }) => t && t.start.offset === e.startSourceSpan.start.offset) ?? e;
     for (let [e, s] of p.entries()) {
      let { endSourceSpan: t, startSourceSpan: a } = s;
      if (null === t) (c = n().errors), (p[e] = i(s));
      else if (is(s, r)) {
       let r = n().errors.find((e) => e.span.start.offset > a.start.offset && e.span.start.offset < t.end.offset);
       r && as(r), (p[e] = i(s));
      }
     }
    }
    c.length > 0 && as(c[0]);
    let h = (e) => {
      let t = e.name.startsWith(':') ? e.name.slice(1).split(':')[0] : null,
       r = e.nameSpan.toString(),
       n = null !== t && r.startsWith(`${t}:`),
       s = n ? r.slice(t.length + 1) : r;
      (e.name = s), (e.namespace = t), (e.hasExplicitNamespace = n);
     },
     d = (e, t) => {
      let r = e.toLowerCase();
      return t(r) ? r : e;
     };
    return (
     fn(
      new (class extends mn {
       visitExpansionCase(e, t) {
        'angular' === n &&
         this.visitChildren(t, (t) => {
          t(e.expression);
         });
       }
       visit(e) {
        ((e) => {
         switch (e.type) {
          case 'element':
           h(e);
           for (let t of e.attrs) h(t), t.valueSpan ? ((t.value = t.valueSpan.toString()), /["']/.test(t.value[0]) && (t.value = t.value.slice(1, -1))) : (t.value = null);
           break;
          case 'comment':
           e.value = e.sourceSpan.toString().slice(4, -3);
           break;
          case 'text':
           e.value = e.sourceSpan.toString();
         }
        })(e),
         ((e) => {
          if ('element' === e.type) {
           let t = tn(u ? e.name : e.name.toLowerCase());
           !e.namespace || e.namespace === t.implicitNamespacePrefix || ye(e) ? (e.tagDefinition = t) : (e.tagDefinition = tn(''));
          }
         })(e),
         ((e) => {
          if ('element' === e.type && (i && (!e.namespace || e.namespace === e.tagDefinition.implicitNamespacePrefix || ye(e)) && (e.name = d(e.name, (e) => ns.has(e))), a)) for (let t of e.attrs) t.namespace || (t.name = d(t.name, (t) => rs.has(e.name) && (rs.get('*').has(t) || rs.get(e.name).has(t))));
         })(e),
         ((e) => {
          e.sourceSpan && e.endSourceSpan && (e.sourceSpan = new vr(e.sourceSpan.start, e.endSourceSpan.end));
         })(e);
       }
      })(),
      p,
     ),
     p
    );
   }
   function is(e, t) {
    var r;
    if ('element' !== e.type || 'template' !== e.name) return !1;
    let n = null == (r = e.attrs.find((e) => 'lang' === e.name)) ? void 0 : r.value;
    return !n || 'html' === ce(t, { language: n });
   }
   function as(e) {
    let {
     msg: t,
     span: { start: r, end: n },
    } = e;
    throw Kn(t, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: e });
   }
   function os(e, t, r = {}, n = !0) {
    let { frontMatter: s, content: i } = n ? Xn(e) : { frontMatter: null, content: e },
     a = new br(e, r.filepath),
     o = new xr(a, 0, 0, 0),
     u = o.moveBy(e.length),
     p = { type: 'root', sourceSpan: new vr(o, u), children: ss(i, t, r) };
    if (s) {
     let e = new xr(a, 0, 0, 0),
      t = e.moveBy(s.raw.length);
     (s.sourceSpan = new vr(e, t)), p.children.unshift(s);
    }
    let c = new Zn(p),
     h = (n, s) => {
      let { offset: i } = s,
       a = os(l(!1, e.slice(0, i), /[^\n\r]/g, ' ') + n, t, r, !1);
      a.sourceSpan = new vr(s, H(!1, a.children, -1).sourceSpan.end);
      let o = a.children[0];
      return o.length === i ? a.children.shift() : ((o.sourceSpan = new vr(o.sourceSpan.start.moveBy(i), o.sourceSpan.end)), (o.value = o.value.slice(i))), a;
     };
    return (
     c.walk((e) => {
      if ('comment' === e.type) {
       let t = (function (e, t) {
        if (e.value)
         for (let { regex: r, parse: n } of ts) {
          let s = e.value.match(r);
          if (s) return n(e, t, s);
         }
        return null;
       })(e, h);
       t && e.parent.replaceChild(e, t);
      }
      (function (e) {
       if ('block' === e.type) {
        if (((e.name = l(!1, e.name.toLowerCase(), /\s+/g, ' ').trim()), (e.type = 'angularControlFlowBlock'), !St(e.parameters))) return void delete e.parameters;
        for (let t of e.parameters) t.type = 'angularControlFlowBlockParameter';
        e.parameters = { type: 'angularControlFlowBlockParameters', children: e.parameters, sourceSpan: new vr(e.parameters[0].sourceSpan.start, H(!1, e.parameters, -1).sourceSpan.end) };
       }
      })(e),
       (function (e) {
        ('plural' === e.type || 'select' === e.type) && ((e.clause = e.type), (e.type = 'angularIcuExpression')), 'expansionCase' === e.type && (e.type = 'angularIcuCase');
       })(e);
     }),
     c
    );
   }
   function us(e) {
    return { parse: (t, r) => os(t, e, r), hasPragma: tr, astFormat: 'html', locStart: wt, locEnd: At };
   }
   var ls = { name: 'html', normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 },
    ps = us(ls),
    cs = us({ name: 'angular' }),
    hs = us({ name: 'vue', isTagNameCaseSensitive: !0, shouldParseAsRawText: (e, t, r, n) => 'html' !== e.toLowerCase() && !r && ('template' !== e || n.some(({ name: e, value: t }) => 'lang' === e && 'html' !== t && '' !== t && void 0 !== t)) }),
    ds = us({ name: 'lwc', canSelfClose: !1 }),
    fs = { html: wr },
    ms = u;
  },
  25032: (e, t, r) => {
   r.d(t, { ZP: () => rs });
   var n = Object.create,
    s = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    p = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    c = (e, t, r) => (
     (r = null != e ? n(o(e)) : {}),
     ((e, t, r, n) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && s(e, o, { get: () => t[o], enumerable: !(n = i(t, o)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : s(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    h = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.extract = function (e) {
       let t = e.match(n);
       return t ? t[0].trimLeft() : '';
      }),
      (e.parse = function (e) {
       return p(e).pragmas;
      }),
      (e.parseWithComments = p),
      (e.print = function ({ comments: e = '', pragmas: t = {} }) {
       let r = '\n',
        n = ' *',
        s = Object.keys(t),
        i = s
         .flatMap((e) => c(e, t[e]))
         .map((e) => `${n} ${e}${r}`)
         .join('');
       if (!e) {
        if (0 === s.length) return '';
        if (1 === s.length && !Array.isArray(t[s[0]])) {
         let e = t[s[0]];
         return `/** ${c(s[0], e)[0]} */`;
        }
       }
       let a =
        e
         .split(r)
         .map((e) => `${n} ${e}`)
         .join(r) + r;
       return '/**\n' + (e ? a : '') + (e && s.length ? n + r : '') + i + ' */';
      }),
      (e.strip = function (e) {
       let t = e.match(n);
       return t && t[0] ? e.substring(t[0].length) : e;
      });
     var t = /\*\/$/,
      r = /^\/\*\*?/,
      n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
      s = /(^|\s+)\/\/([^\r\n]*)/g,
      i = /^(\r?\n)+/,
      a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
      o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
      u = /(\r?\n|^) *\* ?/g,
      l = [];
     function p(e) {
      e = e.replace(r, '').replace(t, '').replace(u, '$1');
      let n = '';
      for (; n !== e; ) (n = e), (e = e.replace(a, '\n$1 $2\n'));
      e = e.replace(i, '').trimRight();
      let p,
       c = Object.create(null),
       h = e.replace(o, '').replace(i, '').trimRight();
      for (; (p = o.exec(e)); ) {
       let e = p[2].replace(s, '');
       'string' == typeof c[p[1]] || Array.isArray(c[p[1]]) ? (c[p[1]] = l.concat(c[p[1]], e)) : (c[p[1]] = e);
      }
      return { comments: h, pragmas: c };
     }
     function c(e, t) {
      return l.concat(t).map((t) => `@${e} ${t}`.trim());
     }
    }),
    d = l((e, t) => {
     (t.exports.isClean = Symbol('isClean')), (t.exports.my = Symbol('my'));
    }),
    f = l((e, t) => {
     var r = String,
      n = function () {
       return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r };
      };
     (t.exports = n()), (t.exports.createColors = n);
    }),
    m = l(() => {}),
    y = l((e, t) => {
     var r = f(),
      n = m(),
      s = class e extends Error {
       constructor(t, r, n, s, i, a) {
        super(t), (this.name = 'CssSyntaxError'), (this.reason = t), i && (this.file = i), s && (this.source = s), a && (this.plugin = a), typeof r < 'u' && typeof n < 'u' && ('number' == typeof r ? ((this.line = r), (this.column = n)) : ((this.line = r.line), (this.column = r.column), (this.endLine = n.line), (this.endColumn = n.column))), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, e);
       }
       setMessage() {
        (this.message = this.plugin ? this.plugin + ': ' : ''), (this.message += this.file ? this.file : '<css input>'), typeof this.line < 'u' && (this.message += ':' + this.line + ':' + this.column), (this.message += ': ' + this.reason);
       }
       showSourceCode(e) {
        if (!this.source) return '';
        let t = this.source;
        null == e && (e = r.isColorSupported), n && e && (t = n(t));
        let s,
         i,
         a = t.split(/\r?\n/),
         o = Math.max(this.line - 3, 0),
         u = Math.min(this.line + 2, a.length),
         l = String(u).length;
        if (e) {
         let { bold: e, gray: t, red: n } = r.createColors(!0);
         (s = (t) => e(n(t))), (i = (e) => t(e));
        } else s = i = (e) => e;
        return a
         .slice(o, u)
         .map((e, t) => {
          let r = o + 1 + t,
           n = ' ' + (' ' + r).slice(-l) + ' | ';
          if (r === this.line) {
           let t = i(n.replace(/\d/g, ' ')) + e.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
           return s('>') + i(n) + e + '\n ' + t + s('^');
          }
          return ' ' + i(n) + e;
         })
         .join('\n');
       }
       toString() {
        let e = this.showSourceCode();
        return e && (e = '\n\n' + e + '\n'), this.name + ': ' + this.message + e;
       }
      };
     (t.exports = s), (s.default = s);
    }),
    g = l((e, t) => {
     var r = { after: '\n', beforeClose: '\n', beforeComment: '\n', beforeDecl: '\n', beforeOpen: ' ', beforeRule: '\n', colon: ': ', commentLeft: ' ', commentRight: ' ', emptyBody: '', indent: '    ', semicolon: !1 };
     var n = class {
      constructor(e) {
       this.builder = e;
      }
      atrule(e, t) {
       let r = '@' + e.name,
        n = e.params ? this.rawValue(e, 'params') : '';
       if ((typeof e.raws.afterName < 'u' ? (r += e.raws.afterName) : n && (r += ' '), e.nodes)) this.block(e, r + n);
       else {
        let s = (e.raws.between || '') + (t ? ';' : '');
        this.builder(r + n + s, e);
       }
      }
      beforeAfter(e, t) {
       let r;
       r = 'decl' === e.type ? this.raw(e, null, 'beforeDecl') : 'comment' === e.type ? this.raw(e, null, 'beforeComment') : 'before' === t ? this.raw(e, null, 'beforeRule') : this.raw(e, null, 'beforeClose');
       let n = e.parent,
        s = 0;
       for (; n && 'root' !== n.type; ) (s += 1), (n = n.parent);
       if (r.includes('\n')) {
        let t = this.raw(e, null, 'indent');
        if (t.length) for (let e = 0; e < s; e++) r += t;
       }
       return r;
      }
      block(e, t) {
       let r,
        n = this.raw(e, 'between', 'beforeOpen');
       this.builder(t + n + '{', e, 'start'), e.nodes && e.nodes.length ? (this.body(e), (r = this.raw(e, 'after'))) : (r = this.raw(e, 'after', 'emptyBody')), r && this.builder(r), this.builder('}', e, 'end');
      }
      body(e) {
       let t = e.nodes.length - 1;
       for (; t > 0 && 'comment' === e.nodes[t].type; ) t -= 1;
       let r = this.raw(e, 'semicolon');
       for (let n = 0; n < e.nodes.length; n++) {
        let s = e.nodes[n],
         i = this.raw(s, 'before');
        i && this.builder(i), this.stringify(s, t !== n || r);
       }
      }
      comment(e) {
       let t = this.raw(e, 'left', 'commentLeft'),
        r = this.raw(e, 'right', 'commentRight');
       this.builder('/*' + t + e.text + r + '*/', e);
      }
      decl(e, t) {
       let r = this.raw(e, 'between', 'colon'),
        n = e.prop + r + this.rawValue(e, 'value');
       e.important && (n += e.raws.important || ' !important'), t && (n += ';'), this.builder(n, e);
      }
      document(e) {
       this.body(e);
      }
      raw(e, t, n) {
       let s;
       if ((n || (n = t), t && ((s = e.raws[t]), typeof s < 'u'))) return s;
       let i = e.parent;
       if ('before' === n && (!i || ('root' === i.type && i.first === e) || (i && 'document' === i.type))) return '';
       if (!i) return r[n];
       let a = e.root();
       if ((a.rawCache || (a.rawCache = {}), typeof a.rawCache[n] < 'u')) return a.rawCache[n];
       if ('before' === n || 'after' === n) return this.beforeAfter(e, n);
       {
        let r = 'raw' + ((o = n)[0].toUpperCase() + o.slice(1));
        this[r]
         ? (s = this[r](a, e))
         : a.walk((e) => {
            if (((s = e.raws[t]), typeof s < 'u')) return !1;
           });
       }
       var o;
       return typeof s > 'u' && (s = r[n]), (a.rawCache[n] = s), s;
      }
      rawBeforeClose(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length > 0 && typeof e.raws.after < 'u') return (t = e.raws.after), t.includes('\n') && (t = t.replace(/[^\n]+$/, '')), !1;
        }),
        t && (t = t.replace(/\S/g, '')),
        t
       );
      }
      rawBeforeComment(e, t) {
       let r;
       return (
        e.walkComments((e) => {
         if (typeof e.raws.before < 'u') return (r = e.raws.before), r.includes('\n') && (r = r.replace(/[^\n]+$/, '')), !1;
        }),
        typeof r > 'u' ? (r = this.raw(t, null, 'beforeDecl')) : r && (r = r.replace(/\S/g, '')),
        r
       );
      }
      rawBeforeDecl(e, t) {
       let r;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.before < 'u') return (r = e.raws.before), r.includes('\n') && (r = r.replace(/[^\n]+$/, '')), !1;
        }),
        typeof r > 'u' ? (r = this.raw(t, null, 'beforeRule')) : r && (r = r.replace(/\S/g, '')),
        r
       );
      }
      rawBeforeOpen(e) {
       let t;
       return (
        e.walk((e) => {
         if ('decl' !== e.type && ((t = e.raws.between), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawBeforeRule(e) {
       let t;
       return (
        e.walk((r) => {
         if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < 'u') return (t = r.raws.before), t.includes('\n') && (t = t.replace(/[^\n]+$/, '')), !1;
        }),
        t && (t = t.replace(/\S/g, '')),
        t
       );
      }
      rawColon(e) {
       let t;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.between < 'u') return (t = e.raws.between.replace(/[^\s:]/g, '')), !1;
        }),
        t
       );
      }
      rawEmptyBody(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && 0 === e.nodes.length && ((t = e.raws.after), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawIndent(e) {
       if (e.raws.indent) return e.raws.indent;
       let t;
       return (
        e.walk((r) => {
         let n = r.parent;
         if (n && n !== e && n.parent && n.parent === e && typeof r.raws.before < 'u') {
          let e = r.raws.before.split('\n');
          return (t = e[e.length - 1]), (t = t.replace(/\S/g, '')), !1;
         }
        }),
        t
       );
      }
      rawSemicolon(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length && 'decl' === e.last.type && ((t = e.raws.semicolon), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawValue(e, t) {
       let r = e[t],
        n = e.raws[t];
       return n && n.value === r ? n.raw : r;
      }
      root(e) {
       this.body(e), e.raws.after && this.builder(e.raws.after);
      }
      rule(e) {
       this.block(e, this.rawValue(e, 'selector')), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, 'end');
      }
      stringify(e, t) {
       if (!this[e.type]) throw new Error('Unknown AST node type ' + e.type + '. Maybe you need to change PostCSS stringifier.');
       this[e.type](e, t);
      }
     };
     (t.exports = n), (n.default = n);
    }),
    D = l((e, t) => {
     var r = g();
     function n(e, t) {
      new r(t).stringify(e);
     }
     (t.exports = n), (n.default = n);
    }),
    x = l((e, t) => {
     var { isClean: r, my: n } = d(),
      s = y(),
      i = g(),
      a = D();
     function o(e, t) {
      let r = new e.constructor();
      for (let n in e) {
       if (!Object.prototype.hasOwnProperty.call(e, n) || 'proxyCache' === n) continue;
       let s = e[n],
        i = typeof s;
       'parent' === n && 'object' === i ? t && (r[n] = t) : 'source' === n ? (r[n] = s) : Array.isArray(s) ? (r[n] = s.map((e) => o(e, r))) : ('object' === i && null !== s && (s = o(s)), (r[n] = s));
      }
      return r;
     }
     var u = class {
      constructor(e = {}) {
       (this.raws = {}), (this[r] = !1), (this[n] = !0);
       for (let t in e)
        if ('nodes' === t) {
         this.nodes = [];
         for (let r of e[t]) 'function' == typeof r.clone ? this.append(r.clone()) : this.append(r);
        } else this[t] = e[t];
      }
      addToError(e) {
       if (((e.postcssNode = this), e.stack && this.source && /\n\s{4}at /.test(e.stack))) {
        let t = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `$&${t.input.from}:${t.start.line}:${t.start.column}$&`);
       }
       return e;
      }
      after(e) {
       return this.parent.insertAfter(this, e), this;
      }
      assign(e = {}) {
       for (let t in e) this[t] = e[t];
       return this;
      }
      before(e) {
       return this.parent.insertBefore(this, e), this;
      }
      cleanRaws(e) {
       delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
      }
      clone(e = {}) {
       let t = o(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneAfter(e = {}) {
       let t = this.clone(e);
       return this.parent.insertAfter(this, t), t;
      }
      cloneBefore(e = {}) {
       let t = this.clone(e);
       return this.parent.insertBefore(this, t), t;
      }
      error(e, t = {}) {
       if (this.source) {
        let { end: r, start: n } = this.rangeBy(t);
        return this.source.input.error(e, { column: n.column, line: n.line }, { column: r.column, line: r.line }, t);
       }
       return new s(e);
      }
      getProxyProcessor() {
       return { get: (e, t) => ('proxyOf' === t ? e : 'root' === t ? () => e.root().toProxy() : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ('prop' === t || 'value' === t || 'name' === t || 'params' === t || 'important' === t || 'text' === t) && e.markDirty()), !0) };
      }
      markDirty() {
       if (this[r]) {
        this[r] = !1;
        let e = this;
        for (; (e = e.parent); ) e[r] = !1;
       }
      }
      next() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      positionBy(e, t) {
       let r = this.source.start;
       if (e.index) r = this.positionInside(e.index, t);
       else if (e.word) {
        let n = (t = this.toString()).indexOf(e.word);
        -1 !== n && (r = this.positionInside(n, t));
       }
       return r;
      }
      positionInside(e, t) {
       let r = t || this.toString(),
        n = this.source.start.column,
        s = this.source.start.line;
       for (let i = 0; i < e; i++) '\n' === r[i] ? ((n = 1), (s += 1)) : (n += 1);
       return { column: n, line: s };
      }
      prev() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      rangeBy(e) {
       let t = { column: this.source.start.column, line: this.source.start.line },
        r = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: t.column + 1, line: t.line };
       if (e.word) {
        let n = this.toString(),
         s = n.indexOf(e.word);
        -1 !== s && ((t = this.positionInside(s, n)), (r = this.positionInside(s + e.word.length, n)));
       } else e.start ? (t = { column: e.start.column, line: e.start.line }) : e.index && (t = this.positionInside(e.index)), e.end ? (r = { column: e.end.column, line: e.end.line }) : 'number' == typeof e.endIndex ? (r = this.positionInside(e.endIndex)) : e.index && (r = this.positionInside(e.index + 1));
       return (r.line < t.line || (r.line === t.line && r.column <= t.column)) && (r = { column: t.column + 1, line: t.line }), { end: r, start: t };
      }
      raw(e, t) {
       return new i().raw(this, e, t);
      }
      remove() {
       return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
      }
      replaceWith(...e) {
       if (this.parent) {
        let t = this,
         r = !1;
        for (let n of e) n === this ? (r = !0) : r ? (this.parent.insertAfter(t, n), (t = n)) : this.parent.insertBefore(t, n);
        r || this.remove();
       }
       return this;
      }
      root() {
       let e = this;
       for (; e.parent && 'document' !== e.parent.type; ) e = e.parent;
       return e;
      }
      toJSON(e, t) {
       let r = {},
        n = null == t;
       t = t || new Map();
       let s = 0;
       for (let i in this) {
        if (!Object.prototype.hasOwnProperty.call(this, i) || 'parent' === i || 'proxyCache' === i) continue;
        let e = this[i];
        if (Array.isArray(e)) r[i] = e.map((e) => ('object' == typeof e && e.toJSON ? e.toJSON(null, t) : e));
        else if ('object' == typeof e && e.toJSON) r[i] = e.toJSON(null, t);
        else if ('source' === i) {
         let n = t.get(e.input);
         null == n && ((n = s), t.set(e.input, s), s++), (r[i] = { end: e.end, inputId: n, start: e.start });
        } else r[i] = e;
       }
       return n && (r.inputs = [...t.keys()].map((e) => e.toJSON())), r;
      }
      toProxy() {
       return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
      }
      toString(e = a) {
       e.stringify && (e = e.stringify);
       let t = '';
       return (
        e(this, (e) => {
         t += e;
        }),
        t
       );
      }
      warn(e, t, r) {
       let n = { node: this };
       for (let s in r) n[s] = r[s];
       return e.warn(t, n);
      }
      get proxyOf() {
       return this;
      }
     };
     (t.exports = u), (u.default = u);
    }),
    b = l((e, t) => {
     var r = x(),
      n = class extends r {
       constructor(e) {
        e && typeof e.value < 'u' && 'string' != typeof e.value && (e = { ...e, value: String(e.value) }), super(e), (this.type = 'decl');
       }
       get variable() {
        return this.prop.startsWith('--') || '$' === this.prop[0];
       }
      };
     (t.exports = n), (n.default = n);
    }),
    v = l((e, t) => {
     var r = x(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'comment');
       }
      };
     (t.exports = n), (n.default = n);
    }),
    E = l((e, t) => {
     var r,
      n,
      s,
      i,
      { isClean: a, my: o } = d(),
      u = b(),
      l = v(),
      p = x();
     function c(e) {
      return e.map((e) => (e.nodes && (e.nodes = c(e.nodes)), delete e.source, e));
     }
     function h(e) {
      if (((e[a] = !1), e.proxyOf.nodes)) for (let t of e.proxyOf.nodes) h(t);
     }
     var f = class e extends p {
      append(...e) {
       for (let t of e) {
        let e = this.normalize(t, this.last);
        for (let t of e) this.proxyOf.nodes.push(t);
       }
       return this.markDirty(), this;
      }
      cleanRaws(e) {
       if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
      }
      each(e) {
       if (!this.proxyOf.nodes) return;
       let t,
        r,
        n = this.getIterator();
       for (; this.indexes[n] < this.proxyOf.nodes.length && ((t = this.indexes[n]), (r = e(this.proxyOf.nodes[t], t)), !1 !== r); ) this.indexes[n] += 1;
       return delete this.indexes[n], r;
      }
      every(e) {
       return this.nodes.every(e);
      }
      getIterator() {
       this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1);
       let e = this.lastEach;
       return (this.indexes[e] = 0), e;
      }
      getProxyProcessor() {
       return { get: (e, t) => ('proxyOf' === t ? e : e[t] ? ('each' === t || ('string' == typeof t && t.startsWith('walk')) ? (...r) => e[t](...r.map((e) => ('function' == typeof e ? (t, r) => e(t.toProxy(), r) : e))) : 'every' === t || 'some' === t ? (r) => e[t]((e, ...t) => r(e.toProxy(), ...t)) : 'root' === t ? () => e.root().toProxy() : 'nodes' === t ? e.nodes.map((e) => e.toProxy()) : 'first' === t || 'last' === t ? e[t].toProxy() : e[t]) : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ('name' === t || 'params' === t || 'selector' === t) && e.markDirty()), !0) };
      }
      index(e) {
       return 'number' == typeof e ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
      }
      insertAfter(e, t) {
       let r,
        n = this.index(e),
        s = this.normalize(t, this.proxyOf.nodes[n]).reverse();
       n = this.index(e);
       for (let i of s) this.proxyOf.nodes.splice(n + 1, 0, i);
       for (let i in this.indexes) (r = this.indexes[i]), n < r && (this.indexes[i] = r + s.length);
       return this.markDirty(), this;
      }
      insertBefore(e, t) {
       let r,
        n = this.index(e),
        s = 0 === n && 'prepend',
        i = this.normalize(t, this.proxyOf.nodes[n], s).reverse();
       n = this.index(e);
       for (let a of i) this.proxyOf.nodes.splice(n, 0, a);
       for (let a in this.indexes) (r = this.indexes[a]), n <= r && (this.indexes[a] = r + i.length);
       return this.markDirty(), this;
      }
      normalize(t, i) {
       if ('string' == typeof t) t = c(r(t).nodes);
       else if (typeof t > 'u') t = [];
       else if (Array.isArray(t)) {
        t = t.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, 'ignore');
       } else if ('root' === t.type && 'document' !== this.type) {
        t = t.nodes.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, 'ignore');
       } else if (t.type) t = [t];
       else if (t.prop) {
        if (typeof t.value > 'u') throw new Error('Value field is missed in node creation');
        'string' != typeof t.value && (t.value = String(t.value)), (t = [new u(t)]);
       } else if (t.selector) t = [new n(t)];
       else if (t.name) t = [new s(t)];
       else {
        if (!t.text) throw new Error('Unknown node type in node creation');
        t = [new l(t)];
       }
       return t.map((t) => (t[o] || e.rebuild(t), (t = t.proxyOf).parent && t.parent.removeChild(t), t[a] && h(t), typeof t.raws.before > 'u' && i && typeof i.raws.before < 'u' && (t.raws.before = i.raws.before.replace(/\S/g, '')), (t.parent = this.proxyOf), t));
      }
      prepend(...e) {
       e = e.reverse();
       for (let t of e) {
        let e = this.normalize(t, this.first, 'prepend').reverse();
        for (let t of e) this.proxyOf.nodes.unshift(t);
        for (let t in this.indexes) this.indexes[t] = this.indexes[t] + e.length;
       }
       return this.markDirty(), this;
      }
      push(e) {
       return (e.parent = this), this.proxyOf.nodes.push(e), this;
      }
      removeAll() {
       for (let e of this.proxyOf.nodes) e.parent = void 0;
       return (this.proxyOf.nodes = []), this.markDirty(), this;
      }
      removeChild(e) {
       let t;
       (e = this.index(e)), (this.proxyOf.nodes[e].parent = void 0), this.proxyOf.nodes.splice(e, 1);
       for (let r in this.indexes) (t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1);
       return this.markDirty(), this;
      }
      replaceValues(e, t, r) {
       return (
        r || ((r = t), (t = {})),
        this.walkDecls((n) => {
         (t.props && !t.props.includes(n.prop)) || (t.fast && !n.value.includes(t.fast)) || (n.value = n.value.replace(e, r));
        }),
        this.markDirty(),
        this
       );
      }
      some(e) {
       return this.nodes.some(e);
      }
      walk(e) {
       return this.each((t, r) => {
        let n;
        try {
         n = e(t, r);
        } catch (s) {
         throw t.addToError(s);
        }
        return !1 !== n && t.walk && (n = t.walk(e)), n;
       });
      }
      walkAtRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ('atrule' === r.type && e.test(r.name)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ('atrule' === r.type && r.name === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('atrule' === e.type) return t(e, r);
          }));
      }
      walkComments(e) {
       return this.walk((t, r) => {
        if ('comment' === t.type) return e(t, r);
       });
      }
      walkDecls(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ('decl' === r.type && e.test(r.prop)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ('decl' === r.type && r.prop === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('decl' === e.type) return t(e, r);
          }));
      }
      walkRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ('rule' === r.type && e.test(r.selector)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ('rule' === r.type && r.selector === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('rule' === e.type) return t(e, r);
          }));
      }
      get first() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
      }
      get last() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
     };
     (f.registerParse = (e) => {
      r = e;
     }),
      (f.registerRule = (e) => {
       n = e;
      }),
      (f.registerAtRule = (e) => {
       s = e;
      }),
      (f.registerRoot = (e) => {
       i = e;
      }),
      (t.exports = f),
      (f.default = f),
      (f.rebuild = (e) => {
       'atrule' === e.type ? Object.setPrototypeOf(e, s.prototype) : 'rule' === e.type ? Object.setPrototypeOf(e, n.prototype) : 'decl' === e.type ? Object.setPrototypeOf(e, u.prototype) : 'comment' === e.type ? Object.setPrototypeOf(e, l.prototype) : 'root' === e.type && Object.setPrototypeOf(e, i.prototype),
        (e[o] = !0),
        e.nodes &&
         e.nodes.forEach((e) => {
          f.rebuild(e);
         });
      });
    }),
    C = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      n = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      s = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i;
     t.exports = function (e, t = {}) {
      let a,
       o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y = e.css.valueOf(),
       g = t.ignoreErrors,
       D = y.length,
       x = 0,
       b = [],
       v = [];
      function E(t) {
       throw e.error('Unclosed ' + t, x);
      }
      return {
       back: function (e) {
        v.push(e);
       },
       endOfFile: function () {
        return 0 === v.length && x >= D;
       },
       nextToken: function (e) {
        if (v.length) return v.pop();
        if (x >= D) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((a = y.charCodeAt(x)), a)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          o = x;
          do {
           (o += 1), (a = y.charCodeAt(o));
          } while (32 === a || 10 === a || 9 === a || 13 === a || 12 === a);
          (m = ['space', y.slice(x, o)]), (x = o - 1);
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(a);
          m = [e, e, x];
          break;
         }
         case 40:
          if (((d = b.length ? b.pop()[1] : ''), (f = y.charCodeAt(x + 1)), 'url' === d && 39 !== f && 34 !== f && 32 !== f && 10 !== f && 9 !== f && 12 !== f && 13 !== f)) {
           o = x;
           do {
            if (((c = !1), (o = y.indexOf(')', o + 1)), -1 === o)) {
             if (g || t) {
              o = x;
              break;
             }
             E('bracket');
            }
            for (h = o; 92 === y.charCodeAt(h - 1); ) (h -= 1), (c = !c);
           } while (c);
           (m = ['brackets', y.slice(x, o + 1), x, o]), (x = o);
          } else (o = y.indexOf(')', x + 1)), (l = y.slice(x, o + 1)), -1 === o || s.test(l) ? (m = ['(', '(', x]) : ((m = ['brackets', l, x, o]), (x = o));
          break;
         case 39:
         case 34:
          (u = 39 === a ? "'" : '"'), (o = x);
          do {
           if (((c = !1), (o = y.indexOf(u, o + 1)), -1 === o)) {
            if (g || t) {
             o = x + 1;
             break;
            }
            E('string');
           }
           for (h = o; 92 === y.charCodeAt(h - 1); ) (h -= 1), (c = !c);
          } while (c);
          (m = ['string', y.slice(x, o + 1), x, o]), (x = o);
          break;
         case 64:
          (r.lastIndex = x + 1), r.test(y), (o = 0 === r.lastIndex ? y.length - 1 : r.lastIndex - 2), (m = ['at-word', y.slice(x, o + 1), x, o]), (x = o);
          break;
         case 92:
          for (o = x, p = !0; 92 === y.charCodeAt(o + 1); ) (o += 1), (p = !p);
          if (((a = y.charCodeAt(o + 1)), p && 47 !== a && 32 !== a && 10 !== a && 9 !== a && 13 !== a && 12 !== a && ((o += 1), i.test(y.charAt(o))))) {
           for (; i.test(y.charAt(o + 1)); ) o += 1;
           32 === y.charCodeAt(o + 1) && (o += 1);
          }
          (m = ['word', y.slice(x, o + 1), x, o]), (x = o);
          break;
         default:
          47 === a && 42 === y.charCodeAt(x + 1) ? ((o = y.indexOf('*/', x + 2) + 1), 0 === o && (g || t ? (o = y.length) : E('comment')), (m = ['comment', y.slice(x, o + 1), x, o]), (x = o)) : ((n.lastIndex = x + 1), n.test(y), (o = 0 === n.lastIndex ? y.length - 1 : n.lastIndex - 2), (m = ['word', y.slice(x, o + 1), x, o]), b.push(m), (x = o));
        }
        return x++, m;
       },
       position: function () {
        return x;
       },
      };
     };
    }),
    T = l((e, t) => {
     var r = E(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'atrule');
       }
       append(...e) {
        return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
       }
       prepend(...e) {
        return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
       }
      };
     (t.exports = n), (n.default = n), r.registerAtRule(n);
    }),
    S = l((e, t) => {
     var r,
      n,
      s = E(),
      i = class extends s {
       constructor(e) {
        super(e), (this.type = 'root'), this.nodes || (this.nodes = []);
       }
       normalize(e, t, r) {
        let n = super.normalize(e);
        if (t)
         if ('prepend' === r) this.nodes.length > 1 ? (t.raws.before = this.nodes[1].raws.before) : delete t.raws.before;
         else if (this.first !== t) for (let s of n) s.raws.before = t.raws.before;
        return n;
       }
       removeChild(e, t) {
        let r = this.index(e);
        return !t && 0 === r && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
       }
       toResult(e = {}) {
        return new r(new n(), this, e).stringify();
       }
      };
     (i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       n = e;
      }),
      (t.exports = i),
      (i.default = i),
      s.registerRoot(i);
    }),
    w = l((e, t) => {
     var r = {
      comma: (e) => r.split(e, [','], !0),
      space(e) {
       let t = [' ', '\n', '\t'];
       return r.split(e, t);
      },
      split(e, t, r) {
       let n = [],
        s = '',
        i = !1,
        a = 0,
        o = !1,
        u = '',
        l = !1;
       for (let p of e) l ? (l = !1) : '\\' === p ? (l = !0) : o ? p === u && (o = !1) : '"' === p || "'" === p ? ((o = !0), (u = p)) : '(' === p ? (a += 1) : ')' === p ? a > 0 && (a -= 1) : 0 === a && t.includes(p) && (i = !0), i ? ('' !== s && n.push(s.trim()), (s = ''), (i = !1)) : (s += p);
       return (r || '' !== s) && n.push(s.trim()), n;
      },
     };
     (t.exports = r), (r.default = r);
    }),
    A = l((e, t) => {
     var r = E(),
      n = w(),
      s = class extends r {
       constructor(e) {
        super(e), (this.type = 'rule'), this.nodes || (this.nodes = []);
       }
       get selectors() {
        return n.comma(this.selector);
       }
       set selectors(e) {
        let t = this.selector ? this.selector.match(/,\s*/) : null,
         r = t ? t[0] : ',' + this.raw('between', 'beforeOpen');
        this.selector = e.join(r);
       }
      };
     (t.exports = s), (s.default = s), r.registerRule(s);
    }),
    F = l((e, t) => {
     var r = b(),
      n = C(),
      s = v(),
      i = T(),
      a = S(),
      o = A(),
      u = { empty: !0, space: !0 };
     t.exports = class {
      constructor(e) {
       (this.input = e), (this.root = new a()), (this.current = this.root), (this.spaces = ''), (this.semicolon = !1), this.createTokenizer(), (this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } });
      }
      atrule(e) {
       let t = new i();
       (t.name = e[1].slice(1)), '' === t.name && this.unnamedAtrule(t, e), this.init(t, e[2]);
       let r,
        n,
        s,
        a = !1,
        o = !1,
        u = [],
        l = [];
       for (; !this.tokenizer.endOfFile(); ) {
        if (((r = (e = this.tokenizer.nextToken())[0]), '(' === r || '[' === r ? l.push('(' === r ? ')' : ']') : '{' === r && l.length > 0 ? l.push('}') : r === l[l.length - 1] && l.pop(), 0 === l.length)) {
         if (';' === r) {
          (t.source.end = this.getPosition(e[2])), t.source.end.offset++, (this.semicolon = !0);
          break;
         }
         if ('{' === r) {
          o = !0;
          break;
         }
         if ('}' === r) {
          if (u.length > 0) {
           for (s = u.length - 1, n = u[s]; n && 'space' === n[0]; ) n = u[--s];
           n && ((t.source.end = this.getPosition(n[3] || n[2])), t.source.end.offset++);
          }
          this.end(e);
          break;
         }
         u.push(e);
        } else u.push(e);
        if (this.tokenizer.endOfFile()) {
         a = !0;
         break;
        }
       }
       (t.raws.between = this.spacesAndCommentsFromEnd(u)), u.length ? ((t.raws.afterName = this.spacesAndCommentsFromStart(u)), this.raw(t, 'params', u), a && ((e = u[u.length - 1]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++, (this.spaces = t.raws.between), (t.raws.between = ''))) : ((t.raws.afterName = ''), (t.params = '')), o && ((t.nodes = []), (this.current = t));
      }
      checkMissedSemicolon(e) {
       let t = this.colon(e);
       if (!1 === t) return;
       let r,
        n = 0;
       for (let s = t - 1; s >= 0 && ((r = e[s]), 'space' === r[0] || ((n += 1), 2 !== n)); s--);
       throw this.input.error('Missed semicolon', 'word' === r[0] ? r[3] + 1 : r[2]);
      }
      colon(e) {
       let t,
        r,
        n,
        s = 0;
       for (let [i, a] of e.entries()) {
        if (((t = a), (r = t[0]), '(' === r && (s += 1), ')' === r && (s -= 1), 0 === s && ':' === r)) {
         if (n) {
          if ('word' === n[0] && 'progid' === n[1]) continue;
          return i;
         }
         this.doubleColon(t);
        }
        n = t;
       }
       return !1;
      }
      comment(e) {
       let t = new s();
       this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++;
       let r = e[1].slice(2, -2);
       if (/^\s*$/.test(r)) (t.text = ''), (t.raws.left = r), (t.raws.right = '');
       else {
        let e = r.match(/^(\s*)([^]*\S)(\s*)$/);
        (t.text = e[2]), (t.raws.left = e[1]), (t.raws.right = e[3]);
       }
      }
      createTokenizer() {
       this.tokenizer = n(this.input);
      }
      decl(e, t) {
       let n = new r();
       this.init(n, e[0][2]);
       let s,
        i = e[e.length - 1];
       for (
        ';' === i[0] && ((this.semicolon = !0), e.pop()),
         n.source.end = this.getPosition(
          i[3] ||
           i[2] ||
           (function (e) {
            for (let t = e.length - 1; t >= 0; t--) {
             let r = e[t],
              n = r[3] || r[2];
             if (n) return n;
            }
           })(e),
         ),
         n.source.end.offset++;
        'word' !== e[0][0];

       )
        1 === e.length && this.unknownWord(e), (n.raws.before += e.shift()[1]);
       for (n.source.start = this.getPosition(e[0][2]), n.prop = ''; e.length; ) {
        let t = e[0][0];
        if (':' === t || 'space' === t || 'comment' === t) break;
        n.prop += e.shift()[1];
       }
       for (n.raws.between = ''; e.length; ) {
        if (((s = e.shift()), ':' === s[0])) {
         n.raws.between += s[1];
         break;
        }
        'word' === s[0] && /\w/.test(s[1]) && this.unknownWord([s]), (n.raws.between += s[1]);
       }
       ('_' === n.prop[0] || '*' === n.prop[0]) && ((n.raws.before += n.prop[0]), (n.prop = n.prop.slice(1)));
       let a,
        o = [];
       for (; e.length && ((a = e[0][0]), 'space' === a || 'comment' === a); ) o.push(e.shift());
       this.precheckMissedSemicolon(e);
       for (let r = e.length - 1; r >= 0; r--) {
        if (((s = e[r]), '!important' === s[1].toLowerCase())) {
         n.important = !0;
         let t = this.stringFrom(e, r);
         (t = this.spacesFromEnd(e) + t), ' !important' !== t && (n.raws.important = t);
         break;
        }
        if ('important' === s[1].toLowerCase()) {
         let t = e.slice(0),
          s = '';
         for (let e = r; e > 0; e--) {
          let r = t[e][0];
          if (0 === s.trim().indexOf('!') && 'space' !== r) break;
          s = t.pop()[1] + s;
         }
         0 === s.trim().indexOf('!') && ((n.important = !0), (n.raws.important = s), (e = t));
        }
        if ('space' !== s[0] && 'comment' !== s[0]) break;
       }
       e.some((e) => 'space' !== e[0] && 'comment' !== e[0]) && ((n.raws.between += o.map((e) => e[1]).join('')), (o = [])), this.raw(n, 'value', o.concat(e), t), n.value.includes(':') && !t && this.checkMissedSemicolon(e);
      }
      doubleColon(e) {
       throw this.input.error('Double colon', { offset: e[2] }, { offset: e[2] + e[1].length });
      }
      emptyRule(e) {
       let t = new o();
       this.init(t, e[2]), (t.selector = ''), (t.raws.between = ''), (this.current = t);
      }
      end(e) {
       this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.semicolon = !1), (this.current.raws.after = (this.current.raws.after || '') + this.spaces), (this.spaces = ''), this.current.parent ? ((this.current.source.end = this.getPosition(e[2])), this.current.source.end.offset++, (this.current = this.current.parent)) : this.unexpectedClose(e);
      }
      endFile() {
       this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.current.raws.after = (this.current.raws.after || '') + this.spaces), (this.root.source.end = this.getPosition(this.tokenizer.position()));
      }
      freeSemicolon(e) {
       if (((this.spaces += e[1]), this.current.nodes)) {
        let e = this.current.nodes[this.current.nodes.length - 1];
        e && 'rule' === e.type && !e.raws.ownSemicolon && ((e.raws.ownSemicolon = this.spaces), (this.spaces = ''));
       }
      }
      getPosition(e) {
       let t = this.input.fromOffset(e);
       return { column: t.col, line: t.line, offset: e };
      }
      init(e, t) {
       this.current.push(e), (e.source = { input: this.input, start: this.getPosition(t) }), (e.raws.before = this.spaces), (this.spaces = ''), 'comment' !== e.type && (this.semicolon = !1);
      }
      other(e) {
       let t = !1,
        r = null,
        n = !1,
        s = null,
        i = [],
        a = e[1].startsWith('--'),
        o = [],
        u = e;
       for (; u; ) {
        if (((r = u[0]), o.push(u), '(' === r || '[' === r)) s || (s = u), i.push('(' === r ? ')' : ']');
        else if (a && n && '{' === r) s || (s = u), i.push('}');
        else if (0 === i.length) {
         if (';' === r) {
          if (n) return void this.decl(o, a);
          break;
         }
         if ('{' === r) return void this.rule(o);
         if ('}' === r) {
          this.tokenizer.back(o.pop()), (t = !0);
          break;
         }
         ':' === r && (n = !0);
        } else r === i[i.length - 1] && (i.pop(), 0 === i.length && (s = null));
        u = this.tokenizer.nextToken();
       }
       if ((this.tokenizer.endOfFile() && (t = !0), i.length > 0 && this.unclosedBracket(s), t && n)) {
        if (!a) for (; o.length && ((u = o[o.length - 1][0]), 'space' === u || 'comment' === u); ) this.tokenizer.back(o.pop());
        this.decl(o, a);
       } else this.unknownWord(o);
      }
      parse() {
       let e;
       for (; !this.tokenizer.endOfFile(); )
        switch (((e = this.tokenizer.nextToken()), e[0])) {
         case 'space':
          this.spaces += e[1];
          break;
         case ';':
          this.freeSemicolon(e);
          break;
         case '}':
          this.end(e);
          break;
         case 'comment':
          this.comment(e);
          break;
         case 'at-word':
          this.atrule(e);
          break;
         case '{':
          this.emptyRule(e);
          break;
         default:
          this.other(e);
        }
       this.endFile();
      }
      precheckMissedSemicolon() {}
      raw(e, t, r, n) {
       let s,
        i,
        a,
        o,
        l = r.length,
        p = '',
        c = !0;
       for (let h = 0; h < l; h += 1) (s = r[h]), (i = s[0]), 'space' !== i || h !== l - 1 || n ? ('comment' === i ? ((o = r[h - 1] ? r[h - 1][0] : 'empty'), (a = r[h + 1] ? r[h + 1][0] : 'empty'), u[o] || u[a] || ',' === p.slice(-1) ? (c = !1) : (p += s[1])) : (p += s[1])) : (c = !1);
       if (!c) {
        let n = r.reduce((e, t) => e + t[1], '');
        e.raws[t] = { raw: n, value: p };
       }
       e[t] = p;
      }
      rule(e) {
       e.pop();
       let t = new o();
       this.init(t, e[0][2]), (t.raws.between = this.spacesAndCommentsFromEnd(e)), this.raw(t, 'selector', e), (this.current = t);
      }
      spacesAndCommentsFromEnd(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[e.length - 1][0]), 'space' === t || 'comment' === t); ) r = e.pop()[1] + r;
       return r;
      }
      spacesAndCommentsFromStart(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[0][0]), 'space' === t || 'comment' === t); ) r += e.shift()[1];
       return r;
      }
      spacesFromEnd(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[e.length - 1][0]), 'space' === t); ) r = e.pop()[1] + r;
       return r;
      }
      stringFrom(e, t) {
       let r = '';
       for (let n = t; n < e.length; n++) r += e[n][1];
       return e.splice(t, e.length - t), r;
      }
      unclosedBlock() {
       let e = this.current.source.start;
       throw this.input.error('Unclosed block', e.line, e.column);
      }
      unclosedBracket(e) {
       throw this.input.error('Unclosed bracket', { offset: e[2] }, { offset: e[2] + 1 });
      }
      unexpectedClose(e) {
       throw this.input.error('Unexpected }', { offset: e[2] }, { offset: e[2] + 1 });
      }
      unknownWord(e) {
       throw this.input.error('Unknown word', { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
      }
      unnamedAtrule(e, t) {
       throw this.input.error('At-rule without name', { offset: t[2] }, { offset: t[2] + t[1].length });
      }
     };
    }),
    k = l(() => {}),
    P = l((e, t) => {
     t.exports = {
      nanoid: (e = 21) => {
       let t = '',
        r = e;
       for (; r--; ) t += 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'[(64 * Math.random()) | 0];
       return t;
      },
      customAlphabet:
       (e, t = 21) =>
       (r = t) => {
        let n = '',
         s = r;
        for (; s--; ) n += e[(Math.random() * e.length) | 0];
        return n;
       },
     };
    }),
    I = l((e, t) => {
     t.exports = class {};
    }),
    N = l((e, t) => {
     var { SourceMapConsumer: r, SourceMapGenerator: n } = k(),
      { fileURLToPath: s, pathToFileURL: i } = {},
      { isAbsolute: a, resolve: o } = {},
      { nanoid: u } = P(),
      l = m(),
      p = y(),
      c = I(),
      h = Symbol('fromOffsetCache'),
      d = !(!r || !n),
      f = !(!o || !a),
      g = class {
       constructor(e, t = {}) {
        if (null === e || typeof e > 'u' || ('object' == typeof e && !e.toString)) throw new Error(`PostCSS received ${e} instead of CSS string`);
        if (((this.css = e.toString()), '\ufeff' === this.css[0] || '\ufffe' === this.css[0] ? ((this.hasBOM = !0), (this.css = this.css.slice(1))) : (this.hasBOM = !1), t.from && (!f || /^\w+:\/\//.test(t.from) || a(t.from) ? (this.file = t.from) : (this.file = o(t.from))), f && d)) {
         let e = new c(this.css, t);
         if (e.text) {
          this.map = e;
          let t = e.consumer().file;
          !this.file && t && (this.file = this.mapResolve(t));
         }
        }
        this.file || (this.id = '<input css ' + u(6) + '>'), this.map && (this.map.file = this.from);
       }
       error(e, t, r, n = {}) {
        let s, a, o;
        if (t && 'object' == typeof t) {
         let e = t,
          n = r;
         if ('number' == typeof e.offset) {
          let n = this.fromOffset(e.offset);
          (t = n.line), (r = n.col);
         } else (t = e.line), (r = e.column);
         if ('number' == typeof n.offset) {
          let e = this.fromOffset(n.offset);
          (a = e.line), (o = e.col);
         } else (a = n.line), (o = n.column);
        } else if (!r) {
         let e = this.fromOffset(t);
         (t = e.line), (r = e.col);
        }
        let u = this.origin(t, r, a, o);
        return (s = u ? new p(e, void 0 === u.endLine ? u.line : { column: u.column, line: u.line }, void 0 === u.endLine ? u.column : { column: u.endColumn, line: u.endLine }, u.source, u.file, n.plugin) : new p(e, void 0 === a ? t : { column: r, line: t }, void 0 === a ? r : { column: o, line: a }, this.css, this.file, n.plugin)), (s.input = { column: r, endColumn: o, endLine: a, line: t, source: this.css }), this.file && (i && (s.input.url = i(this.file).toString()), (s.input.file = this.file)), s;
       }
       fromOffset(e) {
        let t, r;
        if (this[h]) r = this[h];
        else {
         let e = this.css.split('\n');
         r = new Array(e.length);
         let t = 0;
         for (let n = 0, s = e.length; n < s; n++) (r[n] = t), (t += e[n].length + 1);
         this[h] = r;
        }
        t = r[r.length - 1];
        let n = 0;
        if (e >= t) n = r.length - 1;
        else {
         let t,
          s = r.length - 2;
         for (; n < s; )
          if (((t = n + ((s - n) >> 1)), e < r[t])) s = t - 1;
          else {
           if (!(e >= r[t + 1])) {
            n = t;
            break;
           }
           n = t + 1;
          }
        }
        return { col: e - r[n] + 1, line: n + 1 };
       }
       mapResolve(e) {
        return /^\w+:\/\//.test(e) ? e : o(this.map.consumer().sourceRoot || this.map.root || '.', e);
       }
       origin(e, t, r, n) {
        if (!this.map) return !1;
        let o,
         u,
         l = this.map.consumer(),
         p = l.originalPositionFor({ column: t, line: e });
        if (!p.source) return !1;
        'number' == typeof r && (o = l.originalPositionFor({ column: n, line: r })), (u = a(p.source) ? i(p.source) : new URL(p.source, this.map.consumer().sourceRoot || i(this.map.mapFile)));
        let c = { column: p.column, endColumn: o && o.column, endLine: o && o.line, line: p.line, url: u.toString() };
        if ('file:' === u.protocol) {
         if (!s) throw new Error('file: protocol is not available in this PostCSS build');
         c.file = s(u);
        }
        let h = l.sourceContentFor(p.source);
        return h && (c.source = h), c;
       }
       toJSON() {
        let e = {};
        for (let t of ['hasBOM', 'css', 'file', 'id']) null != this[t] && (e[t] = this[t]);
        return this.map && ((e.map = { ...this.map }), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
       }
       get from() {
        return this.file || this.id;
       }
      };
     (t.exports = g), (g.default = g), l && l.registerInput && l.registerInput(g);
    }),
    B = l((e, t) => {
     var r = E(),
      n = F(),
      s = N();
     function i(e, t) {
      let r = new s(e, t),
       i = new n(r);
      try {
       i.parse();
      } catch (a) {
       throw a;
      }
      return i.root;
     }
     (t.exports = i), (i.default = i), r.registerParse(i);
    }),
    _ = l((e, t) => {
     var r = C(),
      n = N();
     t.exports = {
      isInlineComment(e) {
       if ('word' === e[0] && '//' === e[1].slice(0, 2)) {
        let t,
         s,
         i = e,
         a = [];
        for (; e; ) {
         if (/\r?\n/.test(e[1])) {
          if (/['"].*\r?\n/.test(e[1])) {
           a.push(e[1].substring(0, e[1].indexOf('\n'))), (s = e[1].substring(e[1].indexOf('\n')));
           let r = this.input.css.valueOf().substring(this.tokenizer.position());
           (s += r), (t = e[3] + r.length - s.length);
          } else this.tokenizer.back(e);
          break;
         }
         a.push(e[1]), (t = e[2]), (e = this.tokenizer.nextToken({ ignoreUnclosed: !0 }));
        }
        let o = ['comment', a.join(''), i[2], t];
        return this.inlineComment(o), s && ((this.input = new n(s)), (this.tokenizer = r(this.input))), !0;
       }
       if ('/' === e[1]) {
        let r = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
        if ('comment' === r[0] && /^\/\*/.test(r[1])) return (r[0] = 'word'), (r[1] = r[1].slice(1)), (e[1] = '//'), this.tokenizer.back(r), t.exports.isInlineComment.bind(this)(e);
       }
       return !1;
      },
     };
    }),
    L = l((e, t) => {
     t.exports = {
      interpolation(e) {
       let t = [e, this.tokenizer.nextToken()],
        r = ['word', '}'];
       if (t[0][1].length > 1 || '{' !== t[1][0]) return this.tokenizer.back(t[1]), !1;
       for (e = this.tokenizer.nextToken(); e && r.includes(e[0]); ) t.push(e), (e = this.tokenizer.nextToken());
       let n = t.map((e) => e[1]),
        [s] = t,
        i = t.pop(),
        a = ['word', n.join(''), s[2], i[2]];
       return this.tokenizer.back(e), this.tokenizer.back(a), !0;
      },
     };
    }),
    O = l((e, t) => {
     var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/,
      n = /\.[0-9]/;
     t.exports = {
      isMixinToken: (e) => {
       let [, t] = e,
        [s] = t;
       return ('.' === s || '#' === s) && !1 === r.test(t) && !1 === n.test(t);
      },
     };
    }),
    M = l((e, t) => {
     var r = C(),
      n = /^url\((.+)\)/;
     t.exports = (e) => {
      let { name: t, params: s = '' } = e;
      if ('import' === t && s.length) {
       e.import = !0;
       let t = r({ css: s });
       for (e.filename = s.replace(n, '$1'); !t.endOfFile(); ) {
        let [r, n] = t.nextToken();
        if ('word' === r && 'url' === n) return;
        if ('brackets' === r) {
         (e.options = n), (e.filename = s.replace(n, '').trim());
         break;
        }
       }
      }
     };
    }),
    j = l((e, t) => {
     var r = /:$/,
      n = /^:(\s+)?/;
     t.exports = (e) => {
      let { name: t, params: s = '' } = e;
      if (':' === e.name.slice(-1)) {
       if (r.test(t)) {
        let [n] = t.match(r);
        (e.name = t.replace(n, '')), (e.raws.afterName = n + (e.raws.afterName || '')), (e.variable = !0), (e.value = e.params);
       }
       if (n.test(s)) {
        let [t] = s.match(n);
        (e.value = s.replace(t, '')), (e.raws.afterName = (e.raws.afterName || '') + t), (e.variable = !0);
       }
      }
     };
    }),
    R = l((e, t) => {
     var r = v(),
      n = F(),
      { isInlineComment: s } = _(),
      { interpolation: i } = L(),
      { isMixinToken: a } = O(),
      o = M(),
      u = j(),
      l = /(!\s*important)$/i;
     t.exports = class extends n {
      constructor(...e) {
       super(...e), (this.lastNode = null);
      }
      atrule(e) {
       i.bind(this)(e) || (super.atrule(e), o(this.lastNode), u(this.lastNode));
      }
      decl(...e) {
       super.decl(...e), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
      }
      each(e) {
       e[0][1] = ` ${e[0][1]}`;
       let t = e.findIndex((e) => '(' === e[0]),
        r = e.reverse().find((e) => ')' === e[0]),
        n = e.reverse().indexOf(r),
        s = e
         .splice(t, n)
         .map((e) => e[1])
         .join('');
       for (let i of e.reverse()) this.tokenizer.back(i);
       this.atrule(this.tokenizer.nextToken()), (this.lastNode.function = !0), (this.lastNode.params = s);
      }
      init(e, t, r) {
       super.init(e, t, r), (this.lastNode = e);
      }
      inlineComment(e) {
       let t = new r(),
        n = e[1].slice(2);
       if ((this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), (t.inline = !0), (t.raws.begin = '//'), /^\s*$/.test(n))) (t.text = ''), (t.raws.left = n), (t.raws.right = '');
       else {
        let e = n.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, t.raws.left, t.text, t.raws.right] = e;
       }
      }
      mixin(e) {
       let [t] = e,
        r = t[1].slice(0, 1),
        n = e.findIndex((e) => 'brackets' === e[0]),
        s = e.findIndex((e) => '(' === e[0]),
        i = '';
       if ((n < 0 || n > 3) && s > 0) {
        let t = e.reduce((e, t, r) => (')' === t[0] ? r : e)),
         r = e
          .slice(s, t + s)
          .map((e) => e[1])
          .join(''),
         [n] = e.slice(s),
         i = [n[2], n[3]],
         [a] = e.slice(t, t + 1),
         o = [a[2], a[3]],
         u = ['brackets', r].concat(i, o),
         l = e.slice(0, s),
         p = e.slice(t + 1);
        (e = l).push(u), (e = e.concat(p));
       }
       let a = [];
       for (let u of e) if ((('!' === u[1] || a.length) && a.push(u), 'important' === u[1])) break;
       if (a.length) {
        let [t] = a,
         r = e.indexOf(t),
         n = a[a.length - 1],
         s = [t[2], t[3]],
         i = [n[4], n[5]],
         o = ['word', a.map((e) => e[1]).join('')].concat(s, i);
        e.splice(r, a.length, o);
       }
       let o = e.findIndex((e) => l.test(e[1]));
       o > 0 && (([, i] = e[o]), e.splice(o, 1));
       for (let u of e.reverse()) this.tokenizer.back(u);
       this.atrule(this.tokenizer.nextToken()), (this.lastNode.mixin = !0), (this.lastNode.raws.identifier = r), i && ((this.lastNode.important = !0), (this.lastNode.raws.important = i));
      }
      other(e) {
       s.bind(this)(e) || super.other(e);
      }
      rule(e) {
       let t = e[e.length - 1],
        r = e[e.length - 2];
       if ('at-word' === r[0] && '{' === t[0] && (this.tokenizer.back(t), i.bind(this)(r))) {
        let t = this.tokenizer.nextToken();
        e = e.slice(0, e.length - 2).concat([t]);
        for (let r of e.reverse()) this.tokenizer.back(r);
       } else super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
      }
      unknownWord(e) {
       let [t] = e;
       'each' !== e[0][1] || '(' !== e[1][0] ? (a(t) ? this.mixin(e) : super.unknownWord(e)) : this.each(e);
      }
     };
    }),
    q = l((e, t) => {
     var r = g();
     t.exports = class extends r {
      atrule(e, t) {
       if (!e.mixin && !e.variable && !e.function) return void super.atrule(e, t);
       let r = `${e.function ? '' : e.raws.identifier || '@'}${e.name}`,
        n = e.params ? this.rawValue(e, 'params') : '',
        s = e.raws.important || '';
       if ((e.variable && (n = e.value), typeof e.raws.afterName < 'u' ? (r += e.raws.afterName) : n && (r += ' '), e.nodes)) this.block(e, r + n + s);
       else {
        let i = (e.raws.between || '') + s + (t ? ';' : '');
        this.builder(r + n + i, e);
       }
      }
      comment(e) {
       if (e.inline) {
        let t = this.raw(e, 'left', 'commentLeft'),
         r = this.raw(e, 'right', 'commentRight');
        this.builder(`//${t}${e.text}${r}`, e);
       } else super.comment(e);
      }
     };
    }),
    U = l((e, t) => {
     var r = N(),
      n = R(),
      s = q();
     t.exports = {
      parse(e, t) {
       let s = new r(e, t),
        i = new n(s);
       return (
        i.parse(),
        i.root.walk((e) => {
         let t = s.css.lastIndexOf(e.source.input.css);
         if (0 === t) return;
         if (t + e.source.input.css.length !== s.css.length) throw new Error('Invalid state detected in postcss-less');
         let r = t + e.source.start.offset,
          n = s.fromOffset(t + e.source.start.offset);
         if (((e.source.start = { offset: r, line: n.line, column: n.col }), e.source.end)) {
          let r = t + e.source.end.offset,
           n = s.fromOffset(t + e.source.end.offset);
          e.source.end = { offset: r, line: n.line, column: n.col };
         }
        }),
        i.root
       );
      },
      stringify(e, t) {
       new s(t).stringify(e);
      },
      nodeToString(e) {
       let r = '';
       return (
        t.exports.stringify(e, (e) => {
         r += e;
        }),
        r
       );
      },
     };
    }),
    $ = l((e, t) => {
     t.exports = class {
      generate() {}
     };
    }),
    H = l((e, t) => {
     var r,
      n,
      s = E(),
      i = class extends s {
       constructor(e) {
        super({ type: 'document', ...e }), this.nodes || (this.nodes = []);
       }
       toResult(e = {}) {
        return new r(new n(), this, e).stringify();
       }
      };
     (i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       n = e;
      }),
      (t.exports = i),
      (i.default = i);
    }),
    z = l((e, t) => {
     var r = {};
     t.exports = function (e) {
      r[e] || ((r[e] = !0), typeof console < 'u' && console.warn && console.warn(e));
     };
    }),
    V = l((e, t) => {
     var r = class {
      constructor(e, t = {}) {
       if (((this.type = 'warning'), (this.text = e), t.node && t.node.source)) {
        let e = t.node.rangeBy(t);
        (this.line = e.start.line), (this.column = e.start.column), (this.endLine = e.end.line), (this.endColumn = e.end.column);
       }
       for (let r in t) this[r] = t[r];
      }
      toString() {
       return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ': ' + this.text : this.text;
      }
     };
     (t.exports = r), (r.default = r);
    }),
    W = l((e, t) => {
     var r = V(),
      n = class {
       constructor(e, t, r) {
        (this.processor = e), (this.messages = []), (this.root = t), (this.opts = r), (this.css = void 0), (this.map = void 0);
       }
       toString() {
        return this.css;
       }
       warn(e, t = {}) {
        t.plugin || (this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin));
        let n = new r(e, t);
        return this.messages.push(n), n;
       }
       warnings() {
        return this.messages.filter((e) => 'warning' === e.type);
       }
       get content() {
        return this.css;
       }
      };
     (t.exports = n), (n.default = n);
    }),
    J = l((e, t) => {
     var { isClean: r, my: n } = d(),
      s = $(),
      i = D(),
      a = E(),
      o = H(),
      u = (z(), W()),
      l = B(),
      p = S(),
      c = { atrule: 'AtRule', comment: 'Comment', decl: 'Declaration', document: 'Document', root: 'Root', rule: 'Rule' },
      h = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 },
      f = { Once: !0, postcssPlugin: !0, prepare: !0 },
      m = 0;
     function y(e) {
      return 'object' == typeof e && 'function' == typeof e.then;
     }
     function g(e) {
      let t = !1,
       r = c[e.type];
      return 'decl' === e.type ? (t = e.prop.toLowerCase()) : 'atrule' === e.type && (t = e.name.toLowerCase()), t && e.append ? [r, r + '-' + t, m, r + 'Exit', r + 'Exit-' + t] : t ? [r, r + '-' + t, r + 'Exit', r + 'Exit-' + t] : e.append ? [r, m, r + 'Exit'] : [r, r + 'Exit'];
     }
     function x(e) {
      let t;
      return (t = 'document' === e.type ? ['Document', m, 'DocumentExit'] : 'root' === e.type ? ['Root', m, 'RootExit'] : g(e)), { eventIndex: 0, events: t, iterator: 0, node: e, visitorIndex: 0, visitors: [] };
     }
     function b(e) {
      return (e[r] = !1), e.nodes && e.nodes.forEach((e) => b(e)), e;
     }
     var v = {},
      C = class e {
       constructor(t, r, s) {
        let i;
        if (((this.stringified = !1), (this.processed = !1), 'object' != typeof r || null === r || ('root' !== r.type && 'document' !== r.type)))
         if (r instanceof e || r instanceof u) (i = b(r.root)), r.map && (typeof s.map > 'u' && (s.map = {}), s.map.inline || (s.map.inline = !1), (s.map.prev = r.map));
         else {
          let e = l;
          s.syntax && (e = s.syntax.parse), s.parser && (e = s.parser), e.parse && (e = e.parse);
          try {
           i = e(r, s);
          } catch (o) {
           (this.processed = !0), (this.error = o);
          }
          i && !i[n] && a.rebuild(i);
         }
        else i = b(r);
        (this.result = new u(t, i, s)), (this.helpers = { ...v, postcss: v, result: this.result }), (this.plugins = this.processor.plugins.map((e) => ('object' == typeof e && e.prepare ? { ...e, ...e.prepare(this.result) } : e)));
       }
       async() {
        return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
       }
       catch(e) {
        return this.async().catch(e);
       }
       finally(e) {
        return this.async().then(e, e);
       }
       getAsyncError() {
        throw new Error('Use process(css).then(cb) to work with async plugins');
       }
       handleError(e, t) {
        let r = this.result.lastPlugin;
        try {
         t && t.addToError(e), (this.error = e), 'CssSyntaxError' !== e.name || e.plugin ? r.postcssVersion : ((e.plugin = r.postcssPlugin), e.setMessage());
        } catch (n) {
         console && console.error && console.error(n);
        }
        return e;
       }
       prepareVisitors() {
        this.listeners = {};
        let e = (e, t, r) => {
         this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push([e, r]);
        };
        for (let t of this.plugins)
         if ('object' == typeof t)
          for (let r in t) {
           if (!h[r] && /^[A-Z]/.test(r)) throw new Error(`Unknown event ${r} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
           if (!f[r])
            if ('object' == typeof t[r]) for (let n in t[r]) e(t, '*' === n ? r : r + '-' + n.toLowerCase(), t[r][n]);
            else 'function' == typeof t[r] && e(t, r, t[r]);
          }
        this.hasListener = Object.keys(this.listeners).length > 0;
       }
       async runAsync() {
        this.plugin = 0;
        for (let t = 0; t < this.plugins.length; t++) {
         let r = this.plugins[t],
          n = this.runOnRoot(r);
         if (y(n))
          try {
           await n;
          } catch (e) {
           throw this.handleError(e);
          }
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let t = this.result.root;
         for (; !t[r]; ) {
          t[r] = !0;
          let n = [x(t)];
          for (; n.length > 0; ) {
           let t = this.visitTick(n);
           if (y(t))
            try {
             await t;
            } catch (e) {
             let t = n[n.length - 1].node;
             throw this.handleError(e, t);
            }
          }
         }
         if (this.listeners.OnceExit)
          for (let [r, n] of this.listeners.OnceExit) {
           this.result.lastPlugin = r;
           try {
            if ('document' === t.type) {
             let e = t.nodes.map((e) => n(e, this.helpers));
             await Promise.all(e);
            } else await n(t, this.helpers);
           } catch (e) {
            throw this.handleError(e);
           }
          }
        }
        return (this.processed = !0), this.stringify();
       }
       runOnRoot(e) {
        this.result.lastPlugin = e;
        try {
         if ('object' == typeof e && e.Once) {
          if ('document' === this.result.root.type) {
           let t = this.result.root.nodes.map((t) => e.Once(t, this.helpers));
           return y(t[0]) ? Promise.all(t) : t;
          }
          return e.Once(this.result.root, this.helpers);
         }
         if ('function' == typeof e) return e(this.result.root, this.result);
        } catch (t) {
         throw this.handleError(t);
        }
       }
       stringify() {
        if (this.error) throw this.error;
        if (this.stringified) return this.result;
        (this.stringified = !0), this.sync();
        let e = this.result.opts,
         t = i;
        e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
        let r = new s(t, this.result.root, this.result.opts).generate();
        return (this.result.css = r[0]), (this.result.map = r[1]), this.result;
       }
       sync() {
        if (this.error) throw this.error;
        if (this.processed) return this.result;
        if (((this.processed = !0), this.processing)) throw this.getAsyncError();
        for (let e of this.plugins) {
         if (y(this.runOnRoot(e))) throw this.getAsyncError();
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let e = this.result.root;
         for (; !e[r]; ) (e[r] = !0), this.walkSync(e);
         if (this.listeners.OnceExit)
          if ('document' === e.type) for (let t of e.nodes) this.visitSync(this.listeners.OnceExit, t);
          else this.visitSync(this.listeners.OnceExit, e);
        }
        return this.result;
       }
       then(e, t) {
        return this.async().then(e, t);
       }
       toString() {
        return this.css;
       }
       visitSync(e, t) {
        for (let [n, s] of e) {
         let e;
         this.result.lastPlugin = n;
         try {
          e = s(t, this.helpers);
         } catch (r) {
          throw this.handleError(r, t.proxyOf);
         }
         if ('root' !== t.type && 'document' !== t.type && !t.parent) return !0;
         if (y(e)) throw this.getAsyncError();
        }
       }
       visitTick(e) {
        let t = e[e.length - 1],
         { node: n, visitors: s } = t;
        if ('root' !== n.type && 'document' !== n.type && !n.parent) return void e.pop();
        if (s.length > 0 && t.visitorIndex < s.length) {
         let [e, r] = s[t.visitorIndex];
         (t.visitorIndex += 1), t.visitorIndex === s.length && ((t.visitors = []), (t.visitorIndex = 0)), (this.result.lastPlugin = e);
         try {
          return r(n.toProxy(), this.helpers);
         } catch (a) {
          throw this.handleError(a, n);
         }
        }
        if (0 !== t.iterator) {
         let s,
          i = t.iterator;
         for (; (s = n.nodes[n.indexes[i]]); ) if (((n.indexes[i] += 1), !s[r])) return (s[r] = !0), void e.push(x(s));
         (t.iterator = 0), delete n.indexes[i];
        }
        let i = t.events;
        for (; t.eventIndex < i.length; ) {
         let e = i[t.eventIndex];
         if (((t.eventIndex += 1), e === m)) return void (n.nodes && n.nodes.length && ((n[r] = !0), (t.iterator = n.getIterator())));
         if (this.listeners[e]) return void (t.visitors = this.listeners[e]);
        }
        e.pop();
       }
       walkSync(e) {
        e[r] = !0;
        let t = g(e);
        for (let n of t)
         if (n === m)
          e.nodes &&
           e.each((e) => {
            e[r] || this.walkSync(e);
           });
         else {
          let t = this.listeners[n];
          if (t && this.visitSync(t, e.toProxy())) return;
         }
       }
       warnings() {
        return this.sync().warnings();
       }
       get content() {
        return this.stringify().content;
       }
       get css() {
        return this.stringify().css;
       }
       get map() {
        return this.stringify().map;
       }
       get messages() {
        return this.sync().messages;
       }
       get opts() {
        return this.result.opts;
       }
       get processor() {
        return this.result.processor;
       }
       get root() {
        return this.sync().root;
       }
       get [Symbol.toStringTag]() {
        return 'LazyResult';
       }
      };
     (C.registerPostcss = (e) => {
      v = e;
     }),
      (t.exports = C),
      (C.default = C),
      p.registerLazyResult(C),
      o.registerLazyResult(C);
    }),
    K = l((e, t) => {
     var r = $(),
      n = D(),
      s = (z(), B()),
      i = W(),
      a = class {
       constructor(e, t, s) {
        (t = t.toString()), (this.stringified = !1), (this._processor = e), (this._css = t), (this._opts = s), (this._map = void 0);
        let a,
         o = n;
        (this.result = new i(this._processor, a, this._opts)), (this.result.css = t);
        let u = this;
        Object.defineProperty(this.result, 'root', { get: () => u.root });
        let l = new r(o, a, this._opts, t);
        if (l.isMap()) {
         let [e, t] = l.generate();
         e && (this.result.css = e), t && (this.result.map = t);
        } else l.clearAnnotation(), (this.result.css = l.css);
       }
       async() {
        return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
       }
       catch(e) {
        return this.async().catch(e);
       }
       finally(e) {
        return this.async().then(e, e);
       }
       sync() {
        if (this.error) throw this.error;
        return this.result;
       }
       then(e, t) {
        return this.async().then(e, t);
       }
       toString() {
        return this._css;
       }
       warnings() {
        return [];
       }
       get content() {
        return this.result.css;
       }
       get css() {
        return this.result.css;
       }
       get map() {
        return this.result.map;
       }
       get messages() {
        return [];
       }
       get opts() {
        return this.result.opts;
       }
       get processor() {
        return this.result.processor;
       }
       get root() {
        if (this._root) return this._root;
        let e,
         t = s;
        try {
         e = t(this._css, this._opts);
        } catch (r) {
         this.error = r;
        }
        if (this.error) throw this.error;
        return (this._root = e), e;
       }
       get [Symbol.toStringTag]() {
        return 'NoWorkResult';
       }
      };
     (t.exports = a), (a.default = a);
    }),
    G = l((e, t) => {
     var r = K(),
      n = J(),
      s = H(),
      i = S(),
      a = class {
       constructor(e = []) {
        (this.version = '8.4.38'), (this.plugins = this.normalize(e));
       }
       normalize(e) {
        let t = [];
        for (let r of e)
         if ((!0 === r.postcss ? (r = r()) : r.postcss && (r = r.postcss), 'object' == typeof r && Array.isArray(r.plugins))) t = t.concat(r.plugins);
         else if ('object' == typeof r && r.postcssPlugin) t.push(r);
         else if ('function' == typeof r) t.push(r);
         else if ('object' != typeof r || (!r.parse && !r.stringify)) throw new Error(r + ' is not a PostCSS plugin');
        return t;
       }
       process(e, t = {}) {
        return this.plugins.length || t.parser || t.stringifier || t.syntax ? new n(this, e, t) : new r(this, e, t);
       }
       use(e) {
        return (this.plugins = this.plugins.concat(this.normalize([e]))), this;
       }
      };
     (t.exports = a), (a.default = a), i.registerProcessor(a), s.registerProcessor(a);
    }),
    X = l((e, t) => {
     var r = b(),
      n = I(),
      s = v(),
      i = T(),
      a = N(),
      o = S(),
      u = A();
     function l(e, t) {
      if (Array.isArray(e)) return e.map((e) => l(e));
      let { inputs: p, ...c } = e;
      if (p) {
       t = [];
       for (let e of p) {
        let r = { ...e, __proto__: a.prototype };
        r.map && (r.map = { ...r.map, __proto__: n.prototype }), t.push(r);
       }
      }
      if ((c.nodes && (c.nodes = e.nodes.map((e) => l(e, t))), c.source)) {
       let { inputId: e, ...r } = c.source;
       (c.source = r), null != e && (c.source.input = t[e]);
      }
      if ('root' === c.type) return new o(c);
      if ('decl' === c.type) return new r(c);
      if ('rule' === c.type) return new u(c);
      if ('comment' === c.type) return new s(c);
      if ('atrule' === c.type) return new i(c);
      throw new Error('Unknown node type: ' + e.type);
     }
     (t.exports = l), (l.default = l);
    }),
    Y = l((e, t) => {
     var r = y(),
      n = b(),
      s = J(),
      i = E(),
      a = G(),
      o = D(),
      u = X(),
      l = H(),
      p = V(),
      c = v(),
      h = T(),
      d = W(),
      f = N(),
      m = B(),
      g = w(),
      C = A(),
      F = S(),
      k = x();
     function P(...e) {
      return 1 === e.length && Array.isArray(e[0]) && (e = e[0]), new a(e);
     }
     (P.plugin = function (e, t) {
      let r,
       n = !1;
      function s(...r) {
       console && console.warn && !n && ((n = !0), console.warn(e + ': postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration'));
       let s = t(...r);
       return (s.postcssPlugin = e), (s.postcssVersion = new a().version), s;
      }
      return (
       Object.defineProperty(s, 'postcss', { get: () => (r || (r = s()), r) }),
       (s.process = function (e, t, r) {
        return P([s(r)]).process(e, t);
       }),
       s
      );
     }),
      (P.stringify = o),
      (P.parse = m),
      (P.fromJSON = u),
      (P.list = g),
      (P.comment = (e) => new c(e)),
      (P.atRule = (e) => new h(e)),
      (P.decl = (e) => new n(e)),
      (P.rule = (e) => new C(e)),
      (P.root = (e) => new F(e)),
      (P.document = (e) => new l(e)),
      (P.CssSyntaxError = r),
      (P.Declaration = n),
      (P.Container = i),
      (P.Processor = a),
      (P.Document = l),
      (P.Comment = c),
      (P.Warning = p),
      (P.AtRule = h),
      (P.Result = d),
      (P.Input = f),
      (P.Rule = C),
      (P.Root = F),
      (P.Node = k),
      s.registerPostcss(P),
      (t.exports = P),
      (P.default = P);
    }),
    Q = l((e, t) => {
     var { Container: r } = Y();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'decl'), (this.isNested = !0), this.nodes || (this.nodes = []);
      }
     };
    }),
    Z = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      n = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      s = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i,
      a = /[\n\f\r]/g;
     t.exports = function (e, t = {}) {
      let o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       g = e.css.valueOf(),
       D = t.ignoreErrors,
       x = g.length,
       b = 0,
       v = [],
       E = [];
      function C(t) {
       throw e.error('Unclosed ' + t, b);
      }
      function T() {
       let e = 1,
        t = !1,
        r = !1;
       for (; e > 0; ) (u += 1), g.length <= u && C('interpolation'), (o = g.charCodeAt(u)), (f = g.charCodeAt(u + 1)), t ? (r || o !== t ? (92 === o ? (r = !r) : r && (r = !1)) : ((t = !1), (r = !1))) : 39 === o || 34 === o ? (t = o) : 125 === o ? (e -= 1) : 35 === o && 123 === f && (e += 1);
      }
      return {
       back: function (e) {
        E.push(e);
       },
       endOfFile: function () {
        return 0 === E.length && b >= x;
       },
       nextToken: function (e) {
        if (E.length) return E.pop();
        if (b >= x) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((o = g.charCodeAt(b)), o)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          u = b;
          do {
           (u += 1), (o = g.charCodeAt(u));
          } while (32 === o || 10 === o || 9 === o || 13 === o || 12 === o);
          (m = ['space', g.slice(b, u)]), (b = u - 1);
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(o);
          m = [e, e, b];
          break;
         }
         case 44:
          m = ['word', ',', b, b + 1];
          break;
         case 40:
          if (((d = v.length ? v.pop()[1] : ''), (f = g.charCodeAt(b + 1)), 'url' === d && 39 !== f && 34 !== f)) {
           for (y = 1, h = !1, u = b + 1; u <= g.length - 1; ) {
            if (((f = g.charCodeAt(u)), 92 === f)) h = !h;
            else if (40 === f) y += 1;
            else if (41 === f && ((y -= 1), 0 === y)) break;
            u += 1;
           }
           (p = g.slice(b, u + 1)), (m = ['brackets', p, b, u]), (b = u);
          } else (u = g.indexOf(')', b + 1)), (p = g.slice(b, u + 1)), -1 === u || s.test(p) ? (m = ['(', '(', b]) : ((m = ['brackets', p, b, u]), (b = u));
          break;
         case 39:
         case 34:
          for (l = o, u = b, h = !1; u < x && (u++, u === x && C('string'), (o = g.charCodeAt(u)), (f = g.charCodeAt(u + 1)), h || o !== l); ) 92 === o ? (h = !h) : h ? (h = !1) : 35 === o && 123 === f && T();
          (m = ['string', g.slice(b, u + 1), b, u]), (b = u);
          break;
         case 64:
          (r.lastIndex = b + 1), r.test(g), (u = 0 === r.lastIndex ? g.length - 1 : r.lastIndex - 2), (m = ['at-word', g.slice(b, u + 1), b, u]), (b = u);
          break;
         case 92:
          for (u = b, c = !0; 92 === g.charCodeAt(u + 1); ) (u += 1), (c = !c);
          if (((o = g.charCodeAt(u + 1)), c && 47 !== o && 32 !== o && 10 !== o && 9 !== o && 13 !== o && 12 !== o && ((u += 1), i.test(g.charAt(u))))) {
           for (; i.test(g.charAt(u + 1)); ) u += 1;
           32 === g.charCodeAt(u + 1) && (u += 1);
          }
          (m = ['word', g.slice(b, u + 1), b, u]), (b = u);
          break;
         default:
          (f = g.charCodeAt(b + 1)), 35 === o && 123 === f ? ((u = b), T(), (p = g.slice(b, u + 1)), (m = ['word', p, b, u]), (b = u)) : 47 === o && 42 === f ? ((u = g.indexOf('*/', b + 2) + 1), 0 === u && (D || t ? (u = g.length) : C('comment')), (m = ['comment', g.slice(b, u + 1), b, u]), (b = u)) : 47 === o && 47 === f ? ((a.lastIndex = b + 1), a.test(g), (u = 0 === a.lastIndex ? g.length - 1 : a.lastIndex - 2), (p = g.slice(b, u + 1)), (m = ['comment', p, b, u, 'inline']), (b = u)) : ((n.lastIndex = b + 1), n.test(g), (u = 0 === n.lastIndex ? g.length - 1 : n.lastIndex - 2), (m = ['word', g.slice(b, u + 1), b, u]), v.push(m), (b = u));
        }
        return b++, m;
       },
       position: function () {
        return b;
       },
      };
     };
    }),
    ee = l((e, t) => {
     var { Comment: r } = Y(),
      n = F(),
      s = Q(),
      i = Z();
     t.exports = class extends n {
      atrule(e) {
       let t = e[1],
        r = e;
       for (; !this.tokenizer.endOfFile(); ) {
        let e = this.tokenizer.nextToken();
        if ('word' !== e[0] || e[2] !== r[3] + 1) {
         this.tokenizer.back(e);
         break;
        }
        (t += e[1]), (r = e);
       }
       super.atrule(['at-word', t, e[2], r[3]]);
      }
      comment(e) {
       if ('inline' === e[4]) {
        let t = new r();
        this.init(t, e[2]), (t.raws.inline = !0);
        let n = this.input.fromOffset(e[3]);
        t.source.end = { column: n.col, line: n.line, offset: e[3] + 1 };
        let s = e[1].slice(2);
        if (/^\s*$/.test(s)) (t.text = ''), (t.raws.left = s), (t.raws.right = '');
        else {
         let e = s.match(/^(\s*)([^]*\S)(\s*)$/),
          r = e[2].replace(/(\*\/|\/\*)/g, '*//*');
         (t.text = r), (t.raws.left = e[1]), (t.raws.right = e[3]), (t.raws.text = e[2]);
        }
       } else super.comment(e);
      }
      createTokenizer() {
       this.tokenizer = i(this.input);
      }
      raw(e, t, r, n) {
       if ((super.raw(e, t, r, n), e.raws[t])) {
        let n = e.raws[t].raw;
        (e.raws[t].raw = r.reduce((e, t) => {
         if ('comment' === t[0] && 'inline' === t[4]) {
          return e + '/*' + t[1].slice(2).replace(/(\*\/|\/\*)/g, '*//*') + '*/';
         }
         return e + t[1];
        }, '')),
         n !== e.raws[t].raw && (e.raws[t].scss = n);
       }
      }
      rule(e) {
       let t = !1,
        r = 0,
        n = '';
       for (let s of e)
        if (t) 'comment' !== s[0] && '{' !== s[0] && (n += s[1]);
        else {
         if ('space' === s[0] && s[1].includes('\n')) break;
         '(' === s[0] ? (r += 1) : ')' === s[0] ? (r -= 1) : 0 === r && ':' === s[0] && (t = !0);
        }
       if (!t || '' === n.trim() || /^[#:A-Za-z-]/.test(n)) super.rule(e);
       else {
        e.pop();
        let t,
         r,
         n = new s();
        this.init(n, e[0][2]);
        for (let s = e.length - 1; s >= 0; s--)
         if ('space' !== e[s][0]) {
          t = e[s];
          break;
         }
        if (t[3]) {
         let e = this.input.fromOffset(t[3]);
         n.source.end = { column: e.col, line: e.line, offset: t[3] + 1 };
        } else {
         let e = this.input.fromOffset(t[2]);
         n.source.end = { column: e.col, line: e.line, offset: t[2] + 1 };
        }
        for (; 'word' !== e[0][0]; ) n.raws.before += e.shift()[1];
        if (e[0][2]) {
         let t = this.input.fromOffset(e[0][2]);
         n.source.start = { column: t.col, line: t.line, offset: e[0][2] };
        }
        for (n.prop = ''; e.length; ) {
         let t = e[0][0];
         if (':' === t || 'space' === t || 'comment' === t) break;
         n.prop += e.shift()[1];
        }
        for (n.raws.between = ''; e.length; ) {
         if (((r = e.shift()), ':' === r[0])) {
          n.raws.between += r[1];
          break;
         }
         n.raws.between += r[1];
        }
        ('_' === n.prop[0] || '*' === n.prop[0]) && ((n.raws.before += n.prop[0]), (n.prop = n.prop.slice(1))), (n.raws.between += this.spacesAndCommentsFromStart(e)), this.precheckMissedSemicolon(e);
        for (let s = e.length - 1; s > 0; s--) {
         if (((r = e[s]), '!important' === r[1])) {
          n.important = !0;
          let t = this.stringFrom(e, s);
          (t = this.spacesFromEnd(e) + t), ' !important' !== t && (n.raws.important = t);
          break;
         }
         if ('important' === r[1]) {
          let t = e.slice(0),
           r = '';
          for (let e = s; e > 0; e--) {
           let n = t[e][0];
           if (0 === r.trim().indexOf('!') && 'space' !== n) break;
           r = t.pop()[1] + r;
          }
          0 === r.trim().indexOf('!') && ((n.important = !0), (n.raws.important = r), (e = t));
         }
         if ('space' !== r[0] && 'comment' !== r[0]) break;
        }
        this.raw(n, 'value', e), n.value.includes(':') && this.checkMissedSemicolon(e), (this.current = n);
       }
      }
     };
    }),
    te = l((e, t) => {
     var { Input: r } = Y(),
      n = ee();
     t.exports = function (e, t) {
      let s = new r(e, t),
       i = new n(s);
      return i.parse(), i.root;
     };
    }),
    re = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = function (e) {
       (this.after = e.after), (this.before = e.before), (this.type = e.type), (this.value = e.value), (this.sourceIndex = e.sourceIndex);
      });
    }),
    ne = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 });
     var t,
      r = re(),
      n = (t = r) && t.__esModule ? t : { default: t };
     function s(e) {
      var t = this;
      this.constructor(e),
       (this.nodes = e.nodes),
       void 0 === this.after && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ''),
       void 0 === this.before && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ''),
       void 0 === this.sourceIndex && (this.sourceIndex = this.before.length),
       this.nodes.forEach(function (e) {
        e.parent = t;
       });
     }
     (s.prototype = Object.create(n.default.prototype)),
      (s.constructor = n.default),
      (s.prototype.walk = function (e, t) {
       for (var r = 'string' == typeof e || e instanceof RegExp, n = r ? t : e, s = 'string' == typeof e ? new RegExp(e) : e, i = 0; i < this.nodes.length; i++) {
        var a = this.nodes[i];
        if (((!r || s.test(a.type)) && n && !1 === n(a, i, this.nodes)) || (a.nodes && !1 === a.walk(e, t))) return !1;
       }
       return !0;
      }),
      (s.prototype.each = function () {
       for (var e = arguments.length <= 0 || void 0 === arguments[0] ? function () {} : arguments[0], t = 0; t < this.nodes.length; t++) {
        if (!1 === e(this.nodes[t], t, this.nodes)) return !1;
       }
       return !0;
      }),
      (e.default = s);
    }),
    se = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.parseMediaFeature = s),
      (e.parseMediaQuery = i),
      (e.parseMediaList = function (e) {
       var n = [],
        s = 0,
        a = 0,
        o = /^(\s*)url\s*\(/.exec(e);
       if (null !== o) {
        for (var u = o[0].length, l = 1; l > 0; ) {
         var p = e[u];
         '(' === p && l++, ')' === p && l--, u++;
        }
        n.unshift(new t.default({ type: 'url', value: e.substring(0, u).trim(), sourceIndex: o[1].length, before: o[1], after: /^(\s*)/.exec(e.substring(u))[1] })), (s = u);
       }
       for (var c = s; c < e.length; c++) {
        var h = e[c];
        if (('(' === h && a++, ')' === h && a--, 0 === a && ',' === h)) {
         var d = e.substring(s, c),
          f = /^(\s*)/.exec(d)[1];
         n.push(new r.default({ type: 'media-query', value: d.trim(), sourceIndex: s + f.length, nodes: i(d, s), before: f, after: /(\s*)$/.exec(d)[1] })), (s = c + 1);
        }
       }
       var m = e.substring(s),
        y = /^(\s*)/.exec(m)[1];
       return n.push(new r.default({ type: 'media-query', value: m.trim(), sourceIndex: s + y.length, nodes: i(m, s), before: y, after: /(\s*)$/.exec(m)[1] })), n;
      });
     var t = n(re()),
      r = n(ne());
     function n(e) {
      return e && e.__esModule ? e : { default: e };
     }
     function s(e) {
      var t = [{ mode: 'normal', character: null }],
       r = [],
       n = 0,
       s = '',
       i = null,
       a = null,
       o = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       u = e;
      '(' === e[0] && ')' === e[e.length - 1] && ((u = e.substring(1, e.length - 1)), o++);
      for (var l = 0; l < u.length; l++) {
       var p = u[l];
       if ((("'" === p || '"' === p) && (!0 === t[n].isCalculationEnabled ? (t.push({ mode: 'string', isCalculationEnabled: !1, character: p }), n++) : 'string' === t[n].mode && t[n].character === p && '\\' !== u[l - 1] && (t.pop(), n--)), '{' === p ? (t.push({ mode: 'interpolation', isCalculationEnabled: !0 }), n++) : '}' === p && (t.pop(), n--), 'normal' === t[n].mode && ':' === p)) {
        var c = u.substring(l + 1);
        ((a = { type: 'value', before: /^(\s*)/.exec(c)[1], after: /(\s*)$/.exec(c)[1], value: c.trim() }).sourceIndex = a.before.length + l + 1 + o), (i = { type: 'colon', sourceIndex: l + o, after: a.before, value: ':' });
        break;
       }
       s += p;
      }
      return ((s = { type: 'media-feature', before: /^(\s*)/.exec(s)[1], after: /(\s*)$/.exec(s)[1], value: s.trim() }).sourceIndex = s.before.length + o), r.push(s), null !== i && ((i.before = s.after), r.push(i)), null !== a && r.push(a), r;
     }
     function i(e) {
      var n = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       i = [],
       a = 0,
       o = !1,
       u = void 0;
      u = { before: '', after: '', value: '' };
      for (var l = 0; l < e.length; l++) {
       var p = e[l];
       o ? ((u.value += p), ('{' === p || '(' === p) && a++, (')' === p || '}' === p) && a--) : -1 !== p.search(/\s/) ? (u.before += p) : ('(' === p && ((u.type = 'media-feature-expression'), a++), (u.value = p), (u.sourceIndex = n + l), (o = !0)), o && 0 === a && (')' === p || l === e.length - 1 || -1 !== e[l + 1].search(/\s/)) && (-1 !== ['not', 'only', 'and'].indexOf(u.value) && (u.type = 'keyword'), 'media-feature-expression' === u.type && (u.nodes = s(u.value, u.sourceIndex)), i.push(Array.isArray(u.nodes) ? new r.default(u) : new t.default(u)), (u = { before: '', after: '', value: '' }), (o = !1));
      }
      for (var c = 0; c < i.length; c++)
       if (((u = i[c]), c > 0 && (i[c - 1].after = u.before), void 0 === u.type)) {
        if (c > 0) {
         if ('media-feature-expression' === i[c - 1].type) {
          u.type = 'keyword';
          continue;
         }
         if ('not' === i[c - 1].value || 'only' === i[c - 1].value) {
          u.type = 'media-type';
          continue;
         }
         if ('and' === i[c - 1].value) {
          u.type = 'media-feature-expression';
          continue;
         }
         'media-type' === i[c - 1].type && (i[c + 1] ? (u.type = 'media-feature-expression' === i[c + 1].type ? 'keyword' : 'media-feature-expression') : (u.type = 'media-feature-expression'));
        }
        if (0 === c) {
         if (!i[c + 1]) {
          u.type = 'media-type';
          continue;
         }
         if (i[c + 1] && ('media-feature-expression' === i[c + 1].type || 'keyword' === i[c + 1].type)) {
          u.type = 'media-type';
          continue;
         }
         if (i[c + 2]) {
          if ('media-feature-expression' === i[c + 2].type) {
           (u.type = 'media-type'), (i[c + 1].type = 'keyword');
           continue;
          }
          if ('keyword' === i[c + 2].type) {
           (u.type = 'keyword'), (i[c + 1].type = 'media-type');
           continue;
          }
         }
         if (i[c + 3] && 'media-feature-expression' === i[c + 3].type) {
          (u.type = 'keyword'), (i[c + 1].type = 'media-type'), (i[c + 2].type = 'keyword');
          continue;
         }
        }
       }
      return i;
     }
    }),
    ie = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = function (e) {
       return new n.default({ nodes: (0, s.parseMediaList)(e), type: 'media-query-list', value: e.trim() });
      });
     var t,
      r = ne(),
      n = (t = r) && t.__esModule ? t : { default: t },
      s = se();
    }),
    ae = l((e, t) => {
     t.exports = function (e, t) {
      return (t = 'number' == typeof t ? t : 1 / 0)
       ? (function e(r, n) {
          return r.reduce(function (r, s) {
           return Array.isArray(s) && n < t ? r.concat(e(s, n + 1)) : r.concat(s);
          }, []);
         })(e, 1)
       : Array.isArray(e)
         ? e.map(function (e) {
            return e;
           })
         : e;
     };
    }),
    oe = l((e, t) => {
     t.exports = function (e, t) {
      for (var r = -1, n = []; -1 !== (r = e.indexOf(t, r + 1)); ) n.push(r);
      return n;
     };
    }),
    ue = l((e, t) => {
     t.exports = function (e, t, r) {
      return 0 === e.length
       ? e
       : t
         ? (r || e.sort(t),
           (function (e, t) {
            for (var r = 1, n = e.length, s = e[0], i = e[0], a = 1; a < n; ++a)
             if (((i = s), t((s = e[a]), i))) {
              if (a === r) {
               r++;
               continue;
              }
              e[r++] = s;
             }
            return (e.length = r), e;
           })(e, t))
         : (r || e.sort(),
           (function (e) {
            for (var t = 1, r = e.length, n = e[0], s = e[0], i = 1; i < r; ++i, s = n)
             if (((s = n), (n = e[i]) !== s)) {
              if (i === t) {
               t++;
               continue;
              }
              e[t++] = n;
             }
            return (e.length = t), e;
           })(e));
     };
    }),
    le = l((e, t) => {
     e.__esModule = !0;
     var r =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
       ? function (e) {
          return typeof e;
         }
       : function (e) {
          return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
         };
     var n = function e(t, n) {
       if ('object' !== (typeof t > 'u' ? 'undefined' : r(t))) return t;
       var s = new t.constructor();
       for (var i in t)
        if (t.hasOwnProperty(i)) {
         var a = t[i],
          o = typeof a > 'u' ? 'undefined' : r(a);
         'parent' === i && 'object' === o
          ? n && (s[i] = n)
          : (s[i] =
             a instanceof Array
              ? a.map(function (t) {
                 return e(t, s);
                })
              : e(a, s));
        }
       return s;
      },
      s = (function () {
       function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        for (var r in ((function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, e),
        t))
         this[r] = t[r];
        var n = t.spaces,
         s = (n = void 0 === n ? {} : n).before,
         i = void 0 === s ? '' : s,
         a = n.after,
         o = void 0 === a ? '' : a;
        this.spaces = { before: i, after: o };
       }
       return (
        (e.prototype.remove = function () {
         return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
        }),
        (e.prototype.replaceWith = function () {
         if (this.parent) {
          for (var e in arguments) this.parent.insertBefore(this, arguments[e]);
          this.remove();
         }
         return this;
        }),
        (e.prototype.next = function () {
         return this.parent.at(this.parent.index(this) + 1);
        }),
        (e.prototype.prev = function () {
         return this.parent.at(this.parent.index(this) - 1);
        }),
        (e.prototype.clone = function () {
         var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = n(this);
         for (var r in e) t[r] = e[r];
         return t;
        }),
        (e.prototype.toString = function () {
         return [this.spaces.before, String(this.value), this.spaces.after].join('');
        }),
        e
       );
      })();
     (e.default = s), (t.exports = e.default);
    }),
    pe = l((e) => {
     e.__esModule = !0;
     (e.TAG = 'tag'), (e.STRING = 'string'), (e.SELECTOR = 'selector'), (e.ROOT = 'root'), (e.PSEUDO = 'pseudo'), (e.NESTING = 'nesting'), (e.ID = 'id'), (e.COMMENT = 'comment'), (e.COMBINATOR = 'combinator'), (e.CLASS = 'class'), (e.ATTRIBUTE = 'attribute'), (e.UNIVERSAL = 'universal');
    }),
    ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = le(),
      i = (r = s) && r.__esModule ? r : { default: r },
      a = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return (t.default = e), t;
      })(pe());
     var o = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return n.nodes || (n.nodes = []), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.append = function (e) {
        return (e.parent = this), this.nodes.push(e), this;
       }),
       (t.prototype.prepend = function (e) {
        return (e.parent = this), this.nodes.unshift(e), this;
       }),
       (t.prototype.at = function (e) {
        return this.nodes[e];
       }),
       (t.prototype.index = function (e) {
        return 'number' == typeof e ? e : this.nodes.indexOf(e);
       }),
       (t.prototype.removeChild = function (e) {
        (e = this.index(e)), (this.at(e).parent = void 0), this.nodes.splice(e, 1);
        var t = void 0;
        for (var r in this.indexes) (t = this.indexes[r]) >= e && (this.indexes[r] = t - 1);
        return this;
       }),
       (t.prototype.removeAll = function () {
        var e = this.nodes,
         t = Array.isArray(e),
         r = 0;
        for (e = t ? e : e[Symbol.iterator](); ; ) {
         var n;
         if (t) {
          if (r >= e.length) break;
          n = e[r++];
         } else {
          if ((r = e.next()).done) break;
          n = r.value;
         }
         n.parent = void 0;
        }
        return (this.nodes = []), this;
       }),
       (t.prototype.empty = function () {
        return this.removeAll();
       }),
       (t.prototype.insertAfter = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r + 1, 0, t);
        var n = void 0;
        for (var s in this.indexes) r <= (n = this.indexes[s]) && (this.indexes[s] = n + this.nodes.length);
        return this;
       }),
       (t.prototype.insertBefore = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r, 0, t);
        var n = void 0;
        for (var s in this.indexes) r <= (n = this.indexes[s]) && (this.indexes[s] = n + this.nodes.length);
        return this;
       }),
       (t.prototype.each = function (e) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var t = this.lastEach;
        if (((this.indexes[t] = 0), this.length)) {
         for (var r = void 0, n = void 0; this.indexes[t] < this.length && ((r = this.indexes[t]), !1 !== (n = e(this.at(r), r))); ) this.indexes[t] += 1;
         if ((delete this.indexes[t], !1 === n)) return !1;
        }
       }),
       (t.prototype.walk = function (e) {
        return this.each(function (t, r) {
         var n = e(t, r);
         if ((!1 !== n && t.length && (n = t.walk(e)), !1 === n)) return !1;
        });
       }),
       (t.prototype.walkAttributes = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ATTRIBUTE) return e.call(t, r);
        });
       }),
       (t.prototype.walkClasses = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.CLASS) return e.call(t, r);
        });
       }),
       (t.prototype.walkCombinators = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMBINATOR) return e.call(t, r);
        });
       }),
       (t.prototype.walkComments = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMMENT) return e.call(t, r);
        });
       }),
       (t.prototype.walkIds = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ID) return e.call(t, r);
        });
       }),
       (t.prototype.walkNesting = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.NESTING) return e.call(t, r);
        });
       }),
       (t.prototype.walkPseudos = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.PSEUDO) return e.call(t, r);
        });
       }),
       (t.prototype.walkTags = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.TAG) return e.call(t, r);
        });
       }),
       (t.prototype.walkUniversals = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.UNIVERSAL) return e.call(t, r);
        });
       }),
       (t.prototype.split = function (e) {
        var t = this,
         r = [];
        return this.reduce(function (n, s, i) {
         var a = e.call(t, s);
         return r.push(s), a ? (n.push(r), (r = [])) : i === t.length - 1 && n.push(r), n;
        }, []);
       }),
       (t.prototype.map = function (e) {
        return this.nodes.map(e);
       }),
       (t.prototype.reduce = function (e, t) {
        return this.nodes.reduce(e, t);
       }),
       (t.prototype.every = function (e) {
        return this.nodes.every(e);
       }),
       (t.prototype.some = function (e) {
        return this.nodes.some(e);
       }),
       (t.prototype.filter = function (e) {
        return this.nodes.filter(e);
       }),
       (t.prototype.sort = function (e) {
        return this.nodes.sort(e);
       }),
       (t.prototype.toString = function () {
        return this.map(String).join('');
       }),
       n(t, [
        {
         key: 'first',
         get: function () {
          return this.at(0);
         },
        },
        {
         key: 'last',
         get: function () {
          return this.at(this.length - 1);
         },
        },
        {
         key: 'length',
         get: function () {
          return this.nodes.length;
         },
        },
       ]),
       t
      );
     })(i.default);
     (e.default = o), (t.exports = e.default);
    }),
    he = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ce(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ROOT), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.reduce(function (e, t) {
         var r = String(t);
         return r ? e + r + ',' : '';
        }, '').slice(0, -1);
        return this.trailingComma ? e + ',' : e;
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    de = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ce(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.SELECTOR), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    fe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = le();
     var i = (function (e) {
      function t() {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, t),
        (function (e, t) {
         if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
        })(this, e.apply(this, arguments))
       );
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join('');
       }),
       n(t, [
        {
         key: 'ns',
         get: function () {
          var e = this.namespace;
          return e ? ('string' == typeof e ? e : '') + '|' : '';
         },
        },
       ]),
       t
      );
     })(((r = s) && r.__esModule ? r : { default: r }).default);
     (e.default = i), (t.exports = e.default);
    }),
    me = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.CLASS), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, '.' + this.value, this.spaces.after].join('');
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ye = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = le(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.COMMENT), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ge = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ID), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, '#' + this.value, this.spaces.after].join('');
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    De = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.TAG), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    xe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = le(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.STRING), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    be = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ce(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.PSEUDO), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.length ? '(' + this.map(String).join(',') + ')' : '';
        return [this.spaces.before, String(this.value), e, this.spaces.after].join('');
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ve = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ATTRIBUTE), (n.raws = {}), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = [this.spaces.before, '[', this.ns, this.attribute];
        return this.operator && e.push(this.operator), this.value && e.push(this.value), this.raws.insensitive ? e.push(this.raws.insensitive) : this.insensitive && e.push(' i'), e.push(']'), e.concat(this.spaces.after).join('');
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ee = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.UNIVERSAL), (n.value = '*'), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = le(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.COMBINATOR), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Te = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = le(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.NESTING), (n.value = '&'), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Se = l((e, t) => {
     (e.__esModule = !0),
      (e.default = function (e) {
       return e.sort(function (e, t) {
        return e - t;
       });
      }),
      (t.exports = e.default);
    }),
    we = l((e, t) => {
     (e.__esModule = !0),
      (e.default = function (e) {
       for (
        var t = [],
         A = e.css.valueOf(),
         F = void 0,
         k = void 0,
         P = void 0,
         I = void 0,
         N = void 0,
         B = void 0,
         _ = void 0,
         L = void 0,
         O = void 0,
         M = void 0,
         j = void 0,
         R = A.length,
         q = -1,
         U = 1,
         $ = 0,
         H = function (t, r) {
          if (!e.safe) throw e.error('Unclosed ' + t, U, $ - q, $);
          k = (A += r).length - 1;
         };
        $ < R;

       ) {
        switch (((F = A.charCodeAt($)) === a && ((q = $), (U += 1)), F)) {
         case a:
         case o:
         case l:
         case p:
         case u:
          k = $;
          do {
           (k += 1), (F = A.charCodeAt(k)) === a && ((q = k), (U += 1));
          } while (F === o || F === a || F === l || F === p || F === u);
          t.push(['space', A.slice($, k), U, $ - q, $]), ($ = k - 1);
          break;
         case c:
         case h:
         case d:
         case f:
          k = $;
          do {
           (k += 1), (F = A.charCodeAt(k));
          } while (F === c || F === h || F === d || F === f);
          t.push(['combinator', A.slice($, k), U, $ - q, $]), ($ = k - 1);
          break;
         case v:
          t.push(['*', '*', U, $ - q, $]);
          break;
         case C:
          t.push(['&', '&', U, $ - q, $]);
          break;
         case m:
          t.push([',', ',', U, $ - q, $]);
          break;
         case D:
          t.push(['[', '[', U, $ - q, $]);
          break;
         case x:
          t.push([']', ']', U, $ - q, $]);
          break;
         case E:
          t.push([':', ':', U, $ - q, $]);
          break;
         case b:
          t.push([';', ';', U, $ - q, $]);
          break;
         case y:
          t.push(['(', '(', U, $ - q, $]);
          break;
         case g:
          t.push([')', ')', U, $ - q, $]);
          break;
         case r:
         case n:
          (P = F === r ? "'" : '"'), (k = $);
          do {
           for (M = !1, -1 === (k = A.indexOf(P, k + 1)) && H('quote', P), j = k; A.charCodeAt(j - 1) === s; ) (j -= 1), (M = !M);
          } while (M);
          t.push(['string', A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         case T:
          (S.lastIndex = $ + 1), S.test(A), (k = 0 === S.lastIndex ? A.length - 1 : S.lastIndex - 2), t.push(['at-word', A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         case s:
          for (k = $, _ = !0; A.charCodeAt(k + 1) === s; ) (k += 1), (_ = !_);
          (F = A.charCodeAt(k + 1)), _ && F !== i && F !== o && F !== a && F !== l && F !== p && F !== u && (k += 1), t.push(['word', A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         default:
          F === i && A.charCodeAt($ + 1) === v ? (0 === (k = A.indexOf('*/', $ + 2) + 1) && H('comment', '*/'), (N = (I = (B = A.slice($, k + 1)).split('\n')).length - 1) > 0 ? ((L = U + N), (O = k - I[N].length)) : ((L = U), (O = q)), t.push(['comment', B, U, $ - q, L, k - O, $]), (q = O), (U = L), ($ = k)) : ((w.lastIndex = $ + 1), w.test(A), (k = 0 === w.lastIndex ? A.length - 1 : w.lastIndex - 2), t.push(['word', A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k));
        }
        $++;
       }
       return t;
      });
     var r = 39,
      n = 34,
      s = 92,
      i = 47,
      a = 10,
      o = 32,
      u = 12,
      l = 9,
      p = 13,
      c = 43,
      h = 62,
      d = 126,
      f = 124,
      m = 44,
      y = 40,
      g = 41,
      D = 91,
      x = 93,
      b = 59,
      v = 42,
      E = 58,
      C = 38,
      T = 64,
      S = /[ \n\t\r\{\(\)'"\\;/]/g,
      w = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
     t.exports = e.default;
    }),
    Ae = l((e, t) => {
     e.__esModule = !0;
     var r = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      n = v(ae()),
      s = v(oe()),
      i = v(ue()),
      a = v(he()),
      o = v(de()),
      u = v(me()),
      l = v(ye()),
      p = v(ge()),
      c = v(De()),
      h = v(xe()),
      d = v(be()),
      f = v(ve()),
      m = v(Ee()),
      y = v(Ce()),
      g = v(Te()),
      D = v(Se()),
      x = v(we()),
      b = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return (t.default = e), t;
      })(pe());
     function v(e) {
      return e && e.__esModule ? e : { default: e };
     }
     var E = (function () {
      function e(t) {
       (function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, e),
        (this.input = t),
        (this.lossy = !1 === t.options.lossless),
        (this.position = 0),
        (this.root = new a.default());
       var r = new o.default();
       return this.root.append(r), (this.current = r), this.lossy ? (this.tokens = (0, x.default)({ safe: t.safe, css: t.css.trim() })) : (this.tokens = (0, x.default)(t)), this.loop();
      }
      return (
       (e.prototype.attribute = function () {
        var e = '',
         t = void 0,
         r = this.currToken;
        for (this.position++; this.position < this.tokens.length && ']' !== this.currToken[0]; ) (e += this.tokens[this.position][1]), this.position++;
        this.position === this.tokens.length && !~e.indexOf(']') && this.error('Expected a closing square bracket.');
        var n = e.split(/((?:[*~^$|]?=))([^]*)/),
         s = n[0].split(/(\|)/g),
         i = { operator: n[1], value: n[2], source: { start: { line: r[2], column: r[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: r[4] };
        if ((s.length > 1 ? ('' === s[0] && (s[0] = !0), (i.attribute = this.parseValue(s[2])), (i.namespace = this.parseNamespace(s[0]))) : (i.attribute = this.parseValue(n[0])), (t = new f.default(i)), n[2])) {
         var a = n[2].split(/(\s+i\s*?)$/),
          o = a[0].trim();
         (t.value = this.lossy ? o : a[0]), a[1] && ((t.insensitive = !0), this.lossy || (t.raws.insensitive = a[1])), (t.quoted = "'" === o[0] || '"' === o[0]), (t.raws.unquoted = t.quoted ? o.slice(1, -1) : o);
        }
        this.newNode(t), this.position++;
       }),
       (e.prototype.combinator = function () {
        if ('|' === this.currToken[1]) return this.namespace();
        for (var e = new y.default({ value: '', source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && ('space' === this.currToken[0] || 'combinator' === this.currToken[0]); ) this.nextToken && 'combinator' === this.nextToken[0] ? ((e.spaces.before = this.parseSpace(this.currToken[1])), (e.source.start.line = this.nextToken[2]), (e.source.start.column = this.nextToken[3]), (e.source.end.column = this.nextToken[3]), (e.source.end.line = this.nextToken[2]), (e.sourceIndex = this.nextToken[4])) : this.prevToken && 'combinator' === this.prevToken[0] ? (e.spaces.after = this.parseSpace(this.currToken[1])) : 'combinator' === this.currToken[0] ? (e.value = this.currToken[1]) : 'space' === this.currToken[0] && (e.value = this.parseSpace(this.currToken[1], ' ')), this.position++;
        return this.newNode(e);
       }),
       (e.prototype.comma = function () {
        if (this.position === this.tokens.length - 1) return (this.root.trailingComma = !0), void this.position++;
        var e = new o.default();
        this.current.parent.append(e), (this.current = e), this.position++;
       }),
       (e.prototype.comment = function () {
        var e = new l.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
        this.newNode(e), this.position++;
       }),
       (e.prototype.error = function (e) {
        throw new this.input.error(e);
       }),
       (e.prototype.missingBackslash = function () {
        return this.error('Expected a backslash preceding the semicolon.');
       }),
       (e.prototype.missingParenthesis = function () {
        return this.error('Expected opening parenthesis.');
       }),
       (e.prototype.missingSquareBracket = function () {
        return this.error('Expected opening square bracket.');
       }),
       (e.prototype.namespace = function () {
        var e = (this.prevToken && this.prevToken[1]) || !0;
        return 'word' === this.nextToken[0] ? (this.position++, this.word(e)) : '*' === this.nextToken[0] ? (this.position++, this.universal(e)) : void 0;
       }),
       (e.prototype.nesting = function () {
        this.newNode(new g.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
       }),
       (e.prototype.parentheses = function () {
        var e = this.current.last;
        if (e && e.type === b.PSEUDO) {
         var t = new o.default(),
          r = this.current;
         e.append(t), (this.current = t);
         var n = 1;
         for (this.position++; this.position < this.tokens.length && n; ) '(' === this.currToken[0] && n++, ')' === this.currToken[0] && n--, n ? this.parse() : ((t.parent.source.end.line = this.currToken[2]), (t.parent.source.end.column = this.currToken[3]), this.position++);
         n && this.error('Expected closing parenthesis.'), (this.current = r);
        } else {
         var s = 1;
         for (this.position++, e.value += '('; this.position < this.tokens.length && s; ) '(' === this.currToken[0] && s++, ')' === this.currToken[0] && s--, (e.value += this.parseParenthesisToken(this.currToken)), this.position++;
         s && this.error('Expected closing parenthesis.');
        }
       }),
       (e.prototype.pseudo = function () {
        for (var e = this, t = '', r = this.currToken; this.currToken && ':' === this.currToken[0]; ) (t += this.currToken[1]), this.position++;
        if (!this.currToken) return this.error('Expected pseudo-class or pseudo-element');
        if ('word' === this.currToken[0]) {
         var n = void 0;
         this.splitWord(!1, function (s, i) {
          (t += s), (n = new d.default({ value: t, source: { start: { line: r[2], column: r[3] }, end: { line: e.currToken[4], column: e.currToken[5] } }, sourceIndex: r[4] })), e.newNode(n), i > 1 && e.nextToken && '(' === e.nextToken[0] && e.error('Misplaced parenthesis.');
         });
        } else this.error('Unexpected "' + this.currToken[0] + '" found.');
       }),
       (e.prototype.space = function () {
        var e = this.currToken;
        0 === this.position || ',' === this.prevToken[0] || '(' === this.prevToken[0] ? ((this.spaces = this.parseSpace(e[1])), this.position++) : this.position === this.tokens.length - 1 || ',' === this.nextToken[0] || ')' === this.nextToken[0] ? ((this.current.last.spaces.after = this.parseSpace(e[1])), this.position++) : this.combinator();
       }),
       (e.prototype.string = function () {
        var e = this.currToken;
        this.newNode(new h.default({ value: this.currToken[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
       }),
       (e.prototype.universal = function (e) {
        var t = this.nextToken;
        if (t && '|' === t[1]) return this.position++, this.namespace();
        this.newNode(new m.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), e), this.position++;
       }),
       (e.prototype.splitWord = function (e, t) {
        for (var r = this, a = this.nextToken, o = this.currToken[1]; a && 'word' === a[0]; ) {
         this.position++;
         var l = this.currToken[1];
         if (((o += l), l.lastIndexOf('\\') === l.length - 1)) {
          var h = this.nextToken;
          h && 'space' === h[0] && ((o += this.parseSpace(h[1], ' ')), this.position++);
         }
         a = this.nextToken;
        }
        var d = (0, s.default)(o, '.'),
         f = (0, s.default)(o, '#'),
         m = (0, s.default)(o, '#{');
        m.length &&
         (f = f.filter(function (e) {
          return !~m.indexOf(e);
         }));
        var y = (0, D.default)((0, i.default)((0, n.default)([[0], d, f])));
        y.forEach(function (n, s) {
         var i = y[s + 1] || o.length,
          a = o.slice(n, i);
         if (0 === s && t) return t.call(r, a, y.length);
         var l = void 0;
         (l = ~d.indexOf(n) ? new u.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] }) : ~f.indexOf(n) ? new p.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] }) : new c.default({ value: a, source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] })), r.newNode(l, e);
        }),
         this.position++;
       }),
       (e.prototype.word = function (e) {
        var t = this.nextToken;
        return t && '|' === t[1] ? (this.position++, this.namespace()) : this.splitWord(e);
       }),
       (e.prototype.loop = function () {
        for (; this.position < this.tokens.length; ) this.parse(!0);
        return this.root;
       }),
       (e.prototype.parse = function (e) {
        switch (this.currToken[0]) {
         case 'space':
          this.space();
          break;
         case 'comment':
          this.comment();
          break;
         case '(':
          this.parentheses();
          break;
         case ')':
          e && this.missingParenthesis();
          break;
         case '[':
          this.attribute();
          break;
         case ']':
          this.missingSquareBracket();
          break;
         case 'at-word':
         case 'word':
          this.word();
          break;
         case ':':
          this.pseudo();
          break;
         case ';':
          this.missingBackslash();
          break;
         case ',':
          this.comma();
          break;
         case '*':
          this.universal();
          break;
         case '&':
          this.nesting();
          break;
         case 'combinator':
          this.combinator();
          break;
         case 'string':
          this.string();
        }
       }),
       (e.prototype.parseNamespace = function (e) {
        if (this.lossy && 'string' == typeof e) {
         var t = e.trim();
         return !t.length || t;
        }
        return e;
       }),
       (e.prototype.parseSpace = function (e, t) {
        return this.lossy ? t || '' : e;
       }),
       (e.prototype.parseValue = function (e) {
        return this.lossy && e && 'string' == typeof e ? e.trim() : e;
       }),
       (e.prototype.parseParenthesisToken = function (e) {
        return this.lossy ? ('space' === e[0] ? this.parseSpace(e[1], ' ') : this.parseValue(e[1])) : e[1];
       }),
       (e.prototype.newNode = function (e, t) {
        return t && (e.namespace = this.parseNamespace(t)), this.spaces && ((e.spaces.before = this.spaces), (this.spaces = '')), this.current.append(e);
       }),
       r(e, [
        {
         key: 'currToken',
         get: function () {
          return this.tokens[this.position];
         },
        },
        {
         key: 'nextToken',
         get: function () {
          return this.tokens[this.position + 1];
         },
        },
        {
         key: 'prevToken',
         get: function () {
          return this.tokens[this.position - 1];
         },
        },
       ]),
       e
      );
     })();
     (e.default = E), (t.exports = e.default);
    }),
    Fe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = Ae(),
      i = (r = s) && r.__esModule ? r : { default: r };
     var a = (function () {
      function e(t) {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, e),
        (this.func = t || function () {}),
        this
       );
      }
      return (
       (e.prototype.process = function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
         r = new i.default({
          css: e,
          error: function (e) {
           throw new Error(e);
          },
          options: t,
         });
        return (this.res = r), this.func(r), this;
       }),
       n(e, [
        {
         key: 'result',
         get: function () {
          return String(this.res);
         },
        },
       ]),
       e
      );
     })();
     (e.default = a), (t.exports = e.default);
    }),
    ke = l((e, t) => {
     var r = function (e, t) {
      let n = new e.constructor();
      for (let s in e) {
       if (!e.hasOwnProperty(s)) continue;
       let i = e[s],
        a = typeof i;
       'parent' === s && 'object' === a ? t && (n[s] = t) : 'source' === s ? (n[s] = i) : i instanceof Array ? (n[s] = i.map((e) => r(e, n))) : 'before' !== s && 'after' !== s && 'between' !== s && 'semicolon' !== s && ('object' === a && null !== i && (i = r(i)), (n[s] = i));
      }
      return n;
     };
     t.exports = class {
      constructor(e) {
       (e = e || {}), (this.raws = { before: '', after: '' });
       for (let t in e) this[t] = e[t];
      }
      remove() {
       return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
      }
      toString() {
       return [this.raws.before, String(this.value), this.raws.after].join('');
      }
      clone(e) {
       e = e || {};
       let t = r(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneBefore(e) {
       e = e || {};
       let t = this.clone(e);
       return this.parent.insertBefore(this, t), t;
      }
      cloneAfter(e) {
       e = e || {};
       let t = this.clone(e);
       return this.parent.insertAfter(this, t), t;
      }
      replaceWith() {
       let e = Array.prototype.slice.call(arguments);
       if (this.parent) {
        for (let t of e) this.parent.insertBefore(this, t);
        this.remove();
       }
       return this;
      }
      moveTo(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.append(this), this;
      }
      moveBefore(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertBefore(e, this), this;
      }
      moveAfter(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertAfter(e, this), this;
      }
      next() {
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      prev() {
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      toJSON() {
       let e = {};
       for (let t in this) {
        if (!this.hasOwnProperty(t) || 'parent' === t) continue;
        let r = this[t];
        r instanceof Array ? (e[t] = r.map((e) => ('object' == typeof e && e.toJSON ? e.toJSON() : e))) : 'object' == typeof r && r.toJSON ? (e[t] = r.toJSON()) : (e[t] = r);
       }
       return e;
      }
      root() {
       let e = this;
       for (; e.parent; ) e = e.parent;
       return e;
      }
      cleanRaws(e) {
       delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
      }
      positionInside(e) {
       let t = this.toString(),
        r = this.source.start.column,
        n = this.source.start.line;
       for (let s = 0; s < e; s++) '\n' === t[s] ? ((r = 1), (n += 1)) : (r += 1);
       return { line: n, column: r };
      }
      positionBy(e) {
       let t = this.source.start;
       if (Object(e).index) t = this.positionInside(e.index);
       else if (Object(e).word) {
        let r = this.toString().indexOf(e.word);
        -1 !== r && (t = this.positionInside(r));
       }
       return t;
      }
     };
    }),
    Pe = l((e, t) => {
     var r = ke(),
      n = class extends r {
       constructor(e) {
        super(e), this.nodes || (this.nodes = []);
       }
       push(e) {
        return (e.parent = this), this.nodes.push(e), this;
       }
       each(e) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1);
        let t,
         r,
         n = this.lastEach;
        if (((this.indexes[n] = 0), this.nodes)) {
         for (; this.indexes[n] < this.nodes.length && ((t = this.indexes[n]), (r = e(this.nodes[t], t)), !1 !== r); ) this.indexes[n] += 1;
         return delete this.indexes[n], r;
        }
       }
       walk(e) {
        return this.each((t, r) => {
         let n = e(t, r);
         return !1 !== n && t.walk && (n = t.walk(e)), n;
        });
       }
       walkType(e, t) {
        if (!e || !t) throw new Error('Parameters {type} and {callback} are required.');
        let r = 'function' == typeof e;
        return this.walk((n, s) => {
         if ((r && n instanceof e) || (!r && n.type === e)) return t.call(this, n, s);
        });
       }
       append(e) {
        return (e.parent = this), this.nodes.push(e), this;
       }
       prepend(e) {
        return (e.parent = this), this.nodes.unshift(e), this;
       }
       cleanRaws(e) {
        if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
       }
       insertAfter(e, t) {
        let r,
         n = this.index(e);
        this.nodes.splice(n + 1, 0, t);
        for (let s in this.indexes) (r = this.indexes[s]), n <= r && (this.indexes[s] = r + this.nodes.length);
        return this;
       }
       insertBefore(e, t) {
        let r,
         n = this.index(e);
        this.nodes.splice(n, 0, t);
        for (let s in this.indexes) (r = this.indexes[s]), n <= r && (this.indexes[s] = r + this.nodes.length);
        return this;
       }
       removeChild(e) {
        let t;
        (e = this.index(e)), (this.nodes[e].parent = void 0), this.nodes.splice(e, 1);
        for (let r in this.indexes) (t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1);
        return this;
       }
       removeAll() {
        for (let e of this.nodes) e.parent = void 0;
        return (this.nodes = []), this;
       }
       every(e) {
        return this.nodes.every(e);
       }
       some(e) {
        return this.nodes.some(e);
       }
       index(e) {
        return 'number' == typeof e ? e : this.nodes.indexOf(e);
       }
       get first() {
        if (this.nodes) return this.nodes[0];
       }
       get last() {
        if (this.nodes) return this.nodes[this.nodes.length - 1];
       }
       toString() {
        let e = this.nodes.map(String).join('');
        return this.value && (e = this.value + e), this.raws.before && (e = this.raws.before + e), this.raws.after && (e += this.raws.after), e;
       }
      };
     (n.registerWalker = (e) => {
      let t = 'walk' + e.name;
      t.lastIndexOf('s') !== t.length - 1 && (t += 's'),
       !n.prototype[t] &&
        (n.prototype[t] = function (t) {
         return this.walkType(e, t);
        });
     }),
      (t.exports = n);
    }),
    Ie = l((e, t) => {
     var r = Pe();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'root');
      }
     };
    }),
    Ne = l((e, t) => {
     var r = Pe();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'value'), (this.unbalanced = 0);
      }
     };
    }),
    Be = l((e, t) => {
     var r = Pe(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'atword');
       }
       toString() {
        this.quoted && this.raws.quote;
        return [this.raws.before, '@', String.prototype.toString.call(this.value), this.raws.after].join('');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    _e = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'colon');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Le = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'comma');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Oe = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'comment'), (this.inline = Object(e).inline || !1);
       }
       toString() {
        return [this.raws.before, this.inline ? '//' : '/*', String(this.value), this.inline ? '' : '*/', this.raws.after].join('');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Me = l((e, t) => {
     var r = Pe(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'func'), (this.unbalanced = -1);
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    je = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'number'), (this.unit = Object(e).unit || '');
       }
       toString() {
        return [this.raws.before, String(this.value), this.unit, this.raws.after].join('');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Re = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'operator');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    qe = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'paren'), (this.parenType = '');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Ue = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'string');
       }
       toString() {
        let e = this.quoted ? this.raws.quote : '';
        return [this.raws.before, e, this.value + '', e, this.raws.after].join('');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    $e = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'word');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    He = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'unicode-range');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    ze = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       super(e), (this.name = this.constructor.name), (this.message = e || 'An error ocurred while tokzenizing.'), 'function' == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack);
      }
     };
     t.exports = r;
    }),
    Ve = l((e, t) => {
     var r = /[ \n\t\r\{\(\)'"\\;,/]/g,
      n = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g,
      s = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g,
      i = /^[a-z0-9]/i,
      a = /^[a-f0-9?\-]/i,
      o = ze();
     t.exports = function (e, t) {
      t = t || {};
      let u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       g,
       D,
       x = [],
       b = e.valueOf(),
       v = b.length,
       E = -1,
       C = 1,
       T = 0,
       S = 0,
       w = null;
      function A(e) {
       throw new o(`Unclosed ${e} at line: ${C}, column: ${T - E}, token: ${T}`);
      }
      for (; T < v; ) {
       switch (((u = b.charCodeAt(T)), 10 === u && ((E = T), (C += 1)), u)) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
         l = T;
         do {
          (l += 1), (u = b.charCodeAt(l)), 10 === u && ((E = l), (C += 1));
         } while (32 === u || 10 === u || 9 === u || 13 === u || 12 === u);
         x.push(['space', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 58:
         (l = T + 1), x.push(['colon', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 44:
         (l = T + 1), x.push(['comma', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 123:
         x.push(['{', '{', C, T - E, C, l - E, T]);
         break;
        case 125:
         x.push(['}', '}', C, T - E, C, l - E, T]);
         break;
        case 40:
         S++, (w = !w && 1 === S && x.length > 0 && 'word' === x[x.length - 1][0] && 'url' === x[x.length - 1][1]), x.push(['(', '(', C, T - E, C, l - E, T]);
         break;
        case 41:
         S--, (w = w && S > 0), x.push([')', ')', C, T - E, C, l - E, T]);
         break;
        case 39:
        case 34:
         (p = 39 === u ? "'" : '"'), (l = T);
         do {
          for (y = !1, l = b.indexOf(p, l + 1), -1 === l && A('quote'), g = l; 92 === b.charCodeAt(g - 1); ) (g -= 1), (y = !y);
         } while (y);
         x.push(['string', b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 64:
         (r.lastIndex = T + 1), r.test(b), (l = 0 === r.lastIndex ? b.length - 1 : r.lastIndex - 2), x.push(['atword', b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 92:
         (l = T), (u = b.charCodeAt(l + 1)), x.push(['word', b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 43:
        case 45:
        case 42:
         (l = T + 1), (D = b.slice(T + 1, l + 1));
         b.slice(T - 1, T);
         if (45 === u && 45 === D.charCodeAt(0)) {
          l++, x.push(['word', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
          break;
         }
         x.push(['operator', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        default:
         if (47 === u && (42 === b.charCodeAt(T + 1) || (t.loose && !w && 47 === b.charCodeAt(T + 1)))) {
          if (42 === b.charCodeAt(T + 1)) (l = b.indexOf('*/', T + 2) + 1), 0 === l && A('comment');
          else {
           let e = b.indexOf('\n', T + 2);
           l = -1 !== e ? e - 1 : v;
          }
          (d = b.slice(T, l + 1)), (c = d.split('\n')), (h = c.length - 1), h > 0 ? ((f = C + h), (m = l - c[h].length)) : ((f = C), (m = E)), x.push(['comment', d, C, T - E, f, l - m, T]), (E = m), (C = f), (T = l);
         } else if (35 !== u || i.test(b.slice(T + 1, T + 2)))
          if ((117 !== u && 85 !== u) || 43 !== b.charCodeAt(T + 1))
           if (47 === u) (l = T + 1), x.push(['operator', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
           else {
            let e = n;
            if ((u >= 48 && u <= 57 && (e = s), (e.lastIndex = T + 1), e.test(b), (l = 0 === e.lastIndex ? b.length - 1 : e.lastIndex - 2), e === s || 46 === u)) {
             let e = b.charCodeAt(l),
              t = b.charCodeAt(l + 1),
              r = b.charCodeAt(l + 2);
             (101 === e || 69 === e) && (45 === t || 43 === t) && r >= 48 && r <= 57 && ((s.lastIndex = l + 2), s.test(b), (l = 0 === s.lastIndex ? b.length - 1 : s.lastIndex - 2));
            }
            x.push(['word', b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
           }
          else {
           l = T + 2;
           do {
            (l += 1), (u = b.charCodeAt(l));
           } while (l < v && a.test(b.slice(l, l + 1)));
           x.push(['unicoderange', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
          }
         else (l = T + 1), x.push(['#', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
       }
       T++;
      }
      return x;
     };
    }),
    We = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       super(e), (this.name = this.constructor.name), (this.message = e || 'An error ocurred while parsing.'), 'function' == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack);
      }
     };
     t.exports = r;
    }),
    Je = l((e, t) => {
     var r = Ie(),
      n = Ne(),
      s = Be(),
      i = _e(),
      a = Le(),
      o = Oe(),
      u = Me(),
      l = je(),
      p = Re(),
      c = qe(),
      h = Ue(),
      d = $e(),
      f = He(),
      m = Ve(),
      y = ae(),
      g = oe(),
      D = ue(),
      x = We();
     t.exports = class {
      constructor(e, t) {
       (this.cache = []), (this.input = e), (this.options = Object.assign({}, { loose: !1 }, t)), (this.position = 0), (this.unbalanced = 0), (this.root = new r());
       let s = new n();
       this.root.append(s), (this.current = s), (this.tokens = m(e, this.options));
      }
      parse() {
       return this.loop();
      }
      colon() {
       let e = this.currToken;
       this.newNode(new i({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      comma() {
       let e = this.currToken;
       this.newNode(new a({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      comment() {
       let e,
        t = !1,
        r = this.currToken[1].replace(/\/\*|\*\//g, '');
       this.options.loose && r.startsWith('//') && ((r = r.substring(2)), (t = !0)), (e = new o({ value: r, inline: t, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })), this.newNode(e), this.position++;
      }
      error(e, t) {
       throw new x(e + ` at line: ${t[2]}, column ${t[3]}`);
      }
      loop() {
       for (; this.position < this.tokens.length; ) this.parseTokens();
       return !this.current.last && this.spaces ? (this.current.raws.before += this.spaces) : this.spaces && (this.current.last.raws.after += this.spaces), (this.spaces = ''), this.root;
      }
      operator() {
       let e,
        t = this.currToken[1];
       if ('+' === t || '-' === t)
        if ((this.options.loose || (this.position > 0 && ('func' === this.current.type && 'calc' === this.current.value ? (('space' !== this.prevToken[0] && '(' !== this.prevToken[0]) || ('space' !== this.nextToken[0] && 'word' !== this.nextToken[0]) || ('word' === this.nextToken[0] && 'operator' !== this.current.last.type && '(' !== this.current.last.value)) && this.error('Syntax Error', this.currToken) : ('space' === this.nextToken[0] || 'operator' === this.nextToken[0] || 'operator' === this.prevToken[0]) && this.error('Syntax Error', this.currToken))), this.options.loose)) {
         if ((!this.current.nodes.length || (this.current.last && 'operator' === this.current.last.type)) && 'word' === this.nextToken[0]) return this.word();
        } else if ('word' === this.nextToken[0]) return this.word();
       return (e = new p({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++, this.newNode(e);
      }
      parseTokens() {
       switch (this.currToken[0]) {
        case 'space':
         this.space();
         break;
        case 'colon':
         this.colon();
         break;
        case 'comma':
         this.comma();
         break;
        case 'comment':
         this.comment();
         break;
        case '(':
         this.parenOpen();
         break;
        case ')':
         this.parenClose();
         break;
        case 'atword':
        case 'word':
        default:
         this.word();
         break;
        case 'operator':
         this.operator();
         break;
        case 'string':
         this.string();
         break;
        case 'unicoderange':
         this.unicodeRange();
       }
      }
      parenOpen() {
       let e,
        t = 1,
        r = this.position + 1,
        n = this.currToken;
       for (; r < this.tokens.length && t; ) {
        let e = this.tokens[r];
        '(' === e[0] && t++, ')' === e[0] && t--, r++;
       }
       if ((t && this.error('Expected closing parenthesis', n), (e = this.current.last), e && 'func' === e.type && e.unbalanced < 0 && ((e.unbalanced = 0), (this.current = e)), this.current.unbalanced++, this.newNode(new c({ value: n[1], source: { start: { line: n[2], column: n[3] }, end: { line: n[4], column: n[5] } }, sourceIndex: n[6] })), this.position++, 'func' === this.current.type && this.current.unbalanced && 'url' === this.current.value && 'string' !== this.currToken[0] && ')' !== this.currToken[0] && !this.options.loose)) {
        let e = this.nextToken,
         t = this.currToken[1],
         r = { line: this.currToken[2], column: this.currToken[3] };
        for (; e && ')' !== e[0] && this.current.unbalanced; ) this.position++, (t += this.currToken[1]), (e = this.nextToken);
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d({ value: t, source: { start: r, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
       }
      }
      parenClose() {
       let e = this.currToken;
       this.newNode(new c({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++, (!(this.position >= this.tokens.length - 1) || this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error('Expected opening parenthesis', e), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
      }
      space() {
       let e = this.currToken;
       this.position === this.tokens.length - 1 || ',' === this.nextToken[0] || ')' === this.nextToken[0] ? ((this.current.last.raws.after += e[1]), this.position++) : ((this.spaces = e[1]), this.position++);
      }
      unicodeRange() {
       let e = this.currToken;
       this.newNode(new f({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      splitWord() {
       let e,
        t,
        r = this.nextToken,
        n = this.currToken[1],
        i = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
       if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(n))
        for (; r && 'word' === r[0]; ) {
         this.position++;
         let e = this.currToken[1];
         (n += e), (r = this.nextToken);
        }
       var a;
       (e = g(n, '@')),
        (a = D(y([[0], e]))),
        (t = a.sort((e, t) => e - t)),
        t.forEach((a, o) => {
         let p,
          c = t[o + 1] || n.length,
          h = n.slice(a, c);
         if (~e.indexOf(a)) p = new s({ value: h.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] });
         else if (i.test(this.currToken[1])) {
          let e = h.replace(i, '');
          p = new l({ value: h.replace(e, ''), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o], unit: e });
         } else (p = new (r && '(' === r[0] ? u : d)({ value: h, source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] })), 'word' === p.type ? ((p.isHex = /^#(.+)/.test(h)), (p.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(h))) : this.cache.push(this.current);
         this.newNode(p);
        }),
        this.position++;
      }
      string() {
       let e,
        t = this.currToken,
        r = this.currToken[1],
        n = /^(\"|\')/,
        s = n.test(r),
        i = '';
       s && ((i = r.match(n)[0]), (r = r.slice(1, r.length - 1))), (e = new h({ value: r, source: { start: { line: t[2], column: t[3] }, end: { line: t[4], column: t[5] } }, sourceIndex: t[6], quoted: s })), (e.raws.quote = i), this.newNode(e), this.position++;
      }
      word() {
       return this.splitWord();
      }
      newNode(e) {
       return this.spaces && ((e.raws.before += this.spaces), (this.spaces = '')), this.current.append(e);
      }
      get currToken() {
       return this.tokens[this.position];
      }
      get nextToken() {
       return this.tokens[this.position + 1];
      }
      get prevToken() {
       return this.tokens[this.position - 1];
      }
     };
    }),
    Ke = {};
   p(Ke, { languages: () => Dn, options: () => xn, parsers: () => bn, printers: () => ts });
   var Ge = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    Xe = 'string',
    Ye = 'array',
    Qe = 'cursor',
    Ze = 'indent',
    et = 'align',
    tt = 'trim',
    rt = 'group',
    nt = 'fill',
    st = 'if-break',
    it = 'indent-if-break',
    at = 'line-suffix',
    ot = 'line-suffix-boundary',
    ut = 'line',
    lt = 'label',
    pt = 'break-parent',
    ct = new Set([Qe, Ze, et, tt, rt, nt, st, it, at, ot, ut, lt, pt]);
   var ht = function (e) {
    if ('string' == typeof e) return Xe;
    if (Array.isArray(e)) return Ye;
    if (!e) return;
    let { type: t } = e;
    return ct.has(t) ? t : void 0;
   };
   function dt(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (ht(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...ct].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var ft = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      super(dt(e)), (this.doc = e);
     }
    },
    mt = () => {},
    yt = mt,
    gt = mt;
   function Dt(e) {
    return yt(e), { type: Ze, contents: e };
   }
   function xt(e, t) {
    return yt(t), { type: et, contents: t, n: e };
   }
   function bt(e, t = {}) {
    return yt(e), gt(t.expandedStates, !0), { type: rt, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function vt(e) {
    return xt(-1, e);
   }
   function Et(e) {
    return gt(e), { type: nt, parts: e };
   }
   function Ct(e, t = '', r = {}) {
    return yt(e), '' !== t && yt(t), { type: st, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   var Tt = { type: pt },
    St = { type: ut },
    wt = { type: ut, soft: !0 },
    At = [{ type: ut, hard: !0 }, Tt];
   function Ft(e, t) {
    yt(e), gt(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   var kt = (e, t, r) => {
    if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
   };
   function Pt(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (ht(e)) {
       case Ye:
        return t(e.map(n));
       case nt:
        return t({ ...e, parts: e.parts.map(n) });
       case st:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case rt: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case et:
       case Ze:
       case it:
       case lt:
       case at:
        return t({ ...e, contents: n(e.contents) });
       case Xe:
       case Qe:
       case tt:
       case ot:
       case ut:
       case pt:
        return t(e);
       default:
        throw new ft(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function It(e) {
    return e.type !== ut || e.hard ? (e.type === st ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   var Nt = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    Bt = "'";
   var _t = function (e, t) {
    let r = !0 === t || t === Bt ? Bt : '"',
     n = r === Bt ? '"' : Bt,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var Lt = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = Ge(!1, e, /\\(.)|(["'])/gs, (e, s, i) => (s === n ? s : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s) ? s : '\\' + s)));
    return t + s + t;
   };
   var Ot = function (e, t) {
     let r = e.slice(1, -1),
      n = 'json' === t.parser || 'jsonc' === t.parser || ('json5' === t.parser && 'preserve' === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : _t(r, t.singleQuote);
     return Lt(r, n, !('css' === t.parser || 'less' === t.parser || 'scss' === t.parser || t.__embeddedInHtml));
    },
    Mt = class extends Error {
     name = 'UnexpectedNodeError';
     constructor(e, t, r = 'type') {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    };
   var jt = function (e) {
     return 'front-matter' === (null == e ? void 0 : e.type);
    },
    Rt = new Set(['raw', 'raws', 'sourceIndex', 'source', 'before', 'after', 'trailingComma', 'spaces']);
   function qt(e, t, r) {
    if ((jt(e) && 'yaml' === e.language && delete t.value, 'css-comment' === e.type && 'css-root' === r.type && r.nodes.length > 0 && (((r.nodes[0] === e || (jt(r.nodes[0]) && r.nodes[1] === e)) && (delete t.text, /^\*\s*@(?:format|prettier)\s*$/.test(e.text))) || ('css-root' === r.type && kt(!1, r.nodes, -1) === e)))) return null;
    if (
     ('value-root' === e.type && delete t.text,
     ('media-query' === e.type || 'media-query-list' === e.type || 'media-feature-expression' === e.type) && delete t.value,
     'css-rule' === e.type && delete t.params,
     ('media-feature' === e.type || 'media-keyword' === e.type || 'media-type' === e.type || 'media-unknown' === e.type || 'media-url' === e.type || 'media-value' === e.type || 'selector-attribute' === e.type || 'selector-string' === e.type || 'selector-class' === e.type || 'selector-combinator' === e.type || 'value-string' === e.type) &&
      e.value &&
      (t.value = (function (e) {
       return Ge(!1, Ge(!1, e, "'", '"'), /\\([^\da-f])/gi, '$1');
      })(e.value)),
     'selector-combinator' === e.type && (t.value = Ge(!1, t.value, /\s+/g, ' ')),
     'media-feature' === e.type && (t.value = Ge(!1, t.value, ' ', '')),
     (('value-word' === e.type && ((e.isColor && e.isHex) || ['initial', 'inherit', 'unset', 'revert'].includes(e.value.toLowerCase()))) || 'media-feature' === e.type || 'selector-root-invalid' === e.type || 'selector-pseudo' === e.type) && (t.value = t.value.toLowerCase()),
     'css-decl' === e.type && (t.prop = e.prop.toLowerCase()),
     ('css-atrule' === e.type || 'css-import' === e.type) && (t.name = e.name.toLowerCase()),
     'value-number' === e.type && (t.unit = e.unit.toLowerCase()),
     'value-unknown' === e.type && (t.value = Ge(!1, t.value, /;$/g, '')),
     'selector-attribute' === e.type && ((t.attribute = e.attribute.trim()), e.namespace && 'string' == typeof e.namespace && (t.namespace = e.namespace.trim() || !0), e.value && ((t.value = Ge(!1, t.value.trim(), /^["']|["']$/g, '')), delete t.quoted)),
     ('media-value' === e.type || 'media-type' === e.type || 'value-number' === e.type || 'selector-root-invalid' === e.type || 'selector-class' === e.type || 'selector-combinator' === e.type || 'selector-tag' === e.type) &&
      e.value &&
      (t.value = Ge(!1, t.value, /([\d+.e-]+)([a-z]*)/gi, (e, t, r) => {
       let n = Number(t);
       return Number.isNaN(n) ? e : n + r.toLowerCase();
      })),
     'selector-tag' === e.type)
    ) {
     let e = t.value.toLowerCase();
     ['from', 'to'].includes(e) && (t.value = e);
    }
    if (('css-atrule' === e.type && 'supports' === e.name.toLowerCase() && delete t.value, 'selector-unknown' === e.type && delete t.value, 'value-comma_group' === e.type)) {
     let r = e.groups.findIndex((e) => 'value-number' === e.type && '...' === e.unit);
     -1 !== r && ((t.groups[r].unit = ''), t.groups.splice(r + 1, 0, { type: 'value-word', value: '...', isColor: !1, isHex: !1 }));
    }
    return 'value-comma_group' === e.type && e.groups.some((e) => ('value-atword' === e.type && e.value.endsWith('[')) || ('value-word' === e.type && e.value.startsWith(']'))) ? { type: 'value-atword', value: e.groups.map((e) => e.value).join(''), group: { open: null, close: null, groups: [], type: 'value-paren_group' } } : void 0;
   }
   qt.ignoredProperties = Rt;
   var Ut = qt;
   var $t = async function (e, t) {
    if ('yaml' === e.language) {
     let r = e.value.trim(),
      n = r ? await t(r, { parser: 'yaml' }) : '';
     return (function (e) {
      return xt({ type: 'root' }, e);
     })([e.startDelimiter, e.explicitLanguage, At, n, n ? At : '', e.endDelimiter]);
    }
   };
   function Ht(e) {
    let { node: t } = e;
    if ('front-matter' === t.type)
     return async (e) => {
      let r = await $t(t, e);
      return r ? [r, At] : void 0;
     };
   }
   Ht.getVisitorKeys = (e) => ('css-root' === e.type ? ['frontMatter'] : []);
   var zt = Ht,
    Vt = null;
   function Wt(e) {
    if (null !== Vt && (Vt.property, 1)) {
     let e = Vt;
     return (Vt = Wt.prototype = null), e;
    }
    return (Vt = Wt.prototype = e ?? Object.create(null)), new Wt();
   }
   for (let ns = 0; ns <= 10; ns++) Wt();
   var Jt = (function (e, t = 'type') {
    return (
     (function (e) {
      Wt(e);
     })(e),
     function (r) {
      let n = r[t],
       s = e[n];
      if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
      return s;
     }
    );
   })({ 'front-matter': [], 'css-root': ['frontMatter', 'nodes'], 'css-comment': [], 'css-rule': ['selector', 'nodes'], 'css-decl': ['value', 'selector', 'nodes'], 'css-atrule': ['selector', 'params', 'value', 'nodes'], 'media-query-list': ['nodes'], 'media-query': ['nodes'], 'media-type': [], 'media-feature-expression': ['nodes'], 'media-feature': [], 'media-colon': [], 'media-value': [], 'media-keyword': [], 'media-url': [], 'media-unknown': [], 'selector-root': ['nodes'], 'selector-selector': ['nodes'], 'selector-comment': [], 'selector-string': [], 'selector-tag': [], 'selector-id': [], 'selector-class': [], 'selector-attribute': [], 'selector-combinator': ['nodes'], 'selector-universal': [], 'selector-pseudo': ['nodes'], 'selector-nesting': [], 'selector-unknown': [], 'value-value': ['group'], 'value-root': ['group'], 'value-comment': [], 'value-comma_group': ['groups'], 'value-paren_group': ['open', 'groups', 'close'], 'value-func': ['group'], 'value-paren': [], 'value-number': [], 'value-operator': [], 'value-word': [], 'value-colon': [], 'value-comma': [], 'value-string': [], 'value-atword': [], 'value-unicode-range': [], 'value-unknown': [] });
   var Kt = function (e, t) {
    let r = 0;
    for (let n = 0; n < e.line - 1; ++n) r = t.indexOf('\n', r) + 1;
    return r + e.column;
   };
   function Gt(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   Gt(/\s/);
   var Xt = Gt(' \t'),
    Yt = Gt(',; \t'),
    Qt = Gt(/[^\n\r]/);
   function Zt(e, t) {
    var r, n, s;
    if ('number' == typeof (null == (n = null == (r = e.source) ? void 0 : r.start) ? void 0 : n.offset)) return e.source.start.offset;
    if ('number' == typeof e.sourceIndex) return e.sourceIndex;
    if (null != (s = e.source) && s.start) return Kt(e.source.start, t);
    throw Object.assign(new Error('Can not locate node.'), { node: e });
   }
   function er(e, t) {
    var r, n;
    if ('css-comment' === e.type && e.inline) return Qt(t, e.source.startOffset);
    if ('number' == typeof (null == (n = null == (r = e.source) ? void 0 : r.end) ? void 0 : n.offset)) return e.source.end.offset;
    if (e.source) {
     if (e.source.end) return Kt(e.source.end, t);
     if (Nt(e.nodes)) return er(kt(!1, e.nodes, -1), t);
    }
    return null;
   }
   function tr(e, t) {
    e.source && ((e.source.startOffset = Zt(e, t)), (e.source.endOffset = er(e, t)));
    for (let r in e) {
     let n = e[r];
     'source' === r || !n || 'object' != typeof n || ('value-root' === n.type || 'value-unknown' === n.type ? rr(n, nr(e), n.text || n.value) : tr(n, t));
    }
   }
   function rr(e, t, r) {
    e.source && ((e.source.startOffset = Zt(e, r) + t), (e.source.endOffset = er(e, r) + t));
    for (let n in e) {
     let s = e[n];
     'source' === n || !s || 'object' != typeof s || rr(s, t, r);
    }
   }
   function nr(e) {
    var t;
    let r = e.source.startOffset;
    return 'string' == typeof e.prop && (r += e.prop.length), 'css-atrule' === e.type && 'string' == typeof e.name && (r += 1 + e.name.length + e.raws.afterName.match(/^\s*:?\s*/)[0].length), 'css-atrule' !== e.type && 'string' == typeof (null == (t = e.raws) ? void 0 : t.between) && (r += e.raws.between.length), r;
   }
   function sr(e) {
    var t;
    return null == (t = e.source) ? void 0 : t.startOffset;
   }
   function ir(e) {
    var t;
    return null == (t = e.source) ? void 0 : t.endOffset;
   }
   var ar = c(h(), 1);
   var or = function (e) {
    if (!e.startsWith('#!')) return '';
    let t = e.indexOf('\n');
    return -1 === t ? e : e.slice(0, t);
   };
   function ur(e) {
    let t = or(e);
    t && (e = e.slice(t.length + 1));
    let r = (0, ar.extract)(e),
     { pragmas: n, comments: s } = (0, ar.parseWithComments)(r);
    return { shebang: t, text: e, pragmas: n, comments: s };
   }
   var lr = 3;
   var pr = function (e) {
    let t = (function (e) {
     let t = e.slice(0, lr);
     if ('---' !== t && '+++' !== t) return;
     let r = e.indexOf('\n', lr);
     if (-1 === r) return;
     let n = e.slice(lr, r).trim(),
      s = e.indexOf(`\n${t}`, r),
      i = n;
     if ((i || (i = '+++' === t ? 'toml' : 'yaml'), -1 === s && '---' === t && 'yaml' === i && (s = e.indexOf('\n...', r)), -1 === s)) return;
     let a = s + 1 + lr,
      o = e.charAt(a + 1);
     if (!/\s?/.test(o)) return;
     let u = e.slice(0, a);
     return { type: 'front-matter', language: i, explicitLanguage: n, value: e.slice(r + 1, s), startDelimiter: t, endDelimiter: u.slice(-lr), raw: u };
    })(e);
    if (!t) return { content: e };
    let { raw: r } = t;
    return { frontMatter: t, content: Ge(!1, r, /[^\n]/g, ' ') + e.slice(r.length) };
   };
   var cr = new Set(['red', 'green', 'blue', 'alpha', 'a', 'rgb', 'hue', 'h', 'saturation', 's', 'lightness', 'l', 'whiteness', 'w', 'blackness', 'b', 'tint', 'shade', 'blend', 'blenda', 'contrast', 'hsl', 'hsla', 'hwb', 'hwba']);
   var hr = new Set(['initial', 'inherit', 'unset', 'revert']);
   function dr(e, t) {
    var r;
    let n = e.findAncestor((e) => 'css-atrule' === e.type);
    return (null == (r = null == n ? void 0 : n.name) ? void 0 : r.toLowerCase().endsWith('keyframes')) && ['from', 'to'].includes(t.toLowerCase());
   }
   function fr(e) {
    return e.includes('$') || e.includes('@') || e.includes('#') || e.startsWith('%') || e.startsWith('--') || e.startsWith(':--') || (e.includes('(') && e.includes(')')) ? e : e.toLowerCase();
   }
   function mr(e, t) {
    var r;
    let n = e.findAncestor((e) => 'value-func' === e.type);
    return (null == (r = null == n ? void 0 : n.value) ? void 0 : r.toLowerCase()) === t;
   }
   function yr(e) {
    var t;
    let r = e.findAncestor((e) => 'css-rule' === e.type),
     n = null == (t = null == r ? void 0 : r.raws) ? void 0 : t.selector;
    return n && (n.startsWith(':import') || n.startsWith(':export'));
   }
   function gr(e, t) {
    let r = Array.isArray(t) ? t : [t],
     n = e.findAncestor((e) => 'css-atrule' === e.type);
    return n && r.includes(n.name.toLowerCase());
   }
   function Dr(e, t) {
    var r;
    let n = null == (r = e.parent) ? void 0 : r.nodes;
    return n && n.indexOf(t) === n.length - 1;
   }
   function xr(e) {
    let { selector: t } = e;
    return !!t && (('string' == typeof t && /^@.+:.*$/.test(t)) || (t.value && /^@.+:.*$/.test(t.value)));
   }
   function br(e) {
    return 'value-word' === e.type && ['from', 'through', 'end'].includes(e.value);
   }
   function vr(e) {
    return 'value-word' === e.type && ['and', 'or', 'not'].includes(e.value);
   }
   function Er(e) {
    return 'value-word' === e.type && 'in' === e.value;
   }
   function Cr(e) {
    return 'value-operator' === e.type && '*' === e.value;
   }
   function Tr(e) {
    return 'value-operator' === e.type && '/' === e.value;
   }
   function Sr(e) {
    return 'value-operator' === e.type && '+' === e.value;
   }
   function wr(e) {
    return 'value-operator' === e.type && '-' === e.value;
   }
   function Ar(e) {
    return (
     Cr(e) ||
     Tr(e) ||
     Sr(e) ||
     wr(e) ||
     (function (e) {
      return 'value-operator' === e.type && '%' === e.value;
     })(e)
    );
   }
   function Fr(e) {
    return 'value-word' === e.type && ['==', '!='].includes(e.value);
   }
   function kr(e) {
    return 'value-word' === e.type && ['<', '>', '<=', '>='].includes(e.value);
   }
   function Pr(e, t) {
    return 'scss' === t.parser && 'css-atrule' === e.type && ['if', 'else', 'for', 'each', 'while'].includes(e.name);
   }
   function Ir(e) {
    var t;
    return (null == (t = e.raws) ? void 0 : t.params) && /^\(\s*\)$/.test(e.raws.params);
   }
   function Nr(e) {
    return e.name.startsWith('prettier-placeholder');
   }
   function Br(e) {
    return e.prop.startsWith('@prettier-placeholder');
   }
   function _r(e, t) {
    return '$$' === e.value && 'value-func' === e.type && 'value-word' === (null == t ? void 0 : t.type) && !t.raws.before;
   }
   function Lr(e) {
    var t, r, n;
    return 'value-paren_group' === (null == (n = null == (r = null == (t = e.value) ? void 0 : t.group) ? void 0 : r.group) ? void 0 : n.type) && null !== e.value.group.group.open && null !== e.value.group.group.close;
   }
   function Or(e) {
    var t;
    return '' === (null == (t = e.raws) ? void 0 : t.before);
   }
   function Mr(e) {
    var t, r;
    return 'value-comma_group' === e.type && 'value-colon' === (null == (r = null == (t = e.groups) ? void 0 : t[1]) ? void 0 : r.type);
   }
   function jr(e) {
    var t;
    return 'value-paren_group' === e.type && (null == (t = e.groups) ? void 0 : t[0]) && Mr(e.groups[0]);
   }
   function Rr(e, t) {
    var r;
    if ('scss' !== t.parser) return !1;
    let { node: n } = e;
    if (0 === n.groups.length) return !1;
    let s = e.grandparent;
    if (!(jr(n) || (s && jr(s)))) return !1;
    let i = e.findAncestor((e) => 'css-decl' === e.type);
    return !!((null != (r = null == i ? void 0 : i.prop) && r.startsWith('$')) || jr(s) || 'value-func' === s.type);
   }
   function qr(e) {
    return 'value-comment' === e.type && e.inline;
   }
   function Ur(e) {
    return 'value-word' === e.type && '#' === e.value;
   }
   function $r(e) {
    return 'value-word' === e.type && '{' === e.value;
   }
   function Hr(e) {
    return 'value-word' === e.type && '}' === e.value;
   }
   function zr(e) {
    return ['value-word', 'value-atword'].includes(e.type);
   }
   function Vr(e) {
    return 'value-colon' === (null == e ? void 0 : e.type);
   }
   function Wr(e) {
    return e.value && ['not', 'and', 'or'].includes(e.value.toLowerCase());
   }
   function Jr(e) {
    return 'value-func' === e.type && cr.has(e.value.toLowerCase());
   }
   function Kr(e) {
    return /\/\//.test(e.split(/[\n\r]/).pop());
   }
   function Gr(e) {
    return 'value-atword' === (null == e ? void 0 : e.type) && e.value.startsWith('prettier-placeholder-');
   }
   function Xr(e) {
    var t, r;
    return 'value-paren_group' === e.type && '(' === (null == (t = e.open) ? void 0 : t.value) && ')' === (null == (r = e.close) ? void 0 : r.value);
   }
   var Yr = function (e, t, r) {
    var n;
    let { node: s } = e,
     i = e.parent,
     a = e.grandparent,
     o = (function (e) {
      var t, r;
      return null == (r = null == (t = e.findAncestor((e) => 'css-decl' === e.type)) ? void 0 : t.prop) ? void 0 : r.toLowerCase();
     })(e),
     u = o && 'value-value' === i.type && ('grid' === o || o.startsWith('grid-template')),
     l = e.findAncestor((e) => 'css-atrule' === e.type),
     p = l && Pr(l, t),
     c = s.groups.some((e) => qr(e)),
     h = e.map(r, 'groups'),
     d = [],
     f = mr(e, 'url'),
     m = !1,
     y = !1;
    for (let g = 0; g < s.groups.length; ++g) {
     d.push(h[g]);
     let r = s.groups[g - 1],
      o = s.groups[g],
      c = s.groups[g + 1],
      D = s.groups[g + 2];
     if (f) {
      ((c && Sr(c)) || Sr(o)) && d.push(' ');
      continue;
     }
     if ((gr(e, 'forward') && 'value-word' === o.type && o.value && void 0 !== r && 'value-word' === r.type && 'as' === r.value && 'value-operator' === c.type && '*' === c.value) || !c || ('value-word' === o.type && o.value.endsWith('-') && Gr(c))) continue;
     if ('value-string' === o.type && o.quoted) {
      let e = o.value.lastIndexOf('#{'),
       t = o.value.lastIndexOf('}');
      -1 !== e && -1 !== t ? (m = e > t) : -1 !== e ? (m = !0) : -1 !== t && (m = !1);
     }
     if (m || Vr(o) || Vr(c) || ('value-atword' === o.type && ('' === o.value || o.value.endsWith('['))) || ('value-word' === c.type && c.value.startsWith(']')) || '~' === o.value || ('value-string' !== o.type && o.value && o.value.includes('\\') && c && 'value-comment' !== c.type) || (null != r && r.value && r.value.indexOf('\\') === r.value.length - 1 && 'value-operator' === o.type && '/' === o.value) || '\\' === o.value || _r(o, c) || Ur(o) || $r(o) || Hr(c) || ($r(c) && Or(c)) || (Hr(o) && Or(c)) || ('--' === o.value && Ur(c))) continue;
     let x = Ar(o),
      b = Ar(c);
     if ((((x && Ur(c)) || (b && Hr(o))) && Or(c)) || (!r && Tr(o)) || (mr(e, 'calc') && (Sr(o) || Sr(c) || wr(o) || wr(c)) && Or(c))) continue;
     let v = (Sr(o) || wr(o)) && 0 === g && ('value-number' === c.type || c.isHex) && a && Jr(a) && !Or(c),
      E = 'value-func' === (null == D ? void 0 : D.type) || (D && zr(D)) || 'value-func' === o.type || zr(o),
      C = 'value-func' === c.type || zr(c) || 'value-func' === (null == r ? void 0 : r.type) || (r && zr(r));
     if ('scss' === t.parser && x && '-' === o.value && 'value-func' === c.type && ir(o) !== sr(c)) d.push(' ');
     else if ((Cr(c) || Cr(o) || mr(e, 'calc') || v || !((Tr(c) && !E) || (Tr(o) && !C) || (Sr(c) && !E) || (Sr(o) && !C) || wr(c) || wr(o)) || !(Or(c) || (x && (!r || (r && Ar(r)))))) && (('scss' !== t.parser && 'less' !== t.parser) || !x || '-' !== o.value || !Xr(c) || ir(o) !== sr(c.open) || '(' !== c.open.value)) {
      if (qr(o)) {
       if ('value-paren_group' === i.type) {
        d.push(vt(At));
        continue;
       }
       d.push(At);
       continue;
      }
      if (p && (Fr(c) || kr(c) || vr(c) || Er(o) || br(o))) {
       d.push(' ');
       continue;
      }
      if (l && 'namespace' === l.name.toLowerCase()) {
       d.push(' ');
       continue;
      }
      if (u) {
       o.source && c.source && o.source.start.line !== c.source.start.line ? (d.push(At), (y = !0)) : d.push(' ');
       continue;
      }
      if (b) {
       d.push(' ');
       continue;
      }
      if (!('...' === (null == c ? void 0 : c.value) || (Gr(o) && Gr(c) && ir(o) === sr(c)))) {
       if (Gr(o) && Xr(c) && ir(o) === sr(c.open)) {
        d.push(wt);
        continue;
       }
       if ('with' === o.value && Xr(c)) {
        d.push(' ');
        continue;
       }
       (null != (n = o.value) && n.endsWith('#') && '{' === c.value && Xr(c.group)) || d.push(St);
      }
     }
    }
    return (
     c && d.push(Tt),
     y && d.unshift(At),
     p
      ? bt(Dt(d))
      : (function (e) {
           var t;
           let { node: r } = e;
           return 'url' === r.groups[0].value && 2 === r.groups.length && 'import' === (null == (t = e.findAncestor((e) => 'css-atrule' === e.type)) ? void 0 : t.name);
          })(e)
        ? bt(Et(d))
        : bt(Dt(Et(d)))
    );
   };
   var Qr = function (e) {
     return 1 === e.length
      ? e
      : e
         .toLowerCase()
         .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, '$1$2')
         .replace(/^([+-]?[\d.]+)e[+-]?0+$/, '$1')
         .replace(/^([+-])?\./, '$10.')
         .replace(/(\.\d+?)0+(?=e|$)/, '$1')
         .replace(/\.(?=e|$)/, '');
    },
    Zr = new Map([
     ['em', 'em'],
     ['rem', 'rem'],
     ['ex', 'ex'],
     ['rex', 'rex'],
     ['cap', 'cap'],
     ['rcap', 'rcap'],
     ['ch', 'ch'],
     ['rch', 'rch'],
     ['ic', 'ic'],
     ['ric', 'ric'],
     ['lh', 'lh'],
     ['rlh', 'rlh'],
     ['vw', 'vw'],
     ['svw', 'svw'],
     ['lvw', 'lvw'],
     ['dvw', 'dvw'],
     ['vh', 'vh'],
     ['svh', 'svh'],
     ['lvh', 'lvh'],
     ['dvh', 'dvh'],
     ['vi', 'vi'],
     ['svi', 'svi'],
     ['lvi', 'lvi'],
     ['dvi', 'dvi'],
     ['vb', 'vb'],
     ['svb', 'svb'],
     ['lvb', 'lvb'],
     ['dvb', 'dvb'],
     ['vmin', 'vmin'],
     ['svmin', 'svmin'],
     ['lvmin', 'lvmin'],
     ['dvmin', 'dvmin'],
     ['vmax', 'vmax'],
     ['svmax', 'svmax'],
     ['lvmax', 'lvmax'],
     ['dvmax', 'dvmax'],
     ['cm', 'cm'],
     ['mm', 'mm'],
     ['q', 'Q'],
     ['in', 'in'],
     ['pt', 'pt'],
     ['pc', 'pc'],
     ['px', 'px'],
     ['deg', 'deg'],
     ['grad', 'grad'],
     ['rad', 'rad'],
     ['turn', 'turn'],
     ['s', 's'],
     ['ms', 'ms'],
     ['hz', 'Hz'],
     ['khz', 'kHz'],
     ['dpi', 'dpi'],
     ['dpcm', 'dpcm'],
     ['dppx', 'dppx'],
     ['x', 'x'],
     ['cqw', 'cqw'],
     ['cqh', 'cqh'],
     ['cqi', 'cqi'],
     ['cqb', 'cqb'],
     ['cqmin', 'cqmin'],
     ['cqmax', 'cqmax'],
    ]);
   function en(e) {
    let t = e.toLowerCase();
    return Zr.has(t) ? Zr.get(t) : e;
   }
   var tn = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs,
    rn = new RegExp(tn.source + `|(${/[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/gi.source})?(${/(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/gi.source})(${/[a-z]+/gi.source})?`, 'gi');
   function nn(e, t) {
    return Ge(!1, e, tn, (e) => Ot(e, t));
   }
   function sn(e, t) {
    let r = t.singleQuote ? "'" : '"';
    return e.includes('"') || e.includes("'") ? e : r + e + r;
   }
   function an(e) {
    return Ge(!1, e, rn, (e, t, r, n, s) => (!r && n ? on(n) + fr(s || '') : e));
   }
   function on(e) {
    return Qr(e).replace(/\.0(?=$|e)/, '');
   }
   var un = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ('\r' === e.charAt(t - 1) && '\n' === s) return t - 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t - 1;
    } else {
     if ('\r' === s && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t + 1;
    }
    return t;
   };
   var ln = function (e, t, r = {}) {
    let n = Xt(e, r.backwards ? t - 1 : t, r);
    return n !== un(e, n, r);
   };
   var pn = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var cn = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? Qt(e, t) : t);
   };
   var hn = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = Yt(e, n)), (n = pn(e, n)), (n = Xt(e, n));
    return (n = cn(e, n)), (n = un(e, n)), !1 !== n && ln(e, n);
   };
   function dn(e, t) {
    return (function (e) {
     return 'value-func' === e.type && 'var' === e.value.toLowerCase();
    })(e.grandparent) &&
     (function ({ node: e, parent: t }, r) {
      return !(!e.source || !r.originalText.slice(sr(e), sr(t.close)).trimEnd().endsWith(','));
     })(e, t)
     ? ','
     : 'value-comment' === e.node.type ||
         ('value-comma_group' === e.node.type && e.node.groups.every((e) => 'value-comment' === e.type)) ||
         !(function (e) {
          return 'es5' === e.trailingComma || 'all' === e.trailingComma;
         })(t) ||
         !e.callParent(() => Rr(e, t))
       ? ''
       : Ct(',');
   }
   function fn(e, t, r) {
    let { node: n, parent: s } = e,
     i = e.map(({ node: e }) => ('string' == typeof e ? e : r()), 'groups');
    if (
     s &&
     (function (e) {
      return 'value-func' === e.type && 'url' === e.value.toLowerCase();
     })(s) &&
     (1 === n.groups.length || (n.groups.length > 0 && 'value-comma_group' === n.groups[0].type && n.groups[0].groups.length > 0 && 'value-word' === n.groups[0].groups[0].type && n.groups[0].groups[0].value.startsWith('data:')))
    )
     return [n.open ? r('open') : '', Ft(',', i), n.close ? r('close') : ''];
    if (!n.open) {
     let t = mn(e),
      r = Ft([',', t ? At : St], i);
     return Dt(t ? [At, r] : bt(Et(r)));
    }
    let a = e.map(({ node: r, isLast: n, index: s }) => {
      var a;
      let o = i[s];
      if (Mr(r) && 'value-comma_group' === r.type && r.groups && 'value-paren_group' !== r.groups[0].type && 'value-paren_group' === (null == (a = r.groups[2]) ? void 0 : a.type)) {
       let { parts: e } = o.contents.contents;
       (e[1] = bt(e[1])), (o = bt(vt(o)));
      }
      let u = [o, n ? dn(e, t) : ','];
      if (!n && 'value-comma_group' === r.type && Nt(r.groups)) {
       let e = kt(!1, r.groups, -1);
       !e.source && e.close && (e = e.close), e.source && hn(t.originalText, ir(e)) && u.push(At);
      }
      return u;
     }, 'groups'),
     o = (function (e, t) {
      if (!Mr(t)) return !1;
      let { groups: r } = t,
       n = r.indexOf(e);
      return -1 !== n && Vr(r[n + 1]);
     })(n, s),
     u = (function (e, t) {
      var r, n;
      if ('(' !== (null == (r = e.open) ? void 0 : r.value) || ')' !== (null == (n = e.close) ? void 0 : n.value) || e.groups.some((e) => 'value-comma_group' !== e.type)) return !1;
      if ('value-comma_group' === t.type) {
       let r = t.groups.indexOf(e) - 1,
        n = t.groups[r];
       if ('value-word' === (null == n ? void 0 : n.type) && 'with' === n.value) return !0;
      }
      return !1;
     })(n, s),
     l = Rr(e, t),
     p = u || (l && !o),
     c = u || o,
     h = bt([n.open ? r('open') : '', Dt([wt, Ft(St, a)]), wt, n.close ? r('close') : ''], { shouldBreak: p });
    return c ? vt(h) : h;
   }
   function mn(e) {
    return e.match(
     (e) => 'value-paren_group' === e.type && !e.open && e.groups.some((e) => 'value-comma_group' === e.type),
     (e, t) => 'group' === t && 'value-value' === e.type,
     (e, t) => 'group' === t && 'value-root' === e.type,
     (e, t) => 'value' === t && (('css-decl' === e.type && !e.prop.startsWith('--')) || ('css-atrule' === e.type && e.variable)),
    );
   }
   var yn = function (e, t, r) {
    let n = [];
    return (
     e.each(() => {
      let { node: s, previous: i } = e;
      if (('css-comment' === (null == i ? void 0 : i.type) && 'prettier-ignore' === i.text.trim() ? n.push(t.originalText.slice(sr(s), ir(s))) : n.push(r()), e.isLast)) return;
      let { next: a } = e;
      ('css-comment' === a.type && !ln(t.originalText, sr(a), { backwards: !0 }) && !jt(s)) || ('css-atrule' === a.type && 'else' === a.name && 'css-comment' !== s.type) ? n.push(' ') : (n.push(t.__isHTMLStyleAttribute ? St : At), hn(t.originalText, ir(s)) && !jt(s) && n.push(At));
     }, 'nodes'),
     n
    );
   };
   var gn = {
     print: function (e, t, r) {
      var n, s, i, a, o, u;
      let { node: l } = e;
      switch (l.type) {
       case 'front-matter':
        return [l.raw, At];
       case 'css-root': {
        let n = yn(e, t, r),
         s = l.raws.after.trim();
        return s.startsWith(';') && (s = s.slice(1).trim()), [l.frontMatter ? [r('frontMatter'), At] : '', n, s ? ` ${s}` : '', l.nodes.length > 0 ? At : ''];
       }
       case 'css-comment': {
        let e = l.inline || l.raws.inline,
         r = t.originalText.slice(sr(l), ir(l));
        return e ? r.trimEnd() : r;
       }
       case 'css-rule':
        return [r('selector'), l.important ? ' !important' : '', l.nodes ? ['selector-unknown' === (null == (n = l.selector) ? void 0 : n.type) && Kr(l.selector.value) ? St : l.selector ? ' ' : '', '{', l.nodes.length > 0 ? Dt([At, yn(e, t, r)]) : '', At, '}', xr(l) ? ';' : ''] : ';'];
       case 'css-decl': {
        let n = e.parent,
         { between: a } = l.raws,
         o = a.trim(),
         u = ':' === o,
         p = 'string' == typeof l.value && /^ *$/.test(l.value),
         c = 'string' == typeof l.value ? l.value : r('value');
        return (
         (c = (function (e) {
          var t, r;
          return 'value-root' === (null == (t = e.value) ? void 0 : t.type) && 'value-value' === (null == (r = e.value.group) ? void 0 : r.type) && 'composes' === e.prop.toLowerCase();
         })(l)
          ? (function (e) {
             return Pt(e, It);
            })(c)
          : c),
         !u && Kr(o) && !(null != (i = null == (s = l.value) ? void 0 : s.group) && i.group && e.call(() => mn(e), 'value', 'group', 'group')) && (c = Dt([At, vt(c)])),
         [Ge(!1, l.raws.before, /[\s;]/g, ''), ('css-atrule' === n.type && n.variable) || yr(e) ? l.prop : fr(l.prop), o.startsWith('//') ? ' ' : '', o, l.extend || p ? '' : ' ', 'less' === t.parser && l.extend && l.selector ? ['extend(', r('selector'), ')'] : '', c, l.raws.important ? l.raws.important.replace(/\s*!\s*important/i, ' !important') : l.important ? ' !important' : '', l.raws.scssDefault ? l.raws.scssDefault.replace(/\s*!default/i, ' !default') : l.scssDefault ? ' !default' : '', l.raws.scssGlobal ? l.raws.scssGlobal.replace(/\s*!global/i, ' !global') : l.scssGlobal ? ' !global' : '', l.nodes ? [' {', Dt([wt, yn(e, t, r)]), wt, '}'] : Br(l) && !n.raws.semicolon && ';' !== t.originalText[ir(l) - 1] ? '' : t.__isHTMLStyleAttribute && Dr(e, l) ? Ct(';') : ';']
        );
       }
       case 'css-atrule': {
        let n = e.parent,
         s = Nr(l) && !n.raws.semicolon && ';' !== t.originalText[ir(l) - 1];
        if ('less' === t.parser) {
         if (l.mixin) return [r('selector'), l.important ? ' !important' : '', s ? '' : ';'];
         if (l.function) return [l.name, 'string' == typeof l.params ? l.params : r('params'), s ? '' : ';'];
         if (l.variable) return ['@', l.name, ': ', l.value ? r('value') : '', l.raws.between.trim() ? l.raws.between.trim() + ' ' : '', l.nodes ? ['{', Dt([l.nodes.length > 0 ? wt : '', yn(e, t, r)]), wt, '}'] : '', s ? '' : ';'];
        }
        let i = 'import' === l.name && 'value-unknown' === (null == (a = l.params) ? void 0 : a.type) && l.params.value.endsWith(';');
        return ['@', Ir(l) || l.name.endsWith(':') || Nr(l) ? l.name : fr(l.name), l.params ? [Ir(l) ? '' : Nr(l) ? ('' === l.raws.afterName ? '' : l.name.endsWith(':') ? ' ' : /^\s*\n\s*\n/.test(l.raws.afterName) ? [At, At] : /^\s*\n/.test(l.raws.afterName) ? At : ' ') : ' ', 'string' == typeof l.params ? l.params : r('params')] : '', l.selector ? Dt([' ', r('selector')]) : '', l.value ? bt([' ', r('value'), Pr(l, t) ? (Lr(l) ? ' ' : St) : '']) : 'else' === l.name ? ' ' : '', l.nodes ? [Pr(l, t) ? '' : (l.selector && !l.selector.nodes && 'string' == typeof l.selector.value && Kr(l.selector.value)) || (!l.selector && 'string' == typeof l.params && Kr(l.params)) ? St : ' ', '{', Dt([l.nodes.length > 0 ? wt : '', yn(e, t, r)]), wt, '}'] : s || i ? '' : ';'];
       }
       case 'media-query-list': {
        let t = [];
        return (
         e.each(({ node: e }) => {
          ('media-query' === e.type && '' === e.value) || t.push(r());
         }, 'nodes'),
         bt(Dt(Ft(St, t)))
        );
       }
       case 'media-query':
        return [Ft(' ', e.map(r, 'nodes')), Dr(e, l) ? '' : ','];
       case 'media-type':
       case 'media-value':
        return an(nn(l.value, t));
       case 'media-feature-expression':
        return l.nodes ? ['(', ...e.map(r, 'nodes'), ')'] : l.value;
       case 'media-feature':
        return fr(nn(Ge(!1, l.value, / +/g, ' '), t));
       case 'media-colon':
        return [l.value, ' '];
       case 'media-keyword':
       case 'selector-string':
        return nn(l.value, t);
       case 'media-url':
        return nn(Ge(!1, Ge(!1, l.value, /^url\(\s+/gi, 'url('), /\s+\)$/g, ')'), t);
       case 'media-unknown':
       case 'selector-comment':
       case 'selector-nesting':
       case 'value-paren':
       case 'value-operator':
       case 'value-unicode-range':
       case 'value-unknown':
        return l.value;
       case 'selector-root':
        return bt([gr(e, 'custom-selector') ? [e.findAncestor((e) => 'css-atrule' === e.type).customSelector, St] : '', Ft([',', gr(e, ['extend', 'custom-selector', 'nest']) ? St : At], e.map(r, 'nodes'))]);
       case 'selector-selector':
        return bt(Dt(e.map(r, 'nodes')));
       case 'selector-tag':
        return [l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', 'selector-nesting' === (null == (o = e.previous) ? void 0 : o.type) ? l.value : an(dr(e, l.value) ? l.value.toLowerCase() : l.value)];
       case 'selector-id':
        return ['#', l.value];
       case 'selector-class':
        return ['.', an(nn(l.value, t))];
       case 'selector-attribute':
        return ['[', l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', l.attribute.trim(), l.operator ?? '', l.value ? sn(nn(l.value.trim(), t), t) : '', l.insensitive ? ' i' : '', ']'];
       case 'selector-combinator':
        if ('+' === l.value || '>' === l.value || '~' === l.value || '>>>' === l.value) {
         let t = e.parent;
         return ['selector-selector' === t.type && t.nodes[0] === l ? '' : St, l.value, Dr(e, l) ? '' : ' '];
        }
        return [l.value.trim().startsWith('(') ? St : '', an(nn(l.value.trim(), t)) || St];
       case 'selector-universal':
        return [l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', l.value];
       case 'selector-pseudo':
        return [fr(l.value), Nt(l.nodes) ? bt(['(', Dt([wt, Ft([',', St], e.map(r, 'nodes'))]), wt, ')']) : ''];
       case 'selector-unknown': {
        let r = e.findAncestor((e) => 'css-rule' === e.type);
        if (null != r && r.isSCSSNesterProperty) return an(nn(fr(l.value), t));
        let n = e.parent;
        if (null != (u = n.raws) && u.selector) {
         let e = sr(n),
          r = e + n.raws.selector.length;
         return t.originalText.slice(e, r).trim();
        }
        let s = e.grandparent;
        if ('value-paren_group' === n.type && 'value-func' === (null == s ? void 0 : s.type) && 'selector' === s.value) {
         let e = ir(n.open) + 1,
          r = sr(n.close),
          s = t.originalText.slice(e, r).trim();
         return Kr(s) ? [Tt, s] : s;
        }
        return l.value;
       }
       case 'value-value':
       case 'value-root':
        return r('group');
       case 'value-comment':
        return t.originalText.slice(sr(l), ir(l));
       case 'value-comma_group':
        return Yr(e, t, r);
       case 'value-paren_group':
        return fn(e, t, r);
       case 'value-func':
        return [l.value, gr(e, 'supports') && Wr(l) ? ' ' : '', r('group')];
       case 'value-number':
        return [on(l.value), en(l.unit)];
       case 'value-word':
        return (l.isColor && l.isHex) ||
         (function (e) {
          return hr.has(e.toLowerCase());
         })(l.value)
         ? l.value.toLowerCase()
         : l.value;
       case 'value-colon': {
        let { previous: t } = e;
        return [l.value, ('string' == typeof (null == t ? void 0 : t.value) && t.value.endsWith('\\')) || mr(e, 'url') ? '' : St];
       }
       case 'value-string':
        return Ot(l.raws.quote + l.value + l.raws.quote, t);
       case 'value-atword':
        return ['@', l.value];
       default:
        throw new Mt(l, 'PostCSS');
      }
     },
     embed: zt,
     insertPragma: function (e) {
      let { frontMatter: t, content: r } = pr(e);
      return (
       (t ? t.raw + '\n\n' : '') +
       (function (e) {
        let { shebang: t, text: r, pragmas: n, comments: s } = ur(e),
         i = (0, ar.strip)(r);
        return (t ? `${t}\n` : '') + (0, ar.print)({ pragmas: { format: '', ...n }, comments: s.trimStart() }) + (i.startsWith('\n') ? '\n' : '\n\n') + i;
       })(r)
      );
     },
     massageAstNode: Ut,
     getVisitorKeys: Jt,
    },
    Dn = [
     { linguistLanguageId: 50, name: 'CSS', type: 'markup', tmScope: 'source.css', aceMode: 'css', codemirrorMode: 'css', codemirrorMimeType: 'text/css', color: '#563d7c', extensions: ['.css', '.wxss'], parsers: ['css'], vscodeLanguageIds: ['css'] },
     { linguistLanguageId: 262764437, name: 'PostCSS', type: 'markup', color: '#dc3a0c', tmScope: 'source.postcss', group: 'CSS', extensions: ['.pcss', '.postcss'], aceMode: 'text', parsers: ['css'], vscodeLanguageIds: ['postcss'] },
     { linguistLanguageId: 198, name: 'Less', type: 'markup', color: '#1d365d', aliases: ['less-css'], extensions: ['.less'], tmScope: 'source.css.less', aceMode: 'less', codemirrorMode: 'css', codemirrorMimeType: 'text/css', parsers: ['less'], vscodeLanguageIds: ['less'] },
     { linguistLanguageId: 329, name: 'SCSS', type: 'markup', color: '#c6538c', tmScope: 'source.css.scss', aceMode: 'scss', codemirrorMode: 'css', codemirrorMimeType: 'text/x-scss', extensions: ['.scss'], parsers: ['scss'], vscodeLanguageIds: ['scss'] },
    ],
    xn = { singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' } },
    bn = {};
   p(bn, { css: () => Qn, less: () => Zn, scss: () => es });
   var vn = c(B(), 1),
    En = c(U(), 1),
    Cn = c(te(), 1);
   var Tn = function (e, t) {
    let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
    return Object.assign(r, t);
   };
   function Sn(e, t, r) {
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let n in e) Sn(e[n], t, r), 'type' === n && 'string' == typeof e[n] && !e[n].startsWith(t) && (!r || !r.test(e[n])) && (e[n] = t + e[n]);
    }
    return e;
   }
   function wn(e) {
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let t in e) wn(e[t]);
     !Array.isArray(e) && e.value && !e.type && (e.type = 'unknown');
    }
    return e;
   }
   var An = c(ie(), 1).default.default;
   var Fn = function (e) {
     let t;
     try {
      t = An(e);
     } catch {
      return { type: 'selector-unknown', value: e };
     }
     return Sn(wn(t), 'media-');
    },
    kn = c(Fe(), 1);
   var Pn = function (e) {
     if (/\/\/|\/\*/.test(e)) return { type: 'selector-unknown', value: e.trim() };
     let t;
     try {
      new kn.default((e) => {
       t = e;
      }).process(e);
     } catch {
      return { type: 'selector-unknown', value: e };
     }
     return Sn(t, 'selector-');
    },
    In = c(Je(), 1),
    Nn = (e) => {
     for (; e.parent; ) e = e.parent;
     return e;
    };
   var Bn = function (e) {
    return Nn(e)
     .text.slice(e.group.open.sourceIndex + 1, e.group.close.sourceIndex)
     .trim();
   };
   var _n = function (e) {
    if (Nt(e)) for (let t = e.length - 1; t > 0; t--) if ('word' === e[t].type && '{' === e[t].value && 'word' === e[t - 1].type && e[t - 1].value.endsWith('#')) return !0;
    return !1;
   };
   var Ln = function (e) {
    return e.some((e) => 'string' === e.type || ('func' === e.type && !e.value.endsWith('\\')));
   };
   var On = function (e, t) {
    return !('scss' !== t.parser || 'word' !== (null == e ? void 0 : e.type) || !e.value.startsWith('$'));
   };
   function Mn(e, t) {
    var r;
    let { nodes: n } = e,
     s = { open: null, close: null, groups: [], type: 'paren_group' },
     i = [s],
     a = s,
     o = { groups: [], type: 'comma_group' },
     u = [o];
    for (let l = 0; l < n.length; ++l) {
     let a = n[l];
     if (('scss' === t.parser && 'number' === a.type && '..' === a.unit && a.value.endsWith('.') && ((a.value = a.value.slice(0, -1)), (a.unit = '...')), 'func' === a.type && 'selector' === a.value && (a.group.groups = [Pn(Nn(e).text.slice(a.group.open.sourceIndex + 1, a.group.close.sourceIndex))]), 'func' === a.type && 'url' === a.value)) {
      let e = (null == (r = a.group) ? void 0 : r.groups) ?? [],
       n = [];
      for (let t = 0; t < e.length; t++) {
       let r = e[t];
       'comma_group' === r.type ? (n = [...n, ...r.groups]) : n.push(r);
      }
      (_n(n) || (!Ln(n) && !On(n[0], t))) && (a.group.groups = [Bn(a)]);
     }
     if ('paren' === a.type && '(' === a.value) (s = { open: a, close: null, groups: [], type: 'paren_group' }), i.push(s), (o = { groups: [], type: 'comma_group' }), u.push(o);
     else if ('paren' === a.type && ')' === a.value) {
      if ((o.groups.length > 0 && s.groups.push(o), (s.close = a), 1 === u.length)) throw new Error('Unbalanced parenthesis');
      u.pop(), (o = kt(!1, u, -1)), o.groups.push(s), i.pop(), (s = kt(!1, i, -1));
     } else 'comma' === a.type ? (s.groups.push(o), (o = { groups: [], type: 'comma_group' }), (u[u.length - 1] = o)) : o.groups.push(a);
    }
    return o.groups.length > 0 && s.groups.push(o), a;
   }
   function jn(e) {
    return ('paren_group' === e.type && !e.open && !e.close && 1 === e.groups.length) || ('comma_group' === e.type && 1 === e.groups.length) ? jn(e.groups[0]) : 'paren_group' === e.type || 'comma_group' === e.type ? { ...e, groups: e.groups.map(jn) } : e;
   }
   function Rn(e, t) {
    if (e && 'object' == typeof e) for (let r in e) 'parent' !== r && (Rn(e[r], t), 'nodes' === r && ((e.group = jn(Mn(e, t))), delete e[r]));
    return e;
   }
   var qn = function (e, t) {
     if ('less' === t.parser && e.startsWith('~`')) return { type: 'value-unknown', value: e };
     let r = null;
     try {
      r = new In.default(e, { loose: !0 }).parse();
     } catch {
      return { type: 'value-unknown', value: e };
     }
     return (r.text = e), Sn(Rn(r, t), 'value-', /^selector-/);
    },
    Un = new Set(['import', 'use', 'forward']);
   var $n = function (e) {
    return Un.has(e);
   };
   var Hn = function (e, t) {
     return (
      !('scss' !== t.parser || !e.selector) &&
      e.selector
       .replace(/\/\*.*?\*\//, '')
       .replace(/\/\/.*\n/, '')
       .trim()
       .endsWith(':')
     );
    },
    zn = /(\s*)(!default).*$/,
    Vn = /(\s*)(!global).*$/;
   function Wn(e, t) {
    var r, n;
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let r in e) Wn(e[r], t);
     if (!e.type) return e;
     if ((e.raws ?? (e.raws = {}), 'css-decl' === e.type && 'string' == typeof e.prop && e.prop.startsWith('--') && 'string' == typeof e.value && e.value.startsWith('{'))) {
      let n;
      if (e.value.trimEnd().endsWith('}')) {
       let s,
        i,
        a = t.originalText.slice(0, e.source.start.offset),
        o = 'a'.repeat(e.prop.length) + t.originalText.slice(e.source.start.offset + e.prop.length, e.source.end.offset),
        u = Ge(!1, a, /[^\n]/g, ' ') + o;
       s = 'scss' === t.parser ? Xn : 'less' === t.parser ? Gn : Kn;
       try {
        i = s(u, { ...t });
       } catch {}
       1 === (null == (r = null == i ? void 0 : i.nodes) ? void 0 : r.length) && 'css-rule' === i.nodes[0].type && (n = i.nodes[0].nodes);
      }
      return (e.value = n ? { type: 'css-rule', nodes: n } : { type: 'value-unknown', value: e.raws.value.raw }), e;
     }
     let s = '';
     'string' == typeof e.selector && ((s = e.raws.selector ? e.raws.selector.scss ?? e.raws.selector.raw : e.selector), e.raws.between && e.raws.between.trim().length > 0 && (s += e.raws.between), (e.raws.selector = s));
     let i = '';
     'string' == typeof e.value && ((i = e.raws.value ? e.raws.value.scss ?? e.raws.value.raw : e.value), (i = i.trim()), (e.raws.value = i));
     let a = '';
     if (('string' == typeof e.params && ((a = e.raws.params ? e.raws.params.scss ?? e.raws.params.raw : e.params), e.raws.afterName && e.raws.afterName.trim().length > 0 && (a = e.raws.afterName + a), e.raws.between && e.raws.between.trim().length > 0 && (a += e.raws.between), (a = a.trim()), (e.raws.params = a)), s.trim().length > 0)) return s.startsWith('@') && s.endsWith(':') ? e : e.mixin ? ((e.selector = qn(s, t)), e) : (Hn(e, t) && (e.isSCSSNesterProperty = !0), (e.selector = Pn(s)), e);
     if (i.length > 0) {
      let r = i.match(zn);
      r && ((i = i.slice(0, r.index)), (e.scssDefault = !0), '!default' !== r[0].trim() && (e.raws.scssDefault = r[0]));
      let n = i.match(Vn);
      if ((n && ((i = i.slice(0, n.index)), (e.scssGlobal = !0), '!global' !== n[0].trim() && (e.raws.scssGlobal = n[0])), i.startsWith('progid:'))) return { type: 'value-unknown', value: i };
      e.value = qn(i, t);
     }
     if (('less' === t.parser && 'css-decl' === e.type && i.startsWith('extend(') && (e.extend || (e.extend = ':' === e.raws.between), e.extend && !e.selector && (delete e.value, (e.selector = Pn(i.slice(7, -1))))), 'css-atrule' === e.type)) {
      if ('less' === t.parser) {
       if (e.mixin) {
        let t = e.raws.identifier + e.name + e.raws.afterName + e.raws.params;
        return (e.selector = Pn(t)), delete e.params, e;
       }
       if (e.function) return e;
      }
      if ('css' === t.parser && 'custom-selector' === e.name) {
       let t = e.params.match(/:--\S+\s+/)[0].trim();
       return (e.customSelector = t), (e.selector = Pn(e.params.slice(t.length).trim())), delete e.params, e;
      }
      if ('less' === t.parser) {
       if (e.name.includes(':') && !e.params) {
        e.variable = !0;
        let r = e.name.split(':');
        (e.name = r[0]), (e.value = qn(r.slice(1).join(':'), t));
       }
       if (!['page', 'nest', 'keyframes'].includes(e.name) && ':' === (null == (n = e.params) ? void 0 : n[0])) {
        e.variable = !0;
        let r = e.params.slice(1);
        r && (e.value = qn(r, t)), (e.raws.afterName += ':');
       }
       if (e.variable) return delete e.params, e.value || delete e.value, e;
      }
     }
     if ('css-atrule' === e.type && a.length > 0) {
      let { name: r } = e,
       n = e.name.toLowerCase();
      return 'warn' === r || 'error' === r ? ((e.params = { type: 'media-unknown', value: a }), e) : 'extend' === r || 'nest' === r ? ((e.selector = Pn(a)), delete e.params, e) : 'at-root' === r ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(a) ? (e.params = qn(a, t)) : ((e.selector = Pn(a)), delete e.params), e) : $n(n) ? ((e.import = !0), delete e.filename, (e.params = qn(a, t)), e) : ['namespace', 'supports', 'if', 'else', 'for', 'each', 'while', 'debug', 'mixin', 'include', 'function', 'return', 'define-mixin', 'add-mixin'].includes(r) ? ((a = a.replace(/(\$\S+?)(\s+)?\.{3}/, '$1...$2')), (a = a.replace(/^(?!if)(\S+)(\s+)\(/, '$1($2')), (e.value = qn(a, t)), delete e.params, e) : ['media', 'custom-media'].includes(n) ? (a.includes('#{') ? { type: 'media-unknown', value: a } : ((e.params = Fn(a)), e)) : ((e.params = a), e);
     }
    }
    return e;
   }
   function Jn(e, t, r) {
    let n,
     s = pr(t),
     { frontMatter: i } = s;
    t = s.content;
    try {
     n = e(t, { map: !1 });
    } catch (a) {
     let { name: e, reason: t, line: r, column: n } = a;
     throw 'number' != typeof r ? a : Tn(`${e}: ${t}`, { loc: { start: { line: r, column: n } }, cause: a });
    }
    return (r.originalText = t), (n = Wn(Sn(n, 'css-'), r)), tr(n, t), i && ((i.source = { startOffset: 0, endOffset: i.raw.length }), (n.frontMatter = i)), n;
   }
   function Kn(e, t = {}) {
    return Jn(vn.default.default, e, t);
   }
   function Gn(e, t = {}) {
    return Jn(
     (e) =>
      En.default.parse(
       (function (e) {
        let t,
         r = 'initial',
         n = 'initial',
         s = !1,
         i = [];
        for (let a = 0; a < e.length; a++) {
         let o = e[a];
         switch (r) {
          case 'initial':
           if ("'" === o) {
            r = 'single-quotes';
            continue;
           }
           if ('"' === o) {
            r = 'double-quotes';
            continue;
           }
           if (('u' === o || 'U' === o) && 'url(' === e.slice(a, a + 4).toLowerCase()) {
            (r = 'url'), (a += 3);
            continue;
           }
           if ('*' === o && '/' === e[a - 1]) {
            r = 'comment-block';
            continue;
           }
           if ('/' === o && '/' === e[a - 1]) {
            (r = 'comment-inline'), (t = a - 1);
            continue;
           }
           continue;
          case 'single-quotes':
           if (("'" === o && '\\' !== e[a - 1] && ((r = n), (n = 'initial')), '\n' === o || '\r' === o)) return e;
           continue;
          case 'double-quotes':
           if (('"' === o && '\\' !== e[a - 1] && ((r = n), (n = 'initial')), '\n' === o || '\r' === o)) return e;
           continue;
          case 'url':
           if ((')' === o && (r = 'initial'), '\n' === o || '\r' === o)) return e;
           if ("'" === o) {
            (r = 'single-quotes'), (n = 'url');
            continue;
           }
           if ('"' === o) {
            (r = 'double-quotes'), (n = 'url');
            continue;
           }
           continue;
          case 'comment-block':
           '/' === o && '*' === e[a - 1] && (r = 'initial');
           continue;
          case 'comment-inline':
           ('"' === o || "'" === o || '*' === o) && (s = !0), ('\n' === o || '\r' === o) && (s && i.push([t, a]), (r = 'initial'), (s = !1));
           continue;
         }
        }
        for (let [a, o] of i) e = e.slice(0, a) + Ge(!1, e.slice(a, o), /["'*]/g, ' ') + e.slice(o);
        return e;
       })(e),
      ),
     e,
     t,
    );
   }
   function Xn(e, t = {}) {
    return Jn(Cn.default, e, t);
   }
   var Yn = {
     astFormat: 'postcss',
     hasPragma: function (e) {
      return (function (e) {
       let { pragmas: t } = ur(e);
       return Object.prototype.hasOwnProperty.call(t, 'prettier') || Object.prototype.hasOwnProperty.call(t, 'format');
      })(pr(e).content);
     },
     locStart: sr,
     locEnd: ir,
    },
    Qn = { ...Yn, parse: Kn },
    Zn = { ...Yn, parse: Gn },
    es = { ...Yn, parse: Xn },
    ts = { postcss: gn },
    rs = Ke;
  },
  74642: (e, t, r) => {
   r.d(t, { ZP: () => Tn });
   var n = Object.create,
    s = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e) => {
     throw TypeError(e);
    },
    p = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    c = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    h = (e, t, r, n) => {
     if ((t && 'object' == typeof t) || 'function' == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && s(e, o, { get: () => t[o], enumerable: !(n = i(t, o)) || n.enumerable });
     return e;
    },
    d = (e, t, r) => ((r = null != e ? n(o(e)) : {}), h(!t && e && e.__esModule ? r : s(r, 'default', { value: e, enumerable: !0 }), e)),
    f = (e, t, r) => (
     ((e, t, r) => {
      t.has(e) || l('Cannot ' + r);
     })(e, t, 'access private method'),
     r
    ),
    m = p((e) => {
     function t() {}
     function r(e, t, r, n, s) {
      for (var i, a = []; t; ) a.push(t), (i = t.previousComponent), delete t.previousComponent, (t = i);
      a.reverse();
      for (var o = 0, u = a.length, l = 0, p = 0; o < u; o++) {
       var c = a[o];
       if (c.removed) {
        if (((c.value = e.join(n.slice(p, p + c.count))), (p += c.count), o && a[o - 1].added)) {
         var h = a[o - 1];
         (a[o - 1] = a[o]), (a[o] = h);
        }
       } else {
        if (!c.added && s) {
         var d = r.slice(l, l + c.count);
         (d = d.map(function (e, t) {
          var r = n[p + t];
          return r.length > e.length ? r : e;
         })),
          (c.value = e.join(d));
        } else c.value = e.join(r.slice(l, l + c.count));
        (l += c.count), c.added || (p += c.count);
       }
      }
      var f = a[u - 1];
      return u > 1 && 'string' == typeof f.value && (f.added || f.removed) && e.equals('', f.value) && ((a[u - 2].value += f.value), a.pop()), a;
     }
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = t),
      (t.prototype = {
       diff: function (e, t) {
        var n,
         s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
         i = s.callback;
        'function' == typeof s && ((i = s), (s = {})), (this.options = s);
        var a = this;
        function o(e) {
         return i
          ? (setTimeout(function () {
             i(void 0, e);
            }, 0),
            !0)
          : e;
        }
        (e = this.castInput(e)), (t = this.castInput(t)), (e = this.removeEmpty(this.tokenize(e)));
        var u = (t = this.removeEmpty(this.tokenize(t))).length,
         l = e.length,
         p = 1,
         c = u + l;
        s.maxEditLength && (c = Math.min(c, s.maxEditLength));
        var h = null !== (n = s.timeout) && void 0 !== n ? n : 1 / 0,
         d = Date.now() + h,
         f = [{ oldPos: -1, lastComponent: void 0 }],
         m = this.extractCommon(f[0], t, e, 0);
        if (f[0].oldPos + 1 >= l && m + 1 >= u) return o([{ value: this.join(t), count: t.length }]);
        var y = -1 / 0,
         g = 1 / 0;
        function D() {
         for (var n = Math.max(y, -p); n <= Math.min(g, p); n += 2) {
          var s = void 0,
           i = f[n - 1],
           c = f[n + 1];
          i && (f[n - 1] = void 0);
          var h = !1;
          if (c) {
           var d = c.oldPos - n;
           h = c && 0 <= d && d < u;
          }
          var D = i && i.oldPos + 1 < l;
          if (h || D) {
           if (((s = !D || (h && i.oldPos + 1 < c.oldPos) ? a.addToPath(c, !0, void 0, 0) : a.addToPath(i, void 0, !0, 1)), (m = a.extractCommon(s, t, e, n)), s.oldPos + 1 >= l && m + 1 >= u)) return o(r(a, s.lastComponent, t, e, a.useLongestToken));
           (f[n] = s), s.oldPos + 1 >= l && (g = Math.min(g, n - 1)), m + 1 >= u && (y = Math.max(y, n + 1));
          } else f[n] = void 0;
         }
         p++;
        }
        if (i)
         !(function e() {
          setTimeout(function () {
           if (p > c || Date.now() > d) return i();
           D() || e();
          }, 0);
         })();
        else
         for (; p <= c && Date.now() <= d; ) {
          var x = D();
          if (x) return x;
         }
       },
       addToPath: function (e, t, r, n) {
        var s = e.lastComponent;
        return s && s.added === t && s.removed === r ? { oldPos: e.oldPos + n, lastComponent: { count: s.count + 1, added: t, removed: r, previousComponent: s.previousComponent } } : { oldPos: e.oldPos + n, lastComponent: { count: 1, added: t, removed: r, previousComponent: s } };
       },
       extractCommon: function (e, t, r, n) {
        for (var s = t.length, i = r.length, a = e.oldPos, o = a - n, u = 0; o + 1 < s && a + 1 < i && this.equals(t[o + 1], r[a + 1]); ) o++, a++, u++;
        return u && (e.lastComponent = { count: u, previousComponent: e.lastComponent }), (e.oldPos = a), o;
       },
       equals: function (e, t) {
        return this.options.comparator ? this.options.comparator(e, t) : e === t || (this.options.ignoreCase && e.toLowerCase() === t.toLowerCase());
       },
       removeEmpty: function (e) {
        for (var t = [], r = 0; r < e.length; r++) e[r] && t.push(e[r]);
        return t;
       },
       castInput: function (e) {
        return e;
       },
       tokenize: function (e) {
        return e.split('');
       },
       join: function (e) {
        return e.join('');
       },
      });
    }),
    y = p((e) => {
     var t;
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.diffArrays = function (e, t, n) {
       return r.diff(e, t, n);
      }),
      (e.arrayDiff = void 0);
     var r = new ((t = m()) && t.__esModule ? t : { default: t }).default();
     (e.arrayDiff = r),
      (r.tokenize = function (e) {
       return e.slice();
      }),
      (r.join = r.removeEmpty =
       function (e) {
        return e;
       });
    }),
    g = p((e, t) => {
     var r = new Proxy(String, { get: () => r });
     t.exports = r;
    }),
    D = {};
   c(D, { default: () => b, shouldHighlight: () => x });
   var x,
    b,
    v,
    E,
    C =
     ((v = () => {
      (x = () => !1), (b = String);
     }),
     () => (v && (E = v((v = 0))), E)),
    T = p((e, t) => {
     var r = String,
      n = function () {
       return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r };
      };
     (t.exports = n()), (t.exports.createColors = n);
    }),
    S = p((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.codeFrameColumns = p),
      (e.default = function (e, t, r, n = {}) {
       if (!u) {
        u = !0;
        let e = 'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.';
        (new Error(e).name = 'DeprecationWarning'), console.warn(new Error(e));
       }
       return (r = Math.max(r, 0)), p(e, { start: { column: r, line: t } }, n);
      });
     var t = (C(), ((e) => h(s({}, '__esModule', { value: !0 }), e))(D)),
      r = (function (e, t) {
       if (!t && e && e.__esModule) return e;
       if (null === e || ('object' != typeof e && 'function' != typeof e)) return { default: e };
       var r = n(t);
       if (r && r.has(e)) return r.get(e);
       var s = { __proto__: null },
        i = Object.defineProperty && Object.getOwnPropertyDescriptor;
       for (var a in e)
        if ('default' !== a && {}.hasOwnProperty.call(e, a)) {
         var o = i ? Object.getOwnPropertyDescriptor(e, a) : null;
         o && (o.get || o.set) ? Object.defineProperty(s, a, o) : (s[a] = e[a]);
        }
       return (s.default = e), r && r.set(e, s), s;
      })(T(), !0);
     function n(e) {
      if ('function' != typeof WeakMap) return null;
      var t = new WeakMap(),
       r = new WeakMap();
      return (n = function (e) {
       return e ? r : t;
      })(e);
     }
     var i,
      a = r.default,
      o = (e, t) => (r) => e(t(r));
     var u = !1;
     var l = /\r\n|[\n\r\u2028\u2029]/;
     function p(e, n, s = {}) {
      let u = (s.highlightCode || s.forceColor) && (0, t.shouldHighlight)(s),
       p = (function (e) {
        return e ? (null != i || (i = (0, r.createColors)(!0)), i) : a;
       })(s.forceColor),
       c = (function (e) {
        return { gutter: e.gray, marker: o(e.red, e.bold), message: o(e.red, e.bold) };
       })(p),
       h = (e, t) => (u ? e(t) : t),
       d = e.split(l),
       {
        start: f,
        end: m,
        markerLines: y,
       } = (function (e, t, r) {
        let n = Object.assign({ column: 0, line: -1 }, e.start),
         s = Object.assign({}, n, e.end),
         { linesAbove: i = 2, linesBelow: a = 3 } = r || {},
         o = n.line,
         u = n.column,
         l = s.line,
         p = s.column,
         c = Math.max(o - (i + 1), 0),
         h = Math.min(t.length, l + a);
        -1 === o && (c = 0), -1 === l && (h = t.length);
        let d = l - o,
         f = {};
        if (d)
         for (let m = 0; m <= d; m++) {
          let e = m + o;
          if (u)
           if (0 === m) {
            let r = t[e - 1].length;
            f[e] = [u, r - u + 1];
           } else if (m === d) f[e] = [0, p];
           else {
            let r = t[e - m].length;
            f[e] = [0, r];
           }
          else f[e] = !0;
         }
        else f[o] = u === p ? !u || [u, 0] : [u, p - u];
        return { start: c, end: h, markerLines: f };
       })(n, d, s),
       g = n.start && 'number' == typeof n.start.column,
       D = String(m).length,
       x = (u ? (0, t.default)(e, s) : e)
        .split(l, m)
        .slice(f, m)
        .map((e, t) => {
         let r = f + 1 + t,
          n = ` ${` ${r}`.slice(-D)} |`,
          i = y[r],
          a = !y[r + 1];
         if (i) {
          let t = '';
          if (Array.isArray(i)) {
           let r = e.slice(0, Math.max(i[0] - 1, 0)).replace(/[^\t]/g, ' '),
            o = i[1] || 1;
           (t = ['\n ', h(c.gutter, n.replace(/\d/g, ' ')), ' ', r, h(c.marker, '^').repeat(o)].join('')), a && s.message && (t += ' ' + h(c.message, s.message));
          }
          return [h(c.marker, '>'), h(c.gutter, n), e.length > 0 ? ` ${e}` : '', t].join('');
         }
         return ` ${h(c.gutter, n)}${e.length > 0 ? ` ${e}` : ''}`;
        })
        .join('\n');
      return s.message && !g && (x = `${' '.repeat(D + 1)}${s.message}\n${x}`), u ? p.reset(x) : x;
     }
    }),
    w = {};
   c(w, { __debug: () => Cn, check: () => vn, doc: () => Qr, format: () => bn, formatWithCursor: () => xn, getSupportInfo: () => En, util: () => nn, version: () => rn });
   var A = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    F = d(y(), 1);
   function k(e) {
    switch (e) {
     case 'cr':
      return '\r';
     case 'crlf':
      return '\r\n';
     default:
      return '\n';
    }
   }
   function P(e, t) {
    let r;
    switch (t) {
     case '\n':
      r = /\n/g;
      break;
     case '\r':
      r = /\r/g;
      break;
     case '\r\n':
      r = /\r\n/g;
      break;
     default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
    }
    let n = e.match(r);
    return n ? n.length : 0;
   }
   var I = 'string',
    N = 'array',
    B = 'cursor',
    _ = 'indent',
    L = 'align',
    O = 'trim',
    M = 'group',
    j = 'fill',
    R = 'if-break',
    q = 'indent-if-break',
    U = 'line-suffix',
    $ = 'line-suffix-boundary',
    H = 'line',
    z = 'label',
    V = 'break-parent',
    W = new Set([B, _, L, O, M, j, R, q, U, $, H, z, V]);
   var J = function (e) {
    if ('string' == typeof e) return I;
    if (Array.isArray(e)) return N;
    if (!e) return;
    let { type: t } = e;
    return W.has(t) ? t : void 0;
   };
   function K(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (J(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...W].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var G = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      super(K(e)), (this.doc = e);
     }
    },
    X = G,
    Y = {};
   var Q = function (e, t, r, n) {
     let s = [e];
     for (; s.length > 0; ) {
      let e = s.pop();
      if (e === Y) {
       r(s.pop());
       continue;
      }
      r && s.push(e, Y);
      let i = J(e);
      if (!i) throw new X(e);
      if (!1 !== (null == t ? void 0 : t(e)))
       switch (i) {
        case N:
        case j: {
         let t = i === N ? e : e.parts;
         for (let e = t.length - 1; e >= 0; --e) s.push(t[e]);
         break;
        }
        case R:
         s.push(e.flatContents, e.breakContents);
         break;
        case M:
         if (n && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) s.push(e.expandedStates[t]);
         else s.push(e.contents);
         break;
        case L:
        case _:
        case q:
        case z:
        case U:
         s.push(e.contents);
         break;
        case I:
        case B:
        case O:
        case $:
        case H:
        case V:
         break;
        default:
         throw new X(e);
       }
     }
    },
    Z = () => {},
    ee = Z,
    te = Z;
   function re(e) {
    return ee(e), { type: _, contents: e };
   }
   function ne(e, t) {
    return ee(t), { type: L, contents: t, n: e };
   }
   function se(e, t = {}) {
    return ee(e), te(t.expandedStates, !0), { type: M, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function ie(e) {
    return te(e), { type: j, parts: e };
   }
   function ae(e) {
    return ee(e), { type: U, contents: e };
   }
   var oe = { type: $ },
    ue = { type: V },
    le = { type: O },
    pe = { type: H, hard: !0 },
    ce = { type: H, hard: !0, literal: !0 },
    he = { type: H },
    de = { type: H, soft: !0 },
    fe = [pe, ue],
    me = [ce, ue],
    ye = { type: B };
   function ge(e, t) {
    ee(e), te(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   function De(e, t, r) {
    ee(e);
    let n = e;
    if (t > 0) {
     for (let e = 0; e < Math.floor(t / r); ++e) n = re(n);
     (n = ne(t % r, n)), (n = ne(Number.NEGATIVE_INFINITY, n));
    }
    return n;
   }
   function xe(e) {
    var t;
    if (!e) return '';
    if (Array.isArray(e)) {
     let t = [];
     for (let r of e)
      if (Array.isArray(r)) t.push(...xe(r));
      else {
       let e = xe(r);
       '' !== e && t.push(e);
      }
     return t;
    }
    return e.type === R ? { ...e, breakContents: xe(e.breakContents), flatContents: xe(e.flatContents) } : e.type === M ? { ...e, contents: xe(e.contents), expandedStates: null == (t = e.expandedStates) ? void 0 : t.map(xe) } : e.type === j ? { type: 'fill', parts: e.parts.map(xe) } : e.contents ? { ...e, contents: xe(e.contents) } : e;
   }
   var be = (e, t, r) => {
    if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
   };
   var ve = (e) =>
     !(
      (function (e) {
       return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
      })(e) ||
      (function (e) {
       return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9800 && e <= 9811) || 9855 === e || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12771) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 19903) || (e >= 19968 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || 94192 === e || 94193 === e || (e >= 94208 && e <= 100343) || (e >= 100352 && e <= 101589) || (e >= 101632 && e <= 101640) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128727) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129672) || (e >= 129680 && e <= 129725) || (e >= 129727 && e <= 129733) || (e >= 129742 && e <= 129755) || (e >= 129760 && e <= 129768) || (e >= 129776 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
      })(e)
     ),
    Ee = /[^\x20-\x7F]/;
   var Ce = function (e) {
    if (!e) return 0;
    if (!Ee.test(e)) return e.length;
    e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, '  ');
    let t = 0;
    for (let r of e) {
     let e = r.codePointAt(0);
     e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (t += ve(e) ? 1 : 2);
    }
    return t;
   };
   function Te(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (J(e)) {
       case N:
        return t(e.map(n));
       case j:
        return t({ ...e, parts: e.parts.map(n) });
       case R:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case M: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case L:
       case _:
       case q:
       case z:
       case U:
        return t({ ...e, contents: n(e.contents) });
       case I:
       case B:
       case O:
       case $:
       case H:
       case V:
        return t(e);
       default:
        throw new X(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function Se(e, t, r) {
    let n = r,
     s = !1;
    return (
     Q(e, function (e) {
      if (s) return !1;
      let r = t(e);
      void 0 !== r && ((s = !0), (n = r));
     }),
     n
    );
   }
   function we(e) {
    if ((e.type === M && e.break) || (e.type === H && e.hard) || e.type === V) return !0;
   }
   function Ae(e) {
    if (e.length > 0) {
     let t = be(!1, e, -1);
     !t.expandedStates && !t.break && (t.break = 'propagated');
    }
    return null;
   }
   function Fe(e) {
    return e.type !== H || e.hard ? (e.type === R ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   function ke(e) {
    for (e = [...e]; e.length >= 2 && be(!1, e, -2).type === H && be(!1, e, -1).type === V; ) e.length -= 2;
    if (e.length > 0) {
     let t = Pe(be(!1, e, -1));
     e[e.length - 1] = t;
    }
    return e;
   }
   function Pe(e) {
    switch (J(e)) {
     case _:
     case q:
     case M:
     case U:
     case z: {
      let t = Pe(e.contents);
      return { ...e, contents: t };
     }
     case R:
      return { ...e, breakContents: Pe(e.breakContents), flatContents: Pe(e.flatContents) };
     case j:
      return { ...e, parts: ke(e.parts) };
     case N:
      return ke(e);
     case I:
      return e.replace(/[\n\r]*$/, '');
     case L:
     case B:
     case O:
     case $:
     case H:
     case V:
      break;
     default:
      throw new X(e);
    }
    return e;
   }
   function Ie(e) {
    return Pe(
     (function (e) {
      return Te(e, (e) =>
       (function (e) {
        switch (J(e)) {
         case j:
          if (e.parts.every((e) => '' === e)) return '';
          break;
         case M:
          if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
          if (e.contents.type === M && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
          break;
         case L:
         case _:
         case q:
         case U:
          if (!e.contents) return '';
          break;
         case R:
          if (!e.flatContents && !e.breakContents) return '';
          break;
         case N: {
          let t = [];
          for (let r of e) {
           if (!r) continue;
           let [e, ...n] = Array.isArray(r) ? r : [r];
           'string' == typeof e && 'string' == typeof be(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...n);
          }
          return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
         }
         case I:
         case B:
         case O:
         case $:
         case H:
         case z:
         case V:
          break;
         default:
          throw new X(e);
        }
        return e;
       })(e),
      );
     })(e),
    );
   }
   function Ne(e) {
    if (e.type === H) return !0;
   }
   function Be(e, t) {
    return e.type === z ? { ...e, contents: t(e.contents) } : t(e);
   }
   var _e = Symbol('MODE_BREAK'),
    Le = Symbol('MODE_FLAT'),
    Oe = Symbol('cursor');
   function Me(e, t) {
    return Re(e, { type: 'indent' }, t);
   }
   function je(e, t, r) {
    return t === Number.NEGATIVE_INFINITY ? e.root || { value: '', length: 0, queue: [] } : t < 0 ? Re(e, { type: 'dedent' }, r) : t ? ('root' === t.type ? { ...e, root: e } : Re(e, { type: 'string' == typeof t ? 'stringAlign' : 'numberAlign', n: t }, r)) : e;
   }
   function Re(e, t, r) {
    let n = 'dedent' === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     s = '',
     i = 0,
     a = 0,
     o = 0;
    for (let d of n)
     switch (d.type) {
      case 'indent':
       p(), r.useTabs ? u(1) : l(r.tabWidth);
       break;
      case 'stringAlign':
       p(), (s += d.n), (i += d.n.length);
       break;
      case 'numberAlign':
       (a += 1), (o += d.n);
       break;
      default:
       throw new Error(`Unexpected type '${d.type}'`);
     }
    return c(), { ...e, value: s, length: i, queue: n };
    function u(e) {
     (s += '\t'.repeat(e)), (i += r.tabWidth * e);
    }
    function l(e) {
     (s += ' '.repeat(e)), (i += e);
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     o > 0 && l(o), h();
    }
    function h() {
     (a = 0), (o = 0);
    }
   }
   function qe(e) {
    let t = 0,
     r = 0,
     n = e.length;
    e: for (; n--; ) {
     let s = e[n];
     if (s !== Oe)
      for (let r = s.length - 1; r >= 0; r--) {
       let i = s[r];
       if (' ' !== i && '\t' !== i) {
        e[n] = s.slice(0, r + 1);
        break e;
       }
       t++;
      }
     else r++;
    }
    if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(Oe);
    return t;
   }
   function Ue(e, t, r, n, s, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = [e],
     u = [];
    for (; r >= 0; ) {
     if (0 === o.length) {
      if (0 === a) return !0;
      o.push(t[--a]);
      continue;
     }
     let { mode: e, doc: l } = o.pop(),
      p = J(l);
     switch (p) {
      case I:
       u.push(l), (r -= Ce(l));
       break;
      case N:
      case j: {
       let t = p === N ? l : l.parts;
       for (let r = t.length - 1; r >= 0; r--) o.push({ mode: e, doc: t[r] });
       break;
      }
      case _:
      case L:
      case q:
      case z:
       o.push({ mode: e, doc: l.contents });
       break;
      case O:
       r += qe(u);
       break;
      case M: {
       if (i && l.break) return !1;
       let t = l.break ? _e : e,
        r = l.expandedStates && t === _e ? be(!1, l.expandedStates, -1) : l.contents;
       o.push({ mode: t, doc: r });
       break;
      }
      case R: {
       let t = (l.groupId ? s[l.groupId] || Le : e) === _e ? l.breakContents : l.flatContents;
       t && o.push({ mode: e, doc: t });
       break;
      }
      case H:
       if (e === _e || l.hard) return !0;
       l.soft || (u.push(' '), r--);
       break;
      case U:
       n = !0;
       break;
      case $:
       if (n) return !1;
     }
    }
    return !1;
   }
   function $e(e, t) {
    let r = {},
     n = t.printWidth,
     s = k(t.endOfLine),
     i = 0,
     a = [{ ind: { value: '', length: 0, queue: [] }, mode: _e, doc: e }],
     o = [],
     u = !1,
     l = [],
     p = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      Q(
       e,
       function (e) {
        if ((e.type === V && Ae(r), e.type === M)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === M && r.pop().break && Ae(r);
       },
       !0,
      );
     })(e);
     a.length > 0;

    ) {
     let { ind: e, mode: c, doc: h } = a.pop();
     switch (J(h)) {
      case I: {
       let e = '\n' !== s ? A(!1, h, '\n', s) : h;
       o.push(e), a.length > 0 && (i += Ce(e));
       break;
      }
      case N:
       for (let t = h.length - 1; t >= 0; t--) a.push({ ind: e, mode: c, doc: h[t] });
       break;
      case B:
       if (p >= 2) throw new Error("There are too many 'cursor' in doc.");
       o.push(Oe), p++;
       break;
      case _:
       a.push({ ind: Me(e, t), mode: c, doc: h.contents });
       break;
      case L:
       a.push({ ind: je(e, h.n, t), mode: c, doc: h.contents });
       break;
      case O:
       i -= qe(o);
       break;
      case M:
       switch (c) {
        case Le:
         if (!u) {
          a.push({ ind: e, mode: h.break ? _e : Le, doc: h.contents });
          break;
         }
        case _e: {
         u = !1;
         let t = { ind: e, mode: Le, doc: h.contents },
          s = n - i,
          o = l.length > 0;
         if (!h.break && Ue(t, a, s, o, r)) a.push(t);
         else if (h.expandedStates) {
          let t = be(!1, h.expandedStates, -1);
          if (h.break) {
           a.push({ ind: e, mode: _e, doc: t });
           break;
          }
          for (let n = 1; n < h.expandedStates.length + 1; n++) {
           if (n >= h.expandedStates.length) {
            a.push({ ind: e, mode: _e, doc: t });
            break;
           }
           {
            let t = h.expandedStates[n],
             i = { ind: e, mode: Le, doc: t };
            if (Ue(i, a, s, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ ind: e, mode: _e, doc: h.contents });
         break;
        }
       }
       h.id && (r[h.id] = be(!1, a, -1).mode);
       break;
      case j: {
       let t = n - i,
        { parts: s } = h;
       if (0 === s.length) break;
       let [o, u] = s,
        p = { ind: e, mode: Le, doc: o },
        d = { ind: e, mode: _e, doc: o },
        f = Ue(p, [], t, l.length > 0, r, !0);
       if (1 === s.length) {
        f ? a.push(p) : a.push(d);
        break;
       }
       let m = { ind: e, mode: Le, doc: u },
        y = { ind: e, mode: _e, doc: u };
       if (2 === s.length) {
        f ? a.push(m, p) : a.push(y, d);
        break;
       }
       s.splice(0, 2);
       let g = { ind: e, mode: c, doc: ie(s) },
        D = s[0];
       Ue({ ind: e, mode: Le, doc: [o, u, D] }, [], t, l.length > 0, r, !0) ? a.push(g, m, p) : f ? a.push(g, y, p) : a.push(g, y, d);
       break;
      }
      case R:
      case q: {
       let t = h.groupId ? r[h.groupId] : c;
       if (t === _e) {
        let t = h.type === R ? h.breakContents : h.negate ? h.contents : re(h.contents);
        t && a.push({ ind: e, mode: c, doc: t });
       }
       if (t === Le) {
        let t = h.type === R ? h.flatContents : h.negate ? re(h.contents) : h.contents;
        t && a.push({ ind: e, mode: c, doc: t });
       }
       break;
      }
      case U:
       l.push({ ind: e, mode: c, doc: h.contents });
       break;
      case $:
       l.length > 0 && a.push({ ind: e, mode: c, doc: pe });
       break;
      case H:
       switch (c) {
        case Le:
         if (!h.hard) {
          h.soft || (o.push(' '), (i += 1));
          break;
         }
         u = !0;
        case _e:
         if (l.length > 0) {
          a.push({ ind: e, mode: c, doc: h }, ...l.reverse()), (l.length = 0);
          break;
         }
         h.literal ? (e.root ? (o.push(s, e.root.value), (i = e.root.length)) : (o.push(s), (i = 0))) : ((i -= qe(o)), o.push(s + e.value), (i = e.length));
       }
       break;
      case z:
       a.push({ ind: e, mode: c, doc: h.contents });
       break;
      case V:
       break;
      default:
       throw new X(h);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let c = o.indexOf(Oe);
    if (-1 !== c) {
     let e = o.indexOf(Oe, c + 1),
      t = o.slice(0, c).join(''),
      r = o.slice(c + 1, e).join('');
     return { formatted: t + r + o.slice(e + 1).join(''), cursorNodeStart: t.length, cursorNodeText: r };
    }
    return { formatted: o.join('') };
   }
   var He,
    ze,
    Ve,
    We = function (e, t, r = 0) {
     let n = 0;
     for (let s = r; s < e.length; ++s) '\t' === e[s] ? (n = n + t - (n % t)) : n++;
     return n;
    };
   (He = new WeakSet()),
    (ze = function (e) {
     let { stack: t } = this;
     for (let r = t.length - 1; r >= 0; r -= 2) if (!Array.isArray(t[r]) && --e < 0) return r;
     return -1;
    }),
    (Ve = function* () {
     let { stack: e } = this;
     for (let t = e.length - 3; t >= 0; t -= 2) {
      let r = e[t];
      Array.isArray(r) || (yield r);
     }
    });
   var Je = class {
     constructor(e) {
      ((e, t, r) => {
       t.has(e) ? l('Cannot add the same private member more than once') : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, He),
       (this.stack = [e]);
     }
     get key() {
      let { stack: e, siblings: t } = this;
      return be(!1, e, null === t ? -2 : -4) ?? null;
     }
     get index() {
      return null === this.siblings ? null : be(!1, this.stack, -2);
     }
     get node() {
      return be(!1, this.stack, -1);
     }
     get parent() {
      return this.getNode(1);
     }
     get grandparent() {
      return this.getNode(2);
     }
     get isInArray() {
      return null !== this.siblings;
     }
     get siblings() {
      let { stack: e } = this,
       t = be(!1, e, -3);
      return Array.isArray(t) ? t : null;
     }
     get next() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index + 1];
     }
     get previous() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index - 1];
     }
     get isFirst() {
      return 0 === this.index;
     }
     get isLast() {
      let { siblings: e, index: t } = this;
      return null !== e && t === e.length - 1;
     }
     get isRoot() {
      return 1 === this.stack.length;
     }
     get root() {
      return this.stack[0];
     }
     get ancestors() {
      return [...f(this, He, Ve).call(this)];
     }
     getName() {
      let { stack: e } = this,
       { length: t } = e;
      return t > 1 ? be(!1, e, -2) : null;
     }
     getValue() {
      return be(!1, this.stack, -1);
     }
     getNode(e = 0) {
      let t = f(this, He, ze).call(this, e);
      return -1 === t ? null : this.stack[t];
     }
     getParentNode(e = 0) {
      return this.getNode(e + 1);
     }
     call(e, ...t) {
      let { stack: r } = this,
       { length: n } = r,
       s = be(!1, r, -1);
      for (let i of t) (s = s[i]), r.push(i, s);
      try {
       return e(this);
      } finally {
       r.length = n;
      }
     }
     callParent(e, t = 0) {
      let r = f(this, He, ze).call(this, t + 1),
       n = this.stack.splice(r + 1);
      try {
       return e(this);
      } finally {
       this.stack.push(...n);
      }
     }
     each(e, ...t) {
      let { stack: r } = this,
       { length: n } = r,
       s = be(!1, r, -1);
      for (let i of t) (s = s[i]), r.push(i, s);
      try {
       for (let t = 0; t < s.length; ++t) r.push(t, s[t]), e(this, t, s), (r.length -= 2);
      } finally {
       r.length = n;
      }
     }
     map(e, ...t) {
      let r = [];
      return (
       this.each(
        (t, n, s) => {
         r[n] = e(t, n, s);
        },
        ...t,
       ),
       r
      );
     }
     match(...e) {
      let t = this.stack.length - 1,
       r = null,
       n = this.stack[t--];
      for (let s of e) {
       if (void 0 === n) return !1;
       let e = null;
       if (('number' == typeof r && ((e = r), (r = this.stack[t--]), (n = this.stack[t--])), s && !s(n, r, e))) return !1;
       (r = this.stack[t--]), (n = this.stack[t--]);
      }
      return !0;
     }
     findAncestor(e) {
      for (let t of f(this, He, Ve).call(this)) if (e(t)) return t;
     }
     hasAncestor(e) {
      for (let t of f(this, He, Ve).call(this)) if (e(t)) return !0;
      return !1;
     }
    },
    Ke = new Proxy(() => {}, { get: () => Ke }),
    Ge = Ke;
   var Xe = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function* Ye(e, t) {
    let { getVisitorKeys: r, filter: n = () => !0 } = t,
     s = (e) => Xe(e) && n(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) s(e) && (yield e);
     else s(t) && (yield t);
    }
   }
   function Qe(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   var Ze = Qe(/\s/),
    et = Qe(' \t'),
    tt = Qe(',; \t'),
    rt = Qe(/[^\n\r]/);
   var nt = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ('\r' === e.charAt(t - 1) && '\n' === s) return t - 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t - 1;
    } else {
     if ('\r' === s && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t + 1;
    }
    return t;
   };
   var st = function (e, t, r = {}) {
    let n = et(e, r.backwards ? t - 1 : t, r);
    return n !== nt(e, n, r);
   };
   var it = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    at = new Set(['tokens', 'comments', 'parent', 'enclosingNode', 'precedingNode', 'followingNode']),
    ot = (e) => Object.keys(e).filter((e) => !at.has(e));
   var ut = function (e) {
    return e ? (t) => e(t, at) : ot;
   };
   function lt(e, t) {
    (e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || '(unknown type)',
       r = String(e.name || (e.id && ('object' == typeof e.id ? e.id.name : e.id)) || (e.key && ('object' == typeof e.key ? e.key.name : e.key)) || (e.value && ('object' == typeof e.value ? '' : String(e.value))) || e.operator || '');
      return r.length > 20 && (r = r.slice(0, 19) + '\u2026'), t + (r ? ' ' + r : '');
     })(e));
   }
   function pt(e, t) {
    (t.leading = !0), (t.trailing = !1), lt(e, t);
   }
   function ct(e, t, r) {
    (t.leading = !1), (t.trailing = !1), r && (t.marker = r), lt(e, t);
   }
   function ht(e, t) {
    (t.leading = !1), (t.trailing = !0), lt(e, t);
   }
   var dt = new WeakMap();
   function ft(e, t) {
    if (dt.has(e)) return dt.get(e);
    let {
     printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: s },
     locStart: i,
     locEnd: a,
    } = t;
    if (!n) return [];
    let o = ((null == r ? void 0 : r(e, t)) ?? [...Ye(e, { getVisitorKeys: ut(s) })]).flatMap((e) => (n(e) ? [e] : ft(e, t)));
    return o.sort((e, t) => i(e) - i(t) || a(e) - a(t)), dt.set(e, o), o;
   }
   function mt(e, t, r, n) {
    let s,
     i,
     { locStart: a, locEnd: o } = r,
     u = a(t),
     l = o(t),
     p = ft(e, r),
     c = 0,
     h = p.length;
    for (; c < h; ) {
     let e = (c + h) >> 1,
      n = p[e],
      d = a(n),
      f = o(n);
     if (d <= u && l <= f) return mt(n, t, r, n);
     if (f <= u) (s = n), (c = e + 1);
     else {
      if (!(l <= d)) throw new Error('Comment location overlaps with node location');
      (i = n), (h = e);
     }
    }
    if ('TemplateLiteral' === (null == n ? void 0 : n.type)) {
     let { quasis: e } = n,
      a = vt(e, t, r);
     s && vt(e, s, r) !== a && (s = null), i && vt(e, i, r) !== a && (i = null);
    }
    return { enclosingNode: n, precedingNode: s, followingNode: i };
   }
   var yt = () => !1;
   var gt = (e) => !/[\S\n\u2028\u2029]/.test(e);
   function Dt(e, t, r, n) {
    let { comment: s, precedingNode: i } = r[n],
     { locStart: a, locEnd: o } = t,
     u = a(s);
    if (i)
     for (let l = n - 1; l >= 0; l--) {
      let { comment: t, precedingNode: n } = r[l];
      if (n !== i || !gt(e.slice(o(t), u))) break;
      u = a(t);
     }
    return st(e, u, { backwards: !0 });
   }
   function xt(e, t, r, n) {
    let { comment: s, followingNode: i } = r[n],
     { locStart: a, locEnd: o } = t,
     u = o(s);
    if (i)
     for (let l = n + 1; l < r.length; l++) {
      let { comment: t, followingNode: n } = r[l];
      if (n !== i || !gt(e.slice(u, a(t)))) break;
      u = o(t);
     }
    return st(e, u);
   }
   function bt(e, t) {
    var r, n;
    let s = e.length;
    if (0 === s) return;
    let i,
     { precedingNode: a, followingNode: o } = e[0],
     u = t.locStart(o);
    for (i = s; i > 0; --i) {
     let { comment: s, precedingNode: l, followingNode: p } = e[i - 1];
     Ge.strictEqual(l, a), Ge.strictEqual(p, o);
     let c = t.originalText.slice(t.locEnd(s), u);
     if (!((null == (n = (r = t.printer).isGap) ? void 0 : n.call(r, c, t)) ?? /^[\s(]*$/.test(c))) break;
     u = t.locStart(s);
    }
    for (let [l, { comment: p }] of e.entries()) l < i ? ht(a, p) : pt(o, p);
    for (let l of [a, o]) l.comments && l.comments.length > 1 && l.comments.sort((e, r) => t.locStart(e) - t.locStart(r));
    e.length = 0;
   }
   function vt(e, t, r) {
    let n = r.locStart(t) - 1;
    for (let s = 1; s < e.length; ++s) if (n < r.locStart(e[s])) return s - 1;
    return 0;
   }
   var Et = function (e, t) {
    let r = t - 1;
    return (r = et(e, r, { backwards: !0 })), (r = nt(e, r, { backwards: !0 })), (r = et(e, r, { backwards: !0 })), r !== nt(e, r, { backwards: !0 });
   };
   function Ct(e, t) {
    return (e.node.printed = !0), t.printer.printComment(e, t);
   }
   function Tt(e, t) {
    let r = e.node;
    if (!r) return {};
    let n = t[Symbol.for('printedComments')];
    if (0 === (r.comments || []).filter((e) => !n.has(e)).length) return { leading: '', trailing: '' };
    let s,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (null != n && n.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           var r;
           let n = e.node,
            s = [Ct(e, t)],
            { printer: i, originalText: a, locStart: o, locEnd: u } = t;
           if (null == (r = i.isBlockComment) ? void 0 : r.call(i, n)) {
            let e = st(a, u(n)) ? (st(a, o(n), { backwards: !0 }) ? fe : he) : ' ';
            s.push(e);
           } else s.push(fe);
           let l = nt(a, et(a, u(n)));
           return !1 !== l && st(a, l) && s.push(fe), s;
          })(e, t),
         )
       : u &&
         ((s = (function (e, t, r) {
          var n;
          let s = e.node,
           i = Ct(e, t),
           { printer: a, originalText: o, locStart: u } = t,
           l = null == (n = a.isBlockComment) ? void 0 : n.call(a, s);
          if ((null != r && r.hasLineSuffix && (null == r || !r.isBlock)) || st(o, u(s), { backwards: !0 })) {
           let e = Et(o, u(s));
           return { doc: ae([fe, e ? fe : '', i]), isBlock: l, hasLineSuffix: !0 };
          }
          return !l || (null != r && r.hasLineSuffix) ? { doc: [ae([' ', i]), ue], isBlock: l, hasLineSuffix: !0 } : { doc: [' ', i], isBlock: l, hasLineSuffix: !1 };
         })(e, t, s)),
         a.push(s.doc));
     }, 'comments'),
     { leading: i, trailing: a }
    );
   }
   var St = function (e) {
     return () => {};
    },
    wt = class extends Error {
     name = 'ConfigError';
    },
    At = class extends Error {
     name = 'UndefinedParserError';
    },
    Ft = {
     cursorOffset: { category: 'Special', type: 'int', default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: 'Print (to stderr) where a cursor at the given position would move to after formatting.', cliCategory: 'Editor' },
     endOfLine: {
      category: 'Global',
      type: 'choice',
      default: 'lf',
      description: 'Which end of line characters to apply.',
      choices: [
       { value: 'lf', description: 'Line Feed only (\\n), common on Linux and macOS as well as inside git repos' },
       { value: 'crlf', description: 'Carriage Return + Line Feed characters (\\r\\n), common on Windows' },
       { value: 'cr', description: 'Carriage Return character only (\\r), used very rarely' },
       { value: 'auto', description: "Maintain existing\n(mixed values within one file are normalised by looking at what's used after the first line)" },
      ],
     },
     filepath: { category: 'Special', type: 'path', description: 'Specify the input filepath. This will be used to do parser inference.', cliName: 'stdin-filepath', cliCategory: 'Other', cliDescription: 'Path to the file to pretend that stdin comes from.' },
     insertPragma: { category: 'Special', type: 'boolean', default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: 'Other' },
     parser: {
      category: 'Global',
      type: 'choice',
      default: void 0,
      description: 'Which parser to use.',
      exception: (e) => 'string' == typeof e || 'function' == typeof e,
      choices: [
       { value: 'flow', description: 'Flow' },
       { value: 'babel', description: 'JavaScript' },
       { value: 'babel-flow', description: 'Flow' },
       { value: 'babel-ts', description: 'TypeScript' },
       { value: 'typescript', description: 'TypeScript' },
       { value: 'acorn', description: 'JavaScript' },
       { value: 'espree', description: 'JavaScript' },
       { value: 'meriyah', description: 'JavaScript' },
       { value: 'css', description: 'CSS' },
       { value: 'less', description: 'Less' },
       { value: 'scss', description: 'SCSS' },
       { value: 'json', description: 'JSON' },
       { value: 'json5', description: 'JSON5' },
       { value: 'jsonc', description: 'JSON with Comments' },
       { value: 'json-stringify', description: 'JSON.stringify' },
       { value: 'graphql', description: 'GraphQL' },
       { value: 'markdown', description: 'Markdown' },
       { value: 'mdx', description: 'MDX' },
       { value: 'vue', description: 'Vue' },
       { value: 'yaml', description: 'YAML' },
       { value: 'glimmer', description: 'Ember / Handlebars' },
       { value: 'html', description: 'HTML' },
       { value: 'angular', description: 'Angular' },
       { value: 'lwc', description: 'Lightning Web Components' },
      ],
     },
     plugins: { type: 'path', array: !0, default: [{ value: [] }], category: 'Global', description: 'Add a plugin. Multiple plugins can be passed as separate `--plugin`s.', exception: (e) => 'string' == typeof e || 'object' == typeof e, cliName: 'plugin', cliCategory: 'Config' },
     printWidth: { category: 'Global', type: 'int', default: 80, description: 'The line length where Prettier will try wrap.', range: { start: 0, end: 1 / 0, step: 1 } },
     rangeEnd: { category: 'Special', type: 'int', default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: 'Format code ending at a given character offset (exclusive).\nThe range will extend forwards to the end of the selected statement.', cliCategory: 'Editor' },
     rangeStart: { category: 'Special', type: 'int', default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: 'Format code starting at a given character offset.\nThe range will extend backwards to the start of the first line containing the selected statement.', cliCategory: 'Editor' },
     requirePragma: { category: 'Special', type: 'boolean', default: !1, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment\nin order for it to be formatted.", cliCategory: 'Other' },
     tabWidth: { type: 'int', category: 'Global', default: 2, description: 'Number of spaces per indentation level.', range: { start: 0, end: 1 / 0, step: 1 } },
     useTabs: { category: 'Global', type: 'boolean', default: !1, description: 'Indent with tabs instead of spaces.' },
     embeddedLanguageFormatting: {
      category: 'Global',
      type: 'choice',
      default: 'auto',
      description: 'Control how Prettier formats quoted code embedded in the file.',
      choices: [
       { value: 'auto', description: 'Format embedded code if Prettier can automatically identify it.' },
       { value: 'off', description: 'Never automatically format embedded code.' },
      ],
     },
    };
   function kt({ plugins: e = [], showDeprecated: t = !1 } = {}) {
    let r = e.flatMap((e) => e.languages ?? []),
     n = [];
    for (let s of (function (e) {
     let t = [];
     for (let [r, n] of Object.entries(e)) {
      let e = { name: r, ...n };
      Array.isArray(e.default) && (e.default = be(!1, e.default, -1).value), t.push(e);
     }
     return t;
    })(Object.assign({}, ...e.map(({ options: e }) => e), Ft)))
     (!t && s.deprecated) ||
      (Array.isArray(s.choices) && (t || (s.choices = s.choices.filter((e) => !e.deprecated)), 'parser' === s.name && (s.choices = [...s.choices, ...Pt(s.choices, r, e)])),
      (s.pluginDefaults = Object.fromEntries(
       e
        .filter((e) => {
         var t;
         return void 0 !== (null == (t = e.defaultOptions) ? void 0 : t[s.name]);
        })
        .map((e) => [e.name, e.defaultOptions[s.name]]),
      )),
      n.push(s));
    return { languages: r, options: n };
   }
   function* Pt(e, t, r) {
    let n = new Set(e.map((e) => e.value));
    for (let s of t)
     if (s.parsers)
      for (let e of s.parsers)
       if (!n.has(e)) {
        n.add(e);
        let t = r.find((t) => t.parsers && Object.prototype.hasOwnProperty.call(t.parsers, e)),
         i = s.name;
        null != t && t.name && (i += ` (plugin: ${t.name})`), yield { value: e, description: i };
       }
   }
   var It = (e) => String(e).split(/[/\\]/).pop();
   function Nt(e, t) {
    if (!t) return;
    let r = It(t).toLowerCase();
    return e.find(({ filenames: e }) => (null == e ? void 0 : e.some((e) => e.toLowerCase() === r))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.some((e) => r.endsWith(e))));
   }
   var Bt = function (e, t) {
     let r = e.plugins.flatMap((e) => e.languages ?? []),
      n =
       (function (e, t) {
        if (t) return e.find(({ name: e }) => e.toLowerCase() === t) ?? e.find(({ aliases: e }) => (null == e ? void 0 : e.includes(t))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.includes(`.${t}`)));
       })(r, t.language) ??
       Nt(r, t.physicalFile) ??
       Nt(r, t.file) ??
       void t.physicalFile;
     return null == n ? void 0 : n.parsers[0];
    },
    _t = {
     key: (e) => (/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e)),
     value(e) {
      if (null === e || 'object' != typeof e) return JSON.stringify(e);
      if (Array.isArray(e)) return `[${e.map((e) => _t.value(e)).join(', ')}]`;
      let t = Object.keys(e);
      return 0 === t.length ? '{}' : `{ ${t.map((t) => `${_t.key(t)}: ${_t.value(e[t])}`).join(', ')} }`;
     },
     pair: ({ key: e, value: t }) => _t.value({ [e]: t }),
    },
    Lt = d(g(), 1),
    Ot = d(g(), 1),
    Mt = Symbol.for('vnopts.VALUE_NOT_EXIST'),
    jt = Symbol.for('vnopts.VALUE_UNCHANGED'),
    Rt = ' '.repeat(2);
   function qt(e, t, r, n) {
    return [`Invalid ${Ot.default.red(n.key(e))} value.`, `Expected ${Ot.default.blue(r)},`, `but received ${t === Mt ? Ot.default.gray('nothing') : Ot.default.red(n.value(t))}.`].join(' ');
   }
   function Ut({ text: e, list: t }, r) {
    let n = [];
    return e && n.push(`- ${Ot.default.blue(e)}`), t && n.push([`- ${Ot.default.blue(t.title)}:`].concat(t.values.map((e) => Ut(e, r - Rt.length).replace(/^|\n/g, `$&${Rt}`))).join('\n')), $t(n, r);
   }
   function $t(e, t) {
    if (1 === e.length) return e[0];
    let [r, n] = e,
     [s, i] = e.map((e) => e.split('\n', 1)[0].length);
    return s > t && s > i ? n : r;
   }
   var Ht = d(g(), 1),
    zt = [],
    Vt = [];
   var Wt = (e, t, { descriptor: r, logger: n, schemas: s }) => {
     let i = [`Ignored unknown option ${Ht.default.yellow(r.pair({ key: e, value: t }))}.`],
      a = Object.keys(s)
       .sort()
       .find(
        (t) =>
         (function (e, t) {
          if (e === t) return 0;
          let r = e;
          e.length > t.length && ((e = t), (t = r));
          let n = e.length,
           s = t.length;
          for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-s); ) n--, s--;
          let i = 0;
          for (; i < n && e.charCodeAt(i) === t.charCodeAt(i); ) i++;
          if (((n -= i), (s -= i), 0 === n)) return s;
          let a,
           o,
           u,
           l,
           p = 0,
           c = 0;
          for (; p < n; ) (Vt[p] = e.charCodeAt(i + p)), (zt[p] = ++p);
          for (; c < s; ) for (a = t.charCodeAt(i + c), u = c++, o = c, p = 0; p < n; p++) (l = a === Vt[p] ? u : u + 1), (u = zt[p]), (o = zt[p] = u > o ? (l > o ? o + 1 : l) : l > u ? u + 1 : l);
          return o;
         })(e, t) < 3,
       );
     a && i.push(`Did you mean ${Ht.default.blue(r.key(a))}?`), n.warn(i.join(' '));
    },
    Jt = ['default', 'expected', 'validate', 'deprecated', 'forward', 'redirect', 'overlap', 'preprocess', 'postprocess'];
   var Kt = class {
    static create(e) {
     return (function (e, t) {
      let r = new e(t),
       n = Object.create(r);
      for (let s of Jt) s in t && (n[s] = Gt(t[s], r, Kt.prototype[s].length));
      return n;
     })(this, e);
    }
    constructor(e) {
     this.name = e.name;
    }
    default(e) {}
    expected(e) {
     return 'nothing';
    }
    validate(e, t) {
     return !1;
    }
    deprecated(e, t) {
     return !1;
    }
    forward(e, t) {}
    redirect(e, t) {}
    overlap(e, t, r) {
     return e;
    }
    preprocess(e, t) {
     return e;
    }
    postprocess(e, t) {
     return jt;
    }
   };
   function Gt(e, t, r) {
    return 'function' == typeof e ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
   }
   var Xt = class extends Kt {
     constructor(e) {
      super(e), (this._sourceName = e.sourceName);
     }
     expected(e) {
      return e.schemas[this._sourceName].expected(e);
     }
     validate(e, t) {
      return t.schemas[this._sourceName].validate(e, t);
     }
     redirect(e, t) {
      return this._sourceName;
     }
    },
    Yt = class extends Kt {
     expected() {
      return 'anything';
     }
     validate() {
      return !0;
     }
    },
    Qt = class extends Kt {
     constructor({ valueSchema: e, name: t = e.name, ...r }) {
      super({ ...r, name: t }), (this._valueSchema = e);
     }
     expected(e) {
      let { text: t, list: r } = e.normalizeExpectedResult(this._valueSchema.expected(e));
      return { text: t && `an array of ${t}`, list: r && { title: 'an array of the following values', values: [{ list: r }] } };
     }
     validate(e, t) {
      if (!Array.isArray(e)) return !1;
      let r = [];
      for (let n of e) {
       let e = t.normalizeValidateResult(this._valueSchema.validate(n, t), n);
       !0 !== e && r.push(e.value);
      }
      return 0 === r.length || { value: r };
     }
     deprecated(e, t) {
      let r = [];
      for (let n of e) {
       let e = t.normalizeDeprecatedResult(this._valueSchema.deprecated(n, t), n);
       !1 !== e && r.push(...e.map(({ value: e }) => ({ value: [e] })));
      }
      return r;
     }
     forward(e, t) {
      let r = [];
      for (let n of e) {
       let e = t.normalizeForwardResult(this._valueSchema.forward(n, t), n);
       r.push(...e.map(Zt));
      }
      return r;
     }
     redirect(e, t) {
      let r = [],
       n = [];
      for (let s of e) {
       let e = t.normalizeRedirectResult(this._valueSchema.redirect(s, t), s);
       'remain' in e && r.push(e.remain), n.push(...e.redirect.map(Zt));
      }
      return 0 === r.length ? { redirect: n } : { redirect: n, remain: r };
     }
     overlap(e, t) {
      return e.concat(t);
     }
    };
   function Zt({ from: e, to: t }) {
    return { from: [e], to: t };
   }
   var er = class extends Kt {
    expected() {
     return 'true or false';
    }
    validate(e) {
     return 'boolean' == typeof e;
    }
   };
   function tr(e, t) {
    let r = Object.create(null);
    for (let n of e) {
     let e = n[t];
     if (r[e]) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
     r[e] = n;
    }
    return r;
   }
   function rr(e, t) {
    if (e === t) return 0;
    let r = typeof e,
     n = typeof t,
     s = ['undefined', 'object', 'boolean', 'number', 'string'];
    return r !== n ? s.indexOf(r) - s.indexOf(n) : 'string' !== r ? Number(e) - Number(t) : e.localeCompare(t);
   }
   function nr(e) {
    return void 0 === e ? {} : e;
   }
   function sr(e) {
    if ('string' == typeof e) return { text: e };
    let { text: t, list: r } = e;
    return (
     (function (e, t) {
      if (!e) throw new Error(t);
     })(void 0 !== (t || r), 'Unexpected `expected` result, there should be at least one field.'),
     r ? { text: t, list: { title: r.title, values: r.values.map(sr) } } : { text: t }
    );
   }
   function ir(e, t) {
    return !0 === e || (!1 === e ? { value: t } : e);
   }
   function ar(e, t, r = !1) {
    return !1 !== e && (!0 === e ? !!r || [{ value: t }] : 'value' in e ? [e] : 0 !== e.length && e);
   }
   function or(e, t) {
    return 'string' == typeof e || 'key' in e ? { from: t, to: e } : 'from' in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
   }
   function ur(e, t) {
    return void 0 === e ? [] : Array.isArray(e) ? e.map((e) => or(e, t)) : [or(e, t)];
   }
   function lr(e, t) {
    let r = ur('object' == typeof e && 'redirect' in e ? e.redirect : e, t);
    return 0 === r.length ? { remain: t, redirect: r } : 'object' == typeof e && 'remain' in e ? { remain: e.remain, redirect: r } : { redirect: r };
   }
   var pr,
    cr = class extends Kt {
     constructor(e) {
      super(e),
       (this._choices = (function (e, t) {
        let r = new Map();
        for (let n of e) {
         let e = n[t];
         if (r.has(e)) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
         r.set(e, n);
        }
        return r;
       })(
        e.choices.map((e) => (e && 'object' == typeof e ? e : { value: e })),
        'value',
       ));
     }
     expected({ descriptor: e }) {
      let t = Array.from(this._choices.keys())
        .map((e) => this._choices.get(e))
        .filter(({ hidden: e }) => !e)
        .map((e) => e.value)
        .sort(rr)
        .map(e.value),
       r = t.slice(0, -2),
       n = t.slice(-2);
      return { text: r.concat(n.join(' or ')).join(', '), list: { title: 'one of the following values', values: t } };
     }
     validate(e) {
      return this._choices.has(e);
     }
     deprecated(e) {
      let t = this._choices.get(e);
      return !(!t || !t.deprecated) && { value: e };
     }
     forward(e) {
      let t = this._choices.get(e);
      return t ? t.forward : void 0;
     }
     redirect(e) {
      let t = this._choices.get(e);
      return t ? t.redirect : void 0;
     }
    },
    hr = class extends Kt {
     expected() {
      return 'a number';
     }
     validate(e, t) {
      return 'number' == typeof e;
     }
    },
    dr = class extends hr {
     expected() {
      return 'an integer';
     }
     validate(e, t) {
      return (
       !0 === t.normalizeValidateResult(super.validate(e, t), e) &&
       (function (e) {
        return e === Math.floor(e);
       })(e)
      );
     }
    },
    fr = class extends Kt {
     expected() {
      return 'a string';
     }
     validate(e) {
      return 'string' == typeof e;
     }
    },
    mr = _t,
    yr = Wt,
    gr = (e, t, r) => {
     let { text: n, list: s } = r.normalizeExpectedResult(r.schemas[e].expected(r)),
      i = [];
     return n && i.push(qt(e, t, n, r.descriptor)), s && i.push([qt(e, t, s.title, r.descriptor)].concat(s.values.map((e) => Ut(e, r.loggerPrintWidth))).join('\n')), $t(i, r.loggerPrintWidth);
    },
    Dr = (e, t, { descriptor: r }) => {
     let n = [`${Lt.default.yellow('string' == typeof e ? r.key(e) : r.pair(e))} is deprecated`];
     return t && n.push(`we now treat it as ${Lt.default.blue('string' == typeof t ? r.key(t) : r.pair(t))}`), n.join('; ') + '.';
    },
    xr = class {
     constructor(e, t) {
      let { logger: r = console, loggerPrintWidth: n = 80, descriptor: s = mr, unknown: i = yr, invalid: a = gr, deprecated: o = Dr, missing: u = () => !1, required: l = () => !1, preprocess: p = (e) => e, postprocess: c = () => jt } = t || {};
      (this._utils = { descriptor: s, logger: r || { warn: () => {} }, loggerPrintWidth: n, schemas: tr(e, 'name'), normalizeDefaultResult: nr, normalizeExpectedResult: sr, normalizeDeprecatedResult: ar, normalizeForwardResult: ur, normalizeRedirectResult: lr, normalizeValidateResult: ir }),
       (this._unknownHandler = i),
       (this._invalidHandler = (function (e) {
        return (...t) => {
         let r = e(...t);
         return 'string' == typeof r ? new Error(r) : r;
        };
       })(a)),
       (this._deprecatedHandler = o),
       (this._identifyMissing = (e, t) => !(e in t) || u(e, t)),
       (this._identifyRequired = l),
       (this._preprocess = p),
       (this._postprocess = c),
       this.cleanHistory();
     }
     cleanHistory() {
      this._hasDeprecationWarned = (function () {
       let e = Object.create(null);
       return (t) => {
        let r = JSON.stringify(t);
        return !!e[r] || ((e[r] = !0), !1);
       };
      })();
     }
     normalize(e) {
      let t = {},
       r = [this._preprocess(e, this._utils)],
       n = () => {
        for (; 0 !== r.length; ) {
         let e = r.shift(),
          n = this._applyNormalization(e, t);
         r.push(...n);
        }
       };
      n();
      for (let s of Object.keys(this._utils.schemas)) {
       let e = this._utils.schemas[s];
       if (!(s in t)) {
        let t = nr(e.default(this._utils));
        'value' in t && r.push({ [s]: t.value });
       }
      }
      n();
      for (let s of Object.keys(this._utils.schemas)) {
       if (!(s in t)) continue;
       let e = this._utils.schemas[s],
        r = t[s],
        n = e.postprocess(r, this._utils);
       n !== jt && (this._applyValidation(n, s, e), (t[s] = n));
      }
      return this._applyPostprocess(t), this._applyRequiredCheck(t), t;
     }
     _applyNormalization(e, t) {
      let r = [],
       { knownKeys: n, unknownKeys: s } = this._partitionOptionKeys(e);
      for (let i of n) {
       let n = this._utils.schemas[i],
        s = n.preprocess(e[i], this._utils);
       this._applyValidation(s, i, n);
       let a = ({ from: e, to: t }) => {
         r.push('string' == typeof t ? { [t]: e } : { [t.key]: t.value });
        },
        o = ({ value: e, redirectTo: t }) => {
         let r = ar(n.deprecated(e, this._utils), s, !0);
         if (!1 !== r)
          if (!0 === r) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, t, this._utils));
          else
           for (let { value: n } of r) {
            let e = { key: i, value: n };
            if (!this._hasDeprecationWarned(e)) {
             let r = 'string' == typeof t ? { key: t, value: n } : t;
             this._utils.logger.warn(this._deprecatedHandler(e, r, this._utils));
            }
           }
        };
       ur(n.forward(s, this._utils), s).forEach(a);
       let u = lr(n.redirect(s, this._utils), s);
       if ((u.redirect.forEach(a), 'remain' in u)) {
        let e = u.remain;
        (t[i] = i in t ? n.overlap(t[i], e, this._utils) : e), o({ value: e });
       }
       for (let { from: e, to: t } of u.redirect) o({ value: e, redirectTo: t });
      }
      for (let i of s) {
       let n = e[i];
       this._applyUnknownHandler(i, n, t, (e, t) => {
        r.push({ [e]: t });
       });
      }
      return r;
     }
     _applyRequiredCheck(e) {
      for (let t of Object.keys(this._utils.schemas)) if (this._identifyMissing(t, e) && this._identifyRequired(t)) throw this._invalidHandler(t, Mt, this._utils);
     }
     _partitionOptionKeys(e) {
      let [t, r] = (function (e, t) {
       let r = [],
        n = [];
       for (let s of e) t(s) ? r.push(s) : n.push(s);
       return [r, n];
      })(
       Object.keys(e).filter((t) => !this._identifyMissing(t, e)),
       (e) => e in this._utils.schemas,
      );
      return { knownKeys: t, unknownKeys: r };
     }
     _applyValidation(e, t, r) {
      let n = ir(r.validate(e, this._utils), e);
      if (!0 !== n) throw this._invalidHandler(t, n.value, this._utils);
     }
     _applyUnknownHandler(e, t, r, n) {
      let s = this._unknownHandler(e, t, this._utils);
      if (s)
       for (let i of Object.keys(s)) {
        if (this._identifyMissing(i, s)) continue;
        let e = s[i];
        i in this._utils.schemas ? n(i, e) : (r[i] = e);
       }
     }
     _applyPostprocess(e) {
      let t = this._postprocess(e, this._utils);
      if (t !== jt) {
       if (t.delete) for (let r of t.delete) delete e[r];
       if (t.override) {
        let { knownKeys: r, unknownKeys: n } = this._partitionOptionKeys(t.override);
        for (let s of r) {
         let r = t.override[s];
         this._applyValidation(r, s, this._utils.schemas[s]), (e[s] = r);
        }
        for (let s of n) {
         let r = t.override[s];
         this._applyUnknownHandler(s, r, e, (t, r) => {
          let n = this._utils.schemas[t];
          this._applyValidation(r, t, n), (e[t] = r);
         });
        }
       }
      }
     }
    };
   function br(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
    let s,
     { name: i } = e,
     a = { name: i },
     o = {};
    switch (e.type) {
     case 'int':
      (s = dr), t && (a.preprocess = Number);
      break;
     case 'string':
     case 'path':
      s = fr;
      break;
     case 'choice':
      (s = cr), (a.choices = e.choices.map((t) => (null != t && t.redirect ? { ...t, redirect: { to: { key: e.name, value: t.redirect } } } : t)));
      break;
     case 'boolean':
      s = er;
      break;
     case 'flag':
      (s = n), (a.flags = r.flatMap((e) => [e.alias, e.description && e.name, e.oppositeDescription && `no-${e.name}`].filter(Boolean)));
      break;
     default:
      throw new Error(`Unexpected type ${e.type}`);
    }
    if ((e.exception ? (a.validate = (t, r, n) => e.exception(t) || r.validate(t, n)) : (a.validate = (e, t, r) => void 0 === e || t.validate(e, r)), e.redirect && (o.redirect = (t) => (t ? { to: 'string' == typeof e.redirect ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0)), e.deprecated && (o.deprecated = !0), t && !e.array)) {
     let e = a.preprocess || ((e) => e);
     a.preprocess = (t, r, n) => r.preprocess(e(Array.isArray(t) ? be(!1, t, -1) : t), n);
    }
    return e.array ? Qt.create({ ...(t ? { preprocess: (e) => (Array.isArray(e) ? e : [e]) } : {}), ...o, valueSchema: s.create(a) }) : s.create({ ...a, ...o });
   }
   var vr = function (e, t, { logger: r = !1, isCLI: n = !1, passThrough: s = !1, FlagSchema: i, descriptor: a } = {}) {
     if (n) {
      if (!i) throw new Error("'FlagSchema' option is required.");
      if (!a) throw new Error("'descriptor' option is required.");
     } else a = _t;
     let o = s
       ? Array.isArray(s)
         ? (e, t) => (s.includes(e) ? { [e]: t } : void 0)
         : (e, t) => ({ [e]: t })
       : (e, t, r) => {
          let { _: n, ...s } = r.schemas;
          return Wt(e, t, { ...r, schemas: s });
         },
      u = (function (e, { isCLI: t, FlagSchema: r }) {
       let n = [];
       t && n.push(Yt.create({ name: '_' }));
       for (let s of e) n.push(br(s, { isCLI: t, optionInfos: e, FlagSchema: r })), s.alias && t && n.push(Xt.create({ name: s.alias, sourceName: s.name }));
       return n;
      })(t, { isCLI: n, FlagSchema: i }),
      l = new xr(u, { logger: r, unknown: o, descriptor: a }),
      p = !1 !== r;
     p && pr && (l._hasDeprecationWarned = pr);
     let c = l.normalize(e);
     return p && (pr = l._hasDeprecationWarned), c;
    },
    Er = (e, t, r) => {
     if (!e || null != t) {
      if (t.findLast) return t.findLast(r);
      for (let e = t.length - 1; e >= 0; e--) {
       let n = t[e];
       if (r(n, e, t)) return n;
      }
     }
    };
   function Cr(e, t) {
    if (!t) throw new Error('parserName is required.');
    let r = Er(!1, e, (e) => e.parsers && Object.prototype.hasOwnProperty.call(e.parsers, t));
    if (r) return r;
    let n = `Couldn't resolve parser "${t}".`;
    throw ((n += ' Plugins must be explicitly added to the standalone bundle.'), new wt(n));
   }
   function Tr({ plugins: e, parser: t }) {
    return Sr(Cr(e, t), t);
   }
   function Sr(e, t) {
    let r = e.parsers[t];
    return 'function' == typeof r ? r() : r;
   }
   var wr = { astFormat: 'estree', printer: {}, originalText: void 0, locStart: null, locEnd: null };
   var Ar = async function (e, t = {}) {
     var r;
     let n = { ...e };
     if (!n.parser) {
      if (!n.filepath) throw new At("No parser and no file path given, couldn't infer a parser.");
      if (((n.parser = Bt(n, { physicalFile: n.filepath })), !n.parser)) throw new At(`No parser could be inferred for file "${n.filepath}".`);
     }
     let s = kt({ plugins: e.plugins, showDeprecated: !0 }).options,
      i = { ...wr, ...Object.fromEntries(s.filter((e) => void 0 !== e.default).map((e) => [e.name, e.default])) },
      a = Cr(n.plugins, n.parser),
      o = await Sr(a, n.parser);
     (n.astFormat = o.astFormat), (n.locEnd = o.locEnd), (n.locStart = o.locStart);
     let u =
       null != (r = a.printers) && r[o.astFormat]
        ? a
        : (function (e, t) {
           if (!t) throw new Error('astFormat is required.');
           let r = Er(!1, e, (e) => e.printers && Object.prototype.hasOwnProperty.call(e.printers, t));
           if (r) return r;
           let n = `Couldn't find plugin for AST format "${t}".`;
           throw ((n += ' Plugins must be explicitly added to the standalone bundle.'), new wt(n));
          })(n.plugins, o.astFormat),
      l = await (function (e, t) {
       let r = e.printers[t];
       return 'function' == typeof r ? r() : r;
      })(u, o.astFormat);
     n.printer = l;
     let p = { ...i, ...(u.defaultOptions ? Object.fromEntries(Object.entries(u.defaultOptions).filter(([, e]) => void 0 !== e)) : {}) };
     for (let [c, h] of Object.entries(p)) (null === n[c] || void 0 === n[c]) && (n[c] = h);
     return 'json' === n.parser && (n.trailingComma = 'none'), vr(n, s, { passThrough: Object.keys(wr), ...t });
    },
    Fr = d(S(), 1);
   var kr = async function (e, t) {
    let r,
     n = await Tr(t),
     s = n.preprocess ? n.preprocess(e, t) : e;
    t.originalText = s;
    try {
     r = await n.parse(s, t, t);
    } catch (i) {
     !(function (e, t) {
      let { loc: r } = e;
      if (r) {
       let n = (0, Fr.codeFrameColumns)(t, r, { highlightCode: !0 });
       throw ((e.message += '\n' + n), (e.codeFrame = n), e);
      }
      throw e;
     })(i, e);
    }
    return { text: s, ast: r };
   };
   async function Pr(e, t, r, n, s) {
    let {
     embeddedLanguageFormatting: i,
     printer: { embed: a, hasPrettierIgnore: o = () => !1, getVisitorKeys: u },
    } = r;
    if (!a || 'auto' !== i) return;
    if (a.length > 2) throw new Error('printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed');
    let l = ut(a.getVisitorKeys ?? u),
     p = [];
    !(function t() {
     let { node: n } = e;
     if (null === n || 'object' != typeof n || o(e)) return;
     for (let r of l(n)) Array.isArray(n[r]) ? e.each(t, r) : e.call(t, r);
     let i = a(e, r);
     if (i) {
      if ('function' == typeof i) return void p.push({ print: i, node: n, pathStack: [...e.stack] });
      s.set(n, i);
     }
    })();
    let c = e.stack;
    for (let { print: f, node: m, pathStack: y } of p)
     try {
      e.stack = y;
      let n = await f(h, t, e, r);
      n && s.set(m, n);
     } catch (d) {
      if (globalThis.PRETTIER_DEBUG) throw d;
     }
    function h(e, t) {
     return (async function (e, t, r, n) {
      let s = await Ar({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: !0 }),
       { ast: i } = await kr(e, s),
       a = await n(i, s);
      return Ie(a);
     })(e, t, r, n);
    }
    e.stack = c;
   }
   var Ir = function (e, t) {
    let { originalText: r, [Symbol.for('comments')]: n, locStart: s, locEnd: i, [Symbol.for('printedComments')]: a } = t,
     { node: o } = e,
     u = s(o),
     l = i(o);
    for (let p of n) s(p) >= u && i(p) <= l && a.add(p);
    return r.slice(u, l);
   };
   async function Nr(e, t) {
    ({ ast: e } = await _r(e, t));
    let r = new Map(),
     n = new Je(e),
     s = St(t),
     i = new Map();
    await Pr(n, o, t, Nr, i);
    let a = await Br(n, t, o, void 0, i);
    return (
     (function (e) {
      let { [Symbol.for('comments')]: t, [Symbol.for('printedComments')]: r } = e;
      for (let n of t) {
       if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
       delete n.printed;
      }
     })(t),
     a
    );
    function o(e, t) {
     return void 0 === e || e === n ? u(t) : Array.isArray(e) ? n.call(() => u(t), ...e) : n.call(() => u(t), e);
    }
    function u(e) {
     s(n);
     let a = n.node;
     if (null == a) return '';
     let u = a && 'object' == typeof a && void 0 === e;
     if (u && r.has(a)) return r.get(a);
     let l = Br(n, t, o, e, i);
     return u && r.set(a, l), l;
    }
   }
   function Br(e, t, r, n, s) {
    var i;
    let a,
     { node: o } = e,
     { printer: u } = t;
    return (
     (a = null != (i = u.hasPrettierIgnore) && i.call(u, e) ? Ir(e, t) : s.has(o) ? s.get(o) : u.print(e, t, r, n)),
     o === t.cursorNode && (a = Be(a, (e) => [ye, e, ye])),
     u.printComment &&
      (!u.willPrintOwnComments || !u.willPrintOwnComments(e, t)) &&
      (a = (function (e, t, r) {
       let { leading: n, trailing: s } = Tt(e, r);
       return n || s ? Be(t, (e) => [n, e, s]) : t;
      })(e, a, t)),
     a
    );
   }
   async function _r(e, t) {
    let r = e.comments ?? [];
    (t[Symbol.for('comments')] = r),
     (t[Symbol.for('tokens')] = e.tokens ?? []),
     (t[Symbol.for('printedComments')] = new Set()),
     (function (e, t) {
      let { comments: r } = e;
      if ((delete e.comments, !it(r) || !t.printer.canAttachComment)) return;
      let n = [],
       {
        locStart: s,
        locEnd: i,
        printer: { experimentalFeatures: { avoidAstMutation: a = !1 } = {}, handleComments: o = {} },
        originalText: u,
       } = t,
       { ownLine: l = yt, endOfLine: p = yt, remaining: c = yt } = o,
       h = r.map((n, s) => ({ ...mt(e, n, t), comment: n, text: u, options: t, ast: e, isLastComment: r.length - 1 === s }));
      for (let [d, f] of h.entries()) {
       let e,
        { comment: t, precedingNode: r, enclosingNode: o, followingNode: u, text: m, options: y, ast: g, isLastComment: D } = f;
       if ('json' === y.parser || 'json5' === y.parser || 'jsonc' === y.parser || '__js_expression' === y.parser || '__ts_expression' === y.parser || '__vue_expression' === y.parser || '__vue_ts_expression' === y.parser) {
        if (s(t) - s(g) <= 0) {
         pt(g, t);
         continue;
        }
        if (i(t) - i(g) >= 0) {
         ht(g, t);
         continue;
        }
       }
       if ((a ? (e = [f]) : ((t.enclosingNode = o), (t.precedingNode = r), (t.followingNode = u), (e = [t, m, y, g, D])), Dt(m, y, h, d))) (t.placement = 'ownLine'), l(...e) || (u ? pt(u, t) : r ? ht(r, t) : ct(o || g, t));
       else if (xt(m, y, h, d)) (t.placement = 'endOfLine'), p(...e) || (r ? ht(r, t) : u ? pt(u, t) : ct(o || g, t));
       else if (((t.placement = 'remaining'), !c(...e)))
        if (r && u) {
         let e = n.length;
         e > 0 && n[e - 1].followingNode !== u && bt(n, y), n.push(f);
        } else r ? ht(r, t) : u ? pt(u, t) : ct(o || g, t);
      }
      if ((bt(n, t), !a)) for (let d of r) delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
     })(e, t);
    let {
     printer: { preprocess: n },
    } = t;
    return { ast: (e = n ? await n(e, t) : e), comments: r };
   }
   var Lr = function (e, t) {
    let { cursorOffset: r, locStart: n, locEnd: s } = t,
     i = ut(t.printer.getVisitorKeys),
     a = (e) => n(e) <= r && s(e) >= r,
     o = e;
    for (let u of (function* (e, t) {
     let r = [e];
     for (let n = 0; n < r.length; n++) {
      let e = r[n];
      for (let n of Ye(e, t)) yield n, r.push(n);
     }
    })(e, { getVisitorKeys: i, filter: a }))
     o = u;
    return o;
   };
   var Or = function (e, t) {
     let {
      printer: { massageAstNode: r, getVisitorKeys: n },
     } = t;
     if (!r) return e;
     let s = ut(n),
      i = r.ignoredProperties ?? new Set();
     return (function e(t, n) {
      if (null === t || 'object' != typeof t) return t;
      if (Array.isArray(t)) return t.map((t) => e(t, n)).filter(Boolean);
      let a = {},
       o = new Set(s(t));
      for (let r in t) !Object.prototype.hasOwnProperty.call(t, r) || i.has(r) || (o.has(r) ? (a[r] = e(t[r], t)) : (a[r] = t[r]));
      let u = r(t, a, n);
      if (null !== u) return u ?? a;
     })(e);
    },
    Mr = ({ parser: e }) => 'json' === e || 'json5' === e || 'jsonc' === e || 'json-stringify' === e;
   function jr(e) {
    let t = e.length - 1;
    for (;;) {
     let r = e[t];
     if ('Program' !== (null == r ? void 0 : r.type) && 'File' !== (null == r ? void 0 : r.type)) break;
     t--;
    }
    return e.slice(0, t + 1);
   }
   function Rr(e, t, r, n, s = [], i) {
    let { locStart: a, locEnd: o } = r,
     u = a(e),
     l = o(e);
    if (!(t > l || t < u || ('rangeEnd' === i && t === u) || ('rangeStart' === i && t === l))) {
     for (let a of ft(e, r)) {
      let o = Rr(a, t, r, n, [e, ...s], i);
      if (o) return o;
     }
     if (!n || n(e, s[0])) return { node: e, parentNodes: s };
    }
   }
   var qr = new Set(['JsonRoot', 'ObjectExpression', 'ArrayExpression', 'StringLiteral', 'NumericLiteral', 'BooleanLiteral', 'NullLiteral', 'UnaryExpression', 'TemplateLiteral']),
    Ur = new Set(['OperationDefinition', 'FragmentDefinition', 'VariableDefinition', 'TypeExtensionDefinition', 'ObjectTypeDefinition', 'FieldDefinition', 'DirectiveDefinition', 'EnumTypeDefinition', 'EnumValueDefinition', 'InputValueDefinition', 'InputObjectTypeDefinition', 'SchemaDefinition', 'OperationTypeDefinition', 'InterfaceTypeDefinition', 'UnionTypeDefinition', 'ScalarTypeDefinition']);
   function $r(e, t, r) {
    if (!t) return !1;
    switch (e.parser) {
     case 'flow':
     case 'babel':
     case 'babel-flow':
     case 'babel-ts':
     case 'typescript':
     case 'acorn':
     case 'espree':
     case 'meriyah':
     case '__babel_estree':
      return (function (e, t) {
       return 'DeclareExportDeclaration' !== t && 'TypeParameterDeclaration' !== e && ('Directive' === e || 'TypeAlias' === e || 'TSExportAssignment' === e || e.startsWith('Declare') || e.startsWith('TSDeclare') || e.endsWith('Statement') || e.endsWith('Declaration'));
      })(t.type, null == r ? void 0 : r.type);
     case 'json':
     case 'json5':
     case 'jsonc':
     case 'json-stringify':
      return qr.has(t.type);
     case 'graphql':
      return Ur.has(t.kind);
     case 'vue':
      return 'root' !== t.tag;
    }
    return !1;
   }
   function Hr(e, t, r) {
    let { rangeStart: n, rangeEnd: s, locStart: i, locEnd: a } = t;
    Ge.ok(s > n);
    let o = e.slice(n, s).search(/\S/),
     u = -1 === o;
    if (!u) for (n += o; s > n && !/\S/.test(e[s - 1]); --s);
    let l,
     p,
     c = Rr(r, n, t, (e, r) => $r(t, e, r), [], 'rangeStart'),
     h = u ? c : Rr(r, s, t, (e) => $r(t, e), [], 'rangeEnd');
    if (!c || !h) return { rangeStart: 0, rangeEnd: 0 };
    if (Mr(t)) {
     let e = (function (e, t) {
      let r = [e.node, ...e.parentNodes],
       n = new Set([t.node, ...t.parentNodes]);
      return r.find((e) => qr.has(e.type) && n.has(e));
     })(c, h);
     (l = e), (p = e);
    } else
     ({ startNode: l, endNode: p } = (function (e, t, { locStart: r, locEnd: n }) {
      let s = e.node,
       i = t.node;
      if (s === i) return { startNode: s, endNode: i };
      let a = r(e.node);
      for (let u of jr(t.parentNodes)) {
       if (!(r(u) >= a)) break;
       i = u;
      }
      let o = n(t.node);
      for (let u of jr(e.parentNodes)) {
       if (!(n(u) <= o)) break;
       if (((s = u), s === i)) break;
      }
      return { startNode: s, endNode: i };
     })(c, h, t));
    return { rangeStart: Math.min(i(l), i(p)), rangeEnd: Math.max(a(l), a(p)) };
   }
   var zr = '\ufeff',
    Vr = Symbol('cursor');
   async function Wr(e, t, r = 0) {
    if (!e || 0 === e.trim().length) return { formatted: '', cursorOffset: -1, comments: [] };
    let { ast: n, text: s } = await kr(e, t);
    t.cursorOffset >= 0 && (t.cursorNode = Lr(n, t));
    let i = await Nr(n, t);
    r > 0 && (i = De([fe, i], r, t.tabWidth));
    let a = $e(i, t);
    if (r > 0) {
     let e = a.formatted.trim();
     void 0 !== a.cursorNodeStart && (a.cursorNodeStart -= a.formatted.indexOf(e)), (a.formatted = e + k(t.endOfLine));
    }
    let o = t[Symbol.for('comments')];
    if (t.cursorOffset >= 0) {
     let e, r, n, i, u;
     if ((t.cursorNode && a.cursorNodeText ? ((e = t.locStart(t.cursorNode)), (r = s.slice(e, t.locEnd(t.cursorNode))), (n = t.cursorOffset - e), (i = a.cursorNodeStart), (u = a.cursorNodeText)) : ((e = 0), (r = s), (n = t.cursorOffset), (i = 0), (u = a.formatted)), r === u)) return { formatted: a.formatted, cursorOffset: i + n, comments: o };
     let l = r.split('');
     l.splice(n, 0, Vr);
     let p = u.split(''),
      c = (0, F.diffArrays)(l, p),
      h = i;
     for (let t of c)
      if (t.removed) {
       if (t.value.includes(Vr)) break;
      } else h += t.count;
     return { formatted: a.formatted, cursorOffset: h, comments: o };
    }
    return { formatted: a.formatted, cursorOffset: -1, comments: o };
   }
   function Jr(e, t, r) {
    return 'number' != typeof t || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
   }
   function Kr(e, t) {
    let { cursorOffset: r, rangeStart: n, rangeEnd: s } = t;
    return (r = Jr(e, r, -1)), (n = Jr(e, n, 0)), (s = Jr(e, s, e.length)), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: s };
   }
   function Gr(e, t) {
    let { cursorOffset: r, rangeStart: n, rangeEnd: s, endOfLine: i } = Kr(e, t),
     a = e.charAt(0) === zr;
    if (
     (a && ((e = e.slice(1)), r--, n--, s--),
     'auto' === i &&
      (i = (function (e) {
       let t = e.indexOf('\r');
       return t >= 0 ? ('\n' === e.charAt(t + 1) ? 'crlf' : 'cr') : 'lf';
      })(e)),
     e.includes('\r'))
    ) {
     let t = (t) => P(e.slice(0, Math.max(t, 0)), '\r\n');
     (r -= t(r)),
      (n -= t(n)),
      (s -= t(s)),
      (e = (function (e) {
       return A(!1, e, /\r\n?/g, '\n');
      })(e));
    }
    return { hasBOM: a, text: e, options: Kr(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: s, endOfLine: i }) };
   }
   async function Xr(e, t) {
    let r = await Tr(t);
    return !r.hasPragma || r.hasPragma(e);
   }
   async function Yr(e, t) {
    let r,
     { hasBOM: n, text: s, options: i } = Gr(e, await Ar(t));
    return (i.rangeStart >= i.rangeEnd && '' !== s) || (i.requirePragma && !(await Xr(s, i)))
     ? { formatted: e, cursorOffset: t.cursorOffset, comments: [] }
     : (i.rangeStart > 0 || i.rangeEnd < s.length
        ? (r = await (async function (e, t) {
           let { ast: r, text: n } = await kr(e, t),
            { rangeStart: s, rangeEnd: i } = Hr(n, t, r),
            a = n.slice(s, i),
            o = Math.min(s, n.lastIndexOf('\n', s) + 1),
            u = n.slice(o, s).match(/^\s*/)[0],
            l = We(u, t.tabWidth),
            p = await Wr(a, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > s && t.cursorOffset <= i ? t.cursorOffset - s : -1, endOfLine: 'lf' }, l),
            c = p.formatted.trimEnd(),
            { cursorOffset: h } = t;
           h > i ? (h += c.length - a.length) : p.cursorOffset >= 0 && (h = p.cursorOffset + s);
           let d = n.slice(0, s) + c + n.slice(i);
           if ('lf' !== t.endOfLine) {
            let e = k(t.endOfLine);
            h >= 0 && '\r\n' === e && (h += P(d.slice(0, h), '\n')), (d = A(!1, d, '\n', e));
           }
           return { formatted: d, cursorOffset: h, comments: p.comments };
          })(s, i))
        : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !(await Xr(s, i)) && (s = i.printer.insertPragma(s)), (r = await Wr(s, i))),
       n && ((r.formatted = zr + r.formatted), r.cursorOffset >= 0 && r.cursorOffset++),
       r);
   }
   var Qr = {};
   c(Qr, { builders: () => Zr, printer: () => en, utils: () => tn });
   var Zr = {
     join: ge,
     line: he,
     softline: de,
     hardline: fe,
     literalline: me,
     group: se,
     conditionalGroup: function (e, t) {
      return se(e[0], { ...t, expandedStates: e });
     },
     fill: ie,
     lineSuffix: ae,
     lineSuffixBoundary: oe,
     cursor: ye,
     breakParent: ue,
     ifBreak: function (e, t = '', r = {}) {
      return ee(e), '' !== t && ee(t), { type: R, breakContents: e, flatContents: t, groupId: r.groupId };
     },
     trim: le,
     indent: re,
     indentIfBreak: function (e, t) {
      return ee(e), { type: q, contents: e, groupId: t.groupId, negate: t.negate };
     },
     align: ne,
     addAlignmentToDoc: De,
     markAsRoot: function (e) {
      return ne({ type: 'root' }, e);
     },
     dedentToRoot: function (e) {
      return ne(Number.NEGATIVE_INFINITY, e);
     },
     dedent: function (e) {
      return ne(-1, e);
     },
     hardlineWithoutBreakParent: pe,
     literallineWithoutBreakParent: ce,
     label: function (e, t) {
      return ee(t), e ? { type: z, label: e, contents: t } : t;
     },
     concat: (e) => e,
    },
    en = { printDocToString: $e },
    tn = {
     willBreak: function (e) {
      return Se(e, we, !1);
     },
     traverseDoc: Q,
     findInDoc: Se,
     mapDoc: Te,
     removeLines: function (e) {
      return Te(e, Fe);
     },
     stripTrailingHardline: Ie,
     replaceEndOfLine: function (e, t = me) {
      return Te(e, (e) => ('string' == typeof e ? ge(t, e.split('\n')) : e));
     },
     canBreak: function (e) {
      return Se(e, Ne, !1);
     },
    },
    rn = '3.3.2',
    nn = {};
   c(nn, { addDanglingComment: () => ct, addLeadingComment: () => pt, addTrailingComment: () => ht, getAlignmentSize: () => We, getIndentSize: () => ln, getMaxContinuousCount: () => pn, getNextNonSpaceNonCommentCharacter: () => cn, getNextNonSpaceNonCommentCharacterIndex: () => mn, getStringWidth: () => Ce, hasNewline: () => st, hasNewlineInRange: () => hn, hasSpaces: () => dn, isNextLineEmpty: () => gn, isNextLineEmptyAfterIndex: () => un, isPreviousLineEmpty: () => yn, makeString: () => fn, skip: () => Qe, skipEverythingButNewLine: () => rt, skipInlineComment: () => sn, skipNewline: () => nt, skipSpaces: () => et, skipToLineEnd: () => tt, skipTrailingComment: () => an, skipWhitespace: () => Ze });
   var sn = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var an = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? rt(e, t) : t);
   };
   var on = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = et(e, n)), (n = sn(e, n)), (n = an(e, n)), (n = nt(e, n));
    return n;
   };
   var un = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = tt(e, n)), (n = sn(e, n)), (n = et(e, n));
    return (n = an(e, n)), (n = nt(e, n)), !1 !== n && st(e, n);
   };
   var ln = function (e, t) {
    let r = e.lastIndexOf('\n');
    return -1 === r ? 0 : We(e.slice(r + 1).match(/^[\t ]*/)[0], t);
   };
   var pn = function (e, t) {
    let r = e.match(
     new RegExp(
      `(${(function (e) {
       if ('string' != typeof e) throw new TypeError('Expected a string');
       return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
      })(t)})+`,
      'g',
     ),
    );
    return null === r ? 0 : r.reduce((e, r) => Math.max(e, r.length / t.length), 0);
   };
   var cn = function (e, t) {
    let r = on(e, t);
    return !1 === r ? '' : e.charAt(r);
   };
   var hn = function (e, t, r) {
    for (let n = t; n < r; ++n) if ('\n' === e.charAt(n)) return !0;
    return !1;
   };
   var dn = function (e, t, r = {}) {
    return et(e, r.backwards ? t - 1 : t, r) !== t;
   };
   var fn = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = A(!1, e, /\\(.)|(["'])/gs, (e, s, i) => (s === n ? s : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s) ? s : '\\' + s)));
    return t + s + t;
   };
   function mn(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? on(e, t)
     : (function (e, t, r) {
        return on(e, r(t));
       })(...arguments);
   }
   function yn(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? Et(e, t)
     : (function (e, t, r) {
        return Et(e, r(t));
       })(...arguments);
   }
   function gn(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? un(e, t)
     : (function (e, t, r) {
        return un(e, r(t));
       })(...arguments);
   }
   function Dn(e, t = 1) {
    return async (...r) => {
     let n = r[t] ?? {},
      s = n.plugins ?? [];
     return (r[t] = { ...n, plugins: Array.isArray(s) ? s : Object.values(s) }), e(...r);
    };
   }
   var xn = Dn(Yr);
   async function bn(e, t) {
    let { formatted: r } = await xn(e, { ...t, cursorOffset: -1 });
    return r;
   }
   async function vn(e, t) {
    return (await bn(e, t)) === e;
   }
   var En = Dn(kt, 0),
    Cn = {
     parse: Dn(async function (e, t, r) {
      let { text: n, options: s } = Gr(e, await Ar(t)),
       i = await kr(n, s);
      return r && (r.preprocessForPrint && (i.ast = await _r(i.ast, s)), r.massage && (i.ast = Or(i.ast, s))), i;
     }),
     formatAST: Dn(async function (e, t) {
      return (t = await Ar(t)), $e(await Nr(e, t), t);
     }),
     formatDoc: Dn(async function (e, t) {
      let r = (function (e) {
        let t = Object.create(null),
         r = new Set();
        return (function e(t, r, s) {
         var i, a;
         if ('string' == typeof t) return JSON.stringify(t);
         if (Array.isArray(t)) {
          let r = t.map(e).filter(Boolean);
          return 1 === r.length ? r[0] : `[${r.join(', ')}]`;
         }
         if (t.type === H) {
          let e = (null == (i = null == s ? void 0 : s[r + 1]) ? void 0 : i.type) === V;
          return t.literal ? (e ? 'literalline' : 'literallineWithoutBreakParent') : t.hard ? (e ? 'hardline' : 'hardlineWithoutBreakParent') : t.soft ? 'softline' : 'line';
         }
         if (t.type === V) return (null == (a = null == s ? void 0 : s[r - 1]) ? void 0 : a.type) === H && s[r - 1].hard ? void 0 : 'breakParent';
         if (t.type === O) return 'trim';
         if (t.type === _) return 'indent(' + e(t.contents) + ')';
         if (t.type === L) return t.n === Number.NEGATIVE_INFINITY ? 'dedentToRoot(' + e(t.contents) + ')' : t.n < 0 ? 'dedent(' + e(t.contents) + ')' : 'root' === t.n.type ? 'markAsRoot(' + e(t.contents) + ')' : 'align(' + JSON.stringify(t.n) + ', ' + e(t.contents) + ')';
         if (t.type === R) return 'ifBreak(' + e(t.breakContents) + (t.flatContents ? ', ' + e(t.flatContents) : '') + (t.groupId ? (t.flatContents ? '' : ', ""') + `, { groupId: ${n(t.groupId)} }` : '') + ')';
         if (t.type === q) {
          let r = [];
          t.negate && r.push('negate: true'), t.groupId && r.push(`groupId: ${n(t.groupId)}`);
          let s = r.length > 0 ? `, { ${r.join(', ')} }` : '';
          return `indentIfBreak(${e(t.contents)}${s})`;
         }
         if (t.type === M) {
          let r = [];
          t.break && 'propagated' !== t.break && r.push('shouldBreak: true'), t.id && r.push(`id: ${n(t.id)}`);
          let s = r.length > 0 ? `, { ${r.join(', ')} }` : '';
          return t.expandedStates ? `conditionalGroup([${t.expandedStates.map((t) => e(t)).join(',')}]${s})` : `group(${e(t.contents)}${s})`;
         }
         if (t.type === j) return `fill([${t.parts.map((t) => e(t)).join(', ')}])`;
         if (t.type === U) return 'lineSuffix(' + e(t.contents) + ')';
         if (t.type === $) return 'lineSuffixBoundary';
         if (t.type === z) return `label(${JSON.stringify(t.label)}, ${e(t.contents)})`;
         throw new Error('Unknown doc type ' + t.type);
        })(xe(e));
        function n(e) {
         if ('symbol' != typeof e) return JSON.stringify(String(e));
         if (e in t) return t[e];
         let n = e.description || 'symbol';
         for (let s = 0; ; s++) {
          let i = n + (s > 0 ? ` #${s}` : '');
          if (!r.has(i)) return r.add(i), (t[e] = `Symbol.for(${JSON.stringify(i)})`);
         }
        }
       })(e),
       { formatted: n } = await Yr(r, { ...t, parser: '__js_expression' });
      return n;
     }),
     printToDoc: Dn(async function (e, t) {
      t = await Ar(t);
      let { ast: r } = await kr(e, t);
      return Nr(r, t);
     }),
     printDocToString: Dn(async function (e, t) {
      return $e(e, await Ar(t));
     }),
    },
    Tn = w;
  },
 },
]);
