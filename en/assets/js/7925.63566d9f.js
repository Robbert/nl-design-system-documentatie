/*! For license information please see 7925.63566d9f.js.LICENSE.txt */
"use strict";
(self.webpackChunk_nl_design_system_website = self.webpackChunk_nl_design_system_website || []).push([
 [7925],
 {
  91406: (e, t, r) => {
   r.d(t, { Z: () => n });
   var n = (0, r(68199).Z)("mood-happy", "IconMoodHappy", [
    ["path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0", key: "svg-0" }],
    ["path", { d: "M9 9l.01 0", key: "svg-1" }],
    ["path", { d: "M15 9l.01 0", key: "svg-2" }],
    ["path", { d: "M8 13a4 4 0 1 0 8 0h-8", key: "svg-3" }],
   ]);
  },
  9842: (e, t, r) => {
   r.d(t, { Z: () => n });
   var n = (0, r(68199).Z)("mood-sad", "IconMoodSad", [
    ["path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0", key: "svg-0" }],
    ["path", { d: "M9 10l.01 0", key: "svg-1" }],
    ["path", { d: "M15 10l.01 0", key: "svg-2" }],
    ["path", { d: "M9.5 15.25a3.5 3.5 0 0 1 5 0", key: "svg-3" }],
   ]);
  },
  5041: (e, t, r) => {
   var n = r(50959);
   function s(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++) t += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
   }
   var i = Object.prototype.hasOwnProperty,
    a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    o = {},
    u = {};
   function l(e) {
    return !!i.call(u, e) || (!i.call(o, e) && (a.test(e) ? (u[e] = !0) : ((o[e] = !0), !1)));
   }
   function p(e, t, r, n, s, i, a) {
    (this.acceptsBooleans = 2 === t || 3 === t || 4 === t), (this.attributeName = n), (this.attributeNamespace = s), (this.mustUseProperty = r), (this.propertyName = e), (this.type = t), (this.sanitizeURL = i), (this.removeEmptyString = a);
   }
   var c = {};
   "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) {
    c[e] = new p(e, 0, !1, e, null, !1, !1);
   }),
    [
     ["acceptCharset", "accept-charset"],
     ["className", "class"],
     ["htmlFor", "for"],
     ["httpEquiv", "http-equiv"],
    ].forEach(function (e) {
     var t = e[0];
     c[t] = new p(t, 1, !1, e[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
     c[e] = new p(e, 2, !1, e.toLowerCase(), null, !1, !1);
    }),
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) {
     c[e] = new p(e, 2, !1, e, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) {
     c[e] = new p(e, 3, !1, e.toLowerCase(), null, !1, !1);
    }),
    ["checked", "multiple", "muted", "selected"].forEach(function (e) {
     c[e] = new p(e, 3, !0, e, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (e) {
     c[e] = new p(e, 4, !1, e, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (e) {
     c[e] = new p(e, 6, !1, e, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (e) {
     c[e] = new p(e, 5, !1, e.toLowerCase(), null, !1, !1);
    });
   var h = /[\-:]([a-z])/g;
   function d(e) {
    return e[1].toUpperCase();
   }
   "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) {
    var t = e.replace(h, d);
    c[t] = new p(t, 1, !1, e, null, !1, !1);
   }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) {
     var t = e.replace(h, d);
     c[t] = new p(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
    }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
     var t = e.replace(h, d);
     c[t] = new p(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }),
    ["tabIndex", "crossOrigin"].forEach(function (e) {
     c[e] = new p(e, 1, !1, e.toLowerCase(), null, !1, !1);
    }),
    (c.xlinkHref = new p("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1)),
    ["src", "href", "action", "formAction"].forEach(function (e) {
     c[e] = new p(e, 1, !1, e.toLowerCase(), null, !0, !0);
    });
   var f = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    m = ["Webkit", "ms", "Moz", "O"];
   Object.keys(f).forEach(function (e) {
    m.forEach(function (t) {
     (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (f[t] = f[e]);
    });
   });
   var y = /["'&<>]/;
   function g(e) {
    if ("boolean" == typeof e || "number" == typeof e) return "" + e;
    e = "" + e;
    var t = y.exec(e);
    if (t) {
     var r,
      n = "",
      s = 0;
     for (r = t.index; r < e.length; r++) {
      switch (e.charCodeAt(r)) {
       case 34:
        t = "&quot;";
        break;
       case 38:
        t = "&amp;";
        break;
       case 39:
        t = "&#x27;";
        break;
       case 60:
        t = "&lt;";
        break;
       case 62:
        t = "&gt;";
        break;
       default:
        continue;
      }
      s !== r && (n += e.substring(s, r)), (s = r + 1), (n += t);
     }
     e = s !== r ? n + e.substring(s, r) : n;
    }
    return e;
   }
   var D = /([A-Z])/g,
    x = /^ms-/,
    b = Array.isArray;
   function v(e, t) {
    return { insertionMode: e, selectedValue: t };
   }
   var E = new Map();
   function C(e, t, r) {
    if ("object" != typeof r) throw Error(s(62));
    for (var n in ((t = !0), r))
     if (i.call(r, n)) {
      var a = r[n];
      if (null != a && "boolean" != typeof a && "" !== a) {
       if (0 === n.indexOf("--")) {
        var o = g(n);
        a = g(("" + a).trim());
       } else {
        o = n;
        var u = E.get(o);
        void 0 !== u || ((u = g(o.replace(D, "-$1").toLowerCase().replace(x, "-ms-"))), E.set(o, u)), (o = u), (a = "number" == typeof a ? (0 === a || i.call(f, n) ? "" + a : a + "px") : g(("" + a).trim()));
       }
       t ? ((t = !1), e.push(' style="', o, ":", a)) : e.push(";", o, ":", a);
      }
     }
    t || e.push('"');
   }
   function T(e, t, r, n) {
    switch (r) {
     case "style":
      return void C(e, t, n);
     case "defaultValue":
     case "defaultChecked":
     case "innerHTML":
     case "suppressContentEditableWarning":
     case "suppressHydrationWarning":
      return;
    }
    if (!(2 < r.length) || ("o" !== r[0] && "O" !== r[0]) || ("n" !== r[1] && "N" !== r[1]))
     if (null !== (t = c.hasOwnProperty(r) ? c[r] : null)) {
      switch (typeof n) {
       case "function":
       case "symbol":
        return;
       case "boolean":
        if (!t.acceptsBooleans) return;
      }
      switch (((r = t.attributeName), t.type)) {
       case 3:
        n && e.push(" ", r, '=""');
        break;
       case 4:
        !0 === n ? e.push(" ", r, '=""') : !1 !== n && e.push(" ", r, '="', g(n), '"');
        break;
       case 5:
        isNaN(n) || e.push(" ", r, '="', g(n), '"');
        break;
       case 6:
        !isNaN(n) && 1 <= n && e.push(" ", r, '="', g(n), '"');
        break;
       default:
        t.sanitizeURL && (n = "" + n), e.push(" ", r, '="', g(n), '"');
      }
     } else if (l(r)) {
      switch (typeof n) {
       case "function":
       case "symbol":
        return;
       case "boolean":
        if ("data-" !== (t = r.toLowerCase().slice(0, 5)) && "aria-" !== t) return;
      }
      e.push(" ", r, '="', g(n), '"');
     }
   }
   function w(e, t, r) {
    if (null != t) {
     if (null != r) throw Error(s(60));
     if ("object" != typeof t || !("__html" in t)) throw Error(s(61));
     null != (t = t.__html) && e.push("" + t);
    }
   }
   function S(e, t, r, n) {
    e.push(k(r));
    var s,
     a = (r = null);
    for (s in t)
     if (i.call(t, s)) {
      var o = t[s];
      if (null != o)
       switch (s) {
        case "children":
         r = o;
         break;
        case "dangerouslySetInnerHTML":
         a = o;
         break;
        default:
         T(e, n, s, o);
       }
     }
    return e.push(">"), w(e, a, r), "string" == typeof r ? (e.push(g(r)), null) : r;
   }
   var A = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    F = new Map();
   function k(e) {
    var t = F.get(e);
    if (void 0 === t) {
     if (!A.test(e)) throw Error(s(65, e));
     (t = "<" + e), F.set(e, t);
    }
    return t;
   }
   function P(e, t, r, a, o) {
    switch (t) {
     case "select":
      e.push(k("select"));
      var u = null,
       p = null;
      for (f in r)
       if (i.call(r, f)) {
        var c = r[f];
        if (null != c)
         switch (f) {
          case "children":
           u = c;
           break;
          case "dangerouslySetInnerHTML":
           p = c;
           break;
          case "defaultValue":
          case "value":
           break;
          default:
           T(e, a, f, c);
         }
       }
      return e.push(">"), w(e, p, u), u;
     case "option":
      (p = o.selectedValue), e.push(k("option"));
      var h = (c = null),
       d = null,
       f = null;
      for (u in r)
       if (i.call(r, u)) {
        var m = r[u];
        if (null != m)
         switch (u) {
          case "children":
           c = m;
           break;
          case "selected":
           d = m;
           break;
          case "dangerouslySetInnerHTML":
           f = m;
           break;
          case "value":
           h = m;
          default:
           T(e, a, u, m);
         }
       }
      if (null != p)
       if (
        ((r =
         null !== h
          ? "" + h
          : (function (e) {
             var t = "";
             return (
              n.Children.forEach(e, function (e) {
               null != e && (t += e);
              }),
              t
             );
            })(c)),
        b(p))
       ) {
        for (a = 0; a < p.length; a++)
         if ("" + p[a] === r) {
          e.push(' selected=""');
          break;
         }
       } else "" + p === r && e.push(' selected=""');
      else d && e.push(' selected=""');
      return e.push(">"), w(e, f, c), c;
     case "textarea":
      for (c in (e.push(k("textarea")), (f = p = u = null), r))
       if (i.call(r, c) && null != (h = r[c]))
        switch (c) {
         case "children":
          f = h;
          break;
         case "value":
          u = h;
          break;
         case "defaultValue":
          p = h;
          break;
         case "dangerouslySetInnerHTML":
          throw Error(s(91));
         default:
          T(e, a, c, h);
        }
      if ((null === u && null !== p && (u = p), e.push(">"), null != f)) {
       if (null != u) throw Error(s(92));
       if (b(f) && 1 < f.length) throw Error(s(93));
       u = "" + f;
      }
      return "string" == typeof u && "\n" === u[0] && e.push("\n"), null !== u && e.push(g("" + u)), null;
     case "input":
      for (p in (e.push(k("input")), (h = f = c = u = null), r))
       if (i.call(r, p) && null != (d = r[p]))
        switch (p) {
         case "children":
         case "dangerouslySetInnerHTML":
          throw Error(s(399, "input"));
         case "defaultChecked":
          h = d;
          break;
         case "defaultValue":
          c = d;
          break;
         case "checked":
          f = d;
          break;
         case "value":
          u = d;
          break;
         default:
          T(e, a, p, d);
        }
      return null !== f ? T(e, a, "checked", f) : null !== h && T(e, a, "checked", h), null !== u ? T(e, a, "value", u) : null !== c && T(e, a, "value", c), e.push("/>"), null;
     case "menuitem":
      for (var y in (e.push(k("menuitem")), r))
       if (i.call(r, y) && null != (u = r[y]))
        switch (y) {
         case "children":
         case "dangerouslySetInnerHTML":
          throw Error(s(400));
         default:
          T(e, a, y, u);
        }
      return e.push(">"), null;
     case "title":
      for (m in (e.push(k("title")), (u = null), r))
       if (i.call(r, m) && null != (p = r[m]))
        switch (m) {
         case "children":
          u = p;
          break;
         case "dangerouslySetInnerHTML":
          throw Error(s(434));
         default:
          T(e, a, m, p);
        }
      return e.push(">"), u;
     case "listing":
     case "pre":
      for (h in (e.push(k(t)), (p = u = null), r))
       if (i.call(r, h) && null != (c = r[h]))
        switch (h) {
         case "children":
          u = c;
          break;
         case "dangerouslySetInnerHTML":
          p = c;
          break;
         default:
          T(e, a, h, c);
        }
      if ((e.push(">"), null != p)) {
       if (null != u) throw Error(s(60));
       if ("object" != typeof p || !("__html" in p)) throw Error(s(61));
       null != (r = p.__html) && ("string" == typeof r && 0 < r.length && "\n" === r[0] ? e.push("\n", r) : e.push("" + r));
      }
      return "string" == typeof u && "\n" === u[0] && e.push("\n"), u;
     case "area":
     case "base":
     case "br":
     case "col":
     case "embed":
     case "hr":
     case "img":
     case "keygen":
     case "link":
     case "meta":
     case "param":
     case "source":
     case "track":
     case "wbr":
      for (var D in (e.push(k(t)), r))
       if (i.call(r, D) && null != (u = r[D]))
        switch (D) {
         case "children":
         case "dangerouslySetInnerHTML":
          throw Error(s(399, t));
         default:
          T(e, a, D, u);
        }
      return e.push("/>"), null;
     case "annotation-xml":
     case "color-profile":
     case "font-face":
     case "font-face-src":
     case "font-face-uri":
     case "font-face-format":
     case "font-face-name":
     case "missing-glyph":
      return S(e, r, t, a);
     case "html":
      return 0 === o.insertionMode && e.push("<!DOCTYPE html>"), S(e, r, t, a);
     default:
      if (-1 === t.indexOf("-") && "string" != typeof r.is) return S(e, r, t, a);
      for (d in (e.push(k(t)), (p = u = null), r))
       if (i.call(r, d) && null != (c = r[d]))
        switch (d) {
         case "children":
          u = c;
          break;
         case "dangerouslySetInnerHTML":
          p = c;
          break;
         case "style":
          C(e, a, c);
          break;
         case "suppressContentEditableWarning":
         case "suppressHydrationWarning":
          break;
         default:
          l(d) && "function" != typeof c && "symbol" != typeof c && e.push(" ", d, '="', g(c), '"');
        }
      return e.push(">"), w(e, p, u), u;
    }
   }
   function I(e, t, r) {
    if ((e.push('\x3c!--$?--\x3e<template id="'), null === r)) throw Error(s(395));
    return e.push(r), e.push('"></template>');
   }
   var N = /[<\u2028\u2029]/g;
   function B(e) {
    return JSON.stringify(e).replace(N, function (e) {
     switch (e) {
      case "<":
       return "\\u003c";
      case "\u2028":
       return "\\u2028";
      case "\u2029":
       return "\\u2029";
      default:
       throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
     }
    });
   }
   function _(e, t, r, n) {
    return r.generateStaticMarkup ? (e.push(g(t)), !1) : ("" === t ? (e = n) : (n && e.push("\x3c!-- --\x3e"), e.push(g(t)), (e = !0)), e);
   }
   var L = Object.assign,
    O = Symbol.for("react.element"),
    M = Symbol.for("react.portal"),
    j = Symbol.for("react.fragment"),
    R = Symbol.for("react.strict_mode"),
    q = Symbol.for("react.profiler"),
    U = Symbol.for("react.provider"),
    $ = Symbol.for("react.context"),
    V = Symbol.for("react.forward_ref"),
    z = Symbol.for("react.suspense"),
    W = Symbol.for("react.suspense_list"),
    H = Symbol.for("react.memo"),
    J = Symbol.for("react.lazy"),
    K = Symbol.for("react.scope"),
    G = Symbol.for("react.debug_trace_mode"),
    X = Symbol.for("react.legacy_hidden"),
    Y = Symbol.for("react.default_value"),
    Q = Symbol.iterator;
   function Z(e) {
    if (null == e) return null;
    if ("function" == typeof e) return e.displayName || e.name || null;
    if ("string" == typeof e) return e;
    switch (e) {
     case j:
      return "Fragment";
     case M:
      return "Portal";
     case q:
      return "Profiler";
     case R:
      return "StrictMode";
     case z:
      return "Suspense";
     case W:
      return "SuspenseList";
    }
    if ("object" == typeof e)
     switch (e.$$typeof) {
      case $:
       return (e.displayName || "Context") + ".Consumer";
      case U:
       return (e._context.displayName || "Context") + ".Provider";
      case V:
       var t = e.render;
       return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
      case H:
       return null !== (t = e.displayName || null) ? t : Z(e.type) || "Memo";
      case J:
       (t = e._payload), (e = e._init);
       try {
        return Z(e(t));
       } catch (r) {}
     }
    return null;
   }
   var ee = {};
   function te(e, t) {
    if (!(e = e.contextTypes)) return ee;
    var r,
     n = {};
    for (r in e) n[r] = t[r];
    return n;
   }
   var re = null;
   function ne(e, t) {
    if (e !== t) {
     (e.context._currentValue2 = e.parentValue), (e = e.parent);
     var r = t.parent;
     if (null === e) {
      if (null !== r) throw Error(s(401));
     } else {
      if (null === r) throw Error(s(401));
      ne(e, r);
     }
     t.context._currentValue2 = t.value;
    }
   }
   function se(e) {
    (e.context._currentValue2 = e.parentValue), null !== (e = e.parent) && se(e);
   }
   function ie(e) {
    var t = e.parent;
    null !== t && ie(t), (e.context._currentValue2 = e.value);
   }
   function ae(e, t) {
    if (((e.context._currentValue2 = e.parentValue), null === (e = e.parent))) throw Error(s(402));
    e.depth === t.depth ? ne(e, t) : ae(e, t);
   }
   function oe(e, t) {
    var r = t.parent;
    if (null === r) throw Error(s(402));
    e.depth === r.depth ? ne(e, r) : oe(e, r), (t.context._currentValue2 = t.value);
   }
   function ue(e) {
    var t = re;
    t !== e && (null === t ? ie(e) : null === e ? se(t) : t.depth === e.depth ? ne(t, e) : t.depth > e.depth ? ae(t, e) : oe(t, e), (re = e));
   }
   var le = {
    isMounted: function () {
     return !1;
    },
    enqueueSetState: function (e, t) {
     null !== (e = e._reactInternals).queue && e.queue.push(t);
    },
    enqueueReplaceState: function (e, t) {
     ((e = e._reactInternals).replace = !0), (e.queue = [t]);
    },
    enqueueForceUpdate: function () {},
   };
   function pe(e, t, r, n) {
    var s = void 0 !== e.state ? e.state : null;
    (e.updater = le), (e.props = r), (e.state = s);
    var i = { queue: [], replace: !1 };
    e._reactInternals = i;
    var a = t.contextType;
    if (((e.context = "object" == typeof a && null !== a ? a._currentValue2 : n), "function" == typeof (a = t.getDerivedStateFromProps) && ((s = null == (a = a(r, s)) ? s : L({}, s, a)), (e.state = s)), "function" != typeof t.getDerivedStateFromProps && "function" != typeof e.getSnapshotBeforeUpdate && ("function" == typeof e.UNSAFE_componentWillMount || "function" == typeof e.componentWillMount)))
     if (((t = e.state), "function" == typeof e.componentWillMount && e.componentWillMount(), "function" == typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), t !== e.state && le.enqueueReplaceState(e, e.state, null), null !== i.queue && 0 < i.queue.length))
      if (((t = i.queue), (a = i.replace), (i.queue = null), (i.replace = !1), a && 1 === t.length)) e.state = t[0];
      else {
       for (i = a ? t[0] : e.state, s = !0, a = a ? 1 : 0; a < t.length; a++) {
        var o = t[a];
        null != (o = "function" == typeof o ? o.call(e, i, r, n) : o) && (s ? ((s = !1), (i = L({}, i, o))) : L(i, o));
       }
       e.state = i;
      }
     else i.queue = null;
   }
   var ce = { id: 1, overflow: "" };
   function he(e, t, r) {
    var n = e.id;
    e = e.overflow;
    var s = 32 - de(n) - 1;
    (n &= ~(1 << s)), (r += 1);
    var i = 32 - de(t) + s;
    if (30 < i) {
     var a = s - (s % 5);
     return (i = (n & ((1 << a) - 1)).toString(32)), (n >>= a), (s -= a), { id: (1 << (32 - de(t) + s)) | (r << s) | n, overflow: i + e };
    }
    return { id: (1 << i) | (r << s) | n, overflow: e };
   }
   var de = Math.clz32
     ? Math.clz32
     : function (e) {
        return 0 === (e >>>= 0) ? 32 : (31 - ((fe(e) / me) | 0)) | 0;
       },
    fe = Math.log,
    me = Math.LN2;
   var ye =
     "function" == typeof Object.is
      ? Object.is
      : function (e, t) {
         return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
        },
    ge = null,
    De = null,
    xe = null,
    be = null,
    ve = !1,
    Ee = !1,
    Ce = 0,
    Te = null,
    we = 0;
   function Se() {
    if (null === ge) throw Error(s(321));
    return ge;
   }
   function Ae() {
    if (0 < we) throw Error(s(312));
    return { memoizedState: null, queue: null, next: null };
   }
   function Fe() {
    return null === be ? (null === xe ? ((ve = !1), (xe = be = Ae())) : ((ve = !0), (be = xe))) : null === be.next ? ((ve = !1), (be = be.next = Ae())) : ((ve = !0), (be = be.next)), be;
   }
   function ke() {
    (De = ge = null), (Ee = !1), (xe = null), (we = 0), (be = Te = null);
   }
   function Pe(e, t) {
    return "function" == typeof t ? t(e) : t;
   }
   function Ie(e, t, r) {
    if (((ge = Se()), (be = Fe()), ve)) {
     var n = be.queue;
     if (((t = n.dispatch), null !== Te && void 0 !== (r = Te.get(n)))) {
      Te.delete(n), (n = be.memoizedState);
      do {
       (n = e(n, r.action)), (r = r.next);
      } while (null !== r);
      return (be.memoizedState = n), [n, t];
     }
     return [be.memoizedState, t];
    }
    return (e = e === Pe ? ("function" == typeof t ? t() : t) : void 0 !== r ? r(t) : t), (be.memoizedState = e), (e = (e = be.queue = { last: null, dispatch: null }).dispatch = Be.bind(null, ge, e)), [be.memoizedState, e];
   }
   function Ne(e, t) {
    if (((ge = Se()), (t = void 0 === t ? null : t), null !== (be = Fe()))) {
     var r = be.memoizedState;
     if (null !== r && null !== t) {
      var n = r[1];
      e: if (null === n) n = !1;
      else {
       for (var s = 0; s < n.length && s < t.length; s++)
        if (!ye(t[s], n[s])) {
         n = !1;
         break e;
        }
       n = !0;
      }
      if (n) return r[0];
     }
    }
    return (e = e()), (be.memoizedState = [e, t]), e;
   }
   function Be(e, t, r) {
    if (25 <= we) throw Error(s(301));
    if (e === ge)
     if (((Ee = !0), (e = { action: r, next: null }), null === Te && (Te = new Map()), void 0 === (r = Te.get(t)))) Te.set(t, e);
     else {
      for (t = r; null !== t.next; ) t = t.next;
      t.next = e;
     }
   }
   function _e() {
    throw Error(s(394));
   }
   function Le() {}
   var Oe = {
     readContext: function (e) {
      return e._currentValue2;
     },
     useContext: function (e) {
      return Se(), e._currentValue2;
     },
     useMemo: Ne,
     useReducer: Ie,
     useRef: function (e) {
      ge = Se();
      var t = (be = Fe()).memoizedState;
      return null === t ? ((e = { current: e }), (be.memoizedState = e)) : t;
     },
     useState: function (e) {
      return Ie(Pe, e);
     },
     useInsertionEffect: Le,
     useLayoutEffect: function () {},
     useCallback: function (e, t) {
      return Ne(function () {
       return e;
      }, t);
     },
     useImperativeHandle: Le,
     useEffect: Le,
     useDebugValue: Le,
     useDeferredValue: function (e) {
      return Se(), e;
     },
     useTransition: function () {
      return Se(), [!1, _e];
     },
     useId: function () {
      var e = De.treeContext,
       t = e.overflow;
      e = ((e = e.id) & ~(1 << (32 - de(e) - 1))).toString(32) + t;
      var r = Me;
      if (null === r) throw Error(s(404));
      return (t = Ce++), (e = ":" + r.idPrefix + "R" + e), 0 < t && (e += "H" + t.toString(32)), e + ":";
     },
     useMutableSource: function (e, t) {
      return Se(), t(e._source);
     },
     useSyncExternalStore: function (e, t, r) {
      if (void 0 === r) throw Error(s(407));
      return r();
     },
    },
    Me = null,
    je = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
   function Re(e) {
    return console.error(e), null;
   }
   function qe() {}
   function Ue(e, t, r, n, s, i, a, o) {
    e.allPendingTasks++, null === r ? e.pendingRootTasks++ : r.pendingTasks++;
    var u = {
     node: t,
     ping: function () {
      var t = e.pingedTasks;
      t.push(u), 1 === t.length && rt(e);
     },
     blockedBoundary: r,
     blockedSegment: n,
     abortSet: s,
     legacyContext: i,
     context: a,
     treeContext: o,
    };
    return s.add(u), u;
   }
   function $e(e, t, r, n, s, i) {
    return { status: 0, id: -1, index: t, parentFlushed: !1, chunks: [], children: [], formatContext: n, boundary: r, lastPushedText: s, textEmbedded: i };
   }
   function Ve(e, t) {
    if (null != (e = e.onError(t)) && "string" != typeof e) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof e + '" instead');
    return e;
   }
   function ze(e, t) {
    var r = e.onShellError;
    r(t), (r = e.onFatalError)(t), null !== e.destination ? ((e.status = 2), e.destination.destroy(t)) : ((e.status = 1), (e.fatalError = t));
   }
   function We(e, t, r, n, s) {
    for (ge = {}, De = t, Ce = 0, e = r(n, s); Ee; ) (Ee = !1), (Ce = 0), (we += 1), (be = null), (e = r(n, s));
    return ke(), e;
   }
   function He(e, t, r, n) {
    var i = r.render(),
     a = n.childContextTypes;
    if (null != a) {
     var o = t.legacyContext;
     if ("function" != typeof r.getChildContext) n = o;
     else {
      for (var u in (r = r.getChildContext())) if (!(u in a)) throw Error(s(108, Z(n) || "Unknown", u));
      n = L({}, o, r);
     }
     (t.legacyContext = n), Ge(e, t, i), (t.legacyContext = o);
    } else Ge(e, t, i);
   }
   function Je(e, t) {
    if (e && e.defaultProps) {
     for (var r in ((t = L({}, t)), (e = e.defaultProps))) void 0 === t[r] && (t[r] = e[r]);
     return t;
    }
    return t;
   }
   function Ke(e, t, r, n, i) {
    if ("function" == typeof r)
     if (r.prototype && r.prototype.isReactComponent) {
      i = te(r, t.legacyContext);
      var a = r.contextType;
      pe((a = new r(n, "object" == typeof a && null !== a ? a._currentValue2 : i)), r, n, i), He(e, t, a, r);
     } else {
      i = We(e, t, r, n, (a = te(r, t.legacyContext)));
      var o = 0 !== Ce;
      if ("object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof) pe(i, r, n, a), He(e, t, i, r);
      else if (o) {
       (n = t.treeContext), (t.treeContext = he(n, 1, 0));
       try {
        Ge(e, t, i);
       } finally {
        t.treeContext = n;
       }
      } else Ge(e, t, i);
     }
    else {
     if ("string" != typeof r) {
      switch (r) {
       case X:
       case G:
       case R:
       case q:
       case j:
       case W:
        return void Ge(e, t, n.children);
       case K:
        throw Error(s(343));
       case z:
        e: {
         (r = t.blockedBoundary), (i = t.blockedSegment), (a = n.fallback), (n = n.children);
         var u = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: (o = new Set()), errorDigest: null },
          l = $e(0, i.chunks.length, u, i.formatContext, !1, !1);
         i.children.push(l), (i.lastPushedText = !1);
         var p = $e(0, 0, null, i.formatContext, !1, !1);
         (p.parentFlushed = !0), (t.blockedBoundary = u), (t.blockedSegment = p);
         try {
          if ((Ye(e, t, n), e.responseState.generateStaticMarkup || (p.lastPushedText && p.textEmbedded && p.chunks.push("\x3c!-- --\x3e")), (p.status = 1), et(u, p), 0 === u.pendingTasks)) break e;
         } catch (c) {
          (p.status = 4), (u.forceClientRender = !0), (u.errorDigest = Ve(e, c));
         } finally {
          (t.blockedBoundary = r), (t.blockedSegment = i);
         }
         (t = Ue(e, a, r, l, o, t.legacyContext, t.context, t.treeContext)), e.pingedTasks.push(t);
        }
        return;
      }
      if ("object" == typeof r && null !== r)
       switch (r.$$typeof) {
        case V:
         if (((n = We(e, t, r.render, n, i)), 0 !== Ce)) {
          (r = t.treeContext), (t.treeContext = he(r, 1, 0));
          try {
           Ge(e, t, n);
          } finally {
           t.treeContext = r;
          }
         } else Ge(e, t, n);
         return;
        case H:
         return void Ke(e, t, (r = r.type), (n = Je(r, n)), i);
        case U:
         if (((i = n.children), (r = r._context), (n = n.value), (a = r._currentValue2), (r._currentValue2 = n), (re = n = { parent: (o = re), depth: null === o ? 0 : o.depth + 1, context: r, parentValue: a, value: n }), (t.context = n), Ge(e, t, i), null === (e = re))) throw Error(s(403));
         return (n = e.parentValue), (e.context._currentValue2 = n === Y ? e.context._defaultValue : n), (e = re = e.parent), void (t.context = e);
        case $:
         return void Ge(e, t, (n = (n = n.children)(r._currentValue2)));
        case J:
         return void Ke(e, t, (r = (i = r._init)(r._payload)), (n = Je(r, n)), void 0);
       }
      throw Error(s(130, null == r ? r : typeof r, ""));
     }
     switch (
      ((a = P((i = t.blockedSegment).chunks, r, n, e.responseState, i.formatContext)),
      (i.lastPushedText = !1),
      (o = i.formatContext),
      (i.formatContext = (function (e, t, r) {
       switch (t) {
        case "select":
         return v(1, null != r.value ? r.value : r.defaultValue);
        case "svg":
         return v(2, null);
        case "math":
         return v(3, null);
        case "foreignObject":
         return v(1, null);
        case "table":
         return v(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
         return v(5, null);
        case "colgroup":
         return v(7, null);
        case "tr":
         return v(6, null);
       }
       return 4 <= e.insertionMode || 0 === e.insertionMode ? v(1, null) : e;
      })(o, r, n)),
      Ye(e, t, a),
      (i.formatContext = o),
      r)
     ) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
       break;
      default:
       i.chunks.push("</", r, ">");
     }
     i.lastPushedText = !1;
    }
   }
   function Ge(e, t, r) {
    if (((t.node = r), "object" == typeof r && null !== r)) {
     switch (r.$$typeof) {
      case O:
       return void Ke(e, t, r.type, r.props, r.ref);
      case M:
       throw Error(s(257));
      case J:
       var n = r._init;
       return void Ge(e, t, (r = n(r._payload)));
     }
     if (b(r)) return void Xe(e, t, r);
     if ((null === r || "object" != typeof r ? (n = null) : (n = "function" == typeof (n = (Q && r[Q]) || r["@@iterator"]) ? n : null), n && (n = n.call(r)))) {
      if (!(r = n.next()).done) {
       var i = [];
       do {
        i.push(r.value), (r = n.next());
       } while (!r.done);
       Xe(e, t, i);
      }
      return;
     }
     throw ((e = Object.prototype.toString.call(r)), Error(s(31, "[object Object]" === e ? "object with keys {" + Object.keys(r).join(", ") + "}" : e)));
    }
    "string" == typeof r ? ((n = t.blockedSegment).lastPushedText = _(t.blockedSegment.chunks, r, e.responseState, n.lastPushedText)) : "number" == typeof r && ((n = t.blockedSegment).lastPushedText = _(t.blockedSegment.chunks, "" + r, e.responseState, n.lastPushedText));
   }
   function Xe(e, t, r) {
    for (var n = r.length, s = 0; s < n; s++) {
     var i = t.treeContext;
     t.treeContext = he(i, n, s);
     try {
      Ye(e, t, r[s]);
     } finally {
      t.treeContext = i;
     }
    }
   }
   function Ye(e, t, r) {
    var n = t.blockedSegment.formatContext,
     s = t.legacyContext,
     i = t.context;
    try {
     return Ge(e, t, r);
    } catch (u) {
     if ((ke(), "object" != typeof u || null === u || "function" != typeof u.then)) throw ((t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), ue(i), u);
     r = u;
     var a = t.blockedSegment,
      o = $e(0, a.chunks.length, null, a.formatContext, a.lastPushedText, !0);
     a.children.push(o), (a.lastPushedText = !1), (e = Ue(e, t.node, t.blockedBoundary, o, t.abortSet, t.legacyContext, t.context, t.treeContext).ping), r.then(e, e), (t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), ue(i);
    }
   }
   function Qe(e) {
    var t = e.blockedBoundary;
    ((e = e.blockedSegment).status = 3), tt(this, t, e);
   }
   function Ze(e, t, r) {
    var n = e.blockedBoundary;
    (e.blockedSegment.status = 3),
     null === n
      ? (t.allPendingTasks--, 2 !== t.status && ((t.status = 2), null !== t.destination && t.destination.push(null)))
      : (n.pendingTasks--,
        n.forceClientRender || ((n.forceClientRender = !0), (e = void 0 === r ? Error(s(432)) : r), (n.errorDigest = t.onError(e)), n.parentFlushed && t.clientRenderedBoundaries.push(n)),
        n.fallbackAbortableTasks.forEach(function (e) {
         return Ze(e, t, r);
        }),
        n.fallbackAbortableTasks.clear(),
        t.allPendingTasks--,
        0 === t.allPendingTasks && (n = t.onAllReady)());
   }
   function et(e, t) {
    if (0 === t.chunks.length && 1 === t.children.length && null === t.children[0].boundary) {
     var r = t.children[0];
     (r.id = t.id), (r.parentFlushed = !0), 1 === r.status && et(e, r);
    } else e.completedSegments.push(t);
   }
   function tt(e, t, r) {
    if (null === t) {
     if (r.parentFlushed) {
      if (null !== e.completedRootSegment) throw Error(s(389));
      e.completedRootSegment = r;
     }
     e.pendingRootTasks--, 0 === e.pendingRootTasks && ((e.onShellError = qe), (t = e.onShellReady)());
    } else t.pendingTasks--, t.forceClientRender || (0 === t.pendingTasks ? (r.parentFlushed && 1 === r.status && et(t, r), t.parentFlushed && e.completedBoundaries.push(t), t.fallbackAbortableTasks.forEach(Qe, e), t.fallbackAbortableTasks.clear()) : r.parentFlushed && 1 === r.status && (et(t, r), 1 === t.completedSegments.length && t.parentFlushed && e.partialBoundaries.push(t)));
    e.allPendingTasks--, 0 === e.allPendingTasks && (e = e.onAllReady)();
   }
   function rt(e) {
    if (2 !== e.status) {
     var t = re,
      r = je.current;
     je.current = Oe;
     var n = Me;
     Me = e.responseState;
     try {
      var s,
       i = e.pingedTasks;
      for (s = 0; s < i.length; s++) {
       var a = i[s],
        o = e,
        u = a.blockedSegment;
       if (0 === u.status) {
        ue(a.context);
        try {
         Ge(o, a, a.node), o.responseState.generateStaticMarkup || (u.lastPushedText && u.textEmbedded && u.chunks.push("\x3c!-- --\x3e")), a.abortSet.delete(a), (u.status = 1), tt(o, a.blockedBoundary, u);
        } catch (d) {
         if ((ke(), "object" == typeof d && null !== d && "function" == typeof d.then)) {
          var l = a.ping;
          d.then(l, l);
         } else {
          a.abortSet.delete(a), (u.status = 4);
          var p = a.blockedBoundary,
           c = d,
           h = Ve(o, c);
          if ((null === p ? ze(o, c) : (p.pendingTasks--, p.forceClientRender || ((p.forceClientRender = !0), (p.errorDigest = h), p.parentFlushed && o.clientRenderedBoundaries.push(p))), o.allPendingTasks--, 0 === o.allPendingTasks)) (0, o.onAllReady)();
         }
        }
       }
      }
      i.splice(0, s), null !== e.destination && ut(e, e.destination);
     } catch (d) {
      Ve(e, d), ze(e, d);
     } finally {
      (Me = n), (je.current = r), r === Oe && ue(t);
     }
    }
   }
   function nt(e, t, r) {
    switch (((r.parentFlushed = !0), r.status)) {
     case 0:
      var n = (r.id = e.nextSegmentId++);
      return (r.lastPushedText = !1), (r.textEmbedded = !1), (e = e.responseState), t.push('<template id="'), t.push(e.placeholderPrefix), (e = n.toString(16)), t.push(e), t.push('"></template>');
     case 1:
      r.status = 2;
      var i = !0;
      n = r.chunks;
      var a = 0;
      r = r.children;
      for (var o = 0; o < r.length; o++) {
       for (i = r[o]; a < i.index; a++) t.push(n[a]);
       i = st(e, t, i);
      }
      for (; a < n.length - 1; a++) t.push(n[a]);
      return a < n.length && (i = t.push(n[a])), i;
     default:
      throw Error(s(390));
    }
   }
   function st(e, t, r) {
    var n = r.boundary;
    if (null === n) return nt(e, t, r);
    if (((n.parentFlushed = !0), n.forceClientRender)) return e.responseState.generateStaticMarkup || ((n = n.errorDigest), t.push("\x3c!--$!--\x3e"), t.push("<template"), n && (t.push(' data-dgst="'), (n = g(n)), t.push(n), t.push('"')), t.push("></template>")), nt(e, t, r), (e = !!e.responseState.generateStaticMarkup || t.push("\x3c!--/$--\x3e"));
    if (0 < n.pendingTasks) {
     (n.rootSegmentID = e.nextSegmentId++), 0 < n.completedSegments.length && e.partialBoundaries.push(n);
     var i = e.responseState,
      a = i.nextSuspenseID++;
     return (i = i.boundaryPrefix + a.toString(16)), (n = n.id = i), I(t, e.responseState, n), nt(e, t, r), t.push("\x3c!--/$--\x3e");
    }
    if (n.byteSize > e.progressiveChunkSize) return (n.rootSegmentID = e.nextSegmentId++), e.completedBoundaries.push(n), I(t, e.responseState, n.id), nt(e, t, r), t.push("\x3c!--/$--\x3e");
    if ((e.responseState.generateStaticMarkup || t.push("\x3c!--$--\x3e"), 1 !== (r = n.completedSegments).length)) throw Error(s(391));
    return st(e, t, r[0]), (e = !!e.responseState.generateStaticMarkup || t.push("\x3c!--/$--\x3e"));
   }
   function it(e, t, r) {
    return (
     (function (e, t, r, n) {
      switch (r.insertionMode) {
       case 0:
       case 1:
        return e.push('<div hidden id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 2:
        return e.push('<svg aria-hidden="true" style="display:none" id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 3:
        return e.push('<math aria-hidden="true" style="display:none" id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 4:
        return e.push('<table hidden id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 5:
        return e.push('<table hidden><tbody id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 6:
        return e.push('<table hidden><tr id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 7:
        return e.push('<table hidden><colgroup id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       default:
        throw Error(s(397));
      }
     })(t, e.responseState, r.formatContext, r.id),
     st(e, t, r),
     (function (e, t) {
      switch (t.insertionMode) {
       case 0:
       case 1:
        return e.push("</div>");
       case 2:
        return e.push("</svg>");
       case 3:
        return e.push("</math>");
       case 4:
        return e.push("</table>");
       case 5:
        return e.push("</tbody></table>");
       case 6:
        return e.push("</tr></table>");
       case 7:
        return e.push("</colgroup></table>");
       default:
        throw Error(s(397));
      }
     })(t, r.formatContext)
    );
   }
   function at(e, t, r) {
    for (var n = r.completedSegments, i = 0; i < n.length; i++) ot(e, t, r, n[i]);
    if (((n.length = 0), (e = e.responseState), (n = r.id), (r = r.rootSegmentID), t.push(e.startInlineScript), e.sentCompleteBoundaryFunction ? t.push('$RC("') : ((e.sentCompleteBoundaryFunction = !0), t.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), null === n)) throw Error(s(395));
    return (r = r.toString(16)), t.push(n), t.push('","'), t.push(e.segmentPrefix), t.push(r), t.push('")</script>');
   }
   function ot(e, t, r, n) {
    if (2 === n.status) return !0;
    var i = n.id;
    if (-1 === i) {
     if (-1 === (n.id = r.rootSegmentID)) throw Error(s(392));
     return it(e, t, n);
    }
    return it(e, t, n), (e = e.responseState), t.push(e.startInlineScript), e.sentCompleteSegmentFunction ? t.push('$RS("') : ((e.sentCompleteSegmentFunction = !0), t.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), t.push(e.segmentPrefix), (i = i.toString(16)), t.push(i), t.push('","'), t.push(e.placeholderPrefix), t.push(i), t.push('")</script>');
   }
   function ut(e, t) {
    try {
     var r = e.completedRootSegment;
     if (null !== r && 0 === e.pendingRootTasks) {
      st(e, t, r), (e.completedRootSegment = null);
      var n = e.responseState.bootstrapChunks;
      for (r = 0; r < n.length - 1; r++) t.push(n[r]);
      r < n.length && t.push(n[r]);
     }
     var i,
      a = e.clientRenderedBoundaries;
     for (i = 0; i < a.length; i++) {
      var o = a[i];
      n = t;
      var u = e.responseState,
       l = o.id,
       p = o.errorDigest,
       c = o.errorMessage,
       h = o.errorComponentStack;
      if ((n.push(u.startInlineScript), u.sentClientRenderFunction ? n.push('$RX("') : ((u.sentClientRenderFunction = !0), n.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), null === l)) throw Error(s(395));
      if ((n.push(l), n.push('"'), p || c || h)) {
       n.push(",");
       var d = B(p || "");
       n.push(d);
      }
      if (c || h) {
       n.push(",");
       var f = B(c || "");
       n.push(f);
      }
      if (h) {
       n.push(",");
       var m = B(h);
       n.push(m);
      }
      if (!n.push(")</script>")) return (e.destination = null), i++, void a.splice(0, i);
     }
     a.splice(0, i);
     var y = e.completedBoundaries;
     for (i = 0; i < y.length; i++) if (!at(e, t, y[i])) return (e.destination = null), i++, void y.splice(0, i);
     y.splice(0, i);
     var g = e.partialBoundaries;
     for (i = 0; i < g.length; i++) {
      var D = g[i];
      e: {
       (a = e), (o = t);
       var x = D.completedSegments;
       for (u = 0; u < x.length; u++)
        if (!ot(a, o, D, x[u])) {
         u++, x.splice(0, u);
         var b = !1;
         break e;
        }
       x.splice(0, u), (b = !0);
      }
      if (!b) return (e.destination = null), i++, void g.splice(0, i);
     }
     g.splice(0, i);
     var v = e.completedBoundaries;
     for (i = 0; i < v.length; i++) if (!at(e, t, v[i])) return (e.destination = null), i++, void v.splice(0, i);
     v.splice(0, i);
    } finally {
     0 === e.allPendingTasks && 0 === e.pingedTasks.length && 0 === e.clientRenderedBoundaries.length && 0 === e.completedBoundaries.length && t.push(null);
    }
   }
   function lt(e, t) {
    try {
     var r = e.abortableTasks;
     r.forEach(function (r) {
      return Ze(r, e, t);
     }),
      r.clear(),
      null !== e.destination && ut(e, e.destination);
    } catch (n) {
     Ve(e, n), ze(e, n);
    }
   }
   function pt() {}
   function ct(e, t, r, n) {
    var i = !1,
     a = null,
     o = "",
     u = {
      push: function (e) {
       return null !== e && (o += e), !0;
      },
      destroy: function (e) {
       (i = !0), (a = e);
      },
     },
     l = !1;
    if (
     ((e = (function (e, t, r, n, s, i, a, o, u) {
      var l = [],
       p = new Set();
      return ((r = $e((t = { destination: null, responseState: t, progressiveChunkSize: void 0 === n ? 12800 : n, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: p, pingedTasks: l, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === s ? Re : s, onAllReady: void 0 === i ? qe : i, onShellReady: void 0 === a ? qe : a, onShellError: void 0 === o ? qe : o, onFatalError: void 0 === u ? qe : u }), 0, null, r, !1, !1)).parentFlushed = !0), (e = Ue(t, e, null, r, p, ee, null, ce)), l.push(e), t;
     })(
      e,
      (function (e, t) {
       return { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: (t = void 0 === t ? "" : t) + "P:", segmentPrefix: t + "S:", boundaryPrefix: t + "B:", idPrefix: t, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: e };
      })(r, t ? t.identifierPrefix : void 0),
      { insertionMode: 1, selectedValue: null },
      1 / 0,
      pt,
      void 0,
      function () {
       l = !0;
      },
      void 0,
      void 0,
     )),
     rt(e),
     lt(e, n),
     1 === e.status)
    )
     (e.status = 2), u.destroy(e.fatalError);
    else if (2 !== e.status && null === e.destination) {
     e.destination = u;
     try {
      ut(e, u);
     } catch (p) {
      Ve(e, p), ze(e, p);
     }
    }
    if (i) throw a;
    if (!l) throw Error(s(426));
    return o;
   }
   (t.renderToNodeStream = function () {
    throw Error(s(207));
   }),
    (t.renderToStaticMarkup = function (e, t) {
     return ct(e, t, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }),
    (t.renderToStaticNodeStream = function () {
     throw Error(s(208));
    }),
    (t.renderToString = function (e, t) {
     return ct(e, t, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }),
    (t.version = "18.2.0");
  },
  4304: (e, t, r) => {
   var n = r(50959);
   function s(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++) t += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
   }
   var i = null,
    a = 0;
   function o(e, t) {
    if (0 !== t.length)
     if (512 < t.length) 0 < a && (e.enqueue(new Uint8Array(i.buffer, 0, a)), (i = new Uint8Array(512)), (a = 0)), e.enqueue(t);
     else {
      var r = i.length - a;
      r < t.length && (0 === r ? e.enqueue(i) : (i.set(t.subarray(0, r), a), e.enqueue(i), (t = t.subarray(r))), (i = new Uint8Array(512)), (a = 0)), i.set(t, a), (a += t.length);
     }
   }
   function u(e, t) {
    return o(e, t), !0;
   }
   function l(e) {
    i && 0 < a && (e.enqueue(new Uint8Array(i.buffer, 0, a)), (i = null), (a = 0));
   }
   var p = new TextEncoder();
   function c(e) {
    return p.encode(e);
   }
   function h(e) {
    return p.encode(e);
   }
   function d(e, t) {
    "function" == typeof e.error ? e.error(t) : e.close();
   }
   var f = Object.prototype.hasOwnProperty,
    m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    y = {},
    g = {};
   function D(e) {
    return !!f.call(g, e) || (!f.call(y, e) && (m.test(e) ? (g[e] = !0) : ((y[e] = !0), !1)));
   }
   function x(e, t, r, n, s, i, a) {
    (this.acceptsBooleans = 2 === t || 3 === t || 4 === t), (this.attributeName = n), (this.attributeNamespace = s), (this.mustUseProperty = r), (this.propertyName = e), (this.type = t), (this.sanitizeURL = i), (this.removeEmptyString = a);
   }
   var b = {};
   "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) {
    b[e] = new x(e, 0, !1, e, null, !1, !1);
   }),
    [
     ["acceptCharset", "accept-charset"],
     ["className", "class"],
     ["htmlFor", "for"],
     ["httpEquiv", "http-equiv"],
    ].forEach(function (e) {
     var t = e[0];
     b[t] = new x(t, 1, !1, e[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
     b[e] = new x(e, 2, !1, e.toLowerCase(), null, !1, !1);
    }),
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) {
     b[e] = new x(e, 2, !1, e, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) {
     b[e] = new x(e, 3, !1, e.toLowerCase(), null, !1, !1);
    }),
    ["checked", "multiple", "muted", "selected"].forEach(function (e) {
     b[e] = new x(e, 3, !0, e, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (e) {
     b[e] = new x(e, 4, !1, e, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (e) {
     b[e] = new x(e, 6, !1, e, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (e) {
     b[e] = new x(e, 5, !1, e.toLowerCase(), null, !1, !1);
    });
   var v = /[\-:]([a-z])/g;
   function E(e) {
    return e[1].toUpperCase();
   }
   "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) {
    var t = e.replace(v, E);
    b[t] = new x(t, 1, !1, e, null, !1, !1);
   }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) {
     var t = e.replace(v, E);
     b[t] = new x(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
    }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
     var t = e.replace(v, E);
     b[t] = new x(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }),
    ["tabIndex", "crossOrigin"].forEach(function (e) {
     b[e] = new x(e, 1, !1, e.toLowerCase(), null, !1, !1);
    }),
    (b.xlinkHref = new x("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1)),
    ["src", "href", "action", "formAction"].forEach(function (e) {
     b[e] = new x(e, 1, !1, e.toLowerCase(), null, !0, !0);
    });
   var C = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    T = ["Webkit", "ms", "Moz", "O"];
   Object.keys(C).forEach(function (e) {
    T.forEach(function (t) {
     (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (C[t] = C[e]);
    });
   });
   var w = /["'&<>]/;
   function S(e) {
    if ("boolean" == typeof e || "number" == typeof e) return "" + e;
    e = "" + e;
    var t = w.exec(e);
    if (t) {
     var r,
      n = "",
      s = 0;
     for (r = t.index; r < e.length; r++) {
      switch (e.charCodeAt(r)) {
       case 34:
        t = "&quot;";
        break;
       case 38:
        t = "&amp;";
        break;
       case 39:
        t = "&#x27;";
        break;
       case 60:
        t = "&lt;";
        break;
       case 62:
        t = "&gt;";
        break;
       default:
        continue;
      }
      s !== r && (n += e.substring(s, r)), (s = r + 1), (n += t);
     }
     e = s !== r ? n + e.substring(s, r) : n;
    }
    return e;
   }
   var A = /([A-Z])/g,
    F = /^ms-/,
    k = Array.isArray,
    P = h("<script>"),
    I = h("</script>"),
    N = h('<script src="'),
    B = h('<script type="module" src="'),
    _ = h('" async=""></script>'),
    L = /(<\/|<)(s)(cript)/gi;
   function O(e, t, r, n) {
    return t + ("s" === r ? "\\u0073" : "\\u0053") + n;
   }
   function M(e, t) {
    return { insertionMode: e, selectedValue: t };
   }
   var j = h("\x3c!-- --\x3e");
   function R(e, t, r, n) {
    return "" === t ? n : (n && e.push(j), e.push(c(S(t))), !0);
   }
   var q = new Map(),
    U = h(' style="'),
    $ = h(":"),
    V = h(";");
   function z(e, t, r) {
    if ("object" != typeof r) throw Error(s(62));
    for (var n in ((t = !0), r))
     if (f.call(r, n)) {
      var i = r[n];
      if (null != i && "boolean" != typeof i && "" !== i) {
       if (0 === n.indexOf("--")) {
        var a = c(S(n));
        i = c(S(("" + i).trim()));
       } else {
        a = n;
        var o = q.get(a);
        void 0 !== o || ((o = h(S(a.replace(A, "-$1").toLowerCase().replace(F, "-ms-")))), q.set(a, o)), (a = o), (i = "number" == typeof i ? (0 === i || f.call(C, n) ? c("" + i) : c(i + "px")) : c(S(("" + i).trim())));
       }
       t ? ((t = !1), e.push(U, a, $, i)) : e.push(V, a, $, i);
      }
     }
    t || e.push(J);
   }
   var W = h(" "),
    H = h('="'),
    J = h('"'),
    K = h('=""');
   function G(e, t, r, n) {
    switch (r) {
     case "style":
      return void z(e, t, n);
     case "defaultValue":
     case "defaultChecked":
     case "innerHTML":
     case "suppressContentEditableWarning":
     case "suppressHydrationWarning":
      return;
    }
    if (!(2 < r.length) || ("o" !== r[0] && "O" !== r[0]) || ("n" !== r[1] && "N" !== r[1]))
     if (null !== (t = b.hasOwnProperty(r) ? b[r] : null)) {
      switch (typeof n) {
       case "function":
       case "symbol":
        return;
       case "boolean":
        if (!t.acceptsBooleans) return;
      }
      switch (((r = c(t.attributeName)), t.type)) {
       case 3:
        n && e.push(W, r, K);
        break;
       case 4:
        !0 === n ? e.push(W, r, K) : !1 !== n && e.push(W, r, H, c(S(n)), J);
        break;
       case 5:
        isNaN(n) || e.push(W, r, H, c(S(n)), J);
        break;
       case 6:
        !isNaN(n) && 1 <= n && e.push(W, r, H, c(S(n)), J);
        break;
       default:
        t.sanitizeURL && (n = "" + n), e.push(W, r, H, c(S(n)), J);
      }
     } else if (D(r)) {
      switch (typeof n) {
       case "function":
       case "symbol":
        return;
       case "boolean":
        if ("data-" !== (t = r.toLowerCase().slice(0, 5)) && "aria-" !== t) return;
      }
      e.push(W, c(r), H, c(S(n)), J);
     }
   }
   var X = h(">"),
    Y = h("/>");
   function Q(e, t, r) {
    if (null != t) {
     if (null != r) throw Error(s(60));
     if ("object" != typeof t || !("__html" in t)) throw Error(s(61));
     null != (t = t.__html) && e.push(c("" + t));
    }
   }
   var Z = h(' selected=""');
   function ee(e, t, r, n) {
    e.push(se(r));
    var s,
     i = (r = null);
    for (s in t)
     if (f.call(t, s)) {
      var a = t[s];
      if (null != a)
       switch (s) {
        case "children":
         r = a;
         break;
        case "dangerouslySetInnerHTML":
         i = a;
         break;
        default:
         G(e, n, s, a);
       }
     }
    return e.push(X), Q(e, i, r), "string" == typeof r ? (e.push(c(S(r))), null) : r;
   }
   var te = h("\n"),
    re = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    ne = new Map();
   function se(e) {
    var t = ne.get(e);
    if (void 0 === t) {
     if (!re.test(e)) throw Error(s(65, e));
     (t = h("<" + e)), ne.set(e, t);
    }
    return t;
   }
   var ie = h("<!DOCTYPE html>");
   function ae(e, t, r, i, a) {
    switch (t) {
     case "select":
      e.push(se("select"));
      var o = null,
       u = null;
      for (d in r)
       if (f.call(r, d)) {
        var l = r[d];
        if (null != l)
         switch (d) {
          case "children":
           o = l;
           break;
          case "dangerouslySetInnerHTML":
           u = l;
           break;
          case "defaultValue":
          case "value":
           break;
          default:
           G(e, i, d, l);
         }
       }
      return e.push(X), Q(e, u, o), o;
     case "option":
      (u = a.selectedValue), e.push(se("option"));
      var p = (l = null),
       h = null,
       d = null;
      for (o in r)
       if (f.call(r, o)) {
        var m = r[o];
        if (null != m)
         switch (o) {
          case "children":
           l = m;
           break;
          case "selected":
           h = m;
           break;
          case "dangerouslySetInnerHTML":
           d = m;
           break;
          case "value":
           p = m;
          default:
           G(e, i, o, m);
         }
       }
      if (null != u)
       if (
        ((r =
         null !== p
          ? "" + p
          : (function (e) {
             var t = "";
             return (
              n.Children.forEach(e, function (e) {
               null != e && (t += e);
              }),
              t
             );
            })(l)),
        k(u))
       ) {
        for (i = 0; i < u.length; i++)
         if ("" + u[i] === r) {
          e.push(Z);
          break;
         }
       } else "" + u === r && e.push(Z);
      else h && e.push(Z);
      return e.push(X), Q(e, d, l), l;
     case "textarea":
      for (l in (e.push(se("textarea")), (d = u = o = null), r))
       if (f.call(r, l) && null != (p = r[l]))
        switch (l) {
         case "children":
          d = p;
          break;
         case "value":
          o = p;
          break;
         case "defaultValue":
          u = p;
          break;
         case "dangerouslySetInnerHTML":
          throw Error(s(91));
         default:
          G(e, i, l, p);
        }
      if ((null === o && null !== u && (o = u), e.push(X), null != d)) {
       if (null != o) throw Error(s(92));
       if (k(d) && 1 < d.length) throw Error(s(93));
       o = "" + d;
      }
      return "string" == typeof o && "\n" === o[0] && e.push(te), null !== o && e.push(c(S("" + o))), null;
     case "input":
      for (u in (e.push(se("input")), (p = d = l = o = null), r))
       if (f.call(r, u) && null != (h = r[u]))
        switch (u) {
         case "children":
         case "dangerouslySetInnerHTML":
          throw Error(s(399, "input"));
         case "defaultChecked":
          p = h;
          break;
         case "defaultValue":
          l = h;
          break;
         case "checked":
          d = h;
          break;
         case "value":
          o = h;
          break;
         default:
          G(e, i, u, h);
        }
      return null !== d ? G(e, i, "checked", d) : null !== p && G(e, i, "checked", p), null !== o ? G(e, i, "value", o) : null !== l && G(e, i, "value", l), e.push(Y), null;
     case "menuitem":
      for (var y in (e.push(se("menuitem")), r))
       if (f.call(r, y) && null != (o = r[y]))
        switch (y) {
         case "children":
         case "dangerouslySetInnerHTML":
          throw Error(s(400));
         default:
          G(e, i, y, o);
        }
      return e.push(X), null;
     case "title":
      for (m in (e.push(se("title")), (o = null), r))
       if (f.call(r, m) && null != (u = r[m]))
        switch (m) {
         case "children":
          o = u;
          break;
         case "dangerouslySetInnerHTML":
          throw Error(s(434));
         default:
          G(e, i, m, u);
        }
      return e.push(X), o;
     case "listing":
     case "pre":
      for (p in (e.push(se(t)), (u = o = null), r))
       if (f.call(r, p) && null != (l = r[p]))
        switch (p) {
         case "children":
          o = l;
          break;
         case "dangerouslySetInnerHTML":
          u = l;
          break;
         default:
          G(e, i, p, l);
        }
      if ((e.push(X), null != u)) {
       if (null != o) throw Error(s(60));
       if ("object" != typeof u || !("__html" in u)) throw Error(s(61));
       null != (r = u.__html) && ("string" == typeof r && 0 < r.length && "\n" === r[0] ? e.push(te, c(r)) : e.push(c("" + r)));
      }
      return "string" == typeof o && "\n" === o[0] && e.push(te), o;
     case "area":
     case "base":
     case "br":
     case "col":
     case "embed":
     case "hr":
     case "img":
     case "keygen":
     case "link":
     case "meta":
     case "param":
     case "source":
     case "track":
     case "wbr":
      for (var g in (e.push(se(t)), r))
       if (f.call(r, g) && null != (o = r[g]))
        switch (g) {
         case "children":
         case "dangerouslySetInnerHTML":
          throw Error(s(399, t));
         default:
          G(e, i, g, o);
        }
      return e.push(Y), null;
     case "annotation-xml":
     case "color-profile":
     case "font-face":
     case "font-face-src":
     case "font-face-uri":
     case "font-face-format":
     case "font-face-name":
     case "missing-glyph":
      return ee(e, r, t, i);
     case "html":
      return 0 === a.insertionMode && e.push(ie), ee(e, r, t, i);
     default:
      if (-1 === t.indexOf("-") && "string" != typeof r.is) return ee(e, r, t, i);
      for (h in (e.push(se(t)), (u = o = null), r))
       if (f.call(r, h) && null != (l = r[h]))
        switch (h) {
         case "children":
          o = l;
          break;
         case "dangerouslySetInnerHTML":
          u = l;
          break;
         case "style":
          z(e, i, l);
          break;
         case "suppressContentEditableWarning":
         case "suppressHydrationWarning":
          break;
         default:
          D(h) && "function" != typeof l && "symbol" != typeof l && e.push(W, c(h), H, c(S(l)), J);
        }
      return e.push(X), Q(e, u, o), o;
    }
   }
   var oe = h("</"),
    ue = h(">"),
    le = h('<template id="'),
    pe = h('"></template>'),
    ce = h("\x3c!--$--\x3e"),
    he = h('\x3c!--$?--\x3e<template id="'),
    de = h('"></template>'),
    fe = h("\x3c!--$!--\x3e"),
    me = h("\x3c!--/$--\x3e"),
    ye = h("<template"),
    ge = h('"'),
    De = h(' data-dgst="');
   h(' data-msg="'), h(' data-stck="');
   var xe = h("></template>");
   function be(e, t, r) {
    if ((o(e, he), null === r)) throw Error(s(395));
    return o(e, r), u(e, de);
   }
   var ve = h('<div hidden id="'),
    Ee = h('">'),
    Ce = h("</div>"),
    Te = h('<svg aria-hidden="true" style="display:none" id="'),
    we = h('">'),
    Se = h("</svg>"),
    Ae = h('<math aria-hidden="true" style="display:none" id="'),
    Fe = h('">'),
    ke = h("</math>"),
    Pe = h('<table hidden id="'),
    Ie = h('">'),
    Ne = h("</table>"),
    Be = h('<table hidden><tbody id="'),
    _e = h('">'),
    Le = h("</tbody></table>"),
    Oe = h('<table hidden><tr id="'),
    Me = h('">'),
    je = h("</tr></table>"),
    Re = h('<table hidden><colgroup id="'),
    qe = h('">'),
    Ue = h("</colgroup></table>");
   var $e = h('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'),
    Ve = h('$RS("'),
    ze = h('","'),
    We = h('")</script>'),
    He = h('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'),
    Je = h('$RC("'),
    Ke = h('","'),
    Ge = h('")</script>'),
    Xe = h('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'),
    Ye = h('$RX("'),
    Qe = h('"'),
    Ze = h(")</script>"),
    et = h(","),
    tt = /[<\u2028\u2029]/g;
   function rt(e) {
    return JSON.stringify(e).replace(tt, function (e) {
     switch (e) {
      case "<":
       return "\\u003c";
      case "\u2028":
       return "\\u2028";
      case "\u2029":
       return "\\u2029";
      default:
       throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
     }
    });
   }
   var nt = Object.assign,
    st = Symbol.for("react.element"),
    it = Symbol.for("react.portal"),
    at = Symbol.for("react.fragment"),
    ot = Symbol.for("react.strict_mode"),
    ut = Symbol.for("react.profiler"),
    lt = Symbol.for("react.provider"),
    pt = Symbol.for("react.context"),
    ct = Symbol.for("react.forward_ref"),
    ht = Symbol.for("react.suspense"),
    dt = Symbol.for("react.suspense_list"),
    ft = Symbol.for("react.memo"),
    mt = Symbol.for("react.lazy"),
    yt = Symbol.for("react.scope"),
    gt = Symbol.for("react.debug_trace_mode"),
    Dt = Symbol.for("react.legacy_hidden"),
    xt = Symbol.for("react.default_value"),
    bt = Symbol.iterator;
   function vt(e) {
    if (null == e) return null;
    if ("function" == typeof e) return e.displayName || e.name || null;
    if ("string" == typeof e) return e;
    switch (e) {
     case at:
      return "Fragment";
     case it:
      return "Portal";
     case ut:
      return "Profiler";
     case ot:
      return "StrictMode";
     case ht:
      return "Suspense";
     case dt:
      return "SuspenseList";
    }
    if ("object" == typeof e)
     switch (e.$$typeof) {
      case pt:
       return (e.displayName || "Context") + ".Consumer";
      case lt:
       return (e._context.displayName || "Context") + ".Provider";
      case ct:
       var t = e.render;
       return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
      case ft:
       return null !== (t = e.displayName || null) ? t : vt(e.type) || "Memo";
      case mt:
       (t = e._payload), (e = e._init);
       try {
        return vt(e(t));
       } catch (r) {}
     }
    return null;
   }
   var Et = {};
   function Ct(e, t) {
    if (!(e = e.contextTypes)) return Et;
    var r,
     n = {};
    for (r in e) n[r] = t[r];
    return n;
   }
   var Tt = null;
   function wt(e, t) {
    if (e !== t) {
     (e.context._currentValue = e.parentValue), (e = e.parent);
     var r = t.parent;
     if (null === e) {
      if (null !== r) throw Error(s(401));
     } else {
      if (null === r) throw Error(s(401));
      wt(e, r);
     }
     t.context._currentValue = t.value;
    }
   }
   function St(e) {
    (e.context._currentValue = e.parentValue), null !== (e = e.parent) && St(e);
   }
   function At(e) {
    var t = e.parent;
    null !== t && At(t), (e.context._currentValue = e.value);
   }
   function Ft(e, t) {
    if (((e.context._currentValue = e.parentValue), null === (e = e.parent))) throw Error(s(402));
    e.depth === t.depth ? wt(e, t) : Ft(e, t);
   }
   function kt(e, t) {
    var r = t.parent;
    if (null === r) throw Error(s(402));
    e.depth === r.depth ? wt(e, r) : kt(e, r), (t.context._currentValue = t.value);
   }
   function Pt(e) {
    var t = Tt;
    t !== e && (null === t ? At(e) : null === e ? St(t) : t.depth === e.depth ? wt(t, e) : t.depth > e.depth ? Ft(t, e) : kt(t, e), (Tt = e));
   }
   var It = {
    isMounted: function () {
     return !1;
    },
    enqueueSetState: function (e, t) {
     null !== (e = e._reactInternals).queue && e.queue.push(t);
    },
    enqueueReplaceState: function (e, t) {
     ((e = e._reactInternals).replace = !0), (e.queue = [t]);
    },
    enqueueForceUpdate: function () {},
   };
   function Nt(e, t, r, n) {
    var s = void 0 !== e.state ? e.state : null;
    (e.updater = It), (e.props = r), (e.state = s);
    var i = { queue: [], replace: !1 };
    e._reactInternals = i;
    var a = t.contextType;
    if (((e.context = "object" == typeof a && null !== a ? a._currentValue : n), "function" == typeof (a = t.getDerivedStateFromProps) && ((s = null == (a = a(r, s)) ? s : nt({}, s, a)), (e.state = s)), "function" != typeof t.getDerivedStateFromProps && "function" != typeof e.getSnapshotBeforeUpdate && ("function" == typeof e.UNSAFE_componentWillMount || "function" == typeof e.componentWillMount)))
     if (((t = e.state), "function" == typeof e.componentWillMount && e.componentWillMount(), "function" == typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), t !== e.state && It.enqueueReplaceState(e, e.state, null), null !== i.queue && 0 < i.queue.length))
      if (((t = i.queue), (a = i.replace), (i.queue = null), (i.replace = !1), a && 1 === t.length)) e.state = t[0];
      else {
       for (i = a ? t[0] : e.state, s = !0, a = a ? 1 : 0; a < t.length; a++) {
        var o = t[a];
        null != (o = "function" == typeof o ? o.call(e, i, r, n) : o) && (s ? ((s = !1), (i = nt({}, i, o))) : nt(i, o));
       }
       e.state = i;
      }
     else i.queue = null;
   }
   var Bt = { id: 1, overflow: "" };
   function _t(e, t, r) {
    var n = e.id;
    e = e.overflow;
    var s = 32 - Lt(n) - 1;
    (n &= ~(1 << s)), (r += 1);
    var i = 32 - Lt(t) + s;
    if (30 < i) {
     var a = s - (s % 5);
     return (i = (n & ((1 << a) - 1)).toString(32)), (n >>= a), (s -= a), { id: (1 << (32 - Lt(t) + s)) | (r << s) | n, overflow: i + e };
    }
    return { id: (1 << i) | (r << s) | n, overflow: e };
   }
   var Lt = Math.clz32
     ? Math.clz32
     : function (e) {
        return 0 === (e >>>= 0) ? 32 : (31 - ((Ot(e) / Mt) | 0)) | 0;
       },
    Ot = Math.log,
    Mt = Math.LN2;
   var jt =
     "function" == typeof Object.is
      ? Object.is
      : function (e, t) {
         return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
        },
    Rt = null,
    qt = null,
    Ut = null,
    $t = null,
    Vt = !1,
    zt = !1,
    Wt = 0,
    Ht = null,
    Jt = 0;
   function Kt() {
    if (null === Rt) throw Error(s(321));
    return Rt;
   }
   function Gt() {
    if (0 < Jt) throw Error(s(312));
    return { memoizedState: null, queue: null, next: null };
   }
   function Xt() {
    return null === $t ? (null === Ut ? ((Vt = !1), (Ut = $t = Gt())) : ((Vt = !0), ($t = Ut))) : null === $t.next ? ((Vt = !1), ($t = $t.next = Gt())) : ((Vt = !0), ($t = $t.next)), $t;
   }
   function Yt() {
    (qt = Rt = null), (zt = !1), (Ut = null), (Jt = 0), ($t = Ht = null);
   }
   function Qt(e, t) {
    return "function" == typeof t ? t(e) : t;
   }
   function Zt(e, t, r) {
    if (((Rt = Kt()), ($t = Xt()), Vt)) {
     var n = $t.queue;
     if (((t = n.dispatch), null !== Ht && void 0 !== (r = Ht.get(n)))) {
      Ht.delete(n), (n = $t.memoizedState);
      do {
       (n = e(n, r.action)), (r = r.next);
      } while (null !== r);
      return ($t.memoizedState = n), [n, t];
     }
     return [$t.memoizedState, t];
    }
    return (e = e === Qt ? ("function" == typeof t ? t() : t) : void 0 !== r ? r(t) : t), ($t.memoizedState = e), (e = (e = $t.queue = { last: null, dispatch: null }).dispatch = tr.bind(null, Rt, e)), [$t.memoizedState, e];
   }
   function er(e, t) {
    if (((Rt = Kt()), (t = void 0 === t ? null : t), null !== ($t = Xt()))) {
     var r = $t.memoizedState;
     if (null !== r && null !== t) {
      var n = r[1];
      e: if (null === n) n = !1;
      else {
       for (var s = 0; s < n.length && s < t.length; s++)
        if (!jt(t[s], n[s])) {
         n = !1;
         break e;
        }
       n = !0;
      }
      if (n) return r[0];
     }
    }
    return (e = e()), ($t.memoizedState = [e, t]), e;
   }
   function tr(e, t, r) {
    if (25 <= Jt) throw Error(s(301));
    if (e === Rt)
     if (((zt = !0), (e = { action: r, next: null }), null === Ht && (Ht = new Map()), void 0 === (r = Ht.get(t)))) Ht.set(t, e);
     else {
      for (t = r; null !== t.next; ) t = t.next;
      t.next = e;
     }
   }
   function rr() {
    throw Error(s(394));
   }
   function nr() {}
   var sr = {
     readContext: function (e) {
      return e._currentValue;
     },
     useContext: function (e) {
      return Kt(), e._currentValue;
     },
     useMemo: er,
     useReducer: Zt,
     useRef: function (e) {
      Rt = Kt();
      var t = ($t = Xt()).memoizedState;
      return null === t ? ((e = { current: e }), ($t.memoizedState = e)) : t;
     },
     useState: function (e) {
      return Zt(Qt, e);
     },
     useInsertionEffect: nr,
     useLayoutEffect: function () {},
     useCallback: function (e, t) {
      return er(function () {
       return e;
      }, t);
     },
     useImperativeHandle: nr,
     useEffect: nr,
     useDebugValue: nr,
     useDeferredValue: function (e) {
      return Kt(), e;
     },
     useTransition: function () {
      return Kt(), [!1, rr];
     },
     useId: function () {
      var e = qt.treeContext,
       t = e.overflow;
      e = ((e = e.id) & ~(1 << (32 - Lt(e) - 1))).toString(32) + t;
      var r = ir;
      if (null === r) throw Error(s(404));
      return (t = Wt++), (e = ":" + r.idPrefix + "R" + e), 0 < t && (e += "H" + t.toString(32)), e + ":";
     },
     useMutableSource: function (e, t) {
      return Kt(), t(e._source);
     },
     useSyncExternalStore: function (e, t, r) {
      if (void 0 === r) throw Error(s(407));
      return r();
     },
    },
    ir = null,
    ar = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
   function or(e) {
    return console.error(e), null;
   }
   function ur() {}
   function lr(e, t, r, n, s, i, a, o) {
    e.allPendingTasks++, null === r ? e.pendingRootTasks++ : r.pendingTasks++;
    var u = {
     node: t,
     ping: function () {
      var t = e.pingedTasks;
      t.push(u), 1 === t.length && Tr(e);
     },
     blockedBoundary: r,
     blockedSegment: n,
     abortSet: s,
     legacyContext: i,
     context: a,
     treeContext: o,
    };
    return s.add(u), u;
   }
   function pr(e, t, r, n, s, i) {
    return { status: 0, id: -1, index: t, parentFlushed: !1, chunks: [], children: [], formatContext: n, boundary: r, lastPushedText: s, textEmbedded: i };
   }
   function cr(e, t) {
    if (null != (e = e.onError(t)) && "string" != typeof e) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof e + '" instead');
    return e;
   }
   function hr(e, t) {
    var r = e.onShellError;
    r(t), (r = e.onFatalError)(t), null !== e.destination ? ((e.status = 2), d(e.destination, t)) : ((e.status = 1), (e.fatalError = t));
   }
   function dr(e, t, r, n, s) {
    for (Rt = {}, qt = t, Wt = 0, e = r(n, s); zt; ) (zt = !1), (Wt = 0), (Jt += 1), ($t = null), (e = r(n, s));
    return Yt(), e;
   }
   function fr(e, t, r, n) {
    var i = r.render(),
     a = n.childContextTypes;
    if (null != a) {
     var o = t.legacyContext;
     if ("function" != typeof r.getChildContext) n = o;
     else {
      for (var u in (r = r.getChildContext())) if (!(u in a)) throw Error(s(108, vt(n) || "Unknown", u));
      n = nt({}, o, r);
     }
     (t.legacyContext = n), gr(e, t, i), (t.legacyContext = o);
    } else gr(e, t, i);
   }
   function mr(e, t) {
    if (e && e.defaultProps) {
     for (var r in ((t = nt({}, t)), (e = e.defaultProps))) void 0 === t[r] && (t[r] = e[r]);
     return t;
    }
    return t;
   }
   function yr(e, t, r, n, i) {
    if ("function" == typeof r)
     if (r.prototype && r.prototype.isReactComponent) {
      i = Ct(r, t.legacyContext);
      var a = r.contextType;
      Nt((a = new r(n, "object" == typeof a && null !== a ? a._currentValue : i)), r, n, i), fr(e, t, a, r);
     } else {
      i = dr(e, t, r, n, (a = Ct(r, t.legacyContext)));
      var o = 0 !== Wt;
      if ("object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof) Nt(i, r, n, a), fr(e, t, i, r);
      else if (o) {
       (n = t.treeContext), (t.treeContext = _t(n, 1, 0));
       try {
        gr(e, t, i);
       } finally {
        t.treeContext = n;
       }
      } else gr(e, t, i);
     }
    else {
     if ("string" != typeof r) {
      switch (r) {
       case Dt:
       case gt:
       case ot:
       case ut:
       case at:
       case dt:
        return void gr(e, t, n.children);
       case yt:
        throw Error(s(343));
       case ht:
        e: {
         (r = t.blockedBoundary), (i = t.blockedSegment), (a = n.fallback), (n = n.children);
         var u = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: (o = new Set()), errorDigest: null },
          l = pr(0, i.chunks.length, u, i.formatContext, !1, !1);
         i.children.push(l), (i.lastPushedText = !1);
         var p = pr(0, 0, null, i.formatContext, !1, !1);
         (p.parentFlushed = !0), (t.blockedBoundary = u), (t.blockedSegment = p);
         try {
          if ((xr(e, t, n), p.lastPushedText && p.textEmbedded && p.chunks.push(j), (p.status = 1), Er(u, p), 0 === u.pendingTasks)) break e;
         } catch (h) {
          (p.status = 4), (u.forceClientRender = !0), (u.errorDigest = cr(e, h));
         } finally {
          (t.blockedBoundary = r), (t.blockedSegment = i);
         }
         (t = lr(e, a, r, l, o, t.legacyContext, t.context, t.treeContext)), e.pingedTasks.push(t);
        }
        return;
      }
      if ("object" == typeof r && null !== r)
       switch (r.$$typeof) {
        case ct:
         if (((n = dr(e, t, r.render, n, i)), 0 !== Wt)) {
          (r = t.treeContext), (t.treeContext = _t(r, 1, 0));
          try {
           gr(e, t, n);
          } finally {
           t.treeContext = r;
          }
         } else gr(e, t, n);
         return;
        case ft:
         return void yr(e, t, (r = r.type), (n = mr(r, n)), i);
        case lt:
         if (((i = n.children), (r = r._context), (n = n.value), (a = r._currentValue), (r._currentValue = n), (Tt = n = { parent: (o = Tt), depth: null === o ? 0 : o.depth + 1, context: r, parentValue: a, value: n }), (t.context = n), gr(e, t, i), null === (e = Tt))) throw Error(s(403));
         return (n = e.parentValue), (e.context._currentValue = n === xt ? e.context._defaultValue : n), (e = Tt = e.parent), void (t.context = e);
        case pt:
         return void gr(e, t, (n = (n = n.children)(r._currentValue)));
        case mt:
         return void yr(e, t, (r = (i = r._init)(r._payload)), (n = mr(r, n)), void 0);
       }
      throw Error(s(130, null == r ? r : typeof r, ""));
     }
     switch (
      ((a = ae((i = t.blockedSegment).chunks, r, n, e.responseState, i.formatContext)),
      (i.lastPushedText = !1),
      (o = i.formatContext),
      (i.formatContext = (function (e, t, r) {
       switch (t) {
        case "select":
         return M(1, null != r.value ? r.value : r.defaultValue);
        case "svg":
         return M(2, null);
        case "math":
         return M(3, null);
        case "foreignObject":
         return M(1, null);
        case "table":
         return M(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
         return M(5, null);
        case "colgroup":
         return M(7, null);
        case "tr":
         return M(6, null);
       }
       return 4 <= e.insertionMode || 0 === e.insertionMode ? M(1, null) : e;
      })(o, r, n)),
      xr(e, t, a),
      (i.formatContext = o),
      r)
     ) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
       break;
      default:
       i.chunks.push(oe, c(r), ue);
     }
     i.lastPushedText = !1;
    }
   }
   function gr(e, t, r) {
    if (((t.node = r), "object" == typeof r && null !== r)) {
     switch (r.$$typeof) {
      case st:
       return void yr(e, t, r.type, r.props, r.ref);
      case it:
       throw Error(s(257));
      case mt:
       var n = r._init;
       return void gr(e, t, (r = n(r._payload)));
     }
     if (k(r)) return void Dr(e, t, r);
     if ((null === r || "object" != typeof r ? (n = null) : (n = "function" == typeof (n = (bt && r[bt]) || r["@@iterator"]) ? n : null), n && (n = n.call(r)))) {
      if (!(r = n.next()).done) {
       var i = [];
       do {
        i.push(r.value), (r = n.next());
       } while (!r.done);
       Dr(e, t, i);
      }
      return;
     }
     throw ((e = Object.prototype.toString.call(r)), Error(s(31, "[object Object]" === e ? "object with keys {" + Object.keys(r).join(", ") + "}" : e)));
    }
    "string" == typeof r ? ((n = t.blockedSegment).lastPushedText = R(t.blockedSegment.chunks, r, e.responseState, n.lastPushedText)) : "number" == typeof r && ((n = t.blockedSegment).lastPushedText = R(t.blockedSegment.chunks, "" + r, e.responseState, n.lastPushedText));
   }
   function Dr(e, t, r) {
    for (var n = r.length, s = 0; s < n; s++) {
     var i = t.treeContext;
     t.treeContext = _t(i, n, s);
     try {
      xr(e, t, r[s]);
     } finally {
      t.treeContext = i;
     }
    }
   }
   function xr(e, t, r) {
    var n = t.blockedSegment.formatContext,
     s = t.legacyContext,
     i = t.context;
    try {
     return gr(e, t, r);
    } catch (u) {
     if ((Yt(), "object" != typeof u || null === u || "function" != typeof u.then)) throw ((t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), Pt(i), u);
     r = u;
     var a = t.blockedSegment,
      o = pr(0, a.chunks.length, null, a.formatContext, a.lastPushedText, !0);
     a.children.push(o), (a.lastPushedText = !1), (e = lr(e, t.node, t.blockedBoundary, o, t.abortSet, t.legacyContext, t.context, t.treeContext).ping), r.then(e, e), (t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), Pt(i);
    }
   }
   function br(e) {
    var t = e.blockedBoundary;
    ((e = e.blockedSegment).status = 3), Cr(this, t, e);
   }
   function vr(e, t, r) {
    var n = e.blockedBoundary;
    (e.blockedSegment.status = 3),
     null === n
      ? (t.allPendingTasks--, 2 !== t.status && ((t.status = 2), null !== t.destination && t.destination.close()))
      : (n.pendingTasks--,
        n.forceClientRender || ((n.forceClientRender = !0), (e = void 0 === r ? Error(s(432)) : r), (n.errorDigest = t.onError(e)), n.parentFlushed && t.clientRenderedBoundaries.push(n)),
        n.fallbackAbortableTasks.forEach(function (e) {
         return vr(e, t, r);
        }),
        n.fallbackAbortableTasks.clear(),
        t.allPendingTasks--,
        0 === t.allPendingTasks && (n = t.onAllReady)());
   }
   function Er(e, t) {
    if (0 === t.chunks.length && 1 === t.children.length && null === t.children[0].boundary) {
     var r = t.children[0];
     (r.id = t.id), (r.parentFlushed = !0), 1 === r.status && Er(e, r);
    } else e.completedSegments.push(t);
   }
   function Cr(e, t, r) {
    if (null === t) {
     if (r.parentFlushed) {
      if (null !== e.completedRootSegment) throw Error(s(389));
      e.completedRootSegment = r;
     }
     e.pendingRootTasks--, 0 === e.pendingRootTasks && ((e.onShellError = ur), (t = e.onShellReady)());
    } else t.pendingTasks--, t.forceClientRender || (0 === t.pendingTasks ? (r.parentFlushed && 1 === r.status && Er(t, r), t.parentFlushed && e.completedBoundaries.push(t), t.fallbackAbortableTasks.forEach(br, e), t.fallbackAbortableTasks.clear()) : r.parentFlushed && 1 === r.status && (Er(t, r), 1 === t.completedSegments.length && t.parentFlushed && e.partialBoundaries.push(t)));
    e.allPendingTasks--, 0 === e.allPendingTasks && (e = e.onAllReady)();
   }
   function Tr(e) {
    if (2 !== e.status) {
     var t = Tt,
      r = ar.current;
     ar.current = sr;
     var n = ir;
     ir = e.responseState;
     try {
      var s,
       i = e.pingedTasks;
      for (s = 0; s < i.length; s++) {
       var a = i[s],
        o = e,
        u = a.blockedSegment;
       if (0 === u.status) {
        Pt(a.context);
        try {
         gr(o, a, a.node), u.lastPushedText && u.textEmbedded && u.chunks.push(j), a.abortSet.delete(a), (u.status = 1), Cr(o, a.blockedBoundary, u);
        } catch (d) {
         if ((Yt(), "object" == typeof d && null !== d && "function" == typeof d.then)) {
          var l = a.ping;
          d.then(l, l);
         } else {
          a.abortSet.delete(a), (u.status = 4);
          var p = a.blockedBoundary,
           c = d,
           h = cr(o, c);
          if ((null === p ? hr(o, c) : (p.pendingTasks--, p.forceClientRender || ((p.forceClientRender = !0), (p.errorDigest = h), p.parentFlushed && o.clientRenderedBoundaries.push(p))), o.allPendingTasks--, 0 === o.allPendingTasks)) (0, o.onAllReady)();
         }
        }
       }
      }
      i.splice(0, s), null !== e.destination && Pr(e, e.destination);
     } catch (d) {
      cr(e, d), hr(e, d);
     } finally {
      (ir = n), (ar.current = r), r === sr && Pt(t);
     }
    }
   }
   function wr(e, t, r) {
    switch (((r.parentFlushed = !0), r.status)) {
     case 0:
      var n = (r.id = e.nextSegmentId++);
      return (r.lastPushedText = !1), (r.textEmbedded = !1), (e = e.responseState), o(t, le), o(t, e.placeholderPrefix), o(t, (e = c(n.toString(16)))), u(t, pe);
     case 1:
      r.status = 2;
      var i = !0;
      n = r.chunks;
      var a = 0;
      r = r.children;
      for (var l = 0; l < r.length; l++) {
       for (i = r[l]; a < i.index; a++) o(t, n[a]);
       i = Sr(e, t, i);
      }
      for (; a < n.length - 1; a++) o(t, n[a]);
      return a < n.length && (i = u(t, n[a])), i;
     default:
      throw Error(s(390));
    }
   }
   function Sr(e, t, r) {
    var n = r.boundary;
    if (null === n) return wr(e, t, r);
    if (((n.parentFlushed = !0), n.forceClientRender)) (n = n.errorDigest), u(t, fe), o(t, ye), n && (o(t, De), o(t, c(S(n))), o(t, ge)), u(t, xe), wr(e, t, r);
    else if (0 < n.pendingTasks) {
     (n.rootSegmentID = e.nextSegmentId++), 0 < n.completedSegments.length && e.partialBoundaries.push(n);
     var i = e.responseState,
      a = i.nextSuspenseID++;
     (i = h(i.boundaryPrefix + a.toString(16))), (n = n.id = i), be(t, e.responseState, n), wr(e, t, r);
    } else if (n.byteSize > e.progressiveChunkSize) (n.rootSegmentID = e.nextSegmentId++), e.completedBoundaries.push(n), be(t, e.responseState, n.id), wr(e, t, r);
    else {
     if ((u(t, ce), 1 !== (r = n.completedSegments).length)) throw Error(s(391));
     Sr(e, t, r[0]);
    }
    return u(t, me);
   }
   function Ar(e, t, r) {
    return (
     (function (e, t, r, n) {
      switch (r.insertionMode) {
       case 0:
       case 1:
        return o(e, ve), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Ee);
       case 2:
        return o(e, Te), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, we);
       case 3:
        return o(e, Ae), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Fe);
       case 4:
        return o(e, Pe), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Ie);
       case 5:
        return o(e, Be), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, _e);
       case 6:
        return o(e, Oe), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Me);
       case 7:
        return o(e, Re), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, qe);
       default:
        throw Error(s(397));
      }
     })(t, e.responseState, r.formatContext, r.id),
     Sr(e, t, r),
     (function (e, t) {
      switch (t.insertionMode) {
       case 0:
       case 1:
        return u(e, Ce);
       case 2:
        return u(e, Se);
       case 3:
        return u(e, ke);
       case 4:
        return u(e, Ne);
       case 5:
        return u(e, Le);
       case 6:
        return u(e, je);
       case 7:
        return u(e, Ue);
       default:
        throw Error(s(397));
      }
     })(t, r.formatContext)
    );
   }
   function Fr(e, t, r) {
    for (var n = r.completedSegments, i = 0; i < n.length; i++) kr(e, t, r, n[i]);
    if (((n.length = 0), (e = e.responseState), (n = r.id), (r = r.rootSegmentID), o(t, e.startInlineScript), e.sentCompleteBoundaryFunction ? o(t, Je) : ((e.sentCompleteBoundaryFunction = !0), o(t, He)), null === n)) throw Error(s(395));
    return (r = c(r.toString(16))), o(t, n), o(t, Ke), o(t, e.segmentPrefix), o(t, r), u(t, Ge);
   }
   function kr(e, t, r, n) {
    if (2 === n.status) return !0;
    var i = n.id;
    if (-1 === i) {
     if (-1 === (n.id = r.rootSegmentID)) throw Error(s(392));
     return Ar(e, t, n);
    }
    return Ar(e, t, n), o(t, (e = e.responseState).startInlineScript), e.sentCompleteSegmentFunction ? o(t, Ve) : ((e.sentCompleteSegmentFunction = !0), o(t, $e)), o(t, e.segmentPrefix), o(t, (i = c(i.toString(16)))), o(t, ze), o(t, e.placeholderPrefix), o(t, i), u(t, We);
   }
   function Pr(e, t) {
    (i = new Uint8Array(512)), (a = 0);
    try {
     var r = e.completedRootSegment;
     if (null !== r && 0 === e.pendingRootTasks) {
      Sr(e, t, r), (e.completedRootSegment = null);
      var n = e.responseState.bootstrapChunks;
      for (r = 0; r < n.length - 1; r++) o(t, n[r]);
      r < n.length && u(t, n[r]);
     }
     var p,
      h = e.clientRenderedBoundaries;
     for (p = 0; p < h.length; p++) {
      var d = h[p];
      n = t;
      var f = e.responseState,
       m = d.id,
       y = d.errorDigest,
       g = d.errorMessage,
       D = d.errorComponentStack;
      if ((o(n, f.startInlineScript), f.sentClientRenderFunction ? o(n, Ye) : ((f.sentClientRenderFunction = !0), o(n, Xe)), null === m)) throw Error(s(395));
      if ((o(n, m), o(n, Qe), (y || g || D) && (o(n, et), o(n, c(rt(y || "")))), (g || D) && (o(n, et), o(n, c(rt(g || "")))), D && (o(n, et), o(n, c(rt(D)))), !u(n, Ze))) return (e.destination = null), p++, void h.splice(0, p);
     }
     h.splice(0, p);
     var x = e.completedBoundaries;
     for (p = 0; p < x.length; p++) if (!Fr(e, t, x[p])) return (e.destination = null), p++, void x.splice(0, p);
     x.splice(0, p), l(t), (i = new Uint8Array(512)), (a = 0);
     var b = e.partialBoundaries;
     for (p = 0; p < b.length; p++) {
      var v = b[p];
      e: {
       (h = e), (d = t);
       var E = v.completedSegments;
       for (f = 0; f < E.length; f++)
        if (!kr(h, d, v, E[f])) {
         f++, E.splice(0, f);
         var C = !1;
         break e;
        }
       E.splice(0, f), (C = !0);
      }
      if (!C) return (e.destination = null), p++, void b.splice(0, p);
     }
     b.splice(0, p);
     var T = e.completedBoundaries;
     for (p = 0; p < T.length; p++) if (!Fr(e, t, T[p])) return (e.destination = null), p++, void T.splice(0, p);
     T.splice(0, p);
    } finally {
     l(t), 0 === e.allPendingTasks && 0 === e.pingedTasks.length && 0 === e.clientRenderedBoundaries.length && 0 === e.completedBoundaries.length && t.close();
    }
   }
   function Ir(e, t) {
    try {
     var r = e.abortableTasks;
     r.forEach(function (r) {
      return vr(r, e, t);
     }),
      r.clear(),
      null !== e.destination && Pr(e, e.destination);
    } catch (n) {
     cr(e, n), hr(e, n);
    }
   }
   (t.renderToReadableStream = function (e, t) {
    return new Promise(function (r, n) {
     var s,
      i,
      a = new Promise(function (e, t) {
       (i = e), (s = t);
      }),
      o = (function (e, t, r, n, s, i, a, o, u) {
       var l = [],
        p = new Set();
       return ((r = pr((t = { destination: null, responseState: t, progressiveChunkSize: void 0 === n ? 12800 : n, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: p, pingedTasks: l, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === s ? or : s, onAllReady: void 0 === i ? ur : i, onShellReady: void 0 === a ? ur : a, onShellError: void 0 === o ? ur : o, onFatalError: void 0 === u ? ur : u }), 0, null, r, !1, !1)).parentFlushed = !0), (e = lr(t, e, null, r, p, Et, null, Bt)), l.push(e), t;
      })(
       e,
       (function (e, t, r, n, s) {
        (e = void 0 === e ? "" : e), (t = void 0 === t ? P : h('<script nonce="' + S(t) + '">'));
        var i = [];
        if ((void 0 !== r && i.push(t, c(("" + r).replace(L, O)), I), void 0 !== n)) for (r = 0; r < n.length; r++) i.push(N, c(S(n[r])), _);
        if (void 0 !== s) for (n = 0; n < s.length; n++) i.push(B, c(S(s[n])), _);
        return { bootstrapChunks: i, startInlineScript: t, placeholderPrefix: h(e + "P:"), segmentPrefix: h(e + "S:"), boundaryPrefix: e + "B:", idPrefix: e, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
       })(t ? t.identifierPrefix : void 0, t ? t.nonce : void 0, t ? t.bootstrapScriptContent : void 0, t ? t.bootstrapScripts : void 0, t ? t.bootstrapModules : void 0),
       (function (e) {
        return M("http://www.w3.org/2000/svg" === e ? 2 : "http://www.w3.org/1998/Math/MathML" === e ? 3 : 0, null);
       })(t ? t.namespaceURI : void 0),
       t ? t.progressiveChunkSize : void 0,
       t ? t.onError : void 0,
       i,
       function () {
        var e = new ReadableStream(
         {
          type: "bytes",
          pull: function (e) {
           if (1 === o.status) (o.status = 2), d(e, o.fatalError);
           else if (2 !== o.status && null === o.destination) {
            o.destination = e;
            try {
             Pr(o, e);
            } catch (t) {
             cr(o, t), hr(o, t);
            }
           }
          },
          cancel: function () {
           Ir(o);
          },
         },
         { highWaterMark: 0 },
        );
        (e.allReady = a), r(e);
       },
       function (e) {
        a.catch(function () {}), n(e);
       },
       s,
      );
     if (t && t.signal) {
      var u = t.signal,
       l = function () {
        Ir(o, u.reason), u.removeEventListener("abort", l);
       };
      u.addEventListener("abort", l);
     }
     Tr(o);
    });
   }),
    (t.version = "18.2.0");
  },
  9995: (e, t, r) => {
   var n, s;
   (n = r(5041)), (s = r(4304)), n.version, n.renderToString, (t.uS = n.renderToStaticMarkup), n.renderToNodeStream, n.renderToStaticNodeStream, s.renderToReadableStream;
  },
  11910: (e, t, r) => {
   r.d(t, { Z: () => de });
   var n = Object.create,
    s = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    p = (e, t, r) => (
     (r = null != e ? n(o(e)) : {}),
     ((e, t, r, n) => {
      if ((t && "object" == typeof t) || "function" == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && s(e, o, { get: () => t[o], enumerable: !(n = i(t, o)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : s(r, "default", { value: e, enumerable: !0 }), e)
    ),
    c = l((e) => {
     function t(e, t) {
      if (null == e) return {};
      var r,
       n,
       s = {},
       i = Object.keys(e);
      for (n = 0; n < i.length; n++) (r = i[n]), !(t.indexOf(r) >= 0) && (s[r] = e[r]);
      return s;
     }
     Object.defineProperty(e, "__esModule", { value: !0 });
     var r = class {
       constructor(e, t, r) {
        (this.line = void 0), (this.column = void 0), (this.index = void 0), (this.line = e), (this.column = t), (this.index = r);
       }
      },
      n = class {
       constructor(e, t) {
        (this.start = void 0), (this.end = void 0), (this.filename = void 0), (this.identifierName = void 0), (this.start = e), (this.end = t);
       }
      };
     function s(e, t) {
      let { line: n, column: s, index: i } = e;
      return new r(n, s + t, i + t);
     }
     var i = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED",
      a = { ImportMetaOutsideModule: { message: "import.meta may appear only with 'sourceType: \"module\"'", code: i }, ImportOutsideModule: { message: "'import' and 'export' may appear only with 'sourceType: \"module\"'", code: i } },
      o = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" },
      u = ({ type: e, prefix: t }) => ("UpdateExpression" === e ? o.UpdateExpression[String(t)] : o[e]),
      l = { AccessorIsGenerator: ({ kind: e }) => `A ${e}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: e }) => `Missing initializer in ${e} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: e }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: e }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: e, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: e }) => `'${"ForInStatement" === e ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: e }) => `Unsyntactic ${"BreakStatement" === e ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: e }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${e}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: e }) => `\`import()\` requires exactly ${1 === e ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: e }) => `Expected number in radix ${e}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: e }) => `Escape sequence in keyword ${e}.`, InvalidIdentifier: ({ identifierName: e }) => `Invalid identifier ${e}.`, InvalidLhs: ({ ancestor: e }) => `Invalid left-hand side in ${u(e)}.`, InvalidLhsBinding: ({ ancestor: e }) => `Binding invalid left-hand side in ${u(e)}.`, InvalidLhsOptionalChaining: ({ ancestor: e }) => `Invalid optional chaining in the left-hand side of ${u(e)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: e }) => `Unexpected character '${e}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: e }) => `Private name #${e} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: e }) => `Label '${e}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: e }) => `This experimental syntax requires enabling the parser plugin: ${e.map((e) => JSON.stringify(e)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: e }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((e) => JSON.stringify(e)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: e }) => `Duplicate key "${e}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, ModuleExportUndefined: ({ localName: e }) => `Export '${e}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: e }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: e }) => `Duplicate private name #${e}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: e }) => `Unexpected keyword '${e}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: e }) => `Unexpected reserved word '${e}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: e, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: e, onlyValidPropertyName: t }) => `The only valid meta property for ${e} is ${e}.${t}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: e }) => `Identifier '${e}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." },
      p = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]),
      c = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: e }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: e }) => `Hack-style pipe body cannot be an unparenthesized ${u({ type: e })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' },
      h = ["toMessage"],
      d = ["message"];
     function f(e, t, r) {
      Object.defineProperty(e, t, { enumerable: !1, configurable: !0, value: r });
     }
     function m(e) {
      let { toMessage: n } = e,
       s = t(e, h);
      return function e({ loc: t, details: i }) {
       let a = new SyntaxError();
       return (
        Object.assign(a, s, { loc: t, pos: t.index }),
        "missingPlugin" in i && Object.assign(a, { missingPlugin: i.missingPlugin }),
        f(a, "clone", function (n = {}) {
         var s;
         let { line: a, column: o, index: u } = null != (s = n.loc) ? s : t;
         return e({ loc: new r(a, o, u), details: Object.assign({}, i, n.details) });
        }),
        f(a, "details", i),
        Object.defineProperty(a, "message", {
         configurable: !0,
         get() {
          let e = `${n(i)} (${t.line}:${t.column})`;
          return (this.message = e), e;
         },
         set(e) {
          Object.defineProperty(this, "message", { value: e, writable: !0 });
         },
        }),
        a
       );
      };
     }
     function y(e, r) {
      if (Array.isArray(e)) return (t) => y(t, e[0]);
      let n = {};
      for (let s of Object.keys(e)) {
       let i = e[s],
        a = "string" == typeof i ? { message: () => i } : "function" == typeof i ? { message: i } : i,
        { message: o } = a,
        u = t(a, d),
        l = "string" == typeof o ? () => o : o;
       n[s] = m(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: s, toMessage: l }, r ? { syntaxPlugin: r } : {}, u));
      }
      return n;
     }
     var g = Object.assign({}, y(a), y(l), y({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: e }) => `Assigning to '${e}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: e }) => `Binding '${e}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), y`pipelineOperator`(c)),
      { defineProperty: D } = Object,
      x = (e, t) => D(e, t, { enumerable: !1, value: e[t] });
     function b(e) {
      return e.loc.start && x(e.loc.start, "index"), e.loc.end && x(e.loc.end, "index"), e;
     }
     var v = class {
       constructor(e, t) {
        (this.token = void 0), (this.preserveSpace = void 0), (this.token = e), (this.preserveSpace = !!t);
       }
      },
      E = { brace: new v("{"), j_oTag: new v("<tag"), j_cTag: new v("</tag"), j_expr: new v("<tag>...</tag>", !0) };
     E.template = new v("`", !0);
     var C = !0,
      T = !0,
      w = !0,
      S = !0,
      A = !0,
      F = class {
       constructor(e, t = {}) {
        (this.label = void 0), (this.keyword = void 0), (this.beforeExpr = void 0), (this.startsExpr = void 0), (this.rightAssociative = void 0), (this.isLoop = void 0), (this.isAssign = void 0), (this.prefix = void 0), (this.postfix = void 0), (this.binop = void 0), (this.label = e), (this.keyword = t.keyword), (this.beforeExpr = !!t.beforeExpr), (this.startsExpr = !!t.startsExpr), (this.rightAssociative = !!t.rightAssociative), (this.isLoop = !!t.isLoop), (this.isAssign = !!t.isAssign), (this.prefix = !!t.prefix), (this.postfix = !!t.postfix), (this.binop = null != t.binop ? t.binop : null), (this.updateContext = null);
       }
      },
      k = new Map();
     function P(e, t = {}) {
      t.keyword = e;
      let r = R(e, t);
      return k.set(e, r), r;
     }
     function I(e, t) {
      return R(e, { beforeExpr: C, binop: t });
     }
     var N = -1,
      B = [],
      _ = [],
      L = [],
      O = [],
      M = [],
      j = [];
     function R(e, t = {}) {
      var r, n, s, i;
      return ++N, _.push(e), L.push(null != (r = t.binop) ? r : -1), O.push(null != (n = t.beforeExpr) && n), M.push(null != (s = t.startsExpr) && s), j.push(null != (i = t.prefix) && i), B.push(new F(e, t)), N;
     }
     function q(e, t = {}) {
      var r, n, s, i;
      return ++N, k.set(e, N), _.push(e), L.push(null != (r = t.binop) ? r : -1), O.push(null != (n = t.beforeExpr) && n), M.push(null != (s = t.startsExpr) && s), j.push(null != (i = t.prefix) && i), B.push(new F("name", t)), N;
     }
     var U = { bracketL: R("[", { beforeExpr: C, startsExpr: T }), bracketHashL: R("#[", { beforeExpr: C, startsExpr: T }), bracketBarL: R("[|", { beforeExpr: C, startsExpr: T }), bracketR: R("]"), bracketBarR: R("|]"), braceL: R("{", { beforeExpr: C, startsExpr: T }), braceBarL: R("{|", { beforeExpr: C, startsExpr: T }), braceHashL: R("#{", { beforeExpr: C, startsExpr: T }), braceR: R("}"), braceBarR: R("|}"), parenL: R("(", { beforeExpr: C, startsExpr: T }), parenR: R(")"), comma: R(",", { beforeExpr: C }), semi: R(";", { beforeExpr: C }), colon: R(":", { beforeExpr: C }), doubleColon: R("::", { beforeExpr: C }), dot: R("."), question: R("?", { beforeExpr: C }), questionDot: R("?."), arrow: R("=>", { beforeExpr: C }), template: R("template"), ellipsis: R("...", { beforeExpr: C }), backQuote: R("`", { startsExpr: T }), dollarBraceL: R("${", { beforeExpr: C, startsExpr: T }), templateTail: R("...`", { startsExpr: T }), templateNonTail: R("...${", { beforeExpr: C, startsExpr: T }), at: R("@"), hash: R("#", { startsExpr: T }), interpreterDirective: R("#!..."), eq: R("=", { beforeExpr: C, isAssign: S }), assign: R("_=", { beforeExpr: C, isAssign: S }), slashAssign: R("_=", { beforeExpr: C, isAssign: S }), xorAssign: R("_=", { beforeExpr: C, isAssign: S }), moduloAssign: R("_=", { beforeExpr: C, isAssign: S }), incDec: R("++/--", { prefix: A, postfix: !0, startsExpr: T }), bang: R("!", { beforeExpr: C, prefix: A, startsExpr: T }), tilde: R("~", { beforeExpr: C, prefix: A, startsExpr: T }), doubleCaret: R("^^", { startsExpr: T }), doubleAt: R("@@", { startsExpr: T }), pipeline: I("|>", 0), nullishCoalescing: I("??", 1), logicalOR: I("||", 1), logicalAND: I("&&", 2), bitwiseOR: I("|", 3), bitwiseXOR: I("^", 4), bitwiseAND: I("&", 5), equality: I("==/!=/===/!==", 6), lt: I("</>/<=/>=", 7), gt: I("</>/<=/>=", 7), relational: I("</>/<=/>=", 7), bitShift: I("<</>>/>>>", 8), bitShiftL: I("<</>>/>>>", 8), bitShiftR: I("<</>>/>>>", 8), plusMin: R("+/-", { beforeExpr: C, binop: 9, prefix: A, startsExpr: T }), modulo: R("%", { binop: 10, startsExpr: T }), star: R("*", { binop: 10 }), slash: I("/", 10), exponent: R("**", { beforeExpr: C, binop: 11, rightAssociative: !0 }), _in: P("in", { beforeExpr: C, binop: 7 }), _instanceof: P("instanceof", { beforeExpr: C, binop: 7 }), _break: P("break"), _case: P("case", { beforeExpr: C }), _catch: P("catch"), _continue: P("continue"), _debugger: P("debugger"), _default: P("default", { beforeExpr: C }), _else: P("else", { beforeExpr: C }), _finally: P("finally"), _function: P("function", { startsExpr: T }), _if: P("if"), _return: P("return", { beforeExpr: C }), _switch: P("switch"), _throw: P("throw", { beforeExpr: C, prefix: A, startsExpr: T }), _try: P("try"), _var: P("var"), _const: P("const"), _with: P("with"), _new: P("new", { beforeExpr: C, startsExpr: T }), _this: P("this", { startsExpr: T }), _super: P("super", { startsExpr: T }), _class: P("class", { startsExpr: T }), _extends: P("extends", { beforeExpr: C }), _export: P("export"), _import: P("import", { startsExpr: T }), _null: P("null", { startsExpr: T }), _true: P("true", { startsExpr: T }), _false: P("false", { startsExpr: T }), _typeof: P("typeof", { beforeExpr: C, prefix: A, startsExpr: T }), _void: P("void", { beforeExpr: C, prefix: A, startsExpr: T }), _delete: P("delete", { beforeExpr: C, prefix: A, startsExpr: T }), _do: P("do", { isLoop: w, beforeExpr: C }), _for: P("for", { isLoop: w }), _while: P("while", { isLoop: w }), _as: q("as", { startsExpr: T }), _assert: q("assert", { startsExpr: T }), _async: q("async", { startsExpr: T }), _await: q("await", { startsExpr: T }), _defer: q("defer", { startsExpr: T }), _from: q("from", { startsExpr: T }), _get: q("get", { startsExpr: T }), _let: q("let", { startsExpr: T }), _meta: q("meta", { startsExpr: T }), _of: q("of", { startsExpr: T }), _sent: q("sent", { startsExpr: T }), _set: q("set", { startsExpr: T }), _source: q("source", { startsExpr: T }), _static: q("static", { startsExpr: T }), _using: q("using", { startsExpr: T }), _yield: q("yield", { startsExpr: T }), _asserts: q("asserts", { startsExpr: T }), _checks: q("checks", { startsExpr: T }), _exports: q("exports", { startsExpr: T }), _global: q("global", { startsExpr: T }), _implements: q("implements", { startsExpr: T }), _intrinsic: q("intrinsic", { startsExpr: T }), _infer: q("infer", { startsExpr: T }), _is: q("is", { startsExpr: T }), _mixins: q("mixins", { startsExpr: T }), _proto: q("proto", { startsExpr: T }), _require: q("require", { startsExpr: T }), _satisfies: q("satisfies", { startsExpr: T }), _keyof: q("keyof", { startsExpr: T }), _readonly: q("readonly", { startsExpr: T }), _unique: q("unique", { startsExpr: T }), _abstract: q("abstract", { startsExpr: T }), _declare: q("declare", { startsExpr: T }), _enum: q("enum", { startsExpr: T }), _module: q("module", { startsExpr: T }), _namespace: q("namespace", { startsExpr: T }), _interface: q("interface", { startsExpr: T }), _type: q("type", { startsExpr: T }), _opaque: q("opaque", { startsExpr: T }), name: R("name", { startsExpr: T }), string: R("string", { startsExpr: T }), num: R("num", { startsExpr: T }), bigint: R("bigint", { startsExpr: T }), decimal: R("decimal", { startsExpr: T }), regexp: R("regexp", { startsExpr: T }), privateName: R("#name", { startsExpr: T }), eof: R("eof"), jsxName: R("jsxName"), jsxText: R("jsxText", { beforeExpr: !0 }), jsxTagStart: R("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: R("jsxTagEnd"), placeholder: R("%%", { startsExpr: !0 }) };
     function $(e) {
      return e >= 93 && e <= 132;
     }
     function V(e) {
      return e >= 58 && e <= 132;
     }
     function z(e) {
      return e >= 58 && e <= 136;
     }
     function W(e) {
      return M[e];
     }
     function H(e) {
      return e >= 129 && e <= 131;
     }
     function J(e) {
      return e >= 58 && e <= 92;
     }
     function K(e) {
      return _[e];
     }
     function G(e) {
      return L[e];
     }
     function X(e) {
      return e >= 24 && e <= 25;
     }
     function Y(e) {
      return B[e];
     }
     (B[8].updateContext = (e) => {
      e.pop();
     }),
      (B[5].updateContext =
       B[7].updateContext =
       B[23].updateContext =
        (e) => {
         e.push(E.brace);
        }),
      (B[22].updateContext = (e) => {
       e[e.length - 1] === E.template ? e.pop() : e.push(E.template);
      }),
      (B[142].updateContext = (e) => {
       e.push(E.j_expr, E.j_oTag);
      });
     var Q = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",
      Z = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65",
      ee = new RegExp("[" + Q + "]"),
      te = new RegExp("[" + Q + Z + "]");
     Q = Z = null;
     var re = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191],
      ne = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
     function se(e, t) {
      let r = 65536;
      for (let n = 0, s = t.length; n < s; n += 2) {
       if (((r += t[n]), r > e)) return !1;
       if (((r += t[n + 1]), r >= e)) return !0;
      }
      return !1;
     }
     function ie(e) {
      return e < 65 ? 36 === e : e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && ee.test(String.fromCharCode(e)) : se(e, re)));
     }
     function ae(e) {
      return e < 48 ? 36 === e : e < 58 || (!(e < 65) && (e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && te.test(String.fromCharCode(e)) : se(e, re) || se(e, ne)))));
     }
     var oe = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      ue = ["eval", "arguments"],
      le = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]),
      pe = new Set(oe),
      ce = new Set(ue);
     function he(e, t) {
      return (t && "await" === e) || "enum" === e;
     }
     function de(e, t) {
      return he(e, t) || pe.has(e);
     }
     function fe(e) {
      return ce.has(e);
     }
     function me(e, t) {
      return de(e, t) || fe(e);
     }
     var ye = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
     var ge = class {
       constructor(e) {
        (this.var = new Set()), (this.lexical = new Set()), (this.functions = new Set()), (this.flags = e);
       }
      },
      De = class {
       constructor(e, t) {
        (this.parser = void 0), (this.scopeStack = []), (this.inModule = void 0), (this.undefinedExports = new Map()), (this.parser = e), (this.inModule = t);
       }
       get inTopLevel() {
        return (1 & this.currentScope().flags) > 0;
       }
       get inFunction() {
        return (2 & this.currentVarScopeFlags()) > 0;
       }
       get allowSuper() {
        return (16 & this.currentThisScopeFlags()) > 0;
       }
       get allowDirectSuper() {
        return (32 & this.currentThisScopeFlags()) > 0;
       }
       get inClass() {
        return (64 & this.currentThisScopeFlags()) > 0;
       }
       get inClassAndNotInNonArrowFunction() {
        let e = this.currentThisScopeFlags();
        return (64 & e) > 0 && 0 == (2 & e);
       }
       get inStaticBlock() {
        for (let e = this.scopeStack.length - 1; ; e--) {
         let { flags: t } = this.scopeStack[e];
         if (128 & t) return !0;
         if (451 & t) return !1;
        }
       }
       get inNonArrowFunction() {
        return (2 & this.currentThisScopeFlags()) > 0;
       }
       get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
       }
       createScope(e) {
        return new ge(e);
       }
       enter(e) {
        this.scopeStack.push(this.createScope(e));
       }
       exit() {
        return this.scopeStack.pop().flags;
       }
       treatFunctionsAsVarInScope(e) {
        return !!(130 & e.flags || (!this.parser.inModule && 1 & e.flags));
       }
       declareName(e, t, r) {
        let n = this.currentScope();
        if (8 & t || 16 & t) this.checkRedeclarationInScope(n, e, t, r), 16 & t ? n.functions.add(e) : n.lexical.add(e), 8 & t && this.maybeExportDefined(n, e);
        else if (4 & t) for (let s = this.scopeStack.length - 1; s >= 0 && ((n = this.scopeStack[s]), this.checkRedeclarationInScope(n, e, t, r), n.var.add(e), this.maybeExportDefined(n, e), !(387 & n.flags)); --s);
        this.parser.inModule && 1 & n.flags && this.undefinedExports.delete(e);
       }
       maybeExportDefined(e, t) {
        this.parser.inModule && 1 & e.flags && this.undefinedExports.delete(t);
       }
       checkRedeclarationInScope(e, t, r, n) {
        this.isRedeclaredInScope(e, t, r) && this.parser.raise(g.VarRedeclaration, { at: n, identifierName: t });
       }
       isRedeclaredInScope(e, t, r) {
        return !!(1 & r) && (8 & r ? e.lexical.has(t) || e.functions.has(t) || e.var.has(t) : 16 & r ? e.lexical.has(t) || (!this.treatFunctionsAsVarInScope(e) && e.var.has(t)) : (e.lexical.has(t) && !(8 & e.flags && e.lexical.values().next().value === t)) || (!this.treatFunctionsAsVarInScope(e) && e.functions.has(t)));
       }
       checkLocalExport(e) {
        let { name: t } = e,
         r = this.scopeStack[0];
        !r.lexical.has(t) && !r.var.has(t) && !r.functions.has(t) && this.undefinedExports.set(t, e.loc.start);
       }
       currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
       }
       currentVarScopeFlags() {
        for (let e = this.scopeStack.length - 1; ; e--) {
         let { flags: t } = this.scopeStack[e];
         if (387 & t) return t;
        }
       }
       currentThisScopeFlags() {
        for (let e = this.scopeStack.length - 1; ; e--) {
         let { flags: t } = this.scopeStack[e];
         if (451 & t && !(4 & t)) return t;
        }
       }
      },
      xe = class extends ge {
       constructor(...e) {
        super(...e), (this.declareFunctions = new Set());
       }
      },
      be = class extends De {
       createScope(e) {
        return new xe(e);
       }
       declareName(e, t, r) {
        let n = this.currentScope();
        if (2048 & t) return this.checkRedeclarationInScope(n, e, t, r), this.maybeExportDefined(n, e), void n.declareFunctions.add(e);
        super.declareName(e, t, r);
       }
       isRedeclaredInScope(e, t, r) {
        return !!super.isRedeclaredInScope(e, t, r) || (!!(2048 & r) && !e.declareFunctions.has(t) && (e.lexical.has(t) || e.functions.has(t)));
       }
       checkLocalExport(e) {
        this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
       }
      },
      ve = class {
       constructor() {
        (this.sawUnambiguousESM = !1), (this.ambiguousScriptDifferentAst = !1);
       }
       hasPlugin(e) {
        if ("string" == typeof e) return this.plugins.has(e);
        {
         let [t, r] = e;
         if (!this.hasPlugin(t)) return !1;
         let n = this.plugins.get(t);
         for (let e of Object.keys(r)) if ((null == n ? void 0 : n[e]) !== r[e]) return !1;
         return !0;
        }
       }
       getPluginOption(e, t) {
        var r;
        return null == (r = this.plugins.get(e)) ? void 0 : r[t];
       }
      };
     function Ee(e, t) {
      void 0 === e.trailingComments ? (e.trailingComments = t) : e.trailingComments.unshift(...t);
     }
     function Ce(e, t) {
      void 0 === e.innerComments ? (e.innerComments = t) : e.innerComments.unshift(...t);
     }
     function Te(e, t, r) {
      let n = null,
       s = t.length;
      for (; null === n && s > 0; ) n = t[--s];
      null === n || n.start > r.start ? Ce(e, r.comments) : Ee(n, r.comments);
     }
     var we = class extends ve {
       addComment(e) {
        this.filename && (e.loc.filename = this.filename), this.state.comments.push(e);
       }
       processComment(e) {
        let { commentStack: t } = this.state,
         r = t.length;
        if (0 === r) return;
        let n = r - 1,
         s = t[n];
        s.start === e.end && ((s.leadingNode = e), n--);
        let { start: i } = e;
        for (; n >= 0; n--) {
         let r = t[n],
          s = r.end;
         if (!(s > i)) {
          s === i && (r.trailingNode = e);
          break;
         }
         (r.containingNode = e), this.finalizeComment(r), t.splice(n, 1);
        }
       }
       finalizeComment(e) {
        let { comments: t } = e;
        if (null !== e.leadingNode || null !== e.trailingNode)
         null !== e.leadingNode && Ee(e.leadingNode, t),
          null !== e.trailingNode &&
           (function (e, t) {
            void 0 === e.leadingComments ? (e.leadingComments = t) : e.leadingComments.unshift(...t);
           })(e.trailingNode, t);
        else {
         let { containingNode: r, start: n } = e;
         if (44 === this.input.charCodeAt(n - 1))
          switch (r.type) {
           case "ObjectExpression":
           case "ObjectPattern":
           case "RecordExpression":
            Te(r, r.properties, e);
            break;
           case "CallExpression":
           case "OptionalCallExpression":
            Te(r, r.arguments, e);
            break;
           case "FunctionDeclaration":
           case "FunctionExpression":
           case "ArrowFunctionExpression":
           case "ObjectMethod":
           case "ClassMethod":
           case "ClassPrivateMethod":
            Te(r, r.params, e);
            break;
           case "ArrayExpression":
           case "ArrayPattern":
           case "TupleExpression":
            Te(r, r.elements, e);
            break;
           case "ExportNamedDeclaration":
           case "ImportDeclaration":
            Te(r, r.specifiers, e);
            break;
           default:
            Ce(r, t);
          }
         else Ce(r, t);
        }
       }
       finalizeRemainingComments() {
        let { commentStack: e } = this.state;
        for (let t = e.length - 1; t >= 0; t--) this.finalizeComment(e[t]);
        this.state.commentStack = [];
       }
       resetPreviousNodeTrailingComments(e) {
        let { commentStack: t } = this.state,
         { length: r } = t;
        if (0 === r) return;
        let n = t[r - 1];
        n.leadingNode === e && (n.leadingNode = null);
       }
       resetPreviousIdentifierLeadingComments(e) {
        let { commentStack: t } = this.state,
         { length: r } = t;
        0 !== r && (t[r - 1].trailingNode === e ? (t[r - 1].trailingNode = null) : r >= 2 && t[r - 2].trailingNode === e && (t[r - 2].trailingNode = null));
       }
       takeSurroundingComments(e, t, r) {
        let { commentStack: n } = this.state,
         s = n.length;
        if (0 === s) return;
        let i = s - 1;
        for (; i >= 0; i--) {
         let s = n[i],
          a = s.end;
         if (s.start === r) s.leadingNode = e;
         else if (a === t) s.trailingNode = e;
         else if (a < t) break;
        }
       }
      },
      Se = /\r\n?|[\n\u2028\u2029]/,
      Ae = new RegExp(Se.source, "g");
     function Fe(e) {
      switch (e) {
       case 10:
       case 13:
       case 8232:
       case 8233:
        return !0;
       default:
        return !1;
      }
     }
     var ke = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
      Pe = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g,
      Ie = new RegExp("(?=(" + Pe.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
     function Ne(e) {
      switch (e) {
       case 9:
       case 11:
       case 12:
       case 32:
       case 160:
       case 5760:
       case 8192:
       case 8193:
       case 8194:
       case 8195:
       case 8196:
       case 8197:
       case 8198:
       case 8199:
       case 8200:
       case 8201:
       case 8202:
       case 8239:
       case 8287:
       case 12288:
       case 65279:
        return !0;
       default:
        return !1;
      }
     }
     var Be = class e {
       constructor() {
        (this.strict = void 0), (this.curLine = void 0), (this.lineStart = void 0), (this.startLoc = void 0), (this.endLoc = void 0), (this.errors = []), (this.potentialArrowAt = -1), (this.noArrowAt = []), (this.noArrowParamsConversionAt = []), (this.maybeInArrowParameters = !1), (this.inType = !1), (this.noAnonFunctionType = !1), (this.hasFlowComment = !1), (this.isAmbientContext = !1), (this.inAbstractClass = !1), (this.inDisallowConditionalTypesContext = !1), (this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }), (this.soloAwait = !1), (this.inFSharpPipelineDirectBody = !1), (this.labels = []), (this.comments = []), (this.commentStack = []), (this.pos = 0), (this.type = 139), (this.value = null), (this.start = 0), (this.end = 0), (this.lastTokEndLoc = null), (this.lastTokStartLoc = null), (this.lastTokStart = 0), (this.context = [E.brace]), (this.canStartJSXElement = !0), (this.containsEsc = !1), (this.firstInvalidTemplateEscapePos = null), (this.strictErrors = new Map()), (this.tokensLength = 0);
       }
       init({ strictMode: e, sourceType: t, startLine: n, startColumn: s }) {
        (this.strict = !1 !== e && (!0 === e || "module" === t)), (this.curLine = n), (this.lineStart = -s), (this.startLoc = this.endLoc = new r(n, s, 0));
       }
       curPosition() {
        return new r(this.curLine, this.pos - this.lineStart, this.pos);
       }
       clone(t) {
        let r = new e(),
         n = Object.keys(this);
        for (let e = 0, s = n.length; e < s; e++) {
         let s = n[e],
          i = this[s];
         !t && Array.isArray(i) && (i = i.slice()), (r[s] = i);
        }
        return r;
       }
      },
      _e = function (e) {
       return e >= 48 && e <= 57;
      },
      Le = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
      Oe = { bin: (e) => 48 === e || 49 === e, oct: (e) => e >= 48 && e <= 55, dec: (e) => e >= 48 && e <= 57, hex: (e) => (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102) };
     function Me(e, t, r, n, s, i) {
      let a = r,
       o = n,
       u = s,
       l = "",
       p = null,
       c = r,
       { length: h } = t;
      for (;;) {
       if (r >= h) {
        i.unterminated(a, o, u), (l += t.slice(c, r));
        break;
       }
       let d = t.charCodeAt(r);
       if (je(e, d, t, r)) {
        l += t.slice(c, r);
        break;
       }
       if (92 === d) {
        l += t.slice(c, r);
        let a = Re(t, r, n, s, "template" === e, i);
        null !== a.ch || p ? (l += a.ch) : (p = { pos: r, lineStart: n, curLine: s }), ({ pos: r, lineStart: n, curLine: s } = a), (c = r);
       } else 8232 === d || 8233 === d ? (++s, (n = ++r)) : 10 === d || 13 === d ? ("template" === e ? ((l += t.slice(c, r) + "\n"), ++r, 13 === d && 10 === t.charCodeAt(r) && ++r, ++s, (c = n = r)) : i.unterminated(a, o, u)) : ++r;
      }
      return { pos: r, str: l, firstInvalidLoc: p, lineStart: n, curLine: s, containsInvalid: !!p };
     }
     function je(e, t, r, n) {
      return "template" === e ? 96 === t || (36 === t && 123 === r.charCodeAt(n + 1)) : t === ("double" === e ? 34 : 39);
     }
     function Re(e, t, r, n, s, i) {
      let a = !s;
      t++;
      let o = (e) => ({ pos: t, ch: e, lineStart: r, curLine: n }),
       u = e.charCodeAt(t++);
      switch (u) {
       case 110:
        return o("\n");
       case 114:
        return o("\r");
       case 120: {
        let s;
        return ({ code: s, pos: t } = qe(e, t, r, n, 2, !1, a, i)), o(null === s ? null : String.fromCharCode(s));
       }
       case 117: {
        let s;
        return ({ code: s, pos: t } = $e(e, t, r, n, a, i)), o(null === s ? null : String.fromCodePoint(s));
       }
       case 116:
        return o("\t");
       case 98:
        return o("\b");
       case 118:
        return o("\v");
       case 102:
        return o("\f");
       case 13:
        10 === e.charCodeAt(t) && ++t;
       case 10:
        (r = t), ++n;
       case 8232:
       case 8233:
        return o("");
       case 56:
       case 57:
        if (s) return o(null);
        i.strictNumericEscape(t - 1, r, n);
       default:
        if (u >= 48 && u <= 55) {
         let a = t - 1,
          u = e.slice(a, t + 2).match(/^[0-7]+/)[0],
          l = parseInt(u, 8);
         l > 255 && ((u = u.slice(0, -1)), (l = parseInt(u, 8))), (t += u.length - 1);
         let p = e.charCodeAt(t);
         if ("0" !== u || 56 === p || 57 === p) {
          if (s) return o(null);
          i.strictNumericEscape(a, r, n);
         }
         return o(String.fromCharCode(l));
        }
        return o(String.fromCharCode(u));
      }
     }
     function qe(e, t, r, n, s, i, a, o) {
      let u,
       l = t;
      return ({ n: u, pos: t } = Ue(e, t, r, n, 16, s, i, !1, o, !a)), null === u && (a ? o.invalidEscapeSequence(l, r, n) : (t = l - 1)), { code: u, pos: t };
     }
     function Ue(e, t, r, n, s, i, a, o, u, l) {
      let p = t,
       c = 16 === s ? Le.hex : Le.decBinOct,
       h = 16 === s ? Oe.hex : 10 === s ? Oe.dec : 8 === s ? Oe.oct : Oe.bin,
       d = !1,
       f = 0;
      for (let m = 0, y = i ?? 1 / 0; m < y; ++m) {
       let i,
        p = e.charCodeAt(t);
       if (95 !== p || "bail" === o) {
        if (((i = p >= 97 ? p - 97 + 10 : p >= 65 ? p - 65 + 10 : _e(p) ? p - 48 : 1 / 0), i >= s)) {
         if (i <= 9 && l) return { n: null, pos: t };
         if (i <= 9 && u.invalidDigit(t, r, n, s)) i = 0;
         else {
          if (!a) break;
          (i = 0), (d = !0);
         }
        }
        ++t, (f = f * s + i);
       } else {
        let s = e.charCodeAt(t - 1),
         i = e.charCodeAt(t + 1);
        if (o) {
         if (Number.isNaN(i) || !h(i) || c.has(s) || c.has(i)) {
          if (l) return { n: null, pos: t };
          u.unexpectedNumericSeparator(t, r, n);
         }
        } else {
         if (l) return { n: null, pos: t };
         u.numericSeparatorInEscapeSequence(t, r, n);
        }
        ++t;
       }
      }
      return t === p || (null != i && t - p !== i) || d ? { n: null, pos: t } : { n: f, pos: t };
     }
     function $e(e, t, r, n, s, i) {
      let a;
      if (123 === e.charCodeAt(t)) {
       if ((++t, ({ code: a, pos: t } = qe(e, t, r, n, e.indexOf("}", t) - t, !0, s, i)), ++t, null !== a && a > 1114111)) {
        if (!s) return { code: null, pos: t };
        i.invalidCodePoint(t, r, n);
       }
      } else ({ code: a, pos: t } = qe(e, t, r, n, 4, !1, s, i));
      return { code: a, pos: t };
     }
     var Ve = ["at"],
      ze = ["at"];
     function We(e, t, n) {
      return new r(n, e - t, e);
     }
     var He = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
      Je = class {
       constructor(e) {
        (this.type = e.type), (this.value = e.value), (this.start = e.start), (this.end = e.end), (this.loc = new n(e.startLoc, e.endLoc));
       }
      },
      Ke = class extends we {
       constructor(e, t) {
        super(),
         (this.isLookahead = void 0),
         (this.tokens = []),
         (this.errorHandlers_readInt = { invalidDigit: (e, t, r, n) => !!this.options.errorRecovery && (this.raise(g.InvalidDigit, { at: We(e, t, r), radix: n }), !0), numericSeparatorInEscapeSequence: this.errorBuilder(g.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(g.UnexpectedNumericSeparator) }),
         (this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(g.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(g.InvalidCodePoint) })),
         (this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (e, t, r) => {
           this.recordStrictModeErrors(g.StrictNumericEscape, { at: We(e, t, r) });
          },
          unterminated: (e, t, r) => {
           throw this.raise(g.UnterminatedString, { at: We(e - 1, t, r) });
          },
         })),
         (this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(g.StrictNumericEscape),
          unterminated: (e, t, r) => {
           throw this.raise(g.UnterminatedTemplate, { at: We(e, t, r) });
          },
         })),
         (this.state = new Be()),
         this.state.init(e),
         (this.input = t),
         (this.length = t.length),
         (this.isLookahead = !1);
       }
       pushToken(e) {
        (this.tokens.length = this.state.tokensLength), this.tokens.push(e), ++this.state.tokensLength;
       }
       next() {
        this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Je(this.state)), (this.state.lastTokStart = this.state.start), (this.state.lastTokEndLoc = this.state.endLoc), (this.state.lastTokStartLoc = this.state.startLoc), this.nextToken();
       }
       eat(e) {
        return !!this.match(e) && (this.next(), !0);
       }
       match(e) {
        return this.state.type === e;
       }
       createLookaheadState(e) {
        return { pos: e.pos, value: null, type: e.type, start: e.start, end: e.end, context: [this.curContext()], inType: e.inType, startLoc: e.startLoc, lastTokEndLoc: e.lastTokEndLoc, curLine: e.curLine, lineStart: e.lineStart, curPosition: e.curPosition };
       }
       lookahead() {
        let e = this.state;
        (this.state = this.createLookaheadState(e)), (this.isLookahead = !0), this.nextToken(), (this.isLookahead = !1);
        let t = this.state;
        return (this.state = e), t;
       }
       nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
       }
       nextTokenStartSince(e) {
        return (ke.lastIndex = e), ke.test(this.input) ? ke.lastIndex : e;
       }
       lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
       }
       nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
       }
       nextTokenInLineStartSince(e) {
        return (Pe.lastIndex = e), Pe.test(this.input) ? Pe.lastIndex : e;
       }
       lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
       }
       codePointAtPos(e) {
        let t = this.input.charCodeAt(e);
        if (55296 == (64512 & t) && ++e < this.input.length) {
         let r = this.input.charCodeAt(e);
         56320 == (64512 & r) && (t = 65536 + ((1023 & t) << 10) + (1023 & r));
        }
        return t;
       }
       setStrict(e) {
        (this.state.strict = e), e && (this.state.strictErrors.forEach(([e, t]) => this.raise(e, { at: t })), this.state.strictErrors.clear());
       }
       curContext() {
        return this.state.context[this.state.context.length - 1];
       }
       nextToken() {
        this.skipSpace(), (this.state.start = this.state.pos), this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(139) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
       }
       skipBlockComment(e) {
        let t;
        this.isLookahead || (t = this.state.curPosition());
        let r = this.state.pos,
         s = this.input.indexOf(e, r + 2);
        if (-1 === s) throw this.raise(g.UnterminatedComment, { at: this.state.curPosition() });
        for (this.state.pos = s + e.length, Ae.lastIndex = r + 2; Ae.test(this.input) && Ae.lastIndex <= s; ) ++this.state.curLine, (this.state.lineStart = Ae.lastIndex);
        if (this.isLookahead) return;
        let i = { type: "CommentBlock", value: this.input.slice(r + 2, s), start: r, end: s + e.length, loc: new n(t, this.state.curPosition()) };
        return this.options.tokens && this.pushToken(i), i;
       }
       skipLineComment(e) {
        let t,
         r = this.state.pos;
        this.isLookahead || (t = this.state.curPosition());
        let s = this.input.charCodeAt((this.state.pos += e));
        if (this.state.pos < this.length) for (; !Fe(s) && ++this.state.pos < this.length; ) s = this.input.charCodeAt(this.state.pos);
        if (this.isLookahead) return;
        let i = this.state.pos,
         a = { type: "CommentLine", value: this.input.slice(r + e, i), start: r, end: i, loc: new n(t, this.state.curPosition()) };
        return this.options.tokens && this.pushToken(a), a;
       }
       skipSpace() {
        let e = this.state.pos,
         t = [];
        e: for (; this.state.pos < this.length; ) {
         let r = this.input.charCodeAt(this.state.pos);
         switch (r) {
          case 32:
          case 160:
          case 9:
           ++this.state.pos;
           break;
          case 13:
           10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
           ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos);
           break;
          case 47:
           switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42: {
             let e = this.skipBlockComment("*/");
             void 0 !== e && (this.addComment(e), this.options.attachComment && t.push(e));
             break;
            }
            case 47: {
             let e = this.skipLineComment(2);
             void 0 !== e && (this.addComment(e), this.options.attachComment && t.push(e));
             break;
            }
            default:
             break e;
           }
           break;
          default:
           if (Ne(r)) ++this.state.pos;
           else if (45 === r && !this.inModule && this.options.annexB) {
            let r = this.state.pos;
            if (45 !== this.input.charCodeAt(r + 1) || 62 !== this.input.charCodeAt(r + 2) || !(0 === e || this.state.lineStart > e)) break e;
            {
             let e = this.skipLineComment(3);
             void 0 !== e && (this.addComment(e), this.options.attachComment && t.push(e));
            }
           } else {
            if (60 !== r || this.inModule || !this.options.annexB) break e;
            {
             let e = this.state.pos;
             if (33 !== this.input.charCodeAt(e + 1) || 45 !== this.input.charCodeAt(e + 2) || 45 !== this.input.charCodeAt(e + 3)) break e;
             {
              let e = this.skipLineComment(4);
              void 0 !== e && (this.addComment(e), this.options.attachComment && t.push(e));
             }
            }
           }
         }
        }
        if (t.length > 0) {
         let r = { start: e, end: this.state.pos, comments: t, leadingNode: null, trailingNode: null, containingNode: null };
         this.state.commentStack.push(r);
        }
       }
       finishToken(e, t) {
        (this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition());
        let r = this.state.type;
        (this.state.type = e), (this.state.value = t), this.isLookahead || this.updateContext(r);
       }
       replaceToken(e) {
        (this.state.type = e), this.updateContext();
       }
       readToken_numberSign() {
        if (0 === this.state.pos && this.readToken_interpreter()) return;
        let e = this.state.pos + 1,
         t = this.codePointAtPos(e);
        if (t >= 48 && t <= 57) throw this.raise(g.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
        if (123 === t || (91 === t && this.hasPlugin("recordAndTuple"))) {
         if ((this.expectPlugin("recordAndTuple"), "bar" === this.getPluginOption("recordAndTuple", "syntaxType"))) throw this.raise(123 === t ? g.RecordExpressionHashIncorrectStartSyntaxType : g.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
         (this.state.pos += 2), 123 === t ? this.finishToken(7) : this.finishToken(1);
        } else ie(t) ? (++this.state.pos, this.finishToken(138, this.readWord1(t))) : 92 === t ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
       }
       readToken_dot() {
        let e = this.input.charCodeAt(this.state.pos + 1);
        e >= 48 && e <= 57 ? this.readNumber(!0) : 46 === e && 46 === this.input.charCodeAt(this.state.pos + 2) ? ((this.state.pos += 3), this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
       }
       readToken_slash() {
        61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
       }
       readToken_interpreter() {
        if (0 !== this.state.pos || this.length < 2) return !1;
        let e = this.input.charCodeAt(this.state.pos + 1);
        if (33 !== e) return !1;
        let t = this.state.pos;
        for (this.state.pos += 1; !Fe(e) && ++this.state.pos < this.length; ) e = this.input.charCodeAt(this.state.pos);
        let r = this.input.slice(t + 2, this.state.pos);
        return this.finishToken(28, r), !0;
       }
       readToken_mult_modulo(e) {
        let t = 42 === e ? 55 : 54,
         r = 1,
         n = this.input.charCodeAt(this.state.pos + 1);
        42 === e && 42 === n && (r++, (n = this.input.charCodeAt(this.state.pos + 2)), (t = 57)), 61 === n && !this.state.inType && (r++, (t = 37 === e ? 33 : 30)), this.finishOp(t, r);
       }
       readToken_pipe_amp(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        if (t !== e) {
         if (124 === e) {
          if (62 === t) return void this.finishOp(39, 2);
          if (this.hasPlugin("recordAndTuple") && 125 === t) {
           if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
           return (this.state.pos += 2), void this.finishToken(9);
          }
          if (this.hasPlugin("recordAndTuple") && 93 === t) {
           if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
           return (this.state.pos += 2), void this.finishToken(4);
          }
         }
         61 !== t ? this.finishOp(124 === e ? 43 : 45, 1) : this.finishOp(30, 2);
        } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e ? 41 : 42, 2);
       }
       readToken_caret() {
        let e = this.input.charCodeAt(this.state.pos + 1);
        61 !== e || this.state.inType ? (94 === e && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1)) : this.finishOp(32, 2);
       }
       readToken_atSign() {
        64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
       }
       readToken_plus_min(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        t !== e ? (61 === t ? this.finishOp(30, 2) : this.finishOp(53, 1)) : this.finishOp(34, 2);
       }
       readToken_lt() {
        let { pos: e } = this.state,
         t = this.input.charCodeAt(e + 1);
        if (60 === t) return 61 === this.input.charCodeAt(e + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
        61 !== t ? this.finishOp(47, 1) : this.finishOp(49, 2);
       }
       readToken_gt() {
        let { pos: e } = this.state,
         t = this.input.charCodeAt(e + 1);
        if (62 === t) {
         let t = 62 === this.input.charCodeAt(e + 2) ? 3 : 2;
         return 61 === this.input.charCodeAt(e + t) ? void this.finishOp(30, t + 1) : void this.finishOp(52, t);
        }
        61 !== t ? this.finishOp(48, 1) : this.finishOp(49, 2);
       }
       readToken_eq_excl(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        if (61 !== t) return 61 === e && 62 === t ? ((this.state.pos += 2), void this.finishToken(19)) : void this.finishOp(61 === e ? 29 : 35, 1);
        this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
       }
       readToken_question() {
        let e = this.input.charCodeAt(this.state.pos + 1),
         t = this.input.charCodeAt(this.state.pos + 2);
        63 === e ? (61 === t ? this.finishOp(30, 3) : this.finishOp(40, 2)) : 46 !== e || (t >= 48 && t <= 57) ? (++this.state.pos, this.finishToken(17)) : ((this.state.pos += 2), this.finishToken(18));
       }
       getTokenFromCode(e) {
        switch (e) {
         case 46:
          return void this.readToken_dot();
         case 40:
          return ++this.state.pos, void this.finishToken(10);
         case 41:
          return ++this.state.pos, void this.finishToken(11);
         case 59:
          return ++this.state.pos, void this.finishToken(13);
         case 44:
          return ++this.state.pos, void this.finishToken(12);
         case 91:
          if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
           if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
           (this.state.pos += 2), this.finishToken(2);
          } else ++this.state.pos, this.finishToken(0);
          return;
         case 93:
          return ++this.state.pos, void this.finishToken(3);
         case 123:
          if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
           if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
           (this.state.pos += 2), this.finishToken(6);
          } else ++this.state.pos, this.finishToken(5);
          return;
         case 125:
          return ++this.state.pos, void this.finishToken(8);
         case 58:
          return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
         case 63:
          return void this.readToken_question();
         case 96:
          return void this.readTemplateToken();
         case 48: {
          let e = this.input.charCodeAt(this.state.pos + 1);
          if (120 === e || 88 === e) return void this.readRadixNumber(16);
          if (111 === e || 79 === e) return void this.readRadixNumber(8);
          if (98 === e || 66 === e) return void this.readRadixNumber(2);
         }
         case 49:
         case 50:
         case 51:
         case 52:
         case 53:
         case 54:
         case 55:
         case 56:
         case 57:
          return void this.readNumber(!1);
         case 34:
         case 39:
          return void this.readString(e);
         case 47:
          return void this.readToken_slash();
         case 37:
         case 42:
          return void this.readToken_mult_modulo(e);
         case 124:
         case 38:
          return void this.readToken_pipe_amp(e);
         case 94:
          return void this.readToken_caret();
         case 43:
         case 45:
          return void this.readToken_plus_min(e);
         case 60:
          return void this.readToken_lt();
         case 62:
          return void this.readToken_gt();
         case 61:
         case 33:
          return void this.readToken_eq_excl(e);
         case 126:
          return void this.finishOp(36, 1);
         case 64:
          return void this.readToken_atSign();
         case 35:
          return void this.readToken_numberSign();
         case 92:
          return void this.readWord();
         default:
          if (ie(e)) return void this.readWord(e);
        }
        throw this.raise(g.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(e) });
       }
       finishOp(e, t) {
        let r = this.input.slice(this.state.pos, this.state.pos + t);
        (this.state.pos += t), this.finishToken(e, r);
       }
       readRegexp() {
        let e,
         t,
         r = this.state.startLoc,
         n = this.state.start + 1,
         { pos: i } = this.state;
        for (; ; ++i) {
         if (i >= this.length) throw this.raise(g.UnterminatedRegExp, { at: s(r, 1) });
         let n = this.input.charCodeAt(i);
         if (Fe(n)) throw this.raise(g.UnterminatedRegExp, { at: s(r, 1) });
         if (e) e = !1;
         else {
          if (91 === n) t = !0;
          else if (93 === n && t) t = !1;
          else if (47 === n && !t) break;
          e = 92 === n;
         }
        }
        let a = this.input.slice(n, i);
        ++i;
        let o = "",
         u = () => s(r, i + 2 - n);
        for (; i < this.length; ) {
         let e = this.codePointAtPos(i),
          t = String.fromCharCode(e);
         if (He.has(e)) 118 === e ? o.includes("u") && this.raise(g.IncompatibleRegExpUVFlags, { at: u() }) : 117 === e && o.includes("v") && this.raise(g.IncompatibleRegExpUVFlags, { at: u() }), o.includes(t) && this.raise(g.DuplicateRegExpFlags, { at: u() });
         else {
          if (!ae(e) && 92 !== e) break;
          this.raise(g.MalformedRegExpFlags, { at: u() });
         }
         ++i, (o += t);
        }
        (this.state.pos = i), this.finishToken(137, { pattern: a, flags: o });
       }
       readInt(e, t, r = !1, n = !0) {
        let { n: s, pos: i } = Ue(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, t, r, n, this.errorHandlers_readInt, !1);
        return (this.state.pos = i), s;
       }
       readRadixNumber(e) {
        let t = this.state.curPosition(),
         r = !1;
        this.state.pos += 2;
        let n = this.readInt(e);
        null == n && this.raise(g.InvalidDigit, { at: s(t, 2), radix: e });
        let i = this.input.charCodeAt(this.state.pos);
        if (110 === i) ++this.state.pos, (r = !0);
        else if (109 === i) throw this.raise(g.InvalidDecimal, { at: t });
        if (ie(this.codePointAtPos(this.state.pos))) throw this.raise(g.NumberIdentifier, { at: this.state.curPosition() });
        if (r) {
         let e = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, "");
         this.finishToken(135, e);
        } else this.finishToken(134, n);
       }
       readNumber(e) {
        let t = this.state.pos,
         r = this.state.curPosition(),
         n = !1,
         i = !1,
         a = !1,
         o = !1,
         u = !1;
        !e && null === this.readInt(10) && this.raise(g.InvalidNumber, { at: this.state.curPosition() });
        let l = this.state.pos - t >= 2 && 48 === this.input.charCodeAt(t);
        if (l) {
         let e = this.input.slice(t, this.state.pos);
         if ((this.recordStrictModeErrors(g.StrictOctalLiteral, { at: r }), !this.state.strict)) {
          let t = e.indexOf("_");
          t > 0 && this.raise(g.ZeroDigitNumericSeparator, { at: s(r, t) });
         }
         u = l && !/[89]/.test(e);
        }
        let p = this.input.charCodeAt(this.state.pos);
        if ((46 === p && !u && (++this.state.pos, this.readInt(10), (n = !0), (p = this.input.charCodeAt(this.state.pos))), (69 === p || 101 === p) && !u && ((p = this.input.charCodeAt(++this.state.pos)), (43 === p || 45 === p) && ++this.state.pos, null === this.readInt(10) && this.raise(g.InvalidOrMissingExponent, { at: r }), (n = !0), (o = !0), (p = this.input.charCodeAt(this.state.pos))), 110 === p && ((n || l) && this.raise(g.InvalidBigIntLiteral, { at: r }), ++this.state.pos, (i = !0)), 109 === p && (this.expectPlugin("decimal", this.state.curPosition()), (o || l) && this.raise(g.InvalidDecimal, { at: r }), ++this.state.pos, (a = !0)), ie(this.codePointAtPos(this.state.pos)))) throw this.raise(g.NumberIdentifier, { at: this.state.curPosition() });
        let c = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
        if (i) return void this.finishToken(135, c);
        if (a) return void this.finishToken(136, c);
        let h = u ? parseInt(c, 8) : parseFloat(c);
        this.finishToken(134, h);
       }
       readCodePoint(e) {
        let { code: t, pos: r } = $e(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
        return (this.state.pos = r), t;
       }
       readString(e) {
        let { str: t, pos: r, curLine: n, lineStart: s } = Me(34 === e ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        (this.state.pos = r + 1), (this.state.lineStart = s), (this.state.curLine = n), this.finishToken(133, t);
       }
       readTemplateContinuation() {
        this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
       }
       readTemplateToken() {
        let e = this.input[this.state.pos],
         { str: t, firstInvalidLoc: n, pos: s, curLine: i, lineStart: a } = Me("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        (this.state.pos = s + 1), (this.state.lineStart = a), (this.state.curLine = i), n && (this.state.firstInvalidTemplateEscapePos = new r(n.curLine, n.pos - n.lineStart, n.pos)), 96 === this.input.codePointAt(s) ? this.finishToken(24, n ? null : e + t + "`") : (this.state.pos++, this.finishToken(25, n ? null : e + t + "${"));
       }
       recordStrictModeErrors(e, { at: t }) {
        let r = t.index;
        this.state.strict && !this.state.strictErrors.has(r) ? this.raise(e, { at: t }) : this.state.strictErrors.set(r, [e, t]);
       }
       readWord1(e) {
        this.state.containsEsc = !1;
        let t = "",
         r = this.state.pos,
         n = this.state.pos;
        for (void 0 !== e && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
         let e = this.codePointAtPos(this.state.pos);
         if (ae(e)) this.state.pos += e <= 65535 ? 1 : 2;
         else {
          if (92 !== e) break;
          {
           (this.state.containsEsc = !0), (t += this.input.slice(n, this.state.pos));
           let e = this.state.curPosition(),
            s = this.state.pos === r ? ie : ae;
           if (117 !== this.input.charCodeAt(++this.state.pos)) {
            this.raise(g.MissingUnicodeEscape, { at: this.state.curPosition() }), (n = this.state.pos - 1);
            continue;
           }
           ++this.state.pos;
           let i = this.readCodePoint(!0);
           null !== i && (s(i) || this.raise(g.EscapedCharNotAnIdentifier, { at: e }), (t += String.fromCodePoint(i))), (n = this.state.pos);
          }
         }
        }
        return t + this.input.slice(n, this.state.pos);
       }
       readWord(e) {
        let t = this.readWord1(e),
         r = k.get(t);
        void 0 !== r ? this.finishToken(r, K(r)) : this.finishToken(132, t);
       }
       checkKeywordEscapes() {
        let { type: e } = this.state;
        J(e) && this.state.containsEsc && this.raise(g.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: K(e) });
       }
       raise(e, n) {
        let { at: s } = n,
         i = t(n, Ve),
         a = e({ loc: s instanceof r ? s : s.loc.start, details: i });
        if (!this.options.errorRecovery) throw a;
        return this.isLookahead || this.state.errors.push(a), a;
       }
       raiseOverwrite(e, n) {
        let { at: s } = n,
         i = t(n, ze),
         a = s instanceof r ? s : s.loc.start,
         o = a.index,
         u = this.state.errors;
        for (let t = u.length - 1; t >= 0; t--) {
         let r = u[t];
         if (r.loc.index === o) return (u[t] = e({ loc: a, details: i }));
         if (r.loc.index < o) break;
        }
        return this.raise(e, n);
       }
       updateContext(e) {}
       unexpected(e, t) {
        throw this.raise(g.UnexpectedToken, { expected: t ? K(t) : null, at: e ?? this.state.startLoc });
       }
       expectPlugin(e, t) {
        if (this.hasPlugin(e)) return !0;
        throw this.raise(g.MissingPlugin, { at: t ?? this.state.startLoc, missingPlugin: [e] });
       }
       expectOnePlugin(e) {
        if (!e.some((e) => this.hasPlugin(e))) throw this.raise(g.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: e });
       }
       errorBuilder(e) {
        return (t, r, n) => {
         this.raise(e, { at: We(t, r, n) });
        };
       }
      },
      Ge = class {
       constructor() {
        (this.privateNames = new Set()), (this.loneAccessors = new Map()), (this.undefinedPrivateNames = new Map());
       }
      },
      Xe = class {
       constructor(e) {
        (this.parser = void 0), (this.stack = []), (this.undefinedPrivateNames = new Map()), (this.parser = e);
       }
       current() {
        return this.stack[this.stack.length - 1];
       }
       enter() {
        this.stack.push(new Ge());
       }
       exit() {
        let e = this.stack.pop(),
         t = this.current();
        for (let [r, n] of Array.from(e.undefinedPrivateNames)) t ? t.undefinedPrivateNames.has(r) || t.undefinedPrivateNames.set(r, n) : this.parser.raise(g.InvalidPrivateFieldResolution, { at: n, identifierName: r });
       }
       declarePrivateName(e, t, r) {
        let { privateNames: n, loneAccessors: s, undefinedPrivateNames: i } = this.current(),
         a = n.has(e);
        if (3 & t) {
         let r = a && s.get(e);
         if (r) {
          (a = (3 & r) === (3 & t) || (4 & r) !== (4 & t)), a || s.delete(e);
         } else a || s.set(e, t);
        }
        a && this.parser.raise(g.PrivateNameRedeclaration, { at: r, identifierName: e }), n.add(e), i.delete(e);
       }
       usePrivateName(e, t) {
        let r;
        for (r of this.stack) if (r.privateNames.has(e)) return;
        r ? r.undefinedPrivateNames.set(e, t) : this.parser.raise(g.InvalidPrivateFieldResolution, { at: t, identifierName: e });
       }
      },
      Ye = class {
       constructor(e = 0) {
        this.type = e;
       }
       canBeArrowParameterDeclaration() {
        return 2 === this.type || 1 === this.type;
       }
       isCertainlyParameterDeclaration() {
        return 3 === this.type;
       }
      },
      Qe = class extends Ye {
       constructor(e) {
        super(e), (this.declarationErrors = new Map());
       }
       recordDeclarationError(e, { at: t }) {
        let r = t.index;
        this.declarationErrors.set(r, [e, t]);
       }
       clearDeclarationError(e) {
        this.declarationErrors.delete(e);
       }
       iterateErrors(e) {
        this.declarationErrors.forEach(e);
       }
      },
      Ze = class {
       constructor(e) {
        (this.parser = void 0), (this.stack = [new Ye()]), (this.parser = e);
       }
       enter(e) {
        this.stack.push(e);
       }
       exit() {
        this.stack.pop();
       }
       recordParameterInitializerError(e, { at: t }) {
        let r = { at: t.loc.start },
         { stack: n } = this,
         s = n.length - 1,
         i = n[s];
        for (; !i.isCertainlyParameterDeclaration(); ) {
         if (!i.canBeArrowParameterDeclaration()) return;
         i.recordDeclarationError(e, r), (i = n[--s]);
        }
        this.parser.raise(e, r);
       }
       recordArrowParameterBindingError(e, { at: t }) {
        let { stack: r } = this,
         n = r[r.length - 1],
         s = { at: t.loc.start };
        if (n.isCertainlyParameterDeclaration()) this.parser.raise(e, s);
        else {
         if (!n.canBeArrowParameterDeclaration()) return;
         n.recordDeclarationError(e, s);
        }
       }
       recordAsyncArrowParametersError({ at: e }) {
        let { stack: t } = this,
         r = t.length - 1,
         n = t[r];
        for (; n.canBeArrowParameterDeclaration(); ) 2 === n.type && n.recordDeclarationError(g.AwaitBindingIdentifier, { at: e }), (n = t[--r]);
       }
       validateAsPattern() {
        let { stack: e } = this,
         t = e[e.length - 1];
        t.canBeArrowParameterDeclaration() &&
         t.iterateErrors(([t, r]) => {
          this.parser.raise(t, { at: r });
          let n = e.length - 2,
           s = e[n];
          for (; s.canBeArrowParameterDeclaration(); ) s.clearDeclarationError(r.index), (s = e[--n]);
         });
       }
      };
     function et() {
      return new Ye();
     }
     var tt = class {
      constructor() {
       this.stacks = [];
      }
      enter(e) {
       this.stacks.push(e);
      }
      exit() {
       this.stacks.pop();
      }
      currentFlags() {
       return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
       return (2 & this.currentFlags()) > 0;
      }
      get hasYield() {
       return (1 & this.currentFlags()) > 0;
      }
      get hasReturn() {
       return (4 & this.currentFlags()) > 0;
      }
      get hasIn() {
       return (8 & this.currentFlags()) > 0;
      }
     };
     function rt(e, t) {
      return (e ? 2 : 0) | (t ? 1 : 0);
     }
     var nt = class extends Ke {
       addExtra(e, t, r, n = !0) {
        if (!e) return;
        let s = (e.extra = e.extra || {});
        n ? (s[t] = r) : Object.defineProperty(s, t, { enumerable: n, value: r });
       }
       isContextual(e) {
        return this.state.type === e && !this.state.containsEsc;
       }
       isUnparsedContextual(e, t) {
        let r = e + t.length;
        if (this.input.slice(e, r) === t) {
         let e = this.input.charCodeAt(r);
         return !(ae(e) || 55296 == (64512 & e));
        }
        return !1;
       }
       isLookaheadContextual(e) {
        let t = this.nextTokenStart();
        return this.isUnparsedContextual(t, e);
       }
       eatContextual(e) {
        return !!this.isContextual(e) && (this.next(), !0);
       }
       expectContextual(e, t) {
        if (!this.eatContextual(e)) {
         if (null != t) throw this.raise(t, { at: this.state.startLoc });
         this.unexpected(null, e);
        }
       }
       canInsertSemicolon() {
        return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
       }
       hasPrecedingLineBreak() {
        return Se.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
       }
       hasFollowingLineBreak() {
        return (Ie.lastIndex = this.state.end), Ie.test(this.input);
       }
       isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
       }
       semicolon(e = !0) {
        (e ? this.isLineTerminator() : this.eat(13)) || this.raise(g.MissingSemicolon, { at: this.state.lastTokEndLoc });
       }
       expect(e, t) {
        this.eat(e) || this.unexpected(t, e);
       }
       tryParse(e, t = this.state.clone()) {
        let r = { node: null };
        try {
         let n = e((e = null) => {
          throw ((r.node = e), r);
         });
         if (this.state.errors.length > t.errors.length) {
          let e = this.state;
          return (this.state = t), (this.state.tokensLength = e.tokensLength), { node: n, error: e.errors[t.errors.length], thrown: !1, aborted: !1, failState: e };
         }
         return { node: n, error: null, thrown: !1, aborted: !1, failState: null };
        } catch (n) {
         let e = this.state;
         if (((this.state = t), n instanceof SyntaxError)) return { node: null, error: n, thrown: !0, aborted: !1, failState: e };
         if (n === r) return { node: r.node, error: null, thrown: !1, aborted: !0, failState: e };
         throw n;
        }
       }
       checkExpressionErrors(e, t) {
        if (!e) return !1;
        let { shorthandAssignLoc: r, doubleProtoLoc: n, privateKeyLoc: s, optionalParametersLoc: i } = e;
        if (!t) return !!(r || n || i || s);
        null != r && this.raise(g.InvalidCoverInitializedName, { at: r }), null != n && this.raise(g.DuplicateProto, { at: n }), null != s && this.raise(g.UnexpectedPrivateField, { at: s }), null != i && this.unexpected(i);
       }
       isLiteralPropertyName() {
        return z(this.state.type);
       }
       isPrivateName(e) {
        return "PrivateName" === e.type;
       }
       getPrivateNameSV(e) {
        return e.id.name;
       }
       hasPropertyAsPrivateName(e) {
        return ("MemberExpression" === e.type || "OptionalMemberExpression" === e.type) && this.isPrivateName(e.property);
       }
       isObjectProperty(e) {
        return "ObjectProperty" === e.type;
       }
       isObjectMethod(e) {
        return "ObjectMethod" === e.type;
       }
       initializeScopes(e = "module" === this.options.sourceType) {
        let t = this.state.labels;
        this.state.labels = [];
        let r = this.exportedIdentifiers;
        this.exportedIdentifiers = new Set();
        let n = this.inModule;
        this.inModule = e;
        let s = this.scope,
         i = this.getScopeHandler();
        this.scope = new i(this, e);
        let a = this.prodParam;
        this.prodParam = new tt();
        let o = this.classScope;
        this.classScope = new Xe(this);
        let u = this.expressionScope;
        return (
         (this.expressionScope = new Ze(this)),
         () => {
          (this.state.labels = t), (this.exportedIdentifiers = r), (this.inModule = n), (this.scope = s), (this.prodParam = a), (this.classScope = o), (this.expressionScope = u);
         }
        );
       }
       enterInitialScopes() {
        let e = 0;
        this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
       }
       checkDestructuringPrivate(e) {
        let { privateKeyLoc: t } = e;
        null !== t && this.expectPlugin("destructuringPrivate", t);
       }
      },
      st = class {
       constructor() {
        (this.shorthandAssignLoc = null), (this.doubleProtoLoc = null), (this.privateKeyLoc = null), (this.optionalParametersLoc = null);
       }
      },
      it = class {
       constructor(e, t, r) {
        (this.type = ""), (this.start = t), (this.end = 0), (this.loc = new n(r)), null != e && e.options.ranges && (this.range = [t, 0]), null != e && e.filename && (this.loc.filename = e.filename);
       }
      },
      at = it.prototype;
     function ot(e) {
      let { type: t, start: r, end: n, loc: s, range: i, extra: a, name: o } = e,
       u = Object.create(at);
      return (u.type = t), (u.start = r), (u.end = n), (u.loc = s), (u.range = i), (u.extra = a), (u.name = o), "Placeholder" === t && (u.expectedNode = e.expectedNode), u;
     }
     function ut(e) {
      let { type: t, start: r, end: n, loc: s, range: i, extra: a } = e;
      if ("Placeholder" === t)
       return (function (e) {
        return ot(e);
       })(e);
      let o = Object.create(at);
      return (o.type = t), (o.start = r), (o.end = n), (o.loc = s), (o.range = i), void 0 !== e.raw ? (o.raw = e.raw) : (o.extra = a), (o.value = e.value), o;
     }
     at.__clone = function () {
      let e = new it(void 0, this.start, this.loc.start),
       t = Object.keys(this);
      for (let r = 0, n = t.length; r < n; r++) {
       let n = t[r];
       "leadingComments" !== n && "trailingComments" !== n && "innerComments" !== n && (e[n] = this[n]);
      }
      return e;
     };
     var lt = class extends nt {
       startNode() {
        return new it(this, this.state.start, this.state.startLoc);
       }
       startNodeAt(e) {
        return new it(this, e.index, e);
       }
       startNodeAtNode(e) {
        return this.startNodeAt(e.loc.start);
       }
       finishNode(e, t) {
        return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
       }
       finishNodeAt(e, t, r) {
        return (e.type = t), (e.end = r.index), (e.loc.end = r), this.options.ranges && (e.range[1] = r.index), this.options.attachComment && this.processComment(e), e;
       }
       resetStartLocation(e, t) {
        (e.start = t.index), (e.loc.start = t), this.options.ranges && (e.range[0] = t.index);
       }
       resetEndLocation(e, t = this.state.lastTokEndLoc) {
        (e.end = t.index), (e.loc.end = t), this.options.ranges && (e.range[1] = t.index);
       }
       resetStartLocationFromNode(e, t) {
        this.resetStartLocation(e, t.loc.start);
       }
      },
      pt = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]),
      ct = y`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: e }) => `Cannot overwrite reserved type ${e}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: e, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, EnumDuplicateMemberName: ({ memberName: e, enumName: t }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, EnumInconsistentMemberValues: ({ enumName: e }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: e, enumName: t }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: e, memberName: t, explicitType: r }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: e, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: e, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, EnumInvalidMemberName: ({ enumName: e, memberName: t, suggestion: r }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`, EnumNumberMemberNotInitialized: ({ enumName: e, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: e }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: e }) => `Unexpected reserved type ${e}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: e, suggestion: t }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
     function ht(e) {
      return "type" === e.importKind || "typeof" === e.importKind;
     }
     var dt = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
     var ft = /\*?\s*@((?:no)?flow)\b/,
      mt = y`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: e }) => `Expected corresponding JSX closing tag for <${e}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: e, HTMLEntity: t }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
     function yt(e) {
      return !!e && ("JSXOpeningFragment" === e.type || "JSXClosingFragment" === e.type);
     }
     function gt(e) {
      if ("JSXIdentifier" === e.type) return e.name;
      if ("JSXNamespacedName" === e.type) return e.namespace.name + ":" + e.name.name;
      if ("JSXMemberExpression" === e.type) return gt(e.object) + "." + gt(e.property);
      throw new Error("Node had unexpected type: " + e.type);
     }
     var Dt = class extends ge {
       constructor(...e) {
        super(...e), (this.types = new Set()), (this.enums = new Set()), (this.constEnums = new Set()), (this.classes = new Set()), (this.exportOnlyBindings = new Set());
       }
      },
      xt = class extends De {
       constructor(...e) {
        super(...e), (this.importsStack = []);
       }
       createScope(e) {
        return this.importsStack.push(new Set()), new Dt(e);
       }
       enter(e) {
        256 == e && this.importsStack.push(new Set()), super.enter(e);
       }
       exit() {
        let e = super.exit();
        return 256 == e && this.importsStack.pop(), e;
       }
       hasImport(e, t) {
        let r = this.importsStack.length;
        if (this.importsStack[r - 1].has(e)) return !0;
        if (!t && r > 1) for (let n = 0; n < r - 1; n++) if (this.importsStack[n].has(e)) return !0;
        return !1;
       }
       declareName(e, t, r) {
        if (4096 & t) return this.hasImport(e, !0) && this.parser.raise(g.VarRedeclaration, { at: r, identifierName: e }), void this.importsStack[this.importsStack.length - 1].add(e);
        let n = this.currentScope();
        if (1024 & t) return this.maybeExportDefined(n, e), void n.exportOnlyBindings.add(e);
        super.declareName(e, t, r), 2 & t && (1 & t || (this.checkRedeclarationInScope(n, e, t, r), this.maybeExportDefined(n, e)), n.types.add(e)), 256 & t && n.enums.add(e), 512 & t && n.constEnums.add(e), 128 & t && n.classes.add(e);
       }
       isRedeclaredInScope(e, t, r) {
        if (e.enums.has(t)) {
         if (256 & r) {
          return !!(512 & r) !== e.constEnums.has(t);
         }
         return !0;
        }
        return 128 & r && e.classes.has(t) ? !!e.lexical.has(t) && !!(1 & r) : !!(2 & r && e.types.has(t)) || super.isRedeclaredInScope(e, t, r);
       }
       checkLocalExport(e) {
        let { name: t } = e;
        if (!this.hasImport(t)) {
         for (let e = this.scopeStack.length - 1; e >= 0; e--) {
          let r = this.scopeStack[e];
          if (r.types.has(t) || r.exportOnlyBindings.has(t)) return;
         }
         super.checkLocalExport(e);
        }
       }
      },
      bt = (e) => ("ParenthesizedExpression" === e.type ? bt(e.expression) : e),
      vt = class extends lt {
       toAssignable(e, t = !1) {
        var r, n;
        let s;
        switch ((("ParenthesizedExpression" === e.type || (null != (r = e.extra) && r.parenthesized)) && ((s = bt(e)), t ? ("Identifier" === s.type ? this.expressionScope.recordArrowParameterBindingError(g.InvalidParenthesizedAssignment, { at: e }) : "MemberExpression" !== s.type && !this.isOptionalMemberExpression(s) && this.raise(g.InvalidParenthesizedAssignment, { at: e })) : this.raise(g.InvalidParenthesizedAssignment, { at: e })), e.type)) {
         case "Identifier":
         case "ObjectPattern":
         case "ArrayPattern":
         case "AssignmentPattern":
         case "RestElement":
          break;
         case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let r = 0, n = e.properties.length, s = n - 1; r < n; r++) {
           var i;
           let n = e.properties[r],
            a = r === s;
           this.toAssignableObjectExpressionProp(n, a, t), a && "RestElement" === n.type && null != (i = e.extra) && i.trailingCommaLoc && this.raise(g.RestTrailingComma, { at: e.extra.trailingCommaLoc });
          }
          break;
         case "ObjectProperty": {
          let { key: r, value: n } = e;
          this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(n, t);
          break;
         }
         case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
         case "ArrayExpression":
          (e.type = "ArrayPattern"), this.toAssignableList(e.elements, null == (n = e.extra) ? void 0 : n.trailingCommaLoc, t);
          break;
         case "AssignmentExpression":
          "=" !== e.operator && this.raise(g.MissingEqInAssignment, { at: e.left.loc.end }), (e.type = "AssignmentPattern"), delete e.operator, this.toAssignable(e.left, t);
          break;
         case "ParenthesizedExpression":
          this.toAssignable(s, t);
        }
       }
       toAssignableObjectExpressionProp(e, t, r) {
        if ("ObjectMethod" === e.type) this.raise("get" === e.kind || "set" === e.kind ? g.PatternHasAccessor : g.PatternHasMethod, { at: e.key });
        else if ("SpreadElement" === e.type) {
         e.type = "RestElement";
         let n = e.argument;
         this.checkToRestConversion(n, !1), this.toAssignable(n, r), t || this.raise(g.RestTrailingComma, { at: e });
        } else this.toAssignable(e, r);
       }
       toAssignableList(e, t, r) {
        let n = e.length - 1;
        for (let s = 0; s <= n; s++) {
         let i = e[s];
         if (i) {
          if ("SpreadElement" === i.type) {
           i.type = "RestElement";
           let e = i.argument;
           this.checkToRestConversion(e, !0), this.toAssignable(e, r);
          } else this.toAssignable(i, r);
          "RestElement" === i.type && (s < n ? this.raise(g.RestTrailingComma, { at: i }) : t && this.raise(g.RestTrailingComma, { at: t }));
         }
        }
       }
       isAssignable(e, t) {
        switch (e.type) {
         case "Identifier":
         case "ObjectPattern":
         case "ArrayPattern":
         case "AssignmentPattern":
         case "RestElement":
          return !0;
         case "ObjectExpression": {
          let t = e.properties.length - 1;
          return e.properties.every((e, r) => "ObjectMethod" !== e.type && (r === t || "SpreadElement" !== e.type) && this.isAssignable(e));
         }
         case "ObjectProperty":
          return this.isAssignable(e.value);
         case "SpreadElement":
          return this.isAssignable(e.argument);
         case "ArrayExpression":
          return e.elements.every((e) => null === e || this.isAssignable(e));
         case "AssignmentExpression":
          return "=" === e.operator;
         case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
         case "MemberExpression":
         case "OptionalMemberExpression":
          return !t;
         default:
          return !1;
        }
       }
       toReferencedList(e, t) {
        return e;
       }
       toReferencedListDeep(e, t) {
        this.toReferencedList(e, t);
        for (let r of e) "ArrayExpression" === (null == r ? void 0 : r.type) && this.toReferencedListDeep(r.elements);
       }
       parseSpread(e) {
        let t = this.startNode();
        return this.next(), (t.argument = this.parseMaybeAssignAllowIn(e, void 0)), this.finishNode(t, "SpreadElement");
       }
       parseRestBinding() {
        let e = this.startNode();
        return this.next(), (e.argument = this.parseBindingAtom()), this.finishNode(e, "RestElement");
       }
       parseBindingAtom() {
        switch (this.state.type) {
         case 0: {
          let e = this.startNode();
          return this.next(), (e.elements = this.parseBindingList(3, 93, 1)), this.finishNode(e, "ArrayPattern");
         }
         case 5:
          return this.parseObjectLike(8, !0);
        }
        return this.parseIdentifier();
       }
       parseBindingList(e, t, r) {
        let n = 1 & r,
         s = [],
         i = !0;
        for (; !this.eat(e); )
         if ((i ? (i = !1) : this.expect(12), n && this.match(12))) s.push(null);
         else {
          if (this.eat(e)) break;
          if (this.match(21)) {
           if ((s.push(this.parseAssignableListItemTypes(this.parseRestBinding(), r)), !this.checkCommaAfterRest(t))) {
            this.expect(e);
            break;
           }
          } else {
           let e = [];
           for (this.match(26) && this.hasPlugin("decorators") && this.raise(g.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); ) e.push(this.parseDecorator());
           s.push(this.parseAssignableListItem(r, e));
          }
         }
        return s;
       }
       parseBindingRestProperty(e) {
        return this.next(), (e.argument = this.parseIdentifier()), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
       }
       parseBindingProperty() {
        let e = this.startNode(),
         { type: t, startLoc: r } = this.state;
        return 21 === t ? this.parseBindingRestProperty(e) : (138 === t ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), (e.key = this.parsePrivateName())) : this.parsePropertyName(e), (e.method = !1), this.parseObjPropValue(e, r, !1, !1, !0, !1));
       }
       parseAssignableListItem(e, t) {
        let r = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(r, e);
        let n = this.parseMaybeDefault(r.loc.start, r);
        return t.length && (r.decorators = t), n;
       }
       parseAssignableListItemTypes(e, t) {
        return e;
       }
       parseMaybeDefault(e, t) {
        var r;
        if ((null != e || (e = this.state.startLoc), (t = null != (r = t) ? r : this.parseBindingAtom()), !this.eat(29))) return t;
        let n = this.startNodeAt(e);
        return (n.left = t), (n.right = this.parseMaybeAssignAllowIn()), this.finishNode(n, "AssignmentPattern");
       }
       isValidLVal(e, t, r) {
        return ((e, t) => Object.hasOwnProperty.call(e, t) && e[t])({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, e);
       }
       isOptionalMemberExpression(e) {
        return "OptionalMemberExpression" === e.type;
       }
       checkLVal(e, { in: t, binding: r = 64, checkClashes: n = !1, strictModeChanged: s = !1, hasParenthesizedAncestor: i = !1 }) {
        var a;
        let o = e.type;
        if (this.isObjectMethod(e)) return;
        let u = this.isOptionalMemberExpression(e);
        if (u || "MemberExpression" === o) return u && (this.expectPlugin("optionalChainingAssign", e.loc.start), "AssignmentExpression" !== t.type && this.raise(g.InvalidLhsOptionalChaining, { at: e, ancestor: t })), void (64 !== r && this.raise(g.InvalidPropertyBindingPattern, { at: e }));
        if ("Identifier" === o) {
         this.checkIdentifier(e, r, s);
         let { name: t } = e;
         return void (n && (n.has(t) ? this.raise(g.ParamDupe, { at: e }) : n.add(t)));
        }
        let l = this.isValidLVal(o, !(i || (null != (a = e.extra) && a.parenthesized)) && "AssignmentExpression" === t.type, r);
        if (!0 === l) return;
        if (!1 === l) {
         let n = 64 === r ? g.InvalidLhs : g.InvalidLhsBinding;
         return void this.raise(n, { at: e, ancestor: t });
        }
        let [p, c] = Array.isArray(l) ? l : [l, "ParenthesizedExpression" === o],
         h = "ArrayPattern" === o || "ObjectPattern" === o ? { type: o } : t;
        for (let d of [].concat(e[p])) d && this.checkLVal(d, { in: h, binding: r, checkClashes: n, strictModeChanged: s, hasParenthesizedAncestor: c });
       }
       checkIdentifier(e, t, r = !1) {
        this.state.strict && (r ? me(e.name, this.inModule) : fe(e.name)) && (64 === t ? this.raise(g.StrictEvalArguments, { at: e, referenceName: e.name }) : this.raise(g.StrictEvalArgumentsBinding, { at: e, bindingName: e.name })), 8192 & t && "let" === e.name && this.raise(g.LetInLexicalBinding, { at: e }), 64 & t || this.declareNameFromIdentifier(e, t);
       }
       declareNameFromIdentifier(e, t) {
        this.scope.declareName(e.name, t, e.loc.start);
       }
       checkToRestConversion(e, t) {
        switch (e.type) {
         case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, t);
          break;
         case "Identifier":
         case "MemberExpression":
          break;
         case "ArrayExpression":
         case "ObjectExpression":
          if (t) break;
         default:
          this.raise(g.InvalidRestAssignmentPattern, { at: e });
        }
       }
       checkCommaAfterRest(e) {
        return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e ? g.RestTrailingComma : g.ElementAfterRest, { at: this.state.startLoc }), !0);
       }
      };
     function Et(e) {
      if (!e) throw new Error("Assert fail");
     }
     var Ct = y`typescript`({ AbstractMethodHasImplementation: ({ methodName: e }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: e }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: e }) => `'declare' is not allowed in ${e}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: e }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: e }) => `Duplicate modifier: '${e}'.`, EmptyHeritageClauseType: ({ token: e }) => `'${e}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: e }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: e }) => `Index signatures cannot have an accessibility modifier ('${e}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: e }) => `'${e}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: e }) => `'${e}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: e }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: e }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: e }) => `Private elements cannot have an accessibility modifier ('${e}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: e }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.` });
     function Tt(e) {
      return "private" === e || "public" === e || "protected" === e;
     }
     function wt(e) {
      return "in" === e || "out" === e;
     }
     function St(e) {
      if ("MemberExpression" !== e.type) return !1;
      let { computed: t, property: r } = e;
      return (!t || "StringLiteral" === r.type || !("TemplateLiteral" !== r.type || r.expressions.length > 0)) && kt(e.object);
     }
     function At(e, t) {
      var r;
      let { type: n } = e;
      if (null != (r = e.extra) && r.parenthesized) return !1;
      if (t) {
       if ("Literal" === n) {
        let { value: t } = e;
        if ("string" == typeof t || "boolean" == typeof t) return !0;
       }
      } else if ("StringLiteral" === n || "BooleanLiteral" === n) return !0;
      return !!(
       Ft(e, t) ||
       (function (e, t) {
        if ("UnaryExpression" === e.type) {
         let { operator: r, argument: n } = e;
         if ("-" === r && Ft(n, t)) return !0;
        }
        return !1;
       })(e, t) ||
       ("TemplateLiteral" === n && 0 === e.expressions.length) ||
       St(e)
      );
     }
     function Ft(e, t) {
      return t ? "Literal" === e.type && ("number" == typeof e.value || "bigint" in e) : "NumericLiteral" === e.type || "BigIntLiteral" === e.type;
     }
     function kt(e) {
      return "Identifier" === e.type || ("MemberExpression" === e.type && !e.computed && kt(e.object));
     }
     var Pt = y`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
     function It(e, t) {
      let [r, n] = "string" == typeof t ? [t, {}] : t,
       s = Object.keys(n),
       i = 0 === s.length;
      return e.some((e) => {
       if ("string" == typeof e) return i && e === r;
       {
        let [t, i] = e;
        if (t !== r) return !1;
        for (let e of s) if (i[e] !== n[e]) return !1;
        return !0;
       }
      });
     }
     function Nt(e, t, r) {
      let n = e.find((e) => (Array.isArray(e) ? e[0] === t : e === t));
      return n && Array.isArray(n) && n.length > 1 ? n[1][r] : null;
     }
     var Bt = ["minimal", "fsharp", "hack", "smart"],
      _t = ["^^", "@@", "^", "%", "#"],
      Lt = ["hash", "bar"];
     var Ot = {
       estree: (e) =>
        class extends e {
         parse() {
          let e = b(super.parse());
          return this.options.tokens && (e.tokens = e.tokens.map(b)), e;
         }
         parseRegExpLiteral({ pattern: e, flags: t }) {
          let r = null;
          try {
           r = new RegExp(e, t);
          } catch {}
          let n = this.estreeParseLiteral(r);
          return (n.regex = { pattern: e, flags: t }), n;
         }
         parseBigIntLiteral(e) {
          let t;
          try {
           t = BigInt(e);
          } catch {
           t = null;
          }
          let r = this.estreeParseLiteral(t);
          return (r.bigint = String(r.value || e)), r;
         }
         parseDecimalLiteral(e) {
          let t = this.estreeParseLiteral(null);
          return (t.decimal = String(t.value || e)), t;
         }
         estreeParseLiteral(e) {
          return this.parseLiteral(e, "Literal");
         }
         parseStringLiteral(e) {
          return this.estreeParseLiteral(e);
         }
         parseNumericLiteral(e) {
          return this.estreeParseLiteral(e);
         }
         parseNullLiteral() {
          return this.estreeParseLiteral(null);
         }
         parseBooleanLiteral(e) {
          return this.estreeParseLiteral(e);
         }
         directiveToStmt(e) {
          let t = e.value;
          delete e.value, (t.type = "Literal"), (t.raw = t.extra.raw), (t.value = t.extra.expressionValue);
          let r = e;
          return (r.type = "ExpressionStatement"), (r.expression = t), (r.directive = t.extra.rawValue), delete t.extra, r;
         }
         initFunction(e, t) {
          super.initFunction(e, t), (e.expression = !1);
         }
         checkDeclaration(e) {
          null != e && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
         }
         getObjectOrClassMethodParams(e) {
          return e.value.params;
         }
         isValidDirective(e) {
          var t;
          return "ExpressionStatement" === e.type && "Literal" === e.expression.type && "string" == typeof e.expression.value && !(null != (t = e.expression.extra) && t.parenthesized);
         }
         parseBlockBody(e, t, r, n, s) {
          super.parseBlockBody(e, t, r, n, s);
          let i = e.directives.map((e) => this.directiveToStmt(e));
          (e.body = i.concat(e.body)), delete e.directives;
         }
         pushClassMethod(e, t, r, n, s, i) {
          this.parseMethod(t, r, n, s, i, "ClassMethod", !0), t.typeParameters && ((t.value.typeParameters = t.typeParameters), delete t.typeParameters), e.body.push(t);
         }
         parsePrivateName() {
          let e = super.parsePrivateName();
          return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
         }
         convertPrivateNameToPrivateIdentifier(e) {
          let t = super.getPrivateNameSV(e);
          return delete e.id, (e.name = t), (e.type = "PrivateIdentifier"), e;
         }
         isPrivateName(e) {
          return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === e.type : super.isPrivateName(e);
         }
         getPrivateNameSV(e) {
          return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
         }
         parseLiteral(e, t) {
          let r = super.parseLiteral(e, t);
          return (r.raw = r.extra.raw), delete r.extra, r;
         }
         parseFunctionBody(e, t, r = !1) {
          super.parseFunctionBody(e, t, r), (e.expression = "BlockStatement" !== e.body.type);
         }
         parseMethod(e, t, r, n, s, i, a = !1) {
          let o = this.startNode();
          return (o.kind = e.kind), (o = super.parseMethod(o, t, r, n, s, i, a)), (o.type = "FunctionExpression"), delete o.kind, (e.value = o), "ClassPrivateMethod" === i && (e.computed = !1), this.finishNode(e, "MethodDefinition");
         }
         parseClassProperty(...e) {
          let t = super.parseClassProperty(...e);
          return this.getPluginOption("estree", "classFeatures") && (t.type = "PropertyDefinition"), t;
         }
         parseClassPrivateProperty(...e) {
          let t = super.parseClassPrivateProperty(...e);
          return this.getPluginOption("estree", "classFeatures") && ((t.type = "PropertyDefinition"), (t.computed = !1)), t;
         }
         parseObjectMethod(e, t, r, n, s) {
          let i = super.parseObjectMethod(e, t, r, n, s);
          return i && ((i.type = "Property"), "method" === i.kind && (i.kind = "init"), (i.shorthand = !1)), i;
         }
         parseObjectProperty(e, t, r, n) {
          let s = super.parseObjectProperty(e, t, r, n);
          return s && ((s.kind = "init"), (s.type = "Property")), s;
         }
         isValidLVal(e, t, r) {
          return "Property" === e ? "value" : super.isValidLVal(e, t, r);
         }
         isAssignable(e, t) {
          return null != e && this.isObjectProperty(e) ? this.isAssignable(e.value, t) : super.isAssignable(e, t);
         }
         toAssignable(e, t = !1) {
          if (null != e && this.isObjectProperty(e)) {
           let { key: r, value: n } = e;
           this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(n, t);
          } else super.toAssignable(e, t);
         }
         toAssignableObjectExpressionProp(e, t, r) {
          "get" === e.kind || "set" === e.kind ? this.raise(g.PatternHasAccessor, { at: e.key }) : e.method ? this.raise(g.PatternHasMethod, { at: e.key }) : super.toAssignableObjectExpressionProp(e, t, r);
         }
         finishCallExpression(e, t) {
          let r = super.finishCallExpression(e, t);
          if ("Import" === r.callee.type) {
           var n, s;
           if (((r.type = "ImportExpression"), (r.source = r.arguments[0]), this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))) (r.options = null != (n = r.arguments[1]) ? n : null), (r.attributes = null != (s = r.arguments[1]) ? s : null);
           delete r.arguments, delete r.callee;
          }
          return r;
         }
         toReferencedArguments(e) {
          "ImportExpression" !== e.type && super.toReferencedArguments(e);
         }
         parseExport(e, t) {
          let r = this.state.lastTokStartLoc,
           n = super.parseExport(e, t);
          switch (n.type) {
           case "ExportAllDeclaration":
            n.exported = null;
            break;
           case "ExportNamedDeclaration":
            1 === n.specifiers.length && "ExportNamespaceSpecifier" === n.specifiers[0].type && ((n.type = "ExportAllDeclaration"), (n.exported = n.specifiers[0].exported), delete n.specifiers);
           case "ExportDefaultDeclaration": {
            var s;
            let { declaration: e } = n;
            "ClassDeclaration" === (null == e ? void 0 : e.type) && (null == (s = e.decorators) ? void 0 : s.length) > 0 && e.start === n.start && this.resetStartLocation(n, r);
           }
          }
          return n;
         }
         parseSubscript(e, t, r, n) {
          let s = super.parseSubscript(e, t, r, n);
          if (n.optionalChainMember) {
           if ((("OptionalMemberExpression" === s.type || "OptionalCallExpression" === s.type) && (s.type = s.type.substring(8)), n.stop)) {
            let e = this.startNodeAtNode(s);
            return (e.expression = s), this.finishNode(e, "ChainExpression");
           }
          } else ("MemberExpression" === s.type || "CallExpression" === s.type) && (s.optional = !1);
          return s;
         }
         isOptionalMemberExpression(e) {
          return "ChainExpression" === e.type ? "MemberExpression" === e.expression.type : super.isOptionalMemberExpression(e);
         }
         hasPropertyAsPrivateName(e) {
          return "ChainExpression" === e.type && (e = e.expression), super.hasPropertyAsPrivateName(e);
         }
         isObjectProperty(e) {
          return "Property" === e.type && "init" === e.kind && !e.method;
         }
         isObjectMethod(e) {
          return e.method || "get" === e.kind || "set" === e.kind;
         }
         finishNodeAt(e, t, r) {
          return b(super.finishNodeAt(e, t, r));
         }
         resetStartLocation(e, t) {
          super.resetStartLocation(e, t), b(e);
         }
         resetEndLocation(e, t = this.state.lastTokEndLoc) {
          super.resetEndLocation(e, t), b(e);
         }
        },
       jsx: (e) =>
        class extends e {
         jsxReadToken() {
          let e = "",
           t = this.state.pos;
          for (;;) {
           if (this.state.pos >= this.length) throw this.raise(mt.UnterminatedJsxContent, { at: this.state.startLoc });
           let r = this.input.charCodeAt(this.state.pos);
           switch (r) {
            case 60:
            case 123:
             return this.state.pos === this.state.start ? void (60 === r && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(r)) : ((e += this.input.slice(t, this.state.pos)), void this.finishToken(141, e));
            case 38:
             (e += this.input.slice(t, this.state.pos)), (e += this.jsxReadEntity()), (t = this.state.pos);
             break;
            default:
             Fe(r) ? ((e += this.input.slice(t, this.state.pos)), (e += this.jsxReadNewLine(!0)), (t = this.state.pos)) : ++this.state.pos;
           }
          }
         }
         jsxReadNewLine(e) {
          let t,
           r = this.input.charCodeAt(this.state.pos);
          return ++this.state.pos, 13 === r && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, (t = e ? "\n" : "\r\n")) : (t = String.fromCharCode(r)), ++this.state.curLine, (this.state.lineStart = this.state.pos), t;
         }
         jsxReadString(e) {
          let t = "",
           r = ++this.state.pos;
          for (;;) {
           if (this.state.pos >= this.length) throw this.raise(g.UnterminatedString, { at: this.state.startLoc });
           let n = this.input.charCodeAt(this.state.pos);
           if (n === e) break;
           38 === n ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadEntity()), (r = this.state.pos)) : Fe(n) ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadNewLine(!1)), (r = this.state.pos)) : ++this.state.pos;
          }
          (t += this.input.slice(r, this.state.pos++)), this.finishToken(133, t);
         }
         jsxReadEntity() {
          let e = ++this.state.pos;
          if (35 === this.codePointAtPos(this.state.pos)) {
           ++this.state.pos;
           let e = 10;
           120 === this.codePointAtPos(this.state.pos) && ((e = 16), ++this.state.pos);
           let t = this.readInt(e, void 0, !1, "bail");
           if (null !== t && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t);
          } else {
           let t = 0,
            r = !1;
           for (; t++ < 10 && this.state.pos < this.length && !(r = 59 == this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
           if (r) {
            let t;
            this.input.slice(e, this.state.pos);
            if ((++this.state.pos, t)) return t;
           }
          }
          return (this.state.pos = e), "&";
         }
         jsxReadWord() {
          let e,
           t = this.state.pos;
          do {
           e = this.input.charCodeAt(++this.state.pos);
          } while (ae(e) || 45 === e);
          this.finishToken(140, this.input.slice(t, this.state.pos));
         }
         jsxParseIdentifier() {
          let e = this.startNode();
          return this.match(140) ? (e.name = this.state.value) : J(this.state.type) ? (e.name = K(this.state.type)) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
         }
         jsxParseNamespacedName() {
          let e = this.state.startLoc,
           t = this.jsxParseIdentifier();
          if (!this.eat(14)) return t;
          let r = this.startNodeAt(e);
          return (r.namespace = t), (r.name = this.jsxParseIdentifier()), this.finishNode(r, "JSXNamespacedName");
         }
         jsxParseElementName() {
          let e = this.state.startLoc,
           t = this.jsxParseNamespacedName();
          if ("JSXNamespacedName" === t.type) return t;
          for (; this.eat(16); ) {
           let r = this.startNodeAt(e);
           (r.object = t), (r.property = this.jsxParseIdentifier()), (t = this.finishNode(r, "JSXMemberExpression"));
          }
          return t;
         }
         jsxParseAttributeValue() {
          let e;
          switch (this.state.type) {
           case 5:
            return (e = this.startNode()), this.setContext(E.brace), this.next(), (e = this.jsxParseExpressionContainer(e, E.j_oTag)), "JSXEmptyExpression" === e.expression.type && this.raise(mt.AttributeIsEmpty, { at: e }), e;
           case 142:
           case 133:
            return this.parseExprAtom();
           default:
            throw this.raise(mt.UnsupportedJsxValue, { at: this.state.startLoc });
          }
         }
         jsxParseEmptyExpression() {
          let e = this.startNodeAt(this.state.lastTokEndLoc);
          return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
         }
         jsxParseSpreadChild(e) {
          return this.next(), (e.expression = this.parseExpression()), this.setContext(E.j_expr), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, "JSXSpreadChild");
         }
         jsxParseExpressionContainer(e, t) {
          if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
          else {
           let t = this.parseExpression();
           e.expression = t;
          }
          return this.setContext(t), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, "JSXExpressionContainer");
         }
         jsxParseAttribute() {
          let e = this.startNode();
          return this.match(5) ? (this.setContext(E.brace), this.next(), this.expect(21), (e.argument = this.parseMaybeAssignAllowIn()), this.setContext(E.j_oTag), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : ((e.name = this.jsxParseNamespacedName()), (e.value = this.eat(29) ? this.jsxParseAttributeValue() : null), this.finishNode(e, "JSXAttribute"));
         }
         jsxParseOpeningElementAt(e) {
          let t = this.startNodeAt(e);
          return this.eat(143) ? this.finishNode(t, "JSXOpeningFragment") : ((t.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(t));
         }
         jsxParseOpeningElementAfterName(e) {
          let t = [];
          for (; !this.match(56) && !this.match(143); ) t.push(this.jsxParseAttribute());
          return (e.attributes = t), (e.selfClosing = this.eat(56)), this.expect(143), this.finishNode(e, "JSXOpeningElement");
         }
         jsxParseClosingElementAt(e) {
          let t = this.startNodeAt(e);
          return this.eat(143) ? this.finishNode(t, "JSXClosingFragment") : ((t.name = this.jsxParseElementName()), this.expect(143), this.finishNode(t, "JSXClosingElement"));
         }
         jsxParseElementAt(e) {
          let t = this.startNodeAt(e),
           r = [],
           n = this.jsxParseOpeningElementAt(e),
           s = null;
          if (!n.selfClosing) {
           e: for (;;)
            switch (this.state.type) {
             case 142:
              if (((e = this.state.startLoc), this.next(), this.eat(56))) {
               s = this.jsxParseClosingElementAt(e);
               break e;
              }
              r.push(this.jsxParseElementAt(e));
              break;
             case 141:
              r.push(this.parseExprAtom());
              break;
             case 5: {
              let e = this.startNode();
              this.setContext(E.brace), this.next(), this.match(21) ? r.push(this.jsxParseSpreadChild(e)) : r.push(this.jsxParseExpressionContainer(e, E.j_expr));
              break;
             }
             default:
              this.unexpected();
            }
           yt(n) && !yt(s) && null !== s ? this.raise(mt.MissingClosingTagFragment, { at: s }) : ((!yt(n) && yt(s)) || (!yt(n) && !yt(s) && gt(s.name) !== gt(n.name))) && this.raise(mt.MissingClosingTagElement, { at: s, openingTagName: gt(n.name) });
          }
          if ((yt(n) ? ((t.openingFragment = n), (t.closingFragment = s)) : ((t.openingElement = n), (t.closingElement = s)), (t.children = r), this.match(47))) throw this.raise(mt.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
          return yt(n) ? this.finishNode(t, "JSXFragment") : this.finishNode(t, "JSXElement");
         }
         jsxParseElement() {
          let e = this.state.startLoc;
          return this.next(), this.jsxParseElementAt(e);
         }
         setContext(e) {
          let { context: t } = this.state;
          t[t.length - 1] = e;
         }
         parseExprAtom(e) {
          return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(e);
         }
         skipSpace() {
          this.curContext().preserveSpace || super.skipSpace();
         }
         getTokenFromCode(e) {
          let t = this.curContext();
          if (t !== E.j_expr) {
           if (t === E.j_oTag || t === E.j_cTag) {
            if (ie(e)) return void this.jsxReadWord();
            if (62 === e) return ++this.state.pos, void this.finishToken(143);
            if ((34 === e || 39 === e) && t === E.j_oTag) return void this.jsxReadString(e);
           }
           if (60 === e && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(142);
           super.getTokenFromCode(e);
          } else this.jsxReadToken();
         }
         updateContext(e) {
          let { context: t, type: r } = this.state;
          if (56 === r && 142 === e) t.splice(-2, 2, E.j_cTag), (this.state.canStartJSXElement = !1);
          else if (142 === r) t.push(E.j_oTag);
          else if (143 === r) {
           let r = t[t.length - 1];
           (r === E.j_oTag && 56 === e) || r === E.j_cTag ? (t.pop(), (this.state.canStartJSXElement = t[t.length - 1] === E.j_expr)) : (this.setContext(E.j_expr), (this.state.canStartJSXElement = !0));
          } else
           this.state.canStartJSXElement = (function (e) {
            return O[e];
           })(r);
         }
        },
       flow: (e) =>
        class extends e {
         constructor(...e) {
          super(...e), (this.flowPragma = void 0);
         }
         getScopeHandler() {
          return be;
         }
         shouldParseTypes() {
          return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
         }
         shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
         }
         finishToken(e, t) {
          133 !== e && 13 !== e && 28 !== e && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e, t);
         }
         addComment(e) {
          if (void 0 === this.flowPragma) {
           let t = ft.exec(e.value);
           if (t)
            if ("flow" === t[1]) this.flowPragma = "flow";
            else {
             if ("noflow" !== t[1]) throw new Error("Unexpected flow pragma");
             this.flowPragma = "noflow";
            }
          }
          super.addComment(e);
         }
         flowParseTypeInitialiser(e) {
          let t = this.state.inType;
          (this.state.inType = !0), this.expect(e || 14);
          let r = this.flowParseType();
          return (this.state.inType = t), r;
         }
         flowParsePredicate() {
          let e = this.startNode(),
           t = this.state.startLoc;
          return this.next(), this.expectContextual(110), this.state.lastTokStart > t.index + 1 && this.raise(ct.UnexpectedSpaceBetweenModuloChecks, { at: t }), this.eat(10) ? ((e.value = super.parseExpression()), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
         }
         flowParseTypeAndPredicateInitialiser() {
          let e = this.state.inType;
          (this.state.inType = !0), this.expect(14);
          let t = null,
           r = null;
          return this.match(54) ? ((this.state.inType = e), (r = this.flowParsePredicate())) : ((t = this.flowParseType()), (this.state.inType = e), this.match(54) && (r = this.flowParsePredicate())), [t, r];
         }
         flowParseDeclareClass(e) {
          return this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, "DeclareClass");
         }
         flowParseDeclareFunction(e) {
          this.next();
          let t = (e.id = this.parseIdentifier()),
           r = this.startNode(),
           n = this.startNode();
          this.match(47) ? (r.typeParameters = this.flowParseTypeParameterDeclaration()) : (r.typeParameters = null), this.expect(10);
          let s = this.flowParseFunctionTypeParams();
          return (r.params = s.params), (r.rest = s.rest), (r.this = s._this), this.expect(11), ([r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (n.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation")), (t.typeAnnotation = this.finishNode(n, "TypeAnnotation")), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, "DeclareFunction");
         }
         flowParseDeclare(e, t) {
          return this.match(80) ? this.flowParseDeclareClass(e) : this.match(68) ? this.flowParseDeclareFunction(e) : this.match(74) ? this.flowParseDeclareVariable(e) : this.eatContextual(127) ? (this.match(16) ? this.flowParseDeclareModuleExports(e) : (t && this.raise(ct.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e))) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(e) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(e) : this.isContextual(129) ? this.flowParseDeclareInterface(e) : this.match(82) ? this.flowParseDeclareExportDeclaration(e, t) : void this.unexpected();
         }
         flowParseDeclareVariable(e) {
          return this.next(), (e.id = this.flowParseTypeAnnotatableIdentifier(!0)), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
         }
         flowParseDeclareModule(e) {
          this.scope.enter(0), this.match(133) ? (e.id = super.parseExprAtom()) : (e.id = this.parseIdentifier());
          let t = (e.body = this.startNode()),
           r = (t.body = []);
          for (this.expect(5); !this.match(8); ) {
           let e = this.startNode();
           this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ct.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(e)) : (this.expectContextual(125, ct.UnsupportedStatementInDeclareModule), (e = this.flowParseDeclare(e, !0))), r.push(e);
          }
          this.scope.exit(), this.expect(8), this.finishNode(t, "BlockStatement");
          let n = null,
           s = !1;
          return (
           r.forEach((e) => {
            !(function (e) {
             return "DeclareExportAllDeclaration" === e.type || ("DeclareExportDeclaration" === e.type && (!e.declaration || ("TypeAlias" !== e.declaration.type && "InterfaceDeclaration" !== e.declaration.type)));
            })(e)
             ? "DeclareModuleExports" === e.type && (s && this.raise(ct.DuplicateDeclareModuleExports, { at: e }), "ES" === n && this.raise(ct.AmbiguousDeclareModuleKind, { at: e }), (n = "CommonJS"), (s = !0))
             : ("CommonJS" === n && this.raise(ct.AmbiguousDeclareModuleKind, { at: e }), (n = "ES"));
           }),
           (e.kind = n || "CommonJS"),
           this.finishNode(e, "DeclareModule")
          );
         }
         flowParseDeclareExportDeclaration(e, t) {
          if ((this.expect(82), this.eat(65))) return this.match(68) || this.match(80) ? (e.declaration = this.flowParseDeclare(this.startNode())) : ((e.declaration = this.flowParseType()), this.semicolon()), (e.default = !0), this.finishNode(e, "DeclareExportDeclaration");
          if (this.match(75) || this.isLet() || ((this.isContextual(130) || this.isContextual(129)) && !t)) {
           let e = this.state.value;
           throw this.raise(ct.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: e, suggestion: dt[e] });
          }
          return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? ((e.declaration = this.flowParseDeclare(this.startNode())), (e.default = !1), this.finishNode(e, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ("ExportNamedDeclaration" === (e = this.parseExport(e, null)).type && ((e.type = "ExportDeclaration"), (e.default = !1), delete e.exportKind), (e.type = "Declare" + e.type), e) : void this.unexpected();
         }
         flowParseDeclareModuleExports(e) {
          return this.next(), this.expectContextual(111), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
         }
         flowParseDeclareTypeAlias(e) {
          this.next();
          let t = this.flowParseTypeAlias(e);
          return (t.type = "DeclareTypeAlias"), t;
         }
         flowParseDeclareOpaqueType(e) {
          this.next();
          let t = this.flowParseOpaqueType(e, !0);
          return (t.type = "DeclareOpaqueType"), t;
         }
         flowParseDeclareInterface(e) {
          return this.next(), this.flowParseInterfaceish(e, !1), this.finishNode(e, "DeclareInterface");
         }
         flowParseInterfaceish(e, t) {
          if (((e.id = this.flowParseRestrictedIdentifier(!t, !0)), this.scope.declareName(e.id.name, t ? 17 : 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.extends = []), this.eat(81)))
           do {
            e.extends.push(this.flowParseInterfaceExtends());
           } while (!t && this.eat(12));
          if (t) {
           if (((e.implements = []), (e.mixins = []), this.eatContextual(117)))
            do {
             e.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
           if (this.eatContextual(113))
            do {
             e.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          e.body = this.flowParseObjectType({ allowStatic: t, allowExact: !1, allowSpread: !1, allowProto: t, allowInexact: !1 });
         }
         flowParseInterfaceExtends() {
          let e = this.startNode();
          return (e.id = this.flowParseQualifiedTypeIdentifier()), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), this.finishNode(e, "InterfaceExtends");
         }
         flowParseInterface(e) {
          return this.flowParseInterfaceish(e, !1), this.finishNode(e, "InterfaceDeclaration");
         }
         checkNotUnderscore(e) {
          "_" === e && this.raise(ct.UnexpectedReservedUnderscore, { at: this.state.startLoc });
         }
         checkReservedType(e, t, r) {
          pt.has(e) && this.raise(r ? ct.AssignReservedType : ct.UnexpectedReservedType, { at: t, reservedType: e });
         }
         flowParseRestrictedIdentifier(e, t) {
          return this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e);
         }
         flowParseTypeAlias(e) {
          return (e.id = this.flowParseRestrictedIdentifier(!1, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.right = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "TypeAlias");
         }
         flowParseOpaqueType(e, t) {
          return this.expectContextual(130), (e.id = this.flowParseRestrictedIdentifier(!0, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.supertype = null), this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), (e.impltype = null), t || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
         }
         flowParseTypeParameter(e = !1) {
          let t = this.state.startLoc,
           r = this.startNode(),
           n = this.flowParseVariance(),
           s = this.flowParseTypeAnnotatableIdentifier();
          return (r.name = s.name), (r.variance = n), (r.bound = s.typeAnnotation), this.match(29) ? (this.eat(29), (r.default = this.flowParseType())) : e && this.raise(ct.MissingTypeParamDefault, { at: t }), this.finishNode(r, "TypeParameter");
         }
         flowParseTypeParameterDeclaration() {
          let e = this.state.inType,
           t = this.startNode();
          (t.params = []), (this.state.inType = !0), this.match(47) || this.match(142) ? this.next() : this.unexpected();
          let r = !1;
          do {
           let e = this.flowParseTypeParameter(r);
           t.params.push(e), e.default && (r = !0), this.match(48) || this.expect(12);
          } while (!this.match(48));
          return this.expect(48), (this.state.inType = e), this.finishNode(t, "TypeParameterDeclaration");
         }
         flowParseTypeParameterInstantiation() {
          let e = this.startNode(),
           t = this.state.inType;
          (e.params = []), (this.state.inType = !0), this.expect(47);
          let r = this.state.noAnonFunctionType;
          for (this.state.noAnonFunctionType = !1; !this.match(48); ) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
          return (this.state.noAnonFunctionType = r), this.expect(48), (this.state.inType = t), this.finishNode(e, "TypeParameterInstantiation");
         }
         flowParseTypeParameterInstantiationCallOrNew() {
          let e = this.startNode(),
           t = this.state.inType;
          for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
          return this.expect(48), (this.state.inType = t), this.finishNode(e, "TypeParameterInstantiation");
         }
         flowParseInterfaceType() {
          let e = this.startNode();
          if ((this.expectContextual(129), (e.extends = []), this.eat(81)))
           do {
            e.extends.push(this.flowParseInterfaceExtends());
           } while (this.eat(12));
          return (e.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 })), this.finishNode(e, "InterfaceTypeAnnotation");
         }
         flowParseObjectPropertyKey() {
          return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
         }
         flowParseObjectTypeIndexer(e, t, r) {
          return (e.static = t), 14 === this.lookahead().type ? ((e.id = this.flowParseObjectPropertyKey()), (e.key = this.flowParseTypeInitialiser())) : ((e.id = null), (e.key = this.flowParseType())), this.expect(3), (e.value = this.flowParseTypeInitialiser()), (e.variance = r), this.finishNode(e, "ObjectTypeIndexer");
         }
         flowParseObjectTypeInternalSlot(e, t) {
          return (e.static = t), (e.id = this.flowParseObjectPropertyKey()), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? ((e.method = !0), (e.optional = !1), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)))) : ((e.method = !1), this.eat(17) && (e.optional = !0), (e.value = this.flowParseTypeInitialiser())), this.finishNode(e, "ObjectTypeInternalSlot");
         }
         flowParseObjectTypeMethodish(e) {
          for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && ((e.this = this.flowParseFunctionTypeParam(!0)), (e.this.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
          return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), (e.returnType = this.flowParseTypeInitialiser()), this.finishNode(e, "FunctionTypeAnnotation");
         }
         flowParseObjectTypeCallProperty(e, t) {
          let r = this.startNode();
          return (e.static = t), (e.value = this.flowParseObjectTypeMethodish(r)), this.finishNode(e, "ObjectTypeCallProperty");
         }
         flowParseObjectType({ allowStatic: e, allowExact: t, allowSpread: r, allowProto: n, allowInexact: s }) {
          let i = this.state.inType;
          this.state.inType = !0;
          let a = this.startNode();
          (a.callProperties = []), (a.properties = []), (a.indexers = []), (a.internalSlots = []);
          let o,
           u,
           l = !1;
          for (t && this.match(6) ? (this.expect(6), (o = 9), (u = !0)) : (this.expect(5), (o = 8), (u = !1)), a.exact = u; !this.match(o); ) {
           let t = !1,
            i = null,
            o = null,
            p = this.startNode();
           if (n && this.isContextual(118)) {
            let t = this.lookahead();
            14 !== t.type && 17 !== t.type && (this.next(), (i = this.state.startLoc), (e = !1));
           }
           if (e && this.isContextual(106)) {
            let e = this.lookahead();
            14 !== e.type && 17 !== e.type && (this.next(), (t = !0));
           }
           let c = this.flowParseVariance();
           if (this.eat(0)) null != i && this.unexpected(i), this.eat(0) ? (c && this.unexpected(c.loc.start), a.internalSlots.push(this.flowParseObjectTypeInternalSlot(p, t))) : a.indexers.push(this.flowParseObjectTypeIndexer(p, t, c));
           else if (this.match(10) || this.match(47)) null != i && this.unexpected(i), c && this.unexpected(c.loc.start), a.callProperties.push(this.flowParseObjectTypeCallProperty(p, t));
           else {
            let e = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
             z(this.lookahead().type) && ((e = this.state.value), this.next());
            }
            let n = this.flowParseObjectTypeProperty(p, t, i, c, e, r, s ?? !u);
            null === n ? ((l = !0), (o = this.state.lastTokStartLoc)) : a.properties.push(n);
           }
           this.flowObjectTypeSemicolon(), o && !this.match(8) && !this.match(9) && this.raise(ct.UnexpectedExplicitInexactInObject, { at: o });
          }
          this.expect(o), r && (a.inexact = l);
          let p = this.finishNode(a, "ObjectTypeAnnotation");
          return (this.state.inType = i), p;
         }
         flowParseObjectTypeProperty(e, t, r, n, s, i, a) {
          if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (i ? a || this.raise(ct.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(ct.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), n && this.raise(ct.InexactVariance, { at: n }), null) : (i || this.raise(ct.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), null != r && this.unexpected(r), n && this.raise(ct.SpreadVariance, { at: n }), (e.argument = this.flowParseType()), this.finishNode(e, "ObjectTypeSpreadProperty"));
          {
           (e.key = this.flowParseObjectPropertyKey()), (e.static = t), (e.proto = null != r), (e.kind = s);
           let a = !1;
           return this.match(47) || this.match(10) ? ((e.method = !0), null != r && this.unexpected(r), n && this.unexpected(n.loc.start), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))), ("get" === s || "set" === s) && this.flowCheckGetterSetterParams(e), !i && "constructor" === e.key.name && e.value.this && this.raise(ct.ThisParamBannedInConstructor, { at: e.value.this })) : ("init" !== s && this.unexpected(), (e.method = !1), this.eat(17) && (a = !0), (e.value = this.flowParseTypeInitialiser()), (e.variance = n)), (e.optional = a), this.finishNode(e, "ObjectTypeProperty");
          }
         }
         flowCheckGetterSetterParams(e) {
          let t = "get" === e.kind ? 0 : 1,
           r = e.value.params.length + (e.value.rest ? 1 : 0);
          e.value.this && this.raise("get" === e.kind ? ct.GetterMayNotHaveThisParam : ct.SetterMayNotHaveThisParam, { at: e.value.this }), r !== t && this.raise("get" === e.kind ? g.BadGetterArity : g.BadSetterArity, { at: e }), "set" === e.kind && e.value.rest && this.raise(g.BadSetterRestParameter, { at: e });
         }
         flowObjectTypeSemicolon() {
          !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
         }
         flowParseQualifiedTypeIdentifier(e, t) {
          null != e || (e = this.state.startLoc);
          let r = t || this.flowParseRestrictedIdentifier(!0);
          for (; this.eat(16); ) {
           let t = this.startNodeAt(e);
           (t.qualification = r), (t.id = this.flowParseRestrictedIdentifier(!0)), (r = this.finishNode(t, "QualifiedTypeIdentifier"));
          }
          return r;
         }
         flowParseGenericType(e, t) {
          let r = this.startNodeAt(e);
          return (r.typeParameters = null), (r.id = this.flowParseQualifiedTypeIdentifier(e, t)), this.match(47) && (r.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r, "GenericTypeAnnotation");
         }
         flowParseTypeofType() {
          let e = this.startNode();
          return this.expect(87), (e.argument = this.flowParsePrimaryType()), this.finishNode(e, "TypeofTypeAnnotation");
         }
         flowParseTupleType() {
          let e = this.startNode();
          for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
          return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
         }
         flowParseFunctionTypeParam(e) {
          let t = null,
           r = !1,
           n = null,
           s = this.startNode(),
           i = this.lookahead(),
           a = 78 === this.state.type;
          return 14 === i.type || 17 === i.type ? (a && !e && this.raise(ct.ThisParamMustBeFirst, { at: s }), (t = this.parseIdentifier(a)), this.eat(17) && ((r = !0), a && this.raise(ct.ThisParamMayNotBeOptional, { at: s })), (n = this.flowParseTypeInitialiser())) : (n = this.flowParseType()), (s.name = t), (s.optional = r), (s.typeAnnotation = n), this.finishNode(s, "FunctionTypeParam");
         }
         reinterpretTypeAsFunctionTypeParam(e) {
          let t = this.startNodeAt(e.loc.start);
          return (t.name = null), (t.optional = !1), (t.typeAnnotation = e), this.finishNode(t, "FunctionTypeParam");
         }
         flowParseFunctionTypeParams(e = []) {
          let t = null,
           r = null;
          for (this.match(78) && ((r = this.flowParseFunctionTypeParam(!0)), (r.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
          return this.eat(21) && (t = this.flowParseFunctionTypeParam(!1)), { params: e, rest: t, _this: r };
         }
         flowIdentToTypeAnnotation(e, t, r) {
          switch (r.name) {
           case "any":
            return this.finishNode(t, "AnyTypeAnnotation");
           case "bool":
           case "boolean":
            return this.finishNode(t, "BooleanTypeAnnotation");
           case "mixed":
            return this.finishNode(t, "MixedTypeAnnotation");
           case "empty":
            return this.finishNode(t, "EmptyTypeAnnotation");
           case "number":
            return this.finishNode(t, "NumberTypeAnnotation");
           case "string":
            return this.finishNode(t, "StringTypeAnnotation");
           case "symbol":
            return this.finishNode(t, "SymbolTypeAnnotation");
           default:
            return this.checkNotUnderscore(r.name), this.flowParseGenericType(e, r);
          }
         }
         flowParsePrimaryType() {
          let e,
           t,
           r = this.state.startLoc,
           n = this.startNode(),
           s = !1,
           i = this.state.noAnonFunctionType;
          switch (this.state.type) {
           case 5:
            return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
           case 6:
            return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
           case 0:
            return (this.state.noAnonFunctionType = !1), (t = this.flowParseTupleType()), (this.state.noAnonFunctionType = i), t;
           case 47:
            return (n.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), (e = this.flowParseFunctionTypeParams()), (n.params = e.params), (n.rest = e.rest), (n.this = e._this), this.expect(11), this.expect(19), (n.returnType = this.flowParseType()), this.finishNode(n, "FunctionTypeAnnotation");
           case 10:
            if ((this.next(), !this.match(11) && !this.match(21)))
             if ($(this.state.type) || this.match(78)) {
              let e = this.lookahead().type;
              s = 17 !== e && 14 !== e;
             } else s = !0;
            if (s) {
             if (((this.state.noAnonFunctionType = !1), (t = this.flowParseType()), (this.state.noAnonFunctionType = i), this.state.noAnonFunctionType || !(this.match(12) || (this.match(11) && 19 === this.lookahead().type)))) return this.expect(11), t;
             this.eat(12);
            }
            return (e = t ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(t)]) : this.flowParseFunctionTypeParams()), (n.params = e.params), (n.rest = e.rest), (n.this = e._this), this.expect(11), this.expect(19), (n.returnType = this.flowParseType()), (n.typeParameters = null), this.finishNode(n, "FunctionTypeAnnotation");
           case 133:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
           case 85:
           case 86:
            return (n.value = this.match(85)), this.next(), this.finishNode(n, "BooleanLiteralTypeAnnotation");
           case 53:
            if ("-" === this.state.value) {
             if ((this.next(), this.match(134))) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", n);
             if (this.match(135)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", n);
             throw this.raise(ct.UnexpectedSubtractionOperand, { at: this.state.startLoc });
            }
            return void this.unexpected();
           case 134:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
           case 135:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
           case 88:
            return this.next(), this.finishNode(n, "VoidTypeAnnotation");
           case 84:
            return this.next(), this.finishNode(n, "NullLiteralTypeAnnotation");
           case 78:
            return this.next(), this.finishNode(n, "ThisTypeAnnotation");
           case 55:
            return this.next(), this.finishNode(n, "ExistsTypeAnnotation");
           case 87:
            return this.flowParseTypeofType();
           default:
            if (J(this.state.type)) {
             let e = K(this.state.type);
             return this.next(), super.createIdentifier(n, e);
            }
            if ($(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, n, this.parseIdentifier());
          }
          this.unexpected();
         }
         flowParsePostfixType() {
          let e = this.state.startLoc,
           t = this.flowParsePrimaryType(),
           r = !1;
          for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
           let n = this.startNodeAt(e),
            s = this.eat(18);
           (r = r || s), this.expect(0), !s && this.match(3) ? ((n.elementType = t), this.next(), (t = this.finishNode(n, "ArrayTypeAnnotation"))) : ((n.objectType = t), (n.indexType = this.flowParseType()), this.expect(3), r ? ((n.optional = s), (t = this.finishNode(n, "OptionalIndexedAccessType"))) : (t = this.finishNode(n, "IndexedAccessType")));
          }
          return t;
         }
         flowParsePrefixType() {
          let e = this.startNode();
          return this.eat(17) ? ((e.typeAnnotation = this.flowParsePrefixType()), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
         }
         flowParseAnonFunctionWithoutParens() {
          let e = this.flowParsePrefixType();
          if (!this.state.noAnonFunctionType && this.eat(19)) {
           let t = this.startNodeAt(e.loc.start);
           return (t.params = [this.reinterpretTypeAsFunctionTypeParam(e)]), (t.rest = null), (t.this = null), (t.returnType = this.flowParseType()), (t.typeParameters = null), this.finishNode(t, "FunctionTypeAnnotation");
          }
          return e;
         }
         flowParseIntersectionType() {
          let e = this.startNode();
          this.eat(45);
          let t = this.flowParseAnonFunctionWithoutParens();
          for (e.types = [t]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
          return 1 === e.types.length ? t : this.finishNode(e, "IntersectionTypeAnnotation");
         }
         flowParseUnionType() {
          let e = this.startNode();
          this.eat(43);
          let t = this.flowParseIntersectionType();
          for (e.types = [t]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
          return 1 === e.types.length ? t : this.finishNode(e, "UnionTypeAnnotation");
         }
         flowParseType() {
          let e = this.state.inType;
          this.state.inType = !0;
          let t = this.flowParseUnionType();
          return (this.state.inType = e), t;
         }
         flowParseTypeOrImplicitInstantiation() {
          if (132 === this.state.type && "_" === this.state.value) {
           let e = this.state.startLoc,
            t = this.parseIdentifier();
           return this.flowParseGenericType(e, t);
          }
          return this.flowParseType();
         }
         flowParseTypeAnnotation() {
          let e = this.startNode();
          return (e.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(e, "TypeAnnotation");
         }
         flowParseTypeAnnotatableIdentifier(e) {
          let t = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
          return this.match(14) && ((t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t)), t;
         }
         typeCastToParameter(e) {
          return (e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
         }
         flowParseVariance() {
          let e = null;
          return this.match(53) ? ((e = this.startNode()), "+" === this.state.value ? (e.kind = "plus") : (e.kind = "minus"), this.next(), this.finishNode(e, "Variance")) : e;
         }
         parseFunctionBody(e, t, r = !1) {
          t ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, r)) : super.parseFunctionBody(e, !1, r);
         }
         parseFunctionBodyAndFinish(e, t, r = !1) {
          if (this.match(14)) {
           let t = this.startNode();
           ([t.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (e.returnType = t.typeAnnotation ? this.finishNode(t, "TypeAnnotation") : null);
          }
          return super.parseFunctionBodyAndFinish(e, t, r);
         }
         parseStatementLike(e) {
          if (this.state.strict && this.isContextual(129)) {
           if (V(this.lookahead().type)) {
            let e = this.startNode();
            return this.next(), this.flowParseInterface(e);
           }
          } else if (this.shouldParseEnums() && this.isContextual(126)) {
           let e = this.startNode();
           return this.next(), this.flowParseEnumDeclaration(e);
          }
          let t = super.parseStatementLike(e);
          return void 0 === this.flowPragma && !this.isValidDirective(t) && (this.flowPragma = null), t;
         }
         parseExpressionStatement(e, t, r) {
          if ("Identifier" === t.type)
           if ("declare" === t.name) {
            if (this.match(80) || $(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
           } else if ($(this.state.type)) {
            if ("interface" === t.name) return this.flowParseInterface(e);
            if ("type" === t.name) return this.flowParseTypeAlias(e);
            if ("opaque" === t.name) return this.flowParseOpaqueType(e, !1);
           }
          return super.parseExpressionStatement(e, t, r);
         }
         shouldParseExportDeclaration() {
          let { type: e } = this.state;
          return H(e) || (this.shouldParseEnums() && 126 === e) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
         }
         isExportDefaultSpecifier() {
          let { type: e } = this.state;
          return H(e) || (this.shouldParseEnums() && 126 === e) ? this.state.containsEsc : super.isExportDefaultSpecifier();
         }
         parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(126)) {
           let e = this.startNode();
           return this.next(), this.flowParseEnumDeclaration(e);
          }
          return super.parseExportDefaultExpression();
         }
         parseConditional(e, t, r) {
          if (!this.match(17)) return e;
          if (this.state.maybeInArrowParameters) {
           let t = this.lookaheadCharCode();
           if (44 === t || 61 === t || 58 === t || 41 === t) return this.setOptionalParametersError(r), e;
          }
          this.expect(17);
          let n = this.state.clone(),
           s = this.state.noArrowAt,
           i = this.startNodeAt(t),
           { consequent: a, failed: o } = this.tryParseConditionalConsequent(),
           [u, l] = this.getArrowLikeExpressions(a);
          if (o || l.length > 0) {
           let e = [...s];
           if (l.length > 0) {
            (this.state = n), (this.state.noArrowAt = e);
            for (let t = 0; t < l.length; t++) e.push(l[t].start);
            ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()), ([u, l] = this.getArrowLikeExpressions(a));
           }
           o && u.length > 1 && this.raise(ct.AmbiguousConditionalArrow, { at: n.startLoc }), o && 1 === u.length && ((this.state = n), e.push(u[0].start), (this.state.noArrowAt = e), ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()));
          }
          return this.getArrowLikeExpressions(a, !0), (this.state.noArrowAt = s), this.expect(14), (i.test = e), (i.consequent = a), (i.alternate = this.forwardNoArrowParamsConversionAt(i, () => this.parseMaybeAssign(void 0, void 0))), this.finishNode(i, "ConditionalExpression");
         }
         tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          let e = this.parseMaybeAssignAllowIn(),
           t = !this.match(14);
          return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: t };
         }
         getArrowLikeExpressions(e, t) {
          let r = [e],
           n = [];
          for (; 0 !== r.length; ) {
           let e = r.pop();
           "ArrowFunctionExpression" === e.type ? (e.typeParameters || !e.returnType ? this.finishArrowValidation(e) : n.push(e), r.push(e.body)) : "ConditionalExpression" === e.type && (r.push(e.consequent), r.push(e.alternate));
          }
          return t
           ? (n.forEach((e) => this.finishArrowValidation(e)), [n, []])
           : (function (e, t) {
              let r = [],
               n = [];
              for (let s = 0; s < e.length; s++) (t(e[s], s, e) ? r : n).push(e[s]);
              return [r, n];
             })(n, (e) => e.params.every((e) => this.isAssignable(e, !0)));
         }
         finishArrowValidation(e) {
          var t;
          this.toAssignableList(e.params, null == (t = e.extra) ? void 0 : t.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(e, !1, !0), this.scope.exit();
         }
         forwardNoArrowParamsConversionAt(e, t) {
          let r;
          return -1 !== this.state.noArrowParamsConversionAt.indexOf(e.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), (r = t()), this.state.noArrowParamsConversionAt.pop()) : (r = t()), r;
         }
         parseParenItem(e, t) {
          if (((e = super.parseParenItem(e, t)), this.eat(17) && ((e.optional = !0), this.resetEndLocation(e)), this.match(14))) {
           let r = this.startNodeAt(t);
           return (r.expression = e), (r.typeAnnotation = this.flowParseTypeAnnotation()), this.finishNode(r, "TypeCastExpression");
          }
          return e;
         }
         assertModuleNodeAllowed(e) {
          ("ImportDeclaration" === e.type && ("type" === e.importKind || "typeof" === e.importKind)) || ("ExportNamedDeclaration" === e.type && "type" === e.exportKind) || ("ExportAllDeclaration" === e.type && "type" === e.exportKind) || super.assertModuleNodeAllowed(e);
         }
         parseExportDeclaration(e) {
          if (this.isContextual(130)) {
           e.exportKind = "type";
           let t = this.startNode();
           return this.next(), this.match(5) ? ((e.specifiers = this.parseExportSpecifiers(!0)), super.parseExportFrom(e), null) : this.flowParseTypeAlias(t);
          }
          if (this.isContextual(131)) {
           e.exportKind = "type";
           let t = this.startNode();
           return this.next(), this.flowParseOpaqueType(t, !1);
          }
          if (this.isContextual(129)) {
           e.exportKind = "type";
           let t = this.startNode();
           return this.next(), this.flowParseInterface(t);
          }
          if (this.shouldParseEnums() && this.isContextual(126)) {
           e.exportKind = "value";
           let t = this.startNode();
           return this.next(), this.flowParseEnumDeclaration(t);
          }
          return super.parseExportDeclaration(e);
         }
         eatExportStar(e) {
          return !!super.eatExportStar(e) || (!(!this.isContextual(130) || 55 !== this.lookahead().type) && ((e.exportKind = "type"), this.next(), this.next(), !0));
         }
         maybeParseExportNamespaceSpecifier(e) {
          let { startLoc: t } = this.state,
           r = super.maybeParseExportNamespaceSpecifier(e);
          return r && "type" === e.exportKind && this.unexpected(t), r;
         }
         parseClassId(e, t, r) {
          super.parseClassId(e, t, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
         }
         parseClassMember(e, t, r) {
          let { startLoc: n } = this.state;
          if (this.isContextual(125)) {
           if (super.parseClassMemberFromModifier(e, t)) return;
           t.declare = !0;
          }
          super.parseClassMember(e, t, r), t.declare && ("ClassProperty" !== t.type && "ClassPrivateProperty" !== t.type && "PropertyDefinition" !== t.type ? this.raise(ct.DeclareClassElement, { at: n }) : t.value && this.raise(ct.DeclareClassFieldInitializer, { at: t.value }));
         }
         isIterator(e) {
          return "iterator" === e || "asyncIterator" === e;
         }
         readIterator() {
          let e = super.readWord1(),
           t = "@@" + e;
          (!this.isIterator(e) || !this.state.inType) && this.raise(g.InvalidIdentifier, { at: this.state.curPosition(), identifierName: t }), this.finishToken(132, t);
         }
         getTokenFromCode(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          123 === e && 124 === t
           ? this.finishOp(6, 2)
           : !this.state.inType || (62 !== e && 60 !== e)
             ? this.state.inType && 63 === e
               ? 46 === t
                 ? this.finishOp(18, 2)
                 : this.finishOp(17, 1)
               : (function (e, t, r) {
                    return 64 === e && 64 === t && ie(r);
                   })(e, t, this.input.charCodeAt(this.state.pos + 2))
                 ? ((this.state.pos += 2), this.readIterator())
                 : super.getTokenFromCode(e)
             : this.finishOp(62 === e ? 48 : 47, 1);
         }
         isAssignable(e, t) {
          return "TypeCastExpression" === e.type ? this.isAssignable(e.expression, t) : super.isAssignable(e, t);
         }
         toAssignable(e, t = !1) {
          !t && "AssignmentExpression" === e.type && "TypeCastExpression" === e.left.type && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, t);
         }
         toAssignableList(e, t, r) {
          for (let n = 0; n < e.length; n++) {
           let t = e[n];
           "TypeCastExpression" === (null == t ? void 0 : t.type) && (e[n] = this.typeCastToParameter(t));
          }
          super.toAssignableList(e, t, r);
         }
         toReferencedList(e, t) {
          for (let n = 0; n < e.length; n++) {
           var r;
           let s = e[n];
           s && "TypeCastExpression" === s.type && (null == (r = s.extra) || !r.parenthesized) && (e.length > 1 || !t) && this.raise(ct.TypeCastInPattern, { at: s.typeAnnotation });
          }
          return e;
         }
         parseArrayLike(e, t, r, n) {
          let s = super.parseArrayLike(e, t, r, n);
          return t && !this.state.maybeInArrowParameters && this.toReferencedList(s.elements), s;
         }
         isValidLVal(e, t, r) {
          return "TypeCastExpression" === e || super.isValidLVal(e, t, r);
         }
         parseClassProperty(e) {
          return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
         }
         parseClassPrivateProperty(e) {
          return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
         }
         isClassMethod() {
          return this.match(47) || super.isClassMethod();
         }
         isClassProperty() {
          return this.match(14) || super.isClassProperty();
         }
         isNonstaticConstructor(e) {
          return !this.match(14) && super.isNonstaticConstructor(e);
         }
         pushClassMethod(e, t, r, n, s, i) {
          if ((t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, t, r, n, s, i), t.params && s)) {
           let e = t.params;
           e.length > 0 && this.isThisParam(e[0]) && this.raise(ct.ThisParamBannedInConstructor, { at: t });
          } else if ("MethodDefinition" === t.type && s && t.value.params) {
           let e = t.value.params;
           e.length > 0 && this.isThisParam(e[0]) && this.raise(ct.ThisParamBannedInConstructor, { at: t });
          }
         }
         pushClassPrivateMethod(e, t, r, n) {
          t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, t, r, n);
         }
         parseClassSuper(e) {
          if ((super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113))) {
           this.next();
           let t = (e.implements = []);
           do {
            let e = this.startNode();
            (e.id = this.flowParseRestrictedIdentifier(!0)), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), t.push(this.finishNode(e, "ClassImplements"));
           } while (this.eat(12));
          }
         }
         checkGetterSetterParams(e) {
          super.checkGetterSetterParams(e);
          let t = this.getObjectOrClassMethodParams(e);
          if (t.length > 0) {
           let r = t[0];
           this.isThisParam(r) && "get" === e.kind ? this.raise(ct.GetterMayNotHaveThisParam, { at: r }) : this.isThisParam(r) && this.raise(ct.SetterMayNotHaveThisParam, { at: r });
          }
         }
         parsePropertyNamePrefixOperator(e) {
          e.variance = this.flowParseVariance();
         }
         parseObjPropValue(e, t, r, n, s, i, a) {
          let o;
          e.variance && this.unexpected(e.variance.loc.start), delete e.variance, this.match(47) && !i && ((o = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected());
          let u = super.parseObjPropValue(e, t, r, n, s, i, a);
          return o && ((u.value || u).typeParameters = o), u;
         }
         parseAssignableListItemTypes(e) {
          return this.eat(17) && ("Identifier" !== e.type && this.raise(ct.PatternIsOptional, { at: e }), this.isThisParam(e) && this.raise(ct.ThisParamMayNotBeOptional, { at: e }), (e.optional = !0)), this.match(14) ? (e.typeAnnotation = this.flowParseTypeAnnotation()) : this.isThisParam(e) && this.raise(ct.ThisParamAnnotationRequired, { at: e }), this.match(29) && this.isThisParam(e) && this.raise(ct.ThisParamNoDefault, { at: e }), this.resetEndLocation(e), e;
         }
         parseMaybeDefault(e, t) {
          let r = super.parseMaybeDefault(e, t);
          return "AssignmentPattern" === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(ct.TypeBeforeInitializer, { at: r.typeAnnotation }), r;
         }
         checkImportReflection(e) {
          super.checkImportReflection(e), e.module && "value" !== e.importKind && this.raise(ct.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
         }
         parseImportSpecifierLocal(e, t, r) {
          (t.local = ht(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r));
         }
         isPotentialImportPhase(e) {
          if (super.isPotentialImportPhase(e)) return !0;
          if (this.isContextual(130)) {
           if (!e) return !0;
           let t = this.lookaheadCharCode();
           return 123 === t || 42 === t;
          }
          return !e && this.isContextual(87);
         }
         applyImportPhase(e, t, r, n) {
          if ((super.applyImportPhase(e, t, r, n), t)) {
           if (!r && this.match(65)) return;
           e.exportKind = "type" === r ? r : "value";
          } else "type" === r && this.match(55) && this.unexpected(), (e.importKind = "type" === r || "typeof" === r ? r : "value");
         }
         parseImportSpecifier(e, t, r, n, s) {
          let i = e.imported,
           a = null;
          "Identifier" === i.type && ("type" === i.name ? (a = "type") : "typeof" === i.name && (a = "typeof"));
          let o = !1;
          if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
           let t = this.parseIdentifier(!0);
           null === a || V(this.state.type) ? ((e.imported = i), (e.importKind = null), (e.local = this.parseIdentifier())) : ((e.imported = t), (e.importKind = a), (e.local = ot(t)));
          } else {
           if (null !== a && V(this.state.type)) (e.imported = this.parseIdentifier(!0)), (e.importKind = a);
           else {
            if (t) throw this.raise(g.ImportBindingIsString, { at: e, importName: i.value });
            (e.imported = i), (e.importKind = null);
           }
           this.eatContextual(93) ? (e.local = this.parseIdentifier()) : ((o = !0), (e.local = ot(e.imported)));
          }
          let u = ht(e);
          return r && u && this.raise(ct.ImportTypeShorthandOnlyInPureImport, { at: e }), (r || u) && this.checkReservedType(e.local.name, e.local.loc.start, !0), o && !r && !u && this.checkReservedWord(e.local.name, e.loc.start, !0, !0), this.finishImportSpecifier(e, "ImportSpecifier");
         }
         parseBindingAtom() {
          return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
         }
         parseFunctionParams(e, t) {
          let r = e.kind;
          "get" !== r && "set" !== r && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, t);
         }
         parseVarId(e, t) {
          super.parseVarId(e, t), this.match(14) && ((e.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(e.id));
         }
         parseAsyncArrowFromCallExpression(e, t) {
          if (this.match(14)) {
           let t = this.state.noAnonFunctionType;
           (this.state.noAnonFunctionType = !0), (e.returnType = this.flowParseTypeAnnotation()), (this.state.noAnonFunctionType = t);
          }
          return super.parseAsyncArrowFromCallExpression(e, t);
         }
         shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
         }
         parseMaybeAssign(e, t) {
          var r;
          let n,
           s = null;
          if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
           if (((s = this.state.clone()), (n = this.tryParse(() => super.parseMaybeAssign(e, t), s)), !n.error)) return n.node;
           let { context: r } = this.state,
            i = r[r.length - 1];
           (i === E.j_oTag || i === E.j_expr) && r.pop();
          }
          if ((null != (r = n) && r.error) || this.match(47)) {
           var i, a;
           s = s || this.state.clone();
           let r,
            o = this.tryParse((n) => {
             var s;
             r = this.flowParseTypeParameterDeclaration();
             let i = this.forwardNoArrowParamsConversionAt(r, () => {
              let n = super.parseMaybeAssign(e, t);
              return this.resetStartLocationFromNode(n, r), n;
             });
             null != (s = i.extra) && s.parenthesized && n();
             let a = this.maybeUnwrapTypeCastExpression(i);
             return "ArrowFunctionExpression" !== a.type && n(), (a.typeParameters = r), this.resetStartLocationFromNode(a, r), i;
            }, s),
            u = null;
           if (o.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(o.node).type) {
            if (!o.error && !o.aborted) return o.node.async && this.raise(ct.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: r }), o.node;
            u = o.node;
           }
           if (null != (i = n) && i.node) return (this.state = n.failState), n.node;
           if (u) return (this.state = o.failState), u;
           throw null != (a = n) && a.thrown ? n.error : o.thrown ? o.error : this.raise(ct.UnexpectedTokenAfterTypeParameter, { at: r });
          }
          return super.parseMaybeAssign(e, t);
         }
         parseArrow(e) {
          if (this.match(14)) {
           let t = this.tryParse(() => {
            let t = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = !0;
            let r = this.startNode();
            return ([r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (this.state.noAnonFunctionType = t), this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r;
           });
           if (t.thrown) return null;
           t.error && (this.state = t.failState), (e.returnType = t.node.typeAnnotation ? this.finishNode(t.node, "TypeAnnotation") : null);
          }
          return super.parseArrow(e);
         }
         shouldParseArrow(e) {
          return this.match(14) || super.shouldParseArrow(e);
         }
         setArrowFunctionParameters(e, t) {
          -1 !== this.state.noArrowParamsConversionAt.indexOf(e.start) ? (e.params = t) : super.setArrowFunctionParameters(e, t);
         }
         checkParams(e, t, r, n = !0) {
          if (!r || -1 === this.state.noArrowParamsConversionAt.indexOf(e.start)) {
           for (let t = 0; t < e.params.length; t++) this.isThisParam(e.params[t]) && t > 0 && this.raise(ct.ThisParamMustBeFirst, { at: e.params[t] });
           super.checkParams(e, t, r, n);
          }
         }
         parseParenAndDistinguishExpression(e) {
          return super.parseParenAndDistinguishExpression(e && -1 === this.state.noArrowAt.indexOf(this.state.start));
         }
         parseSubscripts(e, t, r) {
          if ("Identifier" === e.type && "async" === e.name && -1 !== this.state.noArrowAt.indexOf(t.index)) {
           this.next();
           let r = this.startNodeAt(t);
           (r.callee = e), (r.arguments = super.parseCallExpressionArguments(11, !1)), (e = this.finishNode(r, "CallExpression"));
          } else if ("Identifier" === e.type && "async" === e.name && this.match(47)) {
           let n = this.state.clone(),
            s = this.tryParse((e) => this.parseAsyncArrowWithTypeParameters(t) || e(), n);
           if (!s.error && !s.aborted) return s.node;
           let i = this.tryParse(() => super.parseSubscripts(e, t, r), n);
           if (i.node && !i.error) return i.node;
           if (s.node) return (this.state = s.failState), s.node;
           if (i.node) return (this.state = i.failState), i.node;
           throw s.error || i.error;
          }
          return super.parseSubscripts(e, t, r);
         }
         parseSubscript(e, t, r, n) {
          if (this.match(18) && this.isLookaheadToken_lt()) {
           if (((n.optionalChainMember = !0), r)) return (n.stop = !0), e;
           this.next();
           let s = this.startNodeAt(t);
           return (s.callee = e), (s.typeArguments = this.flowParseTypeParameterInstantiation()), this.expect(10), (s.arguments = this.parseCallExpressionArguments(11, !1)), (s.optional = !0), this.finishCallExpression(s, !0);
          }
          if (!r && this.shouldParseTypes() && this.match(47)) {
           let r = this.startNodeAt(t);
           r.callee = e;
           let s = this.tryParse(() => ((r.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()), this.expect(10), (r.arguments = super.parseCallExpressionArguments(11, !1)), n.optionalChainMember && (r.optional = !1), this.finishCallExpression(r, n.optionalChainMember)));
           if (s.node) return s.error && (this.state = s.failState), s.node;
          }
          return super.parseSubscript(e, t, r, n);
         }
         parseNewCallee(e) {
          super.parseNewCallee(e);
          let t = null;
          this.shouldParseTypes() && this.match(47) && (t = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), (e.typeArguments = t);
         }
         parseAsyncArrowWithTypeParameters(e) {
          let t = this.startNodeAt(e);
          if ((this.parseFunctionParams(t, !1), this.parseArrow(t))) return super.parseArrowExpression(t, void 0, !0);
         }
         readToken_mult_modulo(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          if (42 === e && 47 === t && this.state.hasFlowComment) return (this.state.hasFlowComment = !1), (this.state.pos += 2), void this.nextToken();
          super.readToken_mult_modulo(e);
         }
         readToken_pipe_amp(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          124 !== e || 125 !== t ? super.readToken_pipe_amp(e) : this.finishOp(9, 2);
         }
         parseTopLevel(e, t) {
          let r = super.parseTopLevel(e, t);
          return this.state.hasFlowComment && this.raise(ct.UnterminatedFlowComment, { at: this.state.curPosition() }), r;
         }
         skipBlockComment() {
          if (!this.hasPlugin("flowComments") || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
          {
           if (this.state.hasFlowComment) throw this.raise(ct.NestedFlowComment, { at: this.state.startLoc });
           this.hasFlowCommentCompletion();
           let e = this.skipFlowComment();
           e && ((this.state.pos += e), (this.state.hasFlowComment = !0));
          }
         }
         skipFlowComment() {
          let { pos: e } = this.state,
           t = 2;
          for (; [32, 9].includes(this.input.charCodeAt(e + t)); ) t++;
          let r = this.input.charCodeAt(t + e),
           n = this.input.charCodeAt(t + e + 1);
          return 58 === r && 58 === n ? t + 2 : "flow-include" === this.input.slice(t + e, t + e + 12) ? t + 12 : 58 === r && 58 !== n && t;
         }
         hasFlowCommentCompletion() {
          if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(g.UnterminatedComment, { at: this.state.curPosition() });
         }
         flowEnumErrorBooleanMemberNotInitialized(e, { enumName: t, memberName: r }) {
          this.raise(ct.EnumBooleanMemberNotInitialized, { at: e, memberName: r, enumName: t });
         }
         flowEnumErrorInvalidMemberInitializer(e, t) {
          return this.raise(t.explicitType ? ("symbol" === t.explicitType ? ct.EnumInvalidMemberInitializerSymbolType : ct.EnumInvalidMemberInitializerPrimaryType) : ct.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e }, t));
         }
         flowEnumErrorNumberMemberNotInitialized(e, { enumName: t, memberName: r }) {
          this.raise(ct.EnumNumberMemberNotInitialized, { at: e, enumName: t, memberName: r });
         }
         flowEnumErrorStringMemberInconsistentlyInitialized(e, { enumName: t }) {
          this.raise(ct.EnumStringMemberInconsistentlyInitialized, { at: e, enumName: t });
         }
         flowEnumMemberInit() {
          let e = this.state.startLoc,
           t = () => this.match(12) || this.match(8);
          switch (this.state.type) {
           case 134: {
            let r = this.parseNumericLiteral(this.state.value);
            return t() ? { type: "number", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
           }
           case 133: {
            let r = this.parseStringLiteral(this.state.value);
            return t() ? { type: "string", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
           }
           case 85:
           case 86: {
            let r = this.parseBooleanLiteral(this.match(85));
            return t() ? { type: "boolean", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
           }
           default:
            return { type: "invalid", loc: e };
          }
         }
         flowEnumMemberRaw() {
          let e = this.state.startLoc;
          return { id: this.parseIdentifier(!0), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e } };
         }
         flowEnumCheckExplicitTypeMismatch(e, t, r) {
          let { explicitType: n } = t;
          null !== n && n !== r && this.flowEnumErrorInvalidMemberInitializer(e, t);
         }
         flowEnumMembers({ enumName: e, explicitType: t }) {
          let r = new Set(),
           n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] },
           s = !1;
          for (; !this.match(8); ) {
           if (this.eat(21)) {
            s = !0;
            break;
           }
           let i = this.startNode(),
            { id: a, init: o } = this.flowEnumMemberRaw(),
            u = a.name;
           if ("" === u) continue;
           /^[a-z]/.test(u) && this.raise(ct.EnumInvalidMemberName, { at: a, memberName: u, suggestion: u[0].toUpperCase() + u.slice(1), enumName: e }), r.has(u) && this.raise(ct.EnumDuplicateMemberName, { at: a, memberName: u, enumName: e }), r.add(u);
           let l = { enumName: e, explicitType: t, memberName: u };
           switch (((i.id = a), o.type)) {
            case "boolean":
             this.flowEnumCheckExplicitTypeMismatch(o.loc, l, "boolean"), (i.init = o.value), n.booleanMembers.push(this.finishNode(i, "EnumBooleanMember"));
             break;
            case "number":
             this.flowEnumCheckExplicitTypeMismatch(o.loc, l, "number"), (i.init = o.value), n.numberMembers.push(this.finishNode(i, "EnumNumberMember"));
             break;
            case "string":
             this.flowEnumCheckExplicitTypeMismatch(o.loc, l, "string"), (i.init = o.value), n.stringMembers.push(this.finishNode(i, "EnumStringMember"));
             break;
            case "invalid":
             throw this.flowEnumErrorInvalidMemberInitializer(o.loc, l);
            case "none":
             switch (t) {
              case "boolean":
               this.flowEnumErrorBooleanMemberNotInitialized(o.loc, l);
               break;
              case "number":
               this.flowEnumErrorNumberMemberNotInitialized(o.loc, l);
               break;
              default:
               n.defaultedMembers.push(this.finishNode(i, "EnumDefaultedMember"));
             }
           }
           this.match(8) || this.expect(12);
          }
          return { members: n, hasUnknownMembers: s };
         }
         flowEnumStringMembers(e, t, { enumName: r }) {
          if (0 === e.length) return t;
          if (0 === t.length) return e;
          if (t.length > e.length) {
           for (let t of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(t, { enumName: r });
           return t;
          }
          for (let n of t) this.flowEnumErrorStringMemberInconsistentlyInitialized(n, { enumName: r });
          return e;
         }
         flowEnumParseExplicitType({ enumName: e }) {
          if (!this.eatContextual(102)) return null;
          if (!$(this.state.type)) throw this.raise(ct.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: e });
          let { value: t } = this.state;
          return this.next(), "boolean" !== t && "number" !== t && "string" !== t && "symbol" !== t && this.raise(ct.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: e, invalidEnumType: t }), t;
         }
         flowEnumBody(e, t) {
          let r = t.name,
           n = t.loc.start,
           s = this.flowEnumParseExplicitType({ enumName: r });
          this.expect(5);
          let { members: i, hasUnknownMembers: a } = this.flowEnumMembers({ enumName: r, explicitType: s });
          switch (((e.hasUnknownMembers = a), s)) {
           case "boolean":
            return (e.explicitType = !0), (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, "EnumBooleanBody");
           case "number":
            return (e.explicitType = !0), (e.members = i.numberMembers), this.expect(8), this.finishNode(e, "EnumNumberBody");
           case "string":
            return (e.explicitType = !0), (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, "EnumStringBody");
           case "symbol":
            return (e.members = i.defaultedMembers), this.expect(8), this.finishNode(e, "EnumSymbolBody");
           default: {
            let t = () => ((e.members = []), this.expect(8), this.finishNode(e, "EnumStringBody"));
            e.explicitType = !1;
            let s = i.booleanMembers.length,
             a = i.numberMembers.length,
             o = i.stringMembers.length,
             u = i.defaultedMembers.length;
            if (!(s || a || o || u)) return t();
            if (!s && !a) return (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, "EnumStringBody");
            if (!a && !o && s >= u) {
             for (let e of i.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
             return (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, "EnumBooleanBody");
            }
            if (!s && !o && a >= u) {
             for (let e of i.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
             return (e.members = i.numberMembers), this.expect(8), this.finishNode(e, "EnumNumberBody");
            }
            return this.raise(ct.EnumInconsistentMemberValues, { at: n, enumName: r }), t();
           }
          }
         }
         flowParseEnumDeclaration(e) {
          let t = this.parseIdentifier();
          return (e.id = t), (e.body = this.flowEnumBody(this.startNode(), t)), this.finishNode(e, "EnumDeclaration");
         }
         isLookaheadToken_lt() {
          let e = this.nextTokenStart();
          if (60 === this.input.charCodeAt(e)) {
           let t = this.input.charCodeAt(e + 1);
           return 60 !== t && 61 !== t;
          }
          return !1;
         }
         maybeUnwrapTypeCastExpression(e) {
          return "TypeCastExpression" === e.type ? e.expression : e;
         }
        },
       typescript: (e) =>
        class extends e {
         constructor(...e) {
          super(...e), (this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: Ct.InvalidModifierOnTypeParameter })), (this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: Ct.InvalidModifierOnTypeParameterPositions })), (this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: Ct.InvalidModifierOnTypeParameter }));
         }
         getScopeHandler() {
          return xt;
         }
         tsIsIdentifier() {
          return $(this.state.type);
         }
         tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
         }
         tsNextTokenCanFollowModifier() {
          return this.next(), this.tsTokenCanFollowModifier();
         }
         tsParseModifier(e, t) {
          if (!$(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
          let r = this.state.value;
          if (-1 !== e.indexOf(r)) {
           if (t && this.tsIsStartOfStaticBlocks()) return;
           if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return r;
          }
         }
         tsParseModifiers({ allowedModifiers: e, disallowedModifiers: t, stopOnStartOfClassStaticBlock: r, errorTemplate: n = Ct.InvalidModifierOnTypeMember }, s) {
          let i = (e, t, r, n) => {
            t === r && s[n] && this.raise(Ct.InvalidModifiersOrder, { at: e, orderedModifiers: [r, n] });
           },
           a = (e, t, r, n) => {
            ((s[r] && t === n) || (s[n] && t === r)) && this.raise(Ct.IncompatibleModifiers, { at: e, modifiers: [r, n] });
           };
          for (;;) {
           let { startLoc: o } = this.state,
            u = this.tsParseModifier(e.concat(t ?? []), r);
           if (!u) break;
           Tt(u) ? (s.accessibility ? this.raise(Ct.DuplicateAccessibilityModifier, { at: o, modifier: u }) : (i(o, u, u, "override"), i(o, u, u, "static"), i(o, u, u, "readonly"), (s.accessibility = u))) : wt(u) ? (s[u] && this.raise(Ct.DuplicateModifier, { at: o, modifier: u }), (s[u] = !0), i(o, u, "in", "out")) : (Object.hasOwnProperty.call(s, u) ? this.raise(Ct.DuplicateModifier, { at: o, modifier: u }) : (i(o, u, "static", "readonly"), i(o, u, "static", "override"), i(o, u, "override", "readonly"), i(o, u, "abstract", "override"), a(o, u, "declare", "override"), a(o, u, "static", "abstract")), (s[u] = !0)), null != t && t.includes(u) && this.raise(n, { at: o, modifier: u });
          }
         }
         tsIsListTerminator(e) {
          switch (e) {
           case "EnumMembers":
           case "TypeMembers":
            return this.match(8);
           case "HeritageClauseElement":
            return this.match(5);
           case "TupleElementTypes":
            return this.match(3);
           case "TypeParametersOrArguments":
            return this.match(48);
          }
         }
         tsParseList(e, t) {
          let r = [];
          for (; !this.tsIsListTerminator(e); ) r.push(t());
          return r;
         }
         tsParseDelimitedList(e, t, r) {
          return (function (e) {
           if (null == e) throw new Error(`Unexpected ${e} value.`);
           return e;
          })(this.tsParseDelimitedListWorker(e, t, !0, r));
         }
         tsParseDelimitedListWorker(e, t, r, n) {
          let s = [],
           i = -1;
          for (; !this.tsIsListTerminator(e); ) {
           i = -1;
           let n = t();
           if (null == n) return;
           if ((s.push(n), !this.eat(12))) {
            if (this.tsIsListTerminator(e)) break;
            return void (r && this.expect(12));
           }
           i = this.state.lastTokStart;
          }
          return n && (n.value = i), s;
         }
         tsParseBracketedList(e, t, r, n, s) {
          n || (r ? this.expect(0) : this.expect(47));
          let i = this.tsParseDelimitedList(e, t, s);
          return r ? this.expect(3) : this.expect(48), i;
         }
         tsParseImportType() {
          let e = this.startNode();
          return this.expect(83), this.expect(10), this.match(133) || this.raise(Ct.UnsupportedImportTypeArgument, { at: this.state.startLoc }), (e.argument = super.parseExprAtom()), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
         }
         tsParseEntityName(e = !0) {
          let t = this.parseIdentifier(e);
          for (; this.eat(16); ) {
           let r = this.startNodeAtNode(t);
           (r.left = t), (r.right = this.parseIdentifier(e)), (t = this.finishNode(r, "TSQualifiedName"));
          }
          return t;
         }
         tsParseTypeReference() {
          let e = this.startNode();
          return (e.typeName = this.tsParseEntityName()), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
         }
         tsParseThisTypePredicate(e) {
          this.next();
          let t = this.startNodeAtNode(e);
          return (t.parameterName = e), (t.typeAnnotation = this.tsParseTypeAnnotation(!1)), (t.asserts = !1), this.finishNode(t, "TSTypePredicate");
         }
         tsParseThisTypeNode() {
          let e = this.startNode();
          return this.next(), this.finishNode(e, "TSThisType");
         }
         tsParseTypeQuery() {
          let e = this.startNode();
          return this.expect(87), this.match(83) ? (e.exprName = this.tsParseImportType()) : (e.exprName = this.tsParseEntityName()), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
         }
         tsParseTypeParameter(e) {
          let t = this.startNode();
          return e(t), (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsEatThenParseType(81)), (t.default = this.tsEatThenParseType(29)), this.finishNode(t, "TSTypeParameter");
         }
         tsTryParseTypeParameters(e) {
          if (this.match(47)) return this.tsParseTypeParameters(e);
         }
         tsParseTypeParameters(e) {
          let t = this.startNode();
          this.match(47) || this.match(142) ? this.next() : this.unexpected();
          let r = { value: -1 };
          return (t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), !1, !0, r)), 0 === t.params.length && this.raise(Ct.EmptyTypeParameters, { at: t }), -1 !== r.value && this.addExtra(t, "trailingComma", r.value), this.finishNode(t, "TSTypeParameterDeclaration");
         }
         tsFillSignature(e, t) {
          let r = 19 === e,
           n = "typeAnnotation";
          (t.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier)), this.expect(10), (t.parameters = this.tsParseBindingListForSignature()), (r || this.match(e)) && (t[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
         }
         tsParseBindingListForSignature() {
          let e = super.parseBindingList(11, 41, 2);
          for (let t of e) {
           let { type: e } = t;
           ("AssignmentPattern" === e || "TSParameterProperty" === e) && this.raise(Ct.UnsupportedSignatureParameterKind, { at: t, type: e });
          }
          return e;
         }
         tsParseTypeMemberSemicolon() {
          !this.eat(12) && !this.isLineTerminator() && this.expect(13);
         }
         tsParseSignatureMember(e, t) {
          return this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e);
         }
         tsIsUnambiguouslyIndexSignature() {
          return this.next(), !!$(this.state.type) && (this.next(), this.match(14));
         }
         tsTryParseIndexSignature(e) {
          if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
          this.expect(0);
          let t = this.parseIdentifier();
          (t.typeAnnotation = this.tsParseTypeAnnotation()), this.resetEndLocation(t), this.expect(3), (e.parameters = [t]);
          let r = this.tsTryParseTypeAnnotation();
          return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
         }
         tsParsePropertyOrMethodSignature(e, t) {
          this.eat(17) && (e.optional = !0);
          let r = e;
          if (this.match(10) || this.match(47)) {
           t && this.raise(Ct.ReadonlyForMethodSignature, { at: e });
           let n = r;
           n.kind && this.match(47) && this.raise(Ct.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon();
           let s = "parameters",
            i = "typeAnnotation";
           if ("get" === n.kind) n[s].length > 0 && (this.raise(g.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(n[s][0]) && this.raise(Ct.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
           else if ("set" === n.kind) {
            if (1 !== n[s].length) this.raise(g.BadSetterArity, { at: this.state.curPosition() });
            else {
             let e = n[s][0];
             this.isThisParam(e) && this.raise(Ct.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), "Identifier" === e.type && e.optional && this.raise(Ct.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), "RestElement" === e.type && this.raise(Ct.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
            }
            n[i] && this.raise(Ct.SetAccesorCannotHaveReturnType, { at: n[i] });
           } else n.kind = "method";
           return this.finishNode(n, "TSMethodSignature");
          }
          {
           let e = r;
           t && (e.readonly = !0);
           let n = this.tsTryParseTypeAnnotation();
           return n && (e.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSPropertySignature");
          }
         }
         tsParseTypeMember() {
          let e = this.startNode();
          if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
          if (this.match(77)) {
           let t = this.startNode();
           return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : ((e.key = this.createIdentifier(t, "new")), this.tsParsePropertyOrMethodSignature(e, !1));
          }
          return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e), this.tsTryParseIndexSignature(e) || (super.parsePropertyName(e), !e.computed && "Identifier" === e.key.type && ("get" === e.key.name || "set" === e.key.name) && this.tsTokenCanFollowModifier() && ((e.kind = e.key.name), super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
         }
         tsParseTypeLiteral() {
          let e = this.startNode();
          return (e.members = this.tsParseObjectTypeMembers()), this.finishNode(e, "TSTypeLiteral");
         }
         tsParseObjectTypeMembers() {
          this.expect(5);
          let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          return this.expect(8), e;
         }
         tsIsStartOfMappedType() {
          return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !(!this.match(0) || (this.next(), !this.tsIsIdentifier())) && (this.next(), this.match(58)));
         }
         tsParseMappedTypeParameter() {
          let e = this.startNode();
          return (e.name = this.tsParseTypeParameterName()), (e.constraint = this.tsExpectThenParseType(58)), this.finishNode(e, "TSTypeParameter");
         }
         tsParseMappedType() {
          let e = this.startNode();
          return this.expect(5), this.match(53) ? ((e.readonly = this.state.value), this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = !0), this.expect(0), (e.typeParameter = this.tsParseMappedTypeParameter()), (e.nameType = this.eatContextual(93) ? this.tsParseType() : null), this.expect(3), this.match(53) ? ((e.optional = this.state.value), this.next(), this.expect(17)) : this.eat(17) && (e.optional = !0), (e.typeAnnotation = this.tsTryParseType()), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
         }
         tsParseTupleType() {
          let e = this.startNode();
          e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
          let t = !1;
          return (
           e.elementTypes.forEach((e) => {
            let { type: r } = e;
            t && "TSRestType" !== r && "TSOptionalType" !== r && !("TSNamedTupleMember" === r && e.optional) && this.raise(Ct.OptionalTypeBeforeRequired, { at: e }), t || (t = ("TSNamedTupleMember" === r && e.optional) || "TSOptionalType" === r);
           }),
           this.finishNode(e, "TSTupleType")
          );
         }
         tsParseTupleElementType() {
          let e,
           t,
           r,
           n,
           { startLoc: s } = this.state,
           i = this.eat(21),
           a = V(this.state.type) ? this.lookaheadCharCode() : null;
          if (58 === a) (e = !0), (r = !1), (t = this.parseIdentifier(!0)), this.expect(14), (n = this.tsParseType());
          else if (63 === a) {
           r = !0;
           let s = this.state.startLoc,
            i = this.state.value,
            a = this.tsParseNonArrayType();
           58 === this.lookaheadCharCode() ? ((e = !0), (t = this.createIdentifier(this.startNodeAt(s), i)), this.expect(17), this.expect(14), (n = this.tsParseType())) : ((e = !1), (n = a), this.expect(17));
          } else (n = this.tsParseType()), (r = this.eat(17)), (e = this.eat(14));
          if (e) {
           let e;
           t ? ((e = this.startNodeAtNode(t)), (e.optional = r), (e.label = t), (e.elementType = n), this.eat(17) && ((e.optional = !0), this.raise(Ct.TupleOptionalAfterType, { at: this.state.lastTokStartLoc }))) : ((e = this.startNodeAtNode(n)), (e.optional = r), this.raise(Ct.InvalidTupleMemberLabel, { at: n }), (e.label = n), (e.elementType = this.tsParseType())), (n = this.finishNode(e, "TSNamedTupleMember"));
          } else if (r) {
           let e = this.startNodeAtNode(n);
           (e.typeAnnotation = n), (n = this.finishNode(e, "TSOptionalType"));
          }
          if (i) {
           let e = this.startNodeAt(s);
           (e.typeAnnotation = n), (n = this.finishNode(e, "TSRestType"));
          }
          return n;
         }
         tsParseParenthesizedType() {
          let e = this.startNode();
          return this.expect(10), (e.typeAnnotation = this.tsParseType()), this.expect(11), this.finishNode(e, "TSParenthesizedType");
         }
         tsParseFunctionOrConstructorType(e, t) {
          let r = this.startNode();
          return "TSConstructorType" === e && ((r.abstract = !!t), t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r)), this.finishNode(r, e);
         }
         tsParseLiteralTypeNode() {
          let e = this.startNode();
          switch (this.state.type) {
           case 134:
           case 135:
           case 133:
           case 85:
           case 86:
            e.literal = super.parseExprAtom();
            break;
           default:
            this.unexpected();
          }
          return this.finishNode(e, "TSLiteralType");
         }
         tsParseTemplateLiteralType() {
          let e = this.startNode();
          return (e.literal = super.parseTemplate(!1)), this.finishNode(e, "TSLiteralType");
         }
         parseTemplateSubstitution() {
          return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
         }
         tsParseThisTypeOrThisTypePredicate() {
          let e = this.tsParseThisTypeNode();
          return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
         }
         tsParseNonArrayType() {
          switch (this.state.type) {
           case 133:
           case 134:
           case 135:
           case 85:
           case 86:
            return this.tsParseLiteralTypeNode();
           case 53:
            if ("-" === this.state.value) {
             let e = this.startNode(),
              t = this.lookahead();
             return 134 !== t.type && 135 !== t.type && this.unexpected(), (e.literal = this.parseMaybeUnary()), this.finishNode(e, "TSLiteralType");
            }
            break;
           case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
           case 87:
            return this.tsParseTypeQuery();
           case 83:
            return this.tsParseImportType();
           case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
           case 0:
            return this.tsParseTupleType();
           case 10:
            return this.tsParseParenthesizedType();
           case 25:
           case 24:
            return this.tsParseTemplateLiteralType();
           default: {
            let { type: e } = this.state;
            if ($(e) || 88 === e || 84 === e) {
             let t =
              88 === e
               ? "TSVoidKeyword"
               : 84 === e
                 ? "TSNullKeyword"
                 : (function (e) {
                    switch (e) {
                     case "any":
                      return "TSAnyKeyword";
                     case "boolean":
                      return "TSBooleanKeyword";
                     case "bigint":
                      return "TSBigIntKeyword";
                     case "never":
                      return "TSNeverKeyword";
                     case "number":
                      return "TSNumberKeyword";
                     case "object":
                      return "TSObjectKeyword";
                     case "string":
                      return "TSStringKeyword";
                     case "symbol":
                      return "TSSymbolKeyword";
                     case "undefined":
                      return "TSUndefinedKeyword";
                     case "unknown":
                      return "TSUnknownKeyword";
                     default:
                      return;
                    }
                   })(this.state.value);
             if (void 0 !== t && 46 !== this.lookaheadCharCode()) {
              let e = this.startNode();
              return this.next(), this.finishNode(e, t);
             }
             return this.tsParseTypeReference();
            }
           }
          }
          this.unexpected();
         }
         tsParseArrayTypeOrHigher() {
          let e = this.tsParseNonArrayType();
          for (; !this.hasPrecedingLineBreak() && this.eat(0); )
           if (this.match(3)) {
            let t = this.startNodeAtNode(e);
            (t.elementType = e), this.expect(3), (e = this.finishNode(t, "TSArrayType"));
           } else {
            let t = this.startNodeAtNode(e);
            (t.objectType = e), (t.indexType = this.tsParseType()), this.expect(3), (e = this.finishNode(t, "TSIndexedAccessType"));
           }
          return e;
         }
         tsParseTypeOperator() {
          let e = this.startNode(),
           t = this.state.value;
          return this.next(), (e.operator = t), (e.typeAnnotation = this.tsParseTypeOperatorOrHigher()), "readonly" === t && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
         }
         tsCheckTypeAnnotationForReadOnly(e) {
          switch (e.typeAnnotation.type) {
           case "TSTupleType":
           case "TSArrayType":
            return;
           default:
            this.raise(Ct.UnexpectedReadonly, { at: e });
          }
         }
         tsParseInferType() {
          let e = this.startNode();
          this.expectContextual(115);
          let t = this.startNode();
          return (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())), (e.typeParameter = this.finishNode(t, "TSTypeParameter")), this.finishNode(e, "TSInferType");
         }
         tsParseConstraintForInferType() {
          if (this.eat(81)) {
           let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
           if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
          }
         }
         tsParseTypeOperatorOrHigher() {
          return (function (e) {
           return e >= 121 && e <= 123;
          })(this.state.type) && !this.state.containsEsc
           ? this.tsParseTypeOperator()
           : this.isContextual(115)
             ? this.tsParseInferType()
             : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
         }
         tsParseUnionOrIntersectionType(e, t, r) {
          let n = this.startNode(),
           s = this.eat(r),
           i = [];
          do {
           i.push(t());
          } while (this.eat(r));
          return 1 !== i.length || s ? ((n.types = i), this.finishNode(n, e)) : i[0];
         }
         tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
         }
         tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
         }
         tsIsStartOfFunctionType() {
          return !!this.match(47) || (this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this)));
         }
         tsSkipParameterStart() {
          if ($(this.state.type) || this.match(78)) return this.next(), !0;
          if (this.match(5)) {
           let { errors: e } = this.state,
            t = e.length;
           try {
            return this.parseObjectLike(8, !0), e.length === t;
           } catch {
            return !1;
           }
          }
          if (this.match(0)) {
           this.next();
           let { errors: e } = this.state,
            t = e.length;
           try {
            return super.parseBindingList(3, 93, 1), e.length === t;
           } catch {
            return !1;
           }
          }
          return !1;
         }
         tsIsUnambiguouslyStartOfFunctionType() {
          return this.next(), !!(this.match(11) || this.match(21) || (this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || (this.match(11) && (this.next(), this.match(19))))));
         }
         tsParseTypeOrTypePredicateAnnotation(e) {
          return this.tsInType(() => {
           let t = this.startNode();
           this.expect(e);
           let r = this.startNode(),
            n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
           if (n && this.match(78)) {
            let e = this.tsParseThisTypeOrThisTypePredicate();
            return "TSThisType" === e.type ? ((r.parameterName = e), (r.asserts = !0), (r.typeAnnotation = null), (e = this.finishNode(r, "TSTypePredicate"))) : (this.resetStartLocationFromNode(e, r), (e.asserts = !0)), (t.typeAnnotation = e), this.finishNode(t, "TSTypeAnnotation");
           }
           let s = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
           if (!s) return n ? ((r.parameterName = this.parseIdentifier()), (r.asserts = n), (r.typeAnnotation = null), (t.typeAnnotation = this.finishNode(r, "TSTypePredicate")), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, t);
           let i = this.tsParseTypeAnnotation(!1);
           return (r.parameterName = s), (r.typeAnnotation = i), (r.asserts = n), (t.typeAnnotation = this.finishNode(r, "TSTypePredicate")), this.finishNode(t, "TSTypeAnnotation");
          });
         }
         tsTryParseTypeOrTypePredicateAnnotation() {
          if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
         }
         tsTryParseTypeAnnotation() {
          if (this.match(14)) return this.tsParseTypeAnnotation();
         }
         tsTryParseType() {
          return this.tsEatThenParseType(14);
         }
         tsParseTypePredicatePrefix() {
          let e = this.parseIdentifier();
          if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e;
         }
         tsParseTypePredicateAsserts() {
          if (109 !== this.state.type) return !1;
          let e = this.state.containsEsc;
          return this.next(), !(!$(this.state.type) && !this.match(78)) && (e && this.raise(g.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), !0);
         }
         tsParseTypeAnnotation(e = !0, t = this.startNode()) {
          return (
           this.tsInType(() => {
            e && this.expect(14), (t.typeAnnotation = this.tsParseType());
           }),
           this.finishNode(t, "TSTypeAnnotation")
          );
         }
         tsParseType() {
          Et(this.state.inType);
          let e = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
          let t = this.startNodeAtNode(e);
          return (t.checkType = e), (t.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())), this.expect(17), (t.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.expect(14), (t.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.finishNode(t, "TSConditionalType");
         }
         isAbstractConstructorSignature() {
          return this.isContextual(124) && 77 === this.lookahead().type;
         }
         tsParseNonConditionalType() {
          return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
         }
         tsParseTypeAssertion() {
          this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Ct.ReservedTypeAssertion, { at: this.state.startLoc });
          let e = this.startNode();
          return (e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType()))), this.expect(48), (e.expression = this.parseMaybeUnary()), this.finishNode(e, "TSTypeAssertion");
         }
         tsParseHeritageClause(e) {
          let t = this.state.startLoc,
           r = this.tsParseDelimitedList("HeritageClauseElement", () => {
            let e = this.startNode();
            return (e.expression = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSExpressionWithTypeArguments");
           });
          return r.length || this.raise(Ct.EmptyHeritageClauseType, { at: t, token: e }), r;
         }
         tsParseInterfaceDeclaration(e, t = {}) {
          if (this.hasFollowingLineBreak()) return null;
          this.expectContextual(129), t.declare && (e.declare = !0), $(this.state.type) ? ((e.id = this.parseIdentifier()), this.checkIdentifier(e.id, 130)) : ((e.id = null), this.raise(Ct.MissingInterfaceName, { at: this.state.startLoc })), (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers)), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
          let r = this.startNode();
          return (r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))), (e.body = this.finishNode(r, "TSInterfaceBody")), this.finishNode(e, "TSInterfaceDeclaration");
         }
         tsParseTypeAliasDeclaration(e) {
          return (
           (e.id = this.parseIdentifier()),
           this.checkIdentifier(e.id, 2),
           (e.typeAnnotation = this.tsInType(() => {
            if (((e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers)), this.expect(29), this.isContextual(114) && 16 !== this.lookahead().type)) {
             let e = this.startNode();
             return this.next(), this.finishNode(e, "TSIntrinsicKeyword");
            }
            return this.tsParseType();
           })),
           this.semicolon(),
           this.finishNode(e, "TSTypeAliasDeclaration")
          );
         }
         tsInNoContext(e) {
          let t = this.state.context;
          this.state.context = [t[0]];
          try {
           return e();
          } finally {
           this.state.context = t;
          }
         }
         tsInType(e) {
          let t = this.state.inType;
          this.state.inType = !0;
          try {
           return e();
          } finally {
           this.state.inType = t;
          }
         }
         tsInDisallowConditionalTypesContext(e) {
          let t = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !0;
          try {
           return e();
          } finally {
           this.state.inDisallowConditionalTypesContext = t;
          }
         }
         tsInAllowConditionalTypesContext(e) {
          let t = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !1;
          try {
           return e();
          } finally {
           this.state.inDisallowConditionalTypesContext = t;
          }
         }
         tsEatThenParseType(e) {
          if (this.match(e)) return this.tsNextThenParseType();
         }
         tsExpectThenParseType(e) {
          return this.tsInType(() => (this.expect(e), this.tsParseType()));
         }
         tsNextThenParseType() {
          return this.tsInType(() => (this.next(), this.tsParseType()));
         }
         tsParseEnumMember() {
          let e = this.startNode();
          return (e.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0)), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
         }
         tsParseEnumDeclaration(e, t = {}) {
          return t.const && (e.const = !0), t.declare && (e.declare = !0), this.expectContextual(126), (e.id = this.parseIdentifier()), this.checkIdentifier(e.id, e.const ? 8971 : 8459), this.expect(5), (e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this))), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
         }
         tsParseModuleBlock() {
          let e = this.startNode();
          return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody((e.body = []), void 0, !0, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
         }
         tsParseModuleOrNamespaceDeclaration(e, t = !1) {
          if (((e.id = this.parseIdentifier()), t || this.checkIdentifier(e.id, 1024), this.eat(16))) {
           let t = this.startNode();
           this.tsParseModuleOrNamespaceDeclaration(t, !0), (e.body = t);
          } else this.scope.enter(256), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit();
          return this.finishNode(e, "TSModuleDeclaration");
         }
         tsParseAmbientExternalModuleDeclaration(e) {
          return this.isContextual(112) ? ((e.global = !0), (e.id = this.parseIdentifier())) : this.match(133) ? (e.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
         }
         tsParseImportEqualsDeclaration(e, t, r) {
          (e.isExport = r || !1), (e.id = t || this.parseIdentifier()), this.checkIdentifier(e.id, 4096), this.expect(29);
          let n = this.tsParseModuleReference();
          return "type" === e.importKind && "TSExternalModuleReference" !== n.type && this.raise(Ct.ImportAliasHasImportType, { at: n }), (e.moduleReference = n), this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
         }
         tsIsExternalModuleReference() {
          return this.isContextual(119) && 40 === this.lookaheadCharCode();
         }
         tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
         }
         tsParseExternalModuleReference() {
          let e = this.startNode();
          return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), (e.expression = super.parseExprAtom()), this.expect(11), (this.sawUnambiguousESM = !0), this.finishNode(e, "TSExternalModuleReference");
         }
         tsLookAhead(e) {
          let t = this.state.clone(),
           r = e();
          return (this.state = t), r;
         }
         tsTryParseAndCatch(e) {
          let t = this.tryParse((t) => e() || t());
          if (!t.aborted && t.node) return t.error && (this.state = t.failState), t.node;
         }
         tsTryParse(e) {
          let t = this.state.clone(),
           r = e();
          if (void 0 !== r && !1 !== r) return r;
          this.state = t;
         }
         tsTryParseDeclare(e) {
          if (this.isLineTerminator()) return;
          let t,
           r = this.state.type;
          return (
           this.isContextual(100) && ((r = 74), (t = "let")),
           this.tsInAmbientContext(() => {
            switch (r) {
             case 68:
              return (e.declare = !0), super.parseFunctionStatement(e, !1, !1);
             case 80:
              return (e.declare = !0), this.parseClass(e, !0, !1);
             case 126:
              return this.tsParseEnumDeclaration(e, { declare: !0 });
             case 112:
              return this.tsParseAmbientExternalModuleDeclaration(e);
             case 75:
             case 74:
              return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(e, { const: !0, declare: !0 })) : ((e.declare = !0), this.parseVarStatement(e, t || this.state.value, !0));
             case 129: {
              let t = this.tsParseInterfaceDeclaration(e, { declare: !0 });
              if (t) return t;
             }
             default:
              if ($(r)) return this.tsParseDeclaration(e, this.state.value, !0, null);
            }
           })
          );
         }
         tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
         }
         tsParseExpressionStatement(e, t, r) {
          switch (t.name) {
           case "declare": {
            let t = this.tsTryParseDeclare(e);
            return t && (t.declare = !0), t;
           }
           case "global":
            if (this.match(5)) {
             this.scope.enter(256), this.prodParam.enter(0);
             let r = e;
             return (r.global = !0), (r.id = t), (r.body = this.tsParseModuleBlock()), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, "TSModuleDeclaration");
            }
            break;
           default:
            return this.tsParseDeclaration(e, t.name, !1, r);
          }
         }
         tsParseDeclaration(e, t, r, n) {
          switch (t) {
           case "abstract":
            if (this.tsCheckLineTerminator(r) && (this.match(80) || $(this.state.type))) return this.tsParseAbstractDeclaration(e, n);
            break;
           case "module":
            if (this.tsCheckLineTerminator(r)) {
             if (this.match(133)) return this.tsParseAmbientExternalModuleDeclaration(e);
             if ($(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
            }
            break;
           case "namespace":
            if (this.tsCheckLineTerminator(r) && $(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
            break;
           case "type":
            if (this.tsCheckLineTerminator(r) && $(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
          }
         }
         tsCheckLineTerminator(e) {
          return e ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
         }
         tsTryParseGenericAsyncArrowFunction(e) {
          if (!this.match(47)) return;
          let t = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = !0;
          let r = this.tsTryParseAndCatch(() => {
           let t = this.startNodeAt(e);
           return (t.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier)), super.parseFunctionParams(t), (t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()), this.expect(19), t;
          });
          return (this.state.maybeInArrowParameters = t), r ? super.parseArrowExpression(r, null, !0) : void 0;
         }
         tsParseTypeArgumentsInExpression() {
          if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
         }
         tsParseTypeArguments() {
          let e = this.startNode();
          return (e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this)))))), 0 === e.params.length ? this.raise(Ct.EmptyTypeArguments, { at: e }) : !this.state.inType && this.curContext() === E.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
         }
         tsIsDeclarationStart() {
          return (function (e) {
           return e >= 124 && e <= 130;
          })(this.state.type);
         }
         isExportDefaultSpecifier() {
          return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
         }
         parseAssignableListItem(e, t) {
          let r = this.state.startLoc,
           n = {};
          this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, n);
          let s = n.accessibility,
           i = n.override,
           a = n.readonly;
          !(4 & e) && (s || a || i) && this.raise(Ct.UnexpectedParameterModifier, { at: r });
          let o = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(o, e);
          let u = this.parseMaybeDefault(o.loc.start, o);
          if (s || a || i) {
           let e = this.startNodeAt(r);
           return t.length && (e.decorators = t), s && (e.accessibility = s), a && (e.readonly = a), i && (e.override = i), "Identifier" !== u.type && "AssignmentPattern" !== u.type && this.raise(Ct.UnsupportedParameterPropertyKind, { at: e }), (e.parameter = u), this.finishNode(e, "TSParameterProperty");
          }
          return t.length && (o.decorators = t), u;
         }
         isSimpleParameter(e) {
          return ("TSParameterProperty" === e.type && super.isSimpleParameter(e.parameter)) || super.isSimpleParameter(e);
         }
         tsDisallowOptionalPattern(e) {
          for (let t of e.params) "Identifier" !== t.type && t.optional && !this.state.isAmbientContext && this.raise(Ct.PatternIsOptional, { at: t });
         }
         setArrowFunctionParameters(e, t, r) {
          super.setArrowFunctionParameters(e, t, r), this.tsDisallowOptionalPattern(e);
         }
         parseFunctionBodyAndFinish(e, t, r = !1) {
          this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
          let n = "FunctionDeclaration" === t ? "TSDeclareFunction" : "ClassMethod" === t || "ClassPrivateMethod" === t ? "TSDeclareMethod" : void 0;
          return n && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, n) : "TSDeclareFunction" === n && this.state.isAmbientContext && (this.raise(Ct.DeclareFunctionHasImplementation, { at: e }), e.declare) ? super.parseFunctionBodyAndFinish(e, n, r) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, t, r));
         }
         registerFunctionStatementId(e) {
          !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
         }
         tsCheckForInvalidTypeCasts(e) {
          e.forEach((e) => {
           "TSTypeCastExpression" === (null == e ? void 0 : e.type) && this.raise(Ct.UnexpectedTypeAnnotation, { at: e.typeAnnotation });
          });
         }
         toReferencedList(e, t) {
          return this.tsCheckForInvalidTypeCasts(e), e;
         }
         parseArrayLike(e, t, r, n) {
          let s = super.parseArrayLike(e, t, r, n);
          return "ArrayExpression" === s.type && this.tsCheckForInvalidTypeCasts(s.elements), s;
         }
         parseSubscript(e, t, r, n) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
           (this.state.canStartJSXElement = !1), this.next();
           let r = this.startNodeAt(t);
           return (r.expression = e), this.finishNode(r, "TSNonNullExpression");
          }
          let s = !1;
          if (this.match(18) && 60 === this.lookaheadCharCode()) {
           if (r) return (n.stop = !0), e;
           (n.optionalChainMember = s = !0), this.next();
          }
          if (this.match(47) || this.match(51)) {
           let i,
            a = this.tsTryParseAndCatch(() => {
             if (!r && this.atPossibleAsyncArrow(e)) {
              let e = this.tsTryParseGenericAsyncArrowFunction(t);
              if (e) return e;
             }
             let a = this.tsParseTypeArgumentsInExpression();
             if (!a) return;
             if (s && !this.match(10)) return void (i = this.state.curPosition());
             if (X(this.state.type)) {
              let r = super.parseTaggedTemplateExpression(e, t, n);
              return (r.typeParameters = a), r;
             }
             if (!r && this.eat(10)) {
              let r = this.startNodeAt(t);
              return (r.callee = e), (r.arguments = this.parseCallExpressionArguments(11, !1)), this.tsCheckForInvalidTypeCasts(r.arguments), (r.typeParameters = a), n.optionalChainMember && (r.optional = s), this.finishCallExpression(r, n.optionalChainMember);
             }
             let o = this.state.type;
             if (48 === o || 52 === o || (10 !== o && W(o) && !this.hasPrecedingLineBreak())) return;
             let u = this.startNodeAt(t);
             return (u.expression = e), (u.typeParameters = a), this.finishNode(u, "TSInstantiationExpression");
            });
           if ((i && this.unexpected(i, 10), a)) return "TSInstantiationExpression" === a.type && (this.match(16) || (this.match(18) && 40 !== this.lookaheadCharCode())) && this.raise(Ct.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), a;
          }
          return super.parseSubscript(e, t, r, n);
         }
         parseNewCallee(e) {
          var t;
          super.parseNewCallee(e);
          let { callee: r } = e;
          "TSInstantiationExpression" === r.type && (null == (t = r.extra) || !t.parenthesized) && ((e.typeParameters = r.typeParameters), (e.callee = r.expression));
         }
         parseExprOp(e, t, r) {
          let n;
          if (G(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(120)))) {
           let s = this.startNodeAt(t);
           return (s.expression = e), (s.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n && this.raise(g.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType()))), this.finishNode(s, n ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(s, t, r);
          }
          return super.parseExprOp(e, t, r);
         }
         checkReservedWord(e, t, r, n) {
          this.state.isAmbientContext || super.checkReservedWord(e, t, r, n);
         }
         checkImportReflection(e) {
          super.checkImportReflection(e), e.module && "value" !== e.importKind && this.raise(Ct.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
         }
         checkDuplicateExports() {}
         isPotentialImportPhase(e) {
          if (super.isPotentialImportPhase(e)) return !0;
          if (this.isContextual(130)) {
           let t = this.lookaheadCharCode();
           return e ? 123 === t || 42 === t : 61 !== t;
          }
          return !e && this.isContextual(87);
         }
         applyImportPhase(e, t, r, n) {
          super.applyImportPhase(e, t, r, n), t ? (e.exportKind = "type" === r ? "type" : "value") : (e.importKind = "type" === r || "typeof" === r ? r : "value");
         }
         parseImport(e) {
          if (this.match(133)) return (e.importKind = "value"), super.parseImport(e);
          let t;
          if ($(this.state.type) && 61 === this.lookaheadCharCode()) return (e.importKind = "value"), this.tsParseImportEqualsDeclaration(e);
          if (this.isContextual(130)) {
           let r = this.parseMaybeImportPhase(e, !1);
           if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e, r);
           t = super.parseImportSpecifiersAndAfter(e, r);
          } else t = super.parseImport(e);
          return "type" === t.importKind && t.specifiers.length > 1 && "ImportDefaultSpecifier" === t.specifiers[0].type && this.raise(Ct.TypeImportCannotSpecifyDefaultAndNamed, { at: t }), t;
         }
         parseExport(e, t) {
          if (this.match(83)) {
           this.next();
           let t = null;
           return this.isContextual(130) && this.isPotentialImportPhase(!1) ? (t = this.parseMaybeImportPhase(e, !1)) : (e.importKind = "value"), this.tsParseImportEqualsDeclaration(e, t, !0);
          }
          if (this.eat(29)) {
           let t = e;
           return (t.expression = super.parseExpression()), this.semicolon(), (this.sawUnambiguousESM = !0), this.finishNode(t, "TSExportAssignment");
          }
          if (this.eatContextual(93)) {
           let t = e;
           return this.expectContextual(128), (t.id = this.parseIdentifier()), this.semicolon(), this.finishNode(t, "TSNamespaceExportDeclaration");
          }
          return super.parseExport(e, t);
         }
         isAbstractClass() {
          return this.isContextual(124) && 80 === this.lookahead().type;
         }
         parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
           let e = this.startNode();
           return this.next(), (e.abstract = !0), this.parseClass(e, !0, !0);
          }
          if (this.match(129)) {
           let e = this.tsParseInterfaceDeclaration(this.startNode());
           if (e) return e;
          }
          return super.parseExportDefaultExpression();
         }
         parseVarStatement(e, t, r = !1) {
          let { isAmbientContext: n } = this.state,
           s = super.parseVarStatement(e, t, r || n);
          if (!n) return s;
          for (let { id: i, init: a } of s.declarations) a && ("const" !== t || i.typeAnnotation ? this.raise(Ct.InitializerNotAllowedInAmbientContext, { at: a }) : At(a, this.hasPlugin("estree")) || this.raise(Ct.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: a }));
          return s;
         }
         parseStatementContent(e, t) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
           let e = this.startNode();
           return this.expect(75), this.tsParseEnumDeclaration(e, { const: !0 });
          }
          if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
          if (this.isContextual(129)) {
           let e = this.tsParseInterfaceDeclaration(this.startNode());
           if (e) return e;
          }
          return super.parseStatementContent(e, t);
         }
         parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
         }
         tsHasSomeModifiers(e, t) {
          return t.some((t) => (Tt(t) ? e.accessibility === t : !!e[t]));
         }
         tsIsStartOfStaticBlocks() {
          return this.isContextual(106) && 123 === this.lookaheadCharCode();
         }
         parseClassMember(e, t, r) {
          let n = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
          this.tsParseModifiers({ allowedModifiers: n, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: Ct.InvalidModifierOnTypeParameterPositions }, t);
          let s = () => {
           this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, n) && this.raise(Ct.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(e, t)) : this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
          };
          t.declare ? this.tsInAmbientContext(s) : s();
         }
         parseClassMemberWithIsStatic(e, t, r, n) {
          let s = this.tsTryParseIndexSignature(t);
          if (s) return e.body.push(s), t.abstract && this.raise(Ct.IndexSignatureHasAbstract, { at: t }), t.accessibility && this.raise(Ct.IndexSignatureHasAccessibility, { at: t, modifier: t.accessibility }), t.declare && this.raise(Ct.IndexSignatureHasDeclare, { at: t }), void (t.override && this.raise(Ct.IndexSignatureHasOverride, { at: t }));
          !this.state.inAbstractClass && t.abstract && this.raise(Ct.NonAbstractClassHasAbstractMethod, { at: t }), t.override && (r.hadSuperClass || this.raise(Ct.OverrideNotInSubClass, { at: t })), super.parseClassMemberWithIsStatic(e, t, r, n);
         }
         parsePostMemberNameModifiers(e) {
          this.eat(17) && (e.optional = !0), e.readonly && this.match(10) && this.raise(Ct.ClassMethodHasReadonly, { at: e }), e.declare && this.match(10) && this.raise(Ct.ClassMethodHasDeclare, { at: e });
         }
         parseExpressionStatement(e, t, r) {
          return ("Identifier" === t.type ? this.tsParseExpressionStatement(e, t, r) : void 0) || super.parseExpressionStatement(e, t, r);
         }
         shouldParseExportDeclaration() {
          return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
         }
         parseConditional(e, t, r) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, t, r);
          let n = this.tryParse(() => super.parseConditional(e, t));
          return n.node ? (n.error && (this.state = n.failState), n.node) : (n.error && super.setOptionalParametersError(r, n.error), e);
         }
         parseParenItem(e, t) {
          if (((e = super.parseParenItem(e, t)), this.eat(17) && ((e.optional = !0), this.resetEndLocation(e)), this.match(14))) {
           let r = this.startNodeAt(t);
           return (r.expression = e), (r.typeAnnotation = this.tsParseTypeAnnotation()), this.finishNode(r, "TSTypeCastExpression");
          }
          return e;
         }
         parseExportDeclaration(e) {
          if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
          let t = this.state.startLoc,
           r = this.eatContextual(125);
          if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(Ct.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
          let n = ($(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(e);
          return n ? (("TSInterfaceDeclaration" === n.type || "TSTypeAliasDeclaration" === n.type || r) && (e.exportKind = "type"), r && (this.resetStartLocation(n, t), (n.declare = !0)), n) : null;
         }
         parseClassId(e, t, r, n) {
          if ((!t || r) && this.isContextual(113)) return;
          super.parseClassId(e, t, r, e.declare ? 1024 : 8331);
          let s = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
          s && (e.typeParameters = s);
         }
         parseClassPropertyAnnotation(e) {
          e.optional || (this.eat(35) ? (e.definite = !0) : this.eat(17) && (e.optional = !0));
          let t = this.tsTryParseTypeAnnotation();
          t && (e.typeAnnotation = t);
         }
         parseClassProperty(e) {
          if ((this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(Ct.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e.abstract && this.match(29))) {
           let { key: t } = e;
           this.raise(Ct.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: "Identifier" !== t.type || e.computed ? `[${this.input.slice(t.start, t.end)}]` : t.name });
          }
          return super.parseClassProperty(e);
         }
         parseClassPrivateProperty(e) {
          return e.abstract && this.raise(Ct.PrivateElementHasAbstract, { at: e }), e.accessibility && this.raise(Ct.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
         }
         parseClassAccessorProperty(e) {
          return this.parseClassPropertyAnnotation(e), e.optional && this.raise(Ct.AccessorCannotBeOptional, { at: e }), super.parseClassAccessorProperty(e);
         }
         pushClassMethod(e, t, r, n, s, i) {
          let a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          a && s && this.raise(Ct.ConstructorHasTypeParameters, { at: a });
          let { declare: o = !1, kind: u } = t;
          o && ("get" === u || "set" === u) && this.raise(Ct.DeclareAccessor, { at: t, kind: u }), a && (t.typeParameters = a), super.pushClassMethod(e, t, r, n, s, i);
         }
         pushClassPrivateMethod(e, t, r, n) {
          let s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          s && (t.typeParameters = s), super.pushClassPrivateMethod(e, t, r, n);
         }
         declareClassPrivateMethodInScope(e, t) {
          "TSDeclareMethod" !== e.type && (("MethodDefinition" === e.type && !e.value.body) || super.declareClassPrivateMethodInScope(e, t));
         }
         parseClassSuper(e) {
          super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause("implements"));
         }
         parseObjPropValue(e, t, r, n, s, i, a) {
          let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          return o && (e.typeParameters = o), super.parseObjPropValue(e, t, r, n, s, i, a);
         }
         parseFunctionParams(e, t) {
          let r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          r && (e.typeParameters = r), super.parseFunctionParams(e, t);
         }
         parseVarId(e, t) {
          super.parseVarId(e, t), "Identifier" === e.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0);
          let r = this.tsTryParseTypeAnnotation();
          r && ((e.id.typeAnnotation = r), this.resetEndLocation(e.id));
         }
         parseAsyncArrowFromCallExpression(e, t) {
          return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, t);
         }
         parseMaybeAssign(e, t) {
          var r, n, s, i, a;
          let o, u, l;
          if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
           if (((o = this.state.clone()), (u = this.tryParse(() => super.parseMaybeAssign(e, t), o)), !u.error)) return u.node;
           let { context: r } = this.state,
            n = r[r.length - 1];
           (n === E.j_oTag || n === E.j_expr) && r.pop();
          }
          if (!((null != (r = u) && r.error) || this.match(47))) return super.parseMaybeAssign(e, t);
          (!o || o === this.state) && (o = this.state.clone());
          let p,
           c = this.tryParse((r) => {
            var n, s;
            p = this.tsParseTypeParameters(this.tsParseConstModifier);
            let i = super.parseMaybeAssign(e, t);
            return ("ArrowFunctionExpression" !== i.type || (null != (n = i.extra) && n.parenthesized)) && r(), 0 !== (null == (s = p) ? void 0 : s.params.length) && this.resetStartLocationFromNode(i, p), (i.typeParameters = p), i;
           }, o);
          if (!c.error && !c.aborted) return p && this.reportReservedArrowTypeParam(p), c.node;
          if (!u && (Et(!this.hasPlugin("jsx")), (l = this.tryParse(() => super.parseMaybeAssign(e, t), o)), !l.error)) return l.node;
          if (null != (n = u) && n.node) return (this.state = u.failState), u.node;
          if (c.node) return (this.state = c.failState), p && this.reportReservedArrowTypeParam(p), c.node;
          if (null != (s = l) && s.node) return (this.state = l.failState), l.node;
          throw (null == (i = u) ? void 0 : i.error) || c.error || (null == (a = l) ? void 0 : a.error);
         }
         reportReservedArrowTypeParam(e) {
          var t;
          1 === e.params.length && !e.params[0].constraint && (null == (t = e.extra) || !t.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Ct.ReservedArrowTypeParam, { at: e });
         }
         parseMaybeUnary(e, t) {
          return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, t);
         }
         parseArrow(e) {
          if (this.match(14)) {
           let t = this.tryParse((e) => {
            let t = this.tsParseTypeOrTypePredicateAnnotation(14);
            return (this.canInsertSemicolon() || !this.match(19)) && e(), t;
           });
           if (t.aborted) return;
           t.thrown || (t.error && (this.state = t.failState), (e.returnType = t.node));
          }
          return super.parseArrow(e);
         }
         parseAssignableListItemTypes(e, t) {
          if (!(2 & t)) return e;
          this.eat(17) && (e.optional = !0);
          let r = this.tsTryParseTypeAnnotation();
          return r && (e.typeAnnotation = r), this.resetEndLocation(e), e;
         }
         isAssignable(e, t) {
          switch (e.type) {
           case "TSTypeCastExpression":
            return this.isAssignable(e.expression, t);
           case "TSParameterProperty":
            return !0;
           default:
            return super.isAssignable(e, t);
          }
         }
         toAssignable(e, t = !1) {
          switch (e.type) {
           case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(e, t);
            break;
           case "TSAsExpression":
           case "TSSatisfiesExpression":
           case "TSNonNullExpression":
           case "TSTypeAssertion":
            t ? this.expressionScope.recordArrowParameterBindingError(Ct.UnexpectedTypeCastInParameter, { at: e }) : this.raise(Ct.UnexpectedTypeCastInParameter, { at: e }), this.toAssignable(e.expression, t);
            break;
           case "AssignmentExpression":
            !t && "TSTypeCastExpression" === e.left.type && (e.left = this.typeCastToParameter(e.left));
           default:
            super.toAssignable(e, t);
          }
         }
         toAssignableParenthesizedExpression(e, t) {
          switch (e.expression.type) {
           case "TSAsExpression":
           case "TSSatisfiesExpression":
           case "TSNonNullExpression":
           case "TSTypeAssertion":
           case "ParenthesizedExpression":
            this.toAssignable(e.expression, t);
            break;
           default:
            super.toAssignable(e, t);
          }
         }
         checkToRestConversion(e, t) {
          switch (e.type) {
           case "TSAsExpression":
           case "TSSatisfiesExpression":
           case "TSTypeAssertion":
           case "TSNonNullExpression":
            this.checkToRestConversion(e.expression, !1);
            break;
           default:
            super.checkToRestConversion(e, t);
          }
         }
         isValidLVal(e, t, r) {
          return ((e, t) => Object.hasOwnProperty.call(e, t) && e[t])({ TSTypeCastExpression: !0, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (64 !== r || !t) && ["expression", !0], TSSatisfiesExpression: (64 !== r || !t) && ["expression", !0], TSTypeAssertion: (64 !== r || !t) && ["expression", !0] }, e) || super.isValidLVal(e, t, r);
         }
         parseBindingAtom() {
          return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
         }
         parseMaybeDecoratorArguments(e) {
          if (this.match(47) || this.match(51)) {
           let t = this.tsParseTypeArgumentsInExpression();
           if (this.match(10)) {
            let r = super.parseMaybeDecoratorArguments(e);
            return (r.typeParameters = t), r;
           }
           this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(e);
         }
         checkCommaAfterRest(e) {
          return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), !1) : super.checkCommaAfterRest(e);
         }
         isClassMethod() {
          return this.match(47) || super.isClassMethod();
         }
         isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
         }
         parseMaybeDefault(e, t) {
          let r = super.parseMaybeDefault(e, t);
          return "AssignmentPattern" === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(Ct.TypeAnnotationAfterAssign, { at: r.typeAnnotation }), r;
         }
         getTokenFromCode(e) {
          if (this.state.inType) {
           if (62 === e) return void this.finishOp(48, 1);
           if (60 === e) return void this.finishOp(47, 1);
          }
          super.getTokenFromCode(e);
         }
         reScan_lt_gt() {
          let { type: e } = this.state;
          47 === e ? ((this.state.pos -= 1), this.readToken_lt()) : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
         }
         reScan_lt() {
          let { type: e } = this.state;
          return 51 === e ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e;
         }
         toAssignableList(e, t, r) {
          for (let n = 0; n < e.length; n++) {
           let t = e[n];
           "TSTypeCastExpression" === (null == t ? void 0 : t.type) && (e[n] = this.typeCastToParameter(t));
          }
          super.toAssignableList(e, t, r);
         }
         typeCastToParameter(e) {
          return (e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
         }
         shouldParseArrow(e) {
          return this.match(14) ? e.every((e) => this.isAssignable(e, !0)) : super.shouldParseArrow(e);
         }
         shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
         }
         canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
         }
         jsxParseOpeningElementAfterName(e) {
          if (this.match(47) || this.match(51)) {
           let t = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
           t && (e.typeParameters = t);
          }
          return super.jsxParseOpeningElementAfterName(e);
         }
         getGetterSetterExpectedParamCount(e) {
          let t = super.getGetterSetterExpectedParamCount(e),
           r = this.getObjectOrClassMethodParams(e)[0];
          return r && this.isThisParam(r) ? t + 1 : t;
         }
         parseCatchClauseParam() {
          let e = super.parseCatchClauseParam(),
           t = this.tsTryParseTypeAnnotation();
          return t && ((e.typeAnnotation = t), this.resetEndLocation(e)), e;
         }
         tsInAmbientContext(e) {
          let t = this.state.isAmbientContext;
          this.state.isAmbientContext = !0;
          try {
           return e();
          } finally {
           this.state.isAmbientContext = t;
          }
         }
         parseClass(e, t, r) {
          let n = this.state.inAbstractClass;
          this.state.inAbstractClass = !!e.abstract;
          try {
           return super.parseClass(e, t, r);
          } finally {
           this.state.inAbstractClass = n;
          }
         }
         tsParseAbstractDeclaration(e, t) {
          if (this.match(80)) return (e.abstract = !0), this.maybeTakeDecorators(t, this.parseClass(e, !0, !1));
          if (this.isContextual(129)) {
           if (!this.hasFollowingLineBreak()) return (e.abstract = !0), this.raise(Ct.NonClassMethodPropertyHasAbstractModifer, { at: e }), this.tsParseInterfaceDeclaration(e);
          } else this.unexpected(null, 80);
         }
         parseMethod(e, t, r, n, s, i, a) {
          let o = super.parseMethod(e, t, r, n, s, i, a);
          if (o.abstract && (this.hasPlugin("estree") ? o.value.body : o.body)) {
           let { key: e } = o;
           this.raise(Ct.AbstractMethodHasImplementation, { at: o, methodName: "Identifier" !== e.type || o.computed ? `[${this.input.slice(e.start, e.end)}]` : e.name });
          }
          return o;
         }
         tsParseTypeParameterName() {
          return this.parseIdentifier().name;
         }
         shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
         }
         parse() {
          return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
         }
         getExpression() {
          return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
         }
         parseExportSpecifier(e, t, r, n) {
          return !t && n ? (this.parseTypeOnlyImportExportSpecifier(e, !1, r), this.finishNode(e, "ExportSpecifier")) : ((e.exportKind = "value"), super.parseExportSpecifier(e, t, r, n));
         }
         parseImportSpecifier(e, t, r, n, s) {
          return !t && n ? (this.parseTypeOnlyImportExportSpecifier(e, !0, r), this.finishNode(e, "ImportSpecifier")) : ((e.importKind = "value"), super.parseImportSpecifier(e, t, r, n, r ? 4098 : 4096));
         }
         parseTypeOnlyImportExportSpecifier(e, t, r) {
          let n,
           s = t ? "imported" : "local",
           i = t ? "local" : "exported",
           a = e[s],
           o = !1,
           u = !0,
           l = a.loc.start;
          if (this.isContextual(93)) {
           let e = this.parseIdentifier();
           if (this.isContextual(93)) {
            let r = this.parseIdentifier();
            V(this.state.type) ? ((o = !0), (a = e), (n = t ? this.parseIdentifier() : this.parseModuleExportName()), (u = !1)) : ((n = r), (u = !1));
           } else V(this.state.type) ? ((u = !1), (n = t ? this.parseIdentifier() : this.parseModuleExportName())) : ((o = !0), (a = e));
          } else V(this.state.type) && ((o = !0), t ? ((a = this.parseIdentifier(!0)), this.isContextual(93) || this.checkReservedWord(a.name, a.loc.start, !0, !0)) : (a = this.parseModuleExportName()));
          o && r && this.raise(t ? Ct.TypeModifierIsUsedInTypeImports : Ct.TypeModifierIsUsedInTypeExports, { at: l }), (e[s] = a), (e[i] = n), (e[t ? "importKind" : "exportKind"] = o ? "type" : "value"), u && this.eatContextual(93) && (e[i] = t ? this.parseIdentifier() : this.parseModuleExportName()), e[i] || (e[i] = ot(e[s])), t && this.checkIdentifier(e[i], o ? 4098 : 4096);
         }
        },
       v8intrinsic: (e) =>
        class extends e {
         parseV8Intrinsic() {
          if (this.match(54)) {
           let e = this.state.startLoc,
            t = this.startNode();
           if ((this.next(), $(this.state.type))) {
            let e = this.parseIdentifierName(),
             r = this.createIdentifier(t, e);
            if (((r.type = "V8IntrinsicIdentifier"), this.match(10))) return r;
           }
           this.unexpected(e);
          }
         }
         parseExprAtom(e) {
          return this.parseV8Intrinsic() || super.parseExprAtom(e);
         }
        },
       placeholders: (e) =>
        class extends e {
         parsePlaceholder(e) {
          if (this.match(144)) {
           let t = this.startNode();
           return this.next(), this.assertNoSpace(), (t.name = super.parseIdentifier(!0)), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(t, e);
          }
         }
         finishPlaceholder(e, t) {
          let r = !(!e.expectedNode || "Placeholder" !== e.type);
          return (e.expectedNode = t), r ? e : this.finishNode(e, "Placeholder");
         }
         getTokenFromCode(e) {
          37 === e && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(144, 2) : super.getTokenFromCode(e);
         }
         parseExprAtom(e) {
          return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
         }
         parseIdentifier(e) {
          return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
         }
         checkReservedWord(e, t, r, n) {
          void 0 !== e && super.checkReservedWord(e, t, r, n);
         }
         parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
         }
         isValidLVal(e, t, r) {
          return "Placeholder" === e || super.isValidLVal(e, t, r);
         }
         toAssignable(e, t) {
          e && "Placeholder" === e.type && "Expression" === e.expectedNode ? (e.expectedNode = "Pattern") : super.toAssignable(e, t);
         }
         chStartsBindingIdentifier(e, t) {
          return !(!super.chStartsBindingIdentifier(e, t) && 144 !== this.lookahead().type);
         }
         verifyBreakContinue(e, t) {
          (e.label && "Placeholder" === e.label.type) || super.verifyBreakContinue(e, t);
         }
         parseExpressionStatement(e, t) {
          var r;
          if ("Placeholder" !== t.type || (null != (r = t.extra) && r.parenthesized)) return super.parseExpressionStatement(e, t);
          if (this.match(14)) {
           let r = e;
           return (r.label = this.finishPlaceholder(t, "Identifier")), this.next(), (r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration()), this.finishNode(r, "LabeledStatement");
          }
          return this.semicolon(), (e.name = t.name), this.finishPlaceholder(e, "Statement");
         }
         parseBlock(e, t, r) {
          return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, t, r);
         }
         parseFunctionId(e) {
          return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
         }
         parseClass(e, t, r) {
          let n = t ? "ClassDeclaration" : "ClassExpression";
          this.next();
          let s = this.state.strict,
           i = this.parsePlaceholder("Identifier");
          if (i) {
           if (!(this.match(81) || this.match(144) || this.match(5))) {
            if (r || !t) return (e.id = null), (e.body = this.finishPlaceholder(i, "ClassBody")), this.finishNode(e, n);
            throw this.raise(Pt.ClassNameIsRequired, { at: this.state.startLoc });
           }
           e.id = i;
          } else this.parseClassId(e, t, r);
          return super.parseClassSuper(e), (e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, s)), this.finishNode(e, n);
         }
         parseExport(e, t) {
          let r = this.parsePlaceholder("Identifier");
          if (!r) return super.parseExport(e, t);
          if (!this.isContextual(98) && !this.match(12)) return (e.specifiers = []), (e.source = null), (e.declaration = this.finishPlaceholder(r, "Declaration")), this.finishNode(e, "ExportNamedDeclaration");
          this.expectPlugin("exportDefaultFrom");
          let n = this.startNode();
          return (n.exported = r), (e.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")]), super.parseExport(e, t);
         }
         isExportDefaultSpecifier() {
          if (this.match(65)) {
           let e = this.nextTokenStart();
           if (this.isUnparsedContextual(e, "from") && this.input.startsWith(K(144), this.nextTokenStartSince(e + 4))) return !0;
          }
          return super.isExportDefaultSpecifier();
         }
         maybeParseExportDefaultSpecifier(e, t) {
          var r;
          return !(null == (r = e.specifiers) || !r.length) || super.maybeParseExportDefaultSpecifier(e, t);
         }
         checkExport(e) {
          let { specifiers: t } = e;
          null != t && t.length && (e.specifiers = t.filter((e) => "Placeholder" === e.exported.type)), super.checkExport(e), (e.specifiers = t);
         }
         parseImport(e) {
          let t = this.parsePlaceholder("Identifier");
          if (!t) return super.parseImport(e);
          if (((e.specifiers = []), !this.isContextual(98) && !this.match(12))) return (e.source = this.finishPlaceholder(t, "StringLiteral")), this.semicolon(), this.finishNode(e, "ImportDeclaration");
          let r = this.startNodeAtNode(t);
          return (r.local = t), e.specifiers.push(this.finishNode(r, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), (e.source = this.parseImportSource()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
         }
         parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
         }
         assertNoSpace() {
          this.state.start > this.state.lastTokEndLoc.index && this.raise(Pt.UnexpectedSpace, { at: this.state.lastTokEndLoc });
         }
        },
      },
      Mt = Object.keys(Ot),
      jt = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
     var Rt = class extends vt {
       checkProto(e, t, r, n) {
        if ("SpreadElement" === e.type || this.isObjectMethod(e) || e.computed || e.shorthand) return;
        let s = e.key;
        if ("__proto__" === ("Identifier" === s.type ? s.name : s.value)) {
         if (t) return void this.raise(g.RecordNoProto, { at: s });
         r.used && (n ? null === n.doubleProtoLoc && (n.doubleProtoLoc = s.loc.start) : this.raise(g.DuplicateProto, { at: s })), (r.used = !0);
        }
       }
       shouldExitDescending(e, t) {
        return "ArrowFunctionExpression" === e.type && e.start === t;
       }
       getExpression() {
        this.enterInitialScopes(), this.nextToken();
        let e = this.parseExpression();
        return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), (e.comments = this.state.comments), (e.errors = this.state.errors), this.options.tokens && (e.tokens = this.tokens), e;
       }
       parseExpression(e, t) {
        return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
       }
       parseExpressionBase(e) {
        let t = this.state.startLoc,
         r = this.parseMaybeAssign(e);
        if (this.match(12)) {
         let n = this.startNodeAt(t);
         for (n.expressions = [r]; this.eat(12); ) n.expressions.push(this.parseMaybeAssign(e));
         return this.toReferencedList(n.expressions), this.finishNode(n, "SequenceExpression");
        }
        return r;
       }
       parseMaybeAssignDisallowIn(e, t) {
        return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
       }
       parseMaybeAssignAllowIn(e, t) {
        return this.allowInAnd(() => this.parseMaybeAssign(e, t));
       }
       setOptionalParametersError(e, t) {
        var r;
        e.optionalParametersLoc = null != (r = null == t ? void 0 : t.loc) ? r : this.state.startLoc;
       }
       parseMaybeAssign(e, t) {
        let r,
         n = this.state.startLoc;
        if (this.isContextual(108) && this.prodParam.hasYield) {
         let e = this.parseYield();
         return t && (e = t.call(this, e, n)), e;
        }
        e ? (r = !1) : ((e = new st()), (r = !0));
        let { type: s } = this.state;
        (10 === s || $(s)) && (this.state.potentialArrowAt = this.state.start);
        let i = this.parseMaybeConditional(e);
        if ((t && (i = t.call(this, i, n)), (a = this.state.type) >= 29 && a <= 33)) {
         let t = this.startNodeAt(n),
          r = this.state.value;
         if (((t.operator = r), this.match(29))) {
          this.toAssignable(i, !0), (t.left = i);
          let r = n.index;
          null != e.doubleProtoLoc && e.doubleProtoLoc.index >= r && (e.doubleProtoLoc = null), null != e.shorthandAssignLoc && e.shorthandAssignLoc.index >= r && (e.shorthandAssignLoc = null), null != e.privateKeyLoc && e.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e), (e.privateKeyLoc = null));
         } else t.left = i;
         return this.next(), (t.right = this.parseMaybeAssign()), this.checkLVal(i, { in: this.finishNode(t, "AssignmentExpression") }), t;
        }
        var a;
        return r && this.checkExpressionErrors(e, !0), i;
       }
       parseMaybeConditional(e) {
        let t = this.state.startLoc,
         r = this.state.potentialArrowAt,
         n = this.parseExprOps(e);
        return this.shouldExitDescending(n, r) ? n : this.parseConditional(n, t, e);
       }
       parseConditional(e, t, r) {
        if (this.eat(17)) {
         let r = this.startNodeAt(t);
         return (r.test = e), (r.consequent = this.parseMaybeAssignAllowIn()), this.expect(14), (r.alternate = this.parseMaybeAssign()), this.finishNode(r, "ConditionalExpression");
        }
        return e;
       }
       parseMaybeUnaryOrPrivate(e) {
        return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
       }
       parseExprOps(e) {
        let t = this.state.startLoc,
         r = this.state.potentialArrowAt,
         n = this.parseMaybeUnaryOrPrivate(e);
        return this.shouldExitDescending(n, r) ? n : this.parseExprOp(n, t, -1);
       }
       parseExprOp(e, t, r) {
        if (this.isPrivateName(e)) {
         let t = this.getPrivateNameSV(e);
         (r >= G(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(g.PrivateInExpectedIn, { at: e, identifierName: t }), this.classScope.usePrivateName(t, e.loc.start);
        }
        let n = this.state.type;
        if ((s = n) >= 39 && s <= 59 && (this.prodParam.hasIn || !this.match(58))) {
         let s = G(n);
         if (s > r) {
          if (39 === n) {
           if ((this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)) return e;
           this.checkPipelineAtInfixOperator(e, t);
          }
          let i = this.startNodeAt(t);
          (i.left = e), (i.operator = this.state.value);
          let a = 41 === n || 42 === n,
           o = 40 === n;
          if ((o && (s = G(42)), this.next(), 39 === n && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && 96 === this.state.type && this.prodParam.hasAwait)) throw this.raise(g.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
          i.right = this.parseExprOpRightExpr(n, s);
          let u = this.finishNode(i, a || o ? "LogicalExpression" : "BinaryExpression"),
           l = this.state.type;
          if ((o && (41 === l || 42 === l)) || (a && 40 === l)) throw this.raise(g.MixingCoalesceWithLogical, { at: this.state.startLoc });
          return this.parseExprOp(u, t, r);
         }
        }
        var s;
        return e;
       }
       parseExprOpRightExpr(e, t) {
        let r = this.state.startLoc;
        if (39 === e)
         switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
           return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case "smart":
           return this.withTopicBindingContext(() => {
            if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(g.PipeBodyIsTighter, { at: this.state.startLoc });
            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), r);
           });
          case "fsharp":
           return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
         }
        return this.parseExprOpBaseRightExpr(e, t);
       }
       parseExprOpBaseRightExpr(e, t) {
        let r = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, 57 === e ? t - 1 : t);
       }
       parseHackPipeBody() {
        var e;
        let { startLoc: t } = this.state,
         r = this.parseMaybeAssign();
        return p.has(r.type) && !(null != (e = r.extra) && e.parenthesized) && this.raise(g.PipeUnparenthesizedBody, { at: t, type: r.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipeTopicUnused, { at: t }), r;
       }
       checkExponentialAfterUnary(e) {
        this.match(57) && this.raise(g.UnexpectedTokenUnaryExponentiation, { at: e.argument });
       }
       parseMaybeUnary(e, t) {
        let r = this.state.startLoc,
         n = this.isContextual(96);
        if (n && this.isAwaitAllowed()) {
         this.next();
         let e = this.parseAwait(r);
         return t || this.checkExponentialAfterUnary(e), e;
        }
        let s = this.match(34),
         i = this.startNode();
        if (((a = this.state.type), j[a])) {
         (i.operator = this.state.value), (i.prefix = !0), this.match(72) && this.expectPlugin("throwExpressions");
         let r = this.match(89);
         if ((this.next(), (i.argument = this.parseMaybeUnary(null, !0)), this.checkExpressionErrors(e, !0), this.state.strict && r)) {
          let e = i.argument;
          "Identifier" === e.type ? this.raise(g.StrictDelete, { at: i }) : this.hasPropertyAsPrivateName(e) && this.raise(g.DeletePrivateField, { at: i });
         }
         if (!s) return t || this.checkExponentialAfterUnary(i), this.finishNode(i, "UnaryExpression");
        }
        var a;
        let o = this.parseUpdate(i, s, e);
        if (n) {
         let { type: e } = this.state;
         if ((this.hasPlugin("v8intrinsic") ? W(e) : W(e) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(g.AwaitNotInAsyncContext, { at: r }), this.parseAwait(r);
        }
        return o;
       }
       parseUpdate(e, t, r) {
        if (t) {
         let t = e;
         return this.checkLVal(t.argument, { in: this.finishNode(t, "UpdateExpression") }), e;
        }
        let n = this.state.startLoc,
         s = this.parseExprSubscripts(r);
        if (this.checkExpressionErrors(r, !1)) return s;
        for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
         let e = this.startNodeAt(n);
         (e.operator = this.state.value), (e.prefix = !1), (e.argument = s), this.next(), this.checkLVal(s, { in: (s = this.finishNode(e, "UpdateExpression")) });
        }
        return s;
       }
       parseExprSubscripts(e) {
        let t = this.state.startLoc,
         r = this.state.potentialArrowAt,
         n = this.parseExprAtom(e);
        return this.shouldExitDescending(n, r) ? n : this.parseSubscripts(n, t);
       }
       parseSubscripts(e, t, r) {
        let n = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(e), stop: !1 };
        do {
         (e = this.parseSubscript(e, t, r, n)), (n.maybeAsyncArrow = !1);
        } while (!n.stop);
        return e;
       }
       parseSubscript(e, t, r, n) {
        let { type: s } = this.state;
        if (!r && 15 === s) return this.parseBind(e, t, r, n);
        if (X(s)) return this.parseTaggedTemplateExpression(e, t, n);
        let i = !1;
        if (18 === s) {
         if (r && (this.raise(g.OptionalChainingNoNew, { at: this.state.startLoc }), 40 === this.lookaheadCharCode())) return (n.stop = !0), e;
         (n.optionalChainMember = i = !0), this.next();
        }
        if (!r && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e, t, n, i);
        {
         let r = this.eat(0);
         return r || i || this.eat(16) ? this.parseMember(e, t, n, r, i) : ((n.stop = !0), e);
        }
       }
       parseMember(e, t, r, n, s) {
        let i = this.startNodeAt(t);
        return (i.object = e), (i.computed = n), n ? ((i.property = this.parseExpression()), this.expect(3)) : this.match(138) ? ("Super" === e.type && this.raise(g.SuperPrivateField, { at: t }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), (i.property = this.parsePrivateName())) : (i.property = this.parseIdentifier(!0)), r.optionalChainMember ? ((i.optional = s), this.finishNode(i, "OptionalMemberExpression")) : this.finishNode(i, "MemberExpression");
       }
       parseBind(e, t, r, n) {
        let s = this.startNodeAt(t);
        return (s.object = e), this.next(), (s.callee = this.parseNoCallExpr()), (n.stop = !0), this.parseSubscripts(this.finishNode(s, "BindExpression"), t, r);
       }
       parseCoverCallAndAsyncArrowHead(e, t, r, n) {
        let s = this.state.maybeInArrowParameters,
         i = null;
        (this.state.maybeInArrowParameters = !0), this.next();
        let a = this.startNodeAt(t);
        a.callee = e;
        let { maybeAsyncArrow: o, optionalChainMember: u } = r;
        o && (this.expressionScope.enter(new Qe(2)), (i = new st())), u && (a.optional = n), (a.arguments = n ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === e.type, "Super" !== e.type, a, i));
        let l = this.finishCallExpression(a, u);
        return o && this.shouldParseAsyncArrow() && !n ? ((r.stop = !0), this.checkDestructuringPrivate(i), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), (l = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), l))) : (o && (this.checkExpressionErrors(i, !0), this.expressionScope.exit()), this.toReferencedArguments(l)), (this.state.maybeInArrowParameters = s), l;
       }
       toReferencedArguments(e, t) {
        this.toReferencedListDeep(e.arguments, t);
       }
       parseTaggedTemplateExpression(e, t, r) {
        let n = this.startNodeAt(t);
        return (n.tag = e), (n.quasi = this.parseTemplate(!0)), r.optionalChainMember && this.raise(g.OptionalChainingNoTemplate, { at: t }), this.finishNode(n, "TaggedTemplateExpression");
       }
       atPossibleAsyncArrow(e) {
        return "Identifier" === e.type && "async" === e.name && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start == 5 && e.start === this.state.potentialArrowAt;
       }
       expectImportAttributesPlugin() {
        this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
       }
       finishCallExpression(e, t) {
        if ("Import" === e.callee.type)
         if ((2 === e.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), 0 === e.arguments.length || e.arguments.length > 2)) this.raise(g.ImportCallArity, { at: e, maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
         else for (let r of e.arguments) "SpreadElement" === r.type && this.raise(g.ImportCallSpreadArgument, { at: r });
        return this.finishNode(e, t ? "OptionalCallExpression" : "CallExpression");
       }
       parseCallExpressionArguments(e, t, r, n, s) {
        let i = [],
         a = !0,
         o = this.state.inFSharpPipelineDirectBody;
        for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
         if (a) a = !1;
         else if ((this.expect(12), this.match(e))) {
          t && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(g.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
         }
         i.push(this.parseExprListItem(!1, s, r));
        }
        return (this.state.inFSharpPipelineDirectBody = o), i;
       }
       shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
       }
       parseAsyncArrowFromCallExpression(e, t) {
        var r;
        return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, !0, null == (r = t.extra) ? void 0 : r.trailingCommaLoc), t.innerComments && Ce(e, t.innerComments), t.callee.trailingComments && Ce(e, t.callee.trailingComments), e;
       }
       parseNoCallExpr() {
        let e = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), e, !0);
       }
       parseExprAtom(e) {
        let t,
         r = null,
         { type: n } = this.state;
        switch (n) {
         case 79:
          return this.parseSuper();
         case 83:
          return (t = this.startNode()), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : this.match(10) ? (this.options.createImportExpressions ? this.parseImportCall(t) : this.finishNode(t, "Import")) : (this.raise(g.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(t, "Import"));
         case 78:
          return (t = this.startNode()), this.next(), this.finishNode(t, "ThisExpression");
         case 90:
          return this.parseDo(this.startNode(), !1);
         case 56:
         case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
         case 134:
          return this.parseNumericLiteral(this.state.value);
         case 135:
          return this.parseBigIntLiteral(this.state.value);
         case 136:
          return this.parseDecimalLiteral(this.state.value);
         case 133:
          return this.parseStringLiteral(this.state.value);
         case 84:
          return this.parseNullLiteral();
         case 85:
          return this.parseBooleanLiteral(!0);
         case 86:
          return this.parseBooleanLiteral(!1);
         case 10: {
          let e = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(e);
         }
         case 2:
         case 1:
          return this.parseArrayLike(2 === this.state.type ? 4 : 3, !1, !0);
         case 0:
          return this.parseArrayLike(3, !0, !1, e);
         case 6:
         case 7:
          return this.parseObjectLike(6 === this.state.type ? 9 : 8, !1, !0);
         case 5:
          return this.parseObjectLike(8, !1, !1, e);
         case 68:
          return this.parseFunctionOrFunctionSent();
         case 26:
          r = this.parseDecorators();
         case 80:
          return this.parseClass(this.maybeTakeDecorators(r, this.startNode()), !1);
         case 77:
          return this.parseNewOrNewTarget();
         case 25:
         case 24:
          return this.parseTemplate(!1);
         case 15: {
          (t = this.startNode()), this.next(), (t.object = null);
          let e = (t.callee = this.parseNoCallExpr());
          if ("MemberExpression" === e.type) return this.finishNode(t, "BindExpression");
          throw this.raise(g.UnsupportedBind, { at: e });
         }
         case 138:
          return this.raise(g.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
         case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
         case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
         case 37:
         case 38:
          return this.parseTopicReference("hack");
         case 44:
         case 54:
         case 27: {
          let e = this.getPluginOption("pipelineOperator", "proposal");
          if (e) return this.parseTopicReference(e);
          this.unexpected();
          break;
         }
         case 47: {
          let e = this.input.codePointAt(this.nextTokenStart());
          ie(e) || 62 === e ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
         }
         default:
          if ($(n)) {
           if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
           let e = this.state.potentialArrowAt === this.state.start,
            t = this.state.containsEsc,
            r = this.parseIdentifier();
           if (!t && "async" === r.name && !this.canInsertSemicolon()) {
            let { type: e } = this.state;
            if (68 === e) return this.resetPreviousNodeTrailingComments(r), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r));
            if ($(e)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r)) : r;
            if (90 === e) return this.resetPreviousNodeTrailingComments(r), this.parseDo(this.startNodeAtNode(r), !0);
           }
           return e && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r), [r], !1)) : r;
          }
          this.unexpected();
        }
       }
       parseTopicReferenceThenEqualsSign(e, t) {
        let r = this.getPluginOption("pipelineOperator", "proposal");
        if (r) return (this.state.type = e), (this.state.value = t), this.state.pos--, this.state.end--, (this.state.endLoc = s(this.state.endLoc, -1)), this.parseTopicReference(r);
        this.unexpected();
       }
       parseTopicReference(e) {
        let t = this.startNode(),
         r = this.state.startLoc,
         n = this.state.type;
        return this.next(), this.finishTopicReference(t, r, e, n);
       }
       finishTopicReference(e, t, r, n) {
        if (this.testTopicReferenceConfiguration(r, t, n)) {
         let n = "smart" === r ? "PipelinePrimaryTopicReference" : "TopicReference";
         return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === r ? g.PrimaryTopicNotAllowed : g.PipeTopicUnbound, { at: t }), this.registerTopicReference(), this.finishNode(e, n);
        }
        throw this.raise(g.PipeTopicUnconfiguredToken, { at: t, token: K(n) });
       }
       testTopicReferenceConfiguration(e, t, r) {
        switch (e) {
         case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: K(r) }]);
         case "smart":
          return 27 === r;
         default:
          throw this.raise(g.PipeTopicRequiresHackPipes, { at: t });
        }
       }
       parseAsyncArrowUnaryFunction(e) {
        this.prodParam.enter(rt(!0, this.prodParam.hasYield));
        let t = [this.parseIdentifier()];
        return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(g.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(e, t, !0);
       }
       parseDo(e, t) {
        this.expectPlugin("doExpressions"), t && this.expectPlugin("asyncDoExpressions"), (e.async = t), this.next();
        let r = this.state.labels;
        return (this.state.labels = []), t ? (this.prodParam.enter(2), (e.body = this.parseBlock()), this.prodParam.exit()) : (e.body = this.parseBlock()), (this.state.labels = r), this.finishNode(e, "DoExpression");
       }
       parseSuper() {
        let e = this.startNode();
        return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(g.UnexpectedSuper, { at: e }) : this.raise(g.SuperNotAllowed, { at: e }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(g.UnsupportedSuper, { at: e }), this.finishNode(e, "Super");
       }
       parsePrivateName() {
        let e = this.startNode(),
         t = this.startNodeAt(s(this.state.startLoc, 1)),
         r = this.state.value;
        return this.next(), (e.id = this.createIdentifier(t, r)), this.finishNode(e, "PrivateName");
       }
       parseFunctionOrFunctionSent() {
        let e = this.startNode();
        if ((this.next(), this.prodParam.hasYield && this.match(16))) {
         let t = this.createIdentifier(this.startNodeAtNode(e), "function");
         return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e, t, "sent");
        }
        return this.parseFunction(e);
       }
       parseMetaProperty(e, t, r) {
        e.meta = t;
        let n = this.state.containsEsc;
        return (e.property = this.parseIdentifier(!0)), (e.property.name !== r || n) && this.raise(g.UnsupportedMetaProperty, { at: e.property, target: t.name, onlyValidPropertyName: r }), this.finishNode(e, "MetaProperty");
       }
       parseImportMetaProperty(e) {
        let t = this.createIdentifier(this.startNodeAtNode(e), "import");
        if ((this.next(), this.isContextual(101))) this.inModule || this.raise(g.ImportMetaOutsideModule, { at: t }), (this.sawUnambiguousESM = !0);
        else if (this.isContextual(105) || this.isContextual(97)) {
         let t = this.isContextual(105);
         if ((t || this.unexpected(), this.expectPlugin(t ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)) throw this.raise(g.DynamicImportPhaseRequiresImportExpressions, { at: this.state.startLoc, phase: this.state.value });
         return this.next(), (e.phase = t ? "source" : "defer"), this.parseImportCall(e);
        }
        return this.parseMetaProperty(e, t, "meta");
       }
       parseLiteralAtNode(e, t, r) {
        return this.addExtra(r, "rawValue", e), this.addExtra(r, "raw", this.input.slice(r.start, this.state.end)), (r.value = e), this.next(), this.finishNode(r, t);
       }
       parseLiteral(e, t) {
        let r = this.startNode();
        return this.parseLiteralAtNode(e, t, r);
       }
       parseStringLiteral(e) {
        return this.parseLiteral(e, "StringLiteral");
       }
       parseNumericLiteral(e) {
        return this.parseLiteral(e, "NumericLiteral");
       }
       parseBigIntLiteral(e) {
        return this.parseLiteral(e, "BigIntLiteral");
       }
       parseDecimalLiteral(e) {
        return this.parseLiteral(e, "DecimalLiteral");
       }
       parseRegExpLiteral(e) {
        let t = this.parseLiteral(e.value, "RegExpLiteral");
        return (t.pattern = e.pattern), (t.flags = e.flags), t;
       }
       parseBooleanLiteral(e) {
        let t = this.startNode();
        return (t.value = e), this.next(), this.finishNode(t, "BooleanLiteral");
       }
       parseNullLiteral() {
        let e = this.startNode();
        return this.next(), this.finishNode(e, "NullLiteral");
       }
       parseParenAndDistinguishExpression(e) {
        let t,
         r = this.state.startLoc;
        this.next(), this.expressionScope.enter(new Qe(1));
        let n = this.state.maybeInArrowParameters,
         s = this.state.inFSharpPipelineDirectBody;
        (this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1);
        let i,
         a,
         o = this.state.startLoc,
         u = [],
         l = new st(),
         p = !0;
        for (; !this.match(11); ) {
         if (p) p = !1;
         else if ((this.expect(12, null === l.optionalParametersLoc ? null : l.optionalParametersLoc), this.match(11))) {
          a = this.state.startLoc;
          break;
         }
         if (this.match(21)) {
          let e = this.state.startLoc;
          if (((i = this.state.startLoc), u.push(this.parseParenItem(this.parseRestBinding(), e)), !this.checkCommaAfterRest(41))) break;
         } else u.push(this.parseMaybeAssignAllowIn(l, this.parseParenItem));
        }
        let c = this.state.lastTokEndLoc;
        this.expect(11), (this.state.maybeInArrowParameters = n), (this.state.inFSharpPipelineDirectBody = s);
        let h = this.startNodeAt(r);
        return e && this.shouldParseArrow(u) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, u, !1), h) : (this.expressionScope.exit(), u.length || this.unexpected(this.state.lastTokStartLoc), a && this.unexpected(a), i && this.unexpected(i), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(u, !0), u.length > 1 ? ((t = this.startNodeAt(o)), (t.expressions = u), this.finishNode(t, "SequenceExpression"), this.resetEndLocation(t, c)) : (t = u[0]), this.wrapParenthesis(r, t));
       }
       wrapParenthesis(e, t) {
        if (!this.options.createParenthesizedExpressions) return this.addExtra(t, "parenthesized", !0), this.addExtra(t, "parenStart", e.index), this.takeSurroundingComments(t, e.index, this.state.lastTokEndLoc.index), t;
        let r = this.startNodeAt(e);
        return (r.expression = t), this.finishNode(r, "ParenthesizedExpression");
       }
       shouldParseArrow(e) {
        return !this.canInsertSemicolon();
       }
       parseArrow(e) {
        if (this.eat(19)) return e;
       }
       parseParenItem(e, t) {
        return e;
       }
       parseNewOrNewTarget() {
        let e = this.startNode();
        if ((this.next(), this.match(16))) {
         let t = this.createIdentifier(this.startNodeAtNode(e), "new");
         this.next();
         let r = this.parseMetaProperty(e, t, "target");
         return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(g.UnexpectedNewTarget, { at: r }), r;
        }
        return this.parseNew(e);
       }
       parseNew(e) {
        if ((this.parseNewCallee(e), this.eat(10))) {
         let t = this.parseExprList(11);
         this.toReferencedList(t), (e.arguments = t);
        } else e.arguments = [];
        return this.finishNode(e, "NewExpression");
       }
       parseNewCallee(e) {
        let t = this.match(83),
         r = this.parseNoCallExpr();
        (e.callee = r), t && ("Import" === r.type || "ImportExpression" === r.type) && this.raise(g.ImportCallNotNewExpression, { at: r });
       }
       parseTemplateElement(e) {
        let { start: t, startLoc: r, end: n, value: i } = this.state,
         a = t + 1,
         o = this.startNodeAt(s(r, 1));
        null === i && (e || this.raise(g.InvalidEscapeSequenceTemplate, { at: s(this.state.firstInvalidTemplateEscapePos, 1) }));
        let u = this.match(24),
         l = u ? -1 : -2,
         p = n + l;
        (o.value = { raw: this.input.slice(a, p).replace(/\r\n?/g, "\n"), cooked: null === i ? null : i.slice(1, l) }), (o.tail = u), this.next();
        let c = this.finishNode(o, "TemplateElement");
        return this.resetEndLocation(c, s(this.state.lastTokEndLoc, l)), c;
       }
       parseTemplate(e) {
        let t = this.startNode();
        t.expressions = [];
        let r = this.parseTemplateElement(e);
        for (t.quasis = [r]; !r.tail; ) t.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), t.quasis.push((r = this.parseTemplateElement(e)));
        return this.finishNode(t, "TemplateLiteral");
       }
       parseTemplateSubstitution() {
        return this.parseExpression();
       }
       parseObjectLike(e, t, r, n) {
        r && this.expectPlugin("recordAndTuple");
        let s = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !1;
        let i = Object.create(null),
         a = !0,
         o = this.startNode();
        for (o.properties = [], this.next(); !this.match(e); ) {
         if (a) a = !1;
         else if ((this.expect(12), this.match(e))) {
          this.addTrailingCommaExtraToNode(o);
          break;
         }
         let s;
         t ? (s = this.parseBindingProperty()) : ((s = this.parsePropertyDefinition(n)), this.checkProto(s, r, i, n)), r && !this.isObjectProperty(s) && "SpreadElement" !== s.type && this.raise(g.InvalidRecordProperty, { at: s }), s.shorthand && this.addExtra(s, "shorthand", !0), o.properties.push(s);
        }
        this.next(), (this.state.inFSharpPipelineDirectBody = s);
        let u = "ObjectExpression";
        return t ? (u = "ObjectPattern") : r && (u = "RecordExpression"), this.finishNode(o, u);
       }
       addTrailingCommaExtraToNode(e) {
        this.addExtra(e, "trailingComma", this.state.lastTokStart), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
       }
       maybeAsyncOrAccessorProp(e) {
        return !e.computed && "Identifier" === e.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
       }
       parsePropertyDefinition(e) {
        let t = [];
        if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(g.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); ) t.push(this.parseDecorator());
        let r,
         n = this.startNode(),
         s = !1,
         i = !1;
        if (this.match(21)) return t.length && this.unexpected(), this.parseSpread();
        t.length && ((n.decorators = t), (t = [])), (n.method = !1), e && (r = this.state.startLoc);
        let a = this.eat(55);
        this.parsePropertyNamePrefixOperator(n);
        let o = this.state.containsEsc,
         u = this.parsePropertyName(n, e);
        if (!a && !o && this.maybeAsyncOrAccessorProp(n)) {
         let e = u.name;
         "async" === e && !this.hasPrecedingLineBreak() && ((s = !0), this.resetPreviousNodeTrailingComments(u), (a = this.eat(55)), this.parsePropertyName(n)), ("get" === e || "set" === e) && ((i = !0), this.resetPreviousNodeTrailingComments(u), (n.kind = e), this.match(55) && ((a = !0), this.raise(g.AccessorIsGenerator, { at: this.state.curPosition(), kind: e }), this.next()), this.parsePropertyName(n));
        }
        return this.parseObjPropValue(n, r, a, s, !1, i, e);
       }
       getGetterSetterExpectedParamCount(e) {
        return "get" === e.kind ? 0 : 1;
       }
       getObjectOrClassMethodParams(e) {
        return e.params;
       }
       checkGetterSetterParams(e) {
        var t;
        let r = this.getGetterSetterExpectedParamCount(e),
         n = this.getObjectOrClassMethodParams(e);
        n.length !== r && this.raise("get" === e.kind ? g.BadGetterArity : g.BadSetterArity, { at: e }), "set" === e.kind && "RestElement" === (null == (t = n[n.length - 1]) ? void 0 : t.type) && this.raise(g.BadSetterRestParameter, { at: e });
       }
       parseObjectMethod(e, t, r, n, s) {
        if (s) {
         let r = this.parseMethod(e, t, !1, !1, !1, "ObjectMethod");
         return this.checkGetterSetterParams(r), r;
        }
        if (r || t || this.match(10)) return n && this.unexpected(), (e.kind = "method"), (e.method = !0), this.parseMethod(e, t, r, !1, !1, "ObjectMethod");
       }
       parseObjectProperty(e, t, r, n) {
        if (((e.shorthand = !1), this.eat(14))) return (e.value = r ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n)), this.finishNode(e, "ObjectProperty");
        if (!e.computed && "Identifier" === e.key.type) {
         if ((this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), r)) e.value = this.parseMaybeDefault(t, ot(e.key));
         else if (this.match(29)) {
          let r = this.state.startLoc;
          null != n ? null === n.shorthandAssignLoc && (n.shorthandAssignLoc = r) : this.raise(g.InvalidCoverInitializedName, { at: r }), (e.value = this.parseMaybeDefault(t, ot(e.key)));
         } else e.value = ot(e.key);
         return (e.shorthand = !0), this.finishNode(e, "ObjectProperty");
        }
       }
       parseObjPropValue(e, t, r, n, s, i, a) {
        let o = this.parseObjectMethod(e, r, n, s, i) || this.parseObjectProperty(e, t, s, a);
        return o || this.unexpected(), o;
       }
       parsePropertyName(e, t) {
        if (this.eat(0)) (e.computed = !0), (e.key = this.parseMaybeAssignAllowIn()), this.expect(3);
        else {
         let r,
          { type: n, value: s } = this.state;
         if (V(n)) r = this.parseIdentifier(!0);
         else
          switch (n) {
           case 134:
            r = this.parseNumericLiteral(s);
            break;
           case 133:
            r = this.parseStringLiteral(s);
            break;
           case 135:
            r = this.parseBigIntLiteral(s);
            break;
           case 136:
            r = this.parseDecimalLiteral(s);
            break;
           case 138: {
            let e = this.state.startLoc;
            null != t ? null === t.privateKeyLoc && (t.privateKeyLoc = e) : this.raise(g.UnexpectedPrivateField, { at: e }), (r = this.parsePrivateName());
            break;
           }
           default:
            this.unexpected();
          }
         (e.key = r), 138 !== n && (e.computed = !1);
        }
        return e.key;
       }
       initFunction(e, t) {
        (e.id = null), (e.generator = !1), (e.async = t);
       }
       parseMethod(e, t, r, n, s, i, a = !1) {
        this.initFunction(e, r), (e.generator = t), this.scope.enter(18 | (a ? 64 : 0) | (s ? 32 : 0)), this.prodParam.enter(rt(r, e.generator)), this.parseFunctionParams(e, n);
        let o = this.parseFunctionBodyAndFinish(e, i, !0);
        return this.prodParam.exit(), this.scope.exit(), o;
       }
       parseArrayLike(e, t, r, n) {
        r && this.expectPlugin("recordAndTuple");
        let s = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !1;
        let i = this.startNode();
        return this.next(), (i.elements = this.parseExprList(e, !r, n, i)), (this.state.inFSharpPipelineDirectBody = s), this.finishNode(i, r ? "TupleExpression" : "ArrayExpression");
       }
       parseArrowExpression(e, t, r, n) {
        this.scope.enter(6);
        let s = rt(r, !1);
        !this.match(5) && this.prodParam.hasIn && (s |= 8), this.prodParam.enter(s), this.initFunction(e, r);
        let i = this.state.maybeInArrowParameters;
        return t && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(e, t, n)), (this.state.maybeInArrowParameters = !1), this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), (this.state.maybeInArrowParameters = i), this.finishNode(e, "ArrowFunctionExpression");
       }
       setArrowFunctionParameters(e, t, r) {
        this.toAssignableList(t, r, !1), (e.params = t);
       }
       parseFunctionBodyAndFinish(e, t, r = !1) {
        return this.parseFunctionBody(e, !1, r), this.finishNode(e, t);
       }
       parseFunctionBody(e, t, r = !1) {
        let n = t && !this.match(5);
        if ((this.expressionScope.enter(et()), n)) (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, t, !1);
        else {
         let n = this.state.strict,
          s = this.state.labels;
         (this.state.labels = []),
          this.prodParam.enter(4 | this.prodParam.currentFlags()),
          (e.body = this.parseBlock(!0, !1, (s) => {
           let i = !this.isSimpleParamList(e.params);
           s && i && this.raise(g.IllegalLanguageModeDirective, { at: ("method" !== e.kind && "constructor" !== e.kind) || !e.key ? e : e.key.loc.end });
           let a = !n && this.state.strict;
           this.checkParams(e, !(this.state.strict || t || r || i), t, a), this.state.strict && e.id && this.checkIdentifier(e.id, 65, a);
          })),
          this.prodParam.exit(),
          (this.state.labels = s);
        }
        this.expressionScope.exit();
       }
       isSimpleParameter(e) {
        return "Identifier" === e.type;
       }
       isSimpleParamList(e) {
        for (let t = 0, r = e.length; t < r; t++) if (!this.isSimpleParameter(e[t])) return !1;
        return !0;
       }
       checkParams(e, t, r, n = !0) {
        let s = !t && new Set(),
         i = { type: "FormalParameters" };
        for (let a of e.params) this.checkLVal(a, { in: i, binding: 5, checkClashes: s, strictModeChanged: n });
       }
       parseExprList(e, t, r, n) {
        let s = [],
         i = !0;
        for (; !this.eat(e); ) {
         if (i) i = !1;
         else if ((this.expect(12), this.match(e))) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
         }
         s.push(this.parseExprListItem(t, r));
        }
        return s;
       }
       parseExprListItem(e, t, r) {
        let n;
        if (this.match(12)) e || this.raise(g.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), (n = null);
        else if (this.match(21)) {
         let e = this.state.startLoc;
         n = this.parseParenItem(this.parseSpread(t), e);
        } else if (this.match(17)) {
         this.expectPlugin("partialApplication"), r || this.raise(g.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
         let e = this.startNode();
         this.next(), (n = this.finishNode(e, "ArgumentPlaceholder"));
        } else n = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
        return n;
       }
       parseIdentifier(e) {
        let t = this.startNode(),
         r = this.parseIdentifierName(e);
        return this.createIdentifier(t, r);
       }
       createIdentifier(e, t) {
        return (e.name = t), (e.loc.identifierName = t), this.finishNode(e, "Identifier");
       }
       parseIdentifierName(e) {
        let t,
         { startLoc: r, type: n } = this.state;
        V(n) ? (t = this.state.value) : this.unexpected();
        let s = n <= 92;
        return e ? s && this.replaceToken(132) : this.checkReservedWord(t, r, s, !1), this.next(), t;
       }
       checkReservedWord(e, t, r, n) {
        var s;
        if (!(e.length > 10) && ((s = e), ye.has(s)))
         if (
          r &&
          (function (e) {
           return le.has(e);
          })(e)
         )
          this.raise(g.UnexpectedKeyword, { at: t, keyword: e });
         else if ((this.state.strict ? (n ? me : de) : he)(e, this.inModule)) this.raise(g.UnexpectedReservedWord, { at: t, reservedWord: e });
         else if ("yield" === e) {
          if (this.prodParam.hasYield) return void this.raise(g.YieldBindingIdentifier, { at: t });
         } else if ("await" === e) {
          if (this.prodParam.hasAwait) return void this.raise(g.AwaitBindingIdentifier, { at: t });
          if (this.scope.inStaticBlock) return void this.raise(g.AwaitBindingIdentifierInStaticBlock, { at: t });
          this.expressionScope.recordAsyncArrowParametersError({ at: t });
         } else if ("arguments" === e && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(g.ArgumentsInClass, { at: t });
       }
       isAwaitAllowed() {
        return !!(this.prodParam.hasAwait || (this.options.allowAwaitOutsideFunction && !this.scope.inFunction));
       }
       parseAwait(e) {
        let t = this.startNodeAt(e);
        return this.expressionScope.recordParameterInitializerError(g.AwaitExpressionFormalParameter, { at: t }), this.eat(55) && this.raise(g.ObsoleteAwaitStar, { at: t }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)), this.state.soloAwait || (t.argument = this.parseMaybeUnary(null, !0)), this.finishNode(t, "AwaitExpression");
       }
       isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak()) return !0;
        let { type: e } = this.state;
        return 53 === e || 10 === e || 0 === e || X(e) || (102 === e && !this.state.containsEsc) || 137 === e || 56 === e || (this.hasPlugin("v8intrinsic") && 54 === e);
       }
       parseYield() {
        let e = this.startNode();
        this.expressionScope.recordParameterInitializerError(g.YieldInParameter, { at: e }), this.next();
        let t = !1,
         r = null;
        if (!this.hasPrecedingLineBreak())
         switch (((t = this.eat(55)), this.state.type)) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
           if (!t) break;
          default:
           r = this.parseMaybeAssign();
         }
        return (e.delegate = t), (e.argument = r), this.finishNode(e, "YieldExpression");
       }
       parseImportCall(e) {
        return this.next(), (e.source = this.parseMaybeAssignAllowIn()), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || ((e.options = this.parseMaybeAssignAllowIn()), this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
       }
       checkPipelineAtInfixOperator(e, t) {
        this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && "SequenceExpression" === e.type && this.raise(g.PipelineHeadSequenceExpression, { at: t });
       }
       parseSmartPipelineBodyInStyle(e, t) {
        if (this.isSimpleReference(e)) {
         let r = this.startNodeAt(t);
         return (r.callee = e), this.finishNode(r, "PipelineBareFunction");
        }
        {
         let r = this.startNodeAt(t);
         return this.checkSmartPipeTopicBodyEarlyErrors(t), (r.expression = e), this.finishNode(r, "PipelineTopicExpression");
        }
       }
       isSimpleReference(e) {
        switch (e.type) {
         case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
         case "Identifier":
          return !0;
         default:
          return !1;
        }
       }
       checkSmartPipeTopicBodyEarlyErrors(e) {
        if (this.match(19)) throw this.raise(g.PipelineBodyNoArrow, { at: this.state.startLoc });
        this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipelineTopicUnused, { at: e });
       }
       withTopicBindingContext(e) {
        let t = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
        try {
         return e();
        } finally {
         this.state.topicContext = t;
        }
       }
       withSmartMixTopicForbiddingContext(e) {
        if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) return e();
        {
         let t = this.state.topicContext;
         this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
         try {
          return e();
         } finally {
          this.state.topicContext = t;
         }
        }
       }
       withSoloAwaitPermittingContext(e) {
        let t = this.state.soloAwait;
        this.state.soloAwait = !0;
        try {
         return e();
        } finally {
         this.state.soloAwait = t;
        }
       }
       allowInAnd(e) {
        let t = this.prodParam.currentFlags();
        if (8 & ~t) {
         this.prodParam.enter(8 | t);
         try {
          return e();
         } finally {
          this.prodParam.exit();
         }
        }
        return e();
       }
       disallowInAnd(e) {
        let t = this.prodParam.currentFlags();
        if (8 & t) {
         this.prodParam.enter(-9 & t);
         try {
          return e();
         } finally {
          this.prodParam.exit();
         }
        }
        return e();
       }
       registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
       }
       topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
       }
       topicReferenceWasUsedInCurrentContext() {
        return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
       }
       parseFSharpPipelineBody(e) {
        let t = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        let r = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !0;
        let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
        return (this.state.inFSharpPipelineDirectBody = r), n;
       }
       parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        let e = this.startNode();
        this.next(), this.match(5) || this.unexpected(null, 5);
        let t = this.startNodeAt(this.state.endLoc);
        this.next();
        let r = this.initializeScopes(!0);
        this.enterInitialScopes();
        try {
         e.body = this.parseProgram(t, 8, "module");
        } finally {
         r();
        }
        return this.finishNode(e, "ModuleExpression");
       }
       parsePropertyNamePrefixOperator(e) {}
      },
      qt = { kind: "loop" },
      Ut = { kind: "switch" },
      $t = /[\uD800-\uDFFF]/u,
      Vt = /in(?:stanceof)?/y;
     var zt = class extends Rt {
       parseTopLevel(e, t) {
        return (
         (e.program = this.parseProgram(t)),
         (e.comments = this.state.comments),
         this.options.tokens &&
          (e.tokens = (function (e, t) {
           for (let r = 0; r < e.length; r++) {
            let n = e[r],
             { type: i } = n;
            if ("number" == typeof i) {
             if (138 === i) {
              let { loc: t, start: i, value: a, end: o } = n,
               u = i + 1,
               l = s(t.start, 1);
              e.splice(r, 1, new Je({ type: Y(27), value: "#", start: i, end: u, startLoc: t.start, endLoc: l }), new Je({ type: Y(132), value: a, start: u, end: o, startLoc: l, endLoc: t.end })), r++;
              continue;
             }
             if (X(i)) {
              let a,
               o,
               u,
               l,
               p,
               { loc: c, start: h, value: d, end: f } = n,
               m = h + 1,
               y = s(c.start, 1);
              (a = 96 === t.charCodeAt(h) ? new Je({ type: Y(22), value: "`", start: h, end: m, startLoc: c.start, endLoc: y }) : new Je({ type: Y(8), value: "}", start: h, end: m, startLoc: c.start, endLoc: y })), 24 === i ? ((u = f - 1), (l = s(c.end, -1)), (o = null === d ? null : d.slice(1, -1)), (p = new Je({ type: Y(22), value: "`", start: u, end: f, startLoc: l, endLoc: c.end }))) : ((u = f - 2), (l = s(c.end, -2)), (o = null === d ? null : d.slice(1, -2)), (p = new Je({ type: Y(23), value: "${", start: u, end: f, startLoc: l, endLoc: c.end }))), e.splice(r, 1, a, new Je({ type: Y(20), value: o, start: m, end: u, startLoc: y, endLoc: l }), p), (r += 2);
              continue;
             }
             n.type = Y(i);
            }
           }
           return e;
          })(this.tokens, this.input)),
         this.finishNode(e, "File")
        );
       }
       parseProgram(e, t = 139, r = this.options.sourceType) {
        if (((e.sourceType = r), (e.interpreter = this.parseInterpreterDirective()), this.parseBlockBody(e, !0, !0, t), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)) for (let [s, i] of Array.from(this.scope.undefinedExports)) this.raise(g.ModuleExportUndefined, { at: i, localName: s });
        let n;
        return (n = 139 === t ? this.finishNode(e, "Program") : this.finishNodeAt(e, "Program", s(this.state.startLoc, -1))), n;
       }
       stmtToDirective(e) {
        let t = e;
        (t.type = "Directive"), (t.value = t.expression), delete t.expression;
        let r = t.value,
         n = r.value,
         s = this.input.slice(r.start, r.end),
         i = (r.value = s.slice(1, -1));
        return this.addExtra(r, "raw", s), this.addExtra(r, "rawValue", i), this.addExtra(r, "expressionValue", n), (r.type = "DirectiveLiteral"), t;
       }
       parseInterpreterDirective() {
        if (!this.match(28)) return null;
        let e = this.startNode();
        return (e.value = this.state.value), this.next(), this.finishNode(e, "InterpreterDirective");
       }
       isLet() {
        return !!this.isContextual(100) && this.hasFollowingBindingAtom();
       }
       chStartsBindingIdentifier(e, t) {
        if (ie(e)) {
         if (((Vt.lastIndex = t), Vt.test(this.input))) {
          let e = this.codePointAtPos(Vt.lastIndex);
          if (!ae(e) && 92 !== e) return !1;
         }
         return !0;
        }
        return 92 === e;
       }
       chStartsBindingPattern(e) {
        return 91 === e || 123 === e;
       }
       hasFollowingBindingAtom() {
        let e = this.nextTokenStart(),
         t = this.codePointAtPos(e);
        return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e);
       }
       hasInLineFollowingBindingIdentifier() {
        let e = this.nextTokenInLineStart(),
         t = this.codePointAtPos(e);
        return this.chStartsBindingIdentifier(t, e);
       }
       startsUsingForOf() {
        let { type: e, containsEsc: t } = this.lookahead();
        return !(102 === e && !t) && ($(e) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), !0) : void 0);
       }
       startsAwaitUsing() {
        let e = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(e, "using")) {
         e = this.nextTokenInLineStartSince(e + 5);
         let t = this.codePointAtPos(e);
         if (this.chStartsBindingIdentifier(t, e)) return this.expectPlugin("explicitResourceManagement"), !0;
        }
        return !1;
       }
       parseModuleItem() {
        return this.parseStatementLike(15);
       }
       parseStatementListItem() {
        return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
       }
       parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
        let t = 0;
        return this.options.annexB && !this.state.strict && ((t |= 4), e && (t |= 8)), this.parseStatementLike(t);
       }
       parseStatement() {
        return this.parseStatementLike(0);
       }
       parseStatementLike(e) {
        let t = null;
        return this.match(26) && (t = this.parseDecorators(!0)), this.parseStatementContent(e, t);
       }
       parseStatementContent(e, t) {
        let r = this.state.type,
         n = this.startNode(),
         s = !!(2 & e),
         i = !!(4 & e),
         a = 1 & e;
        switch (r) {
         case 60:
          return this.parseBreakContinueStatement(n, !0);
         case 63:
          return this.parseBreakContinueStatement(n, !1);
         case 64:
          return this.parseDebuggerStatement(n);
         case 90:
          return this.parseDoWhileStatement(n);
         case 91:
          return this.parseForStatement(n);
         case 68:
          if (46 === this.lookaheadCharCode()) break;
          return i || this.raise(this.state.strict ? g.StrictFunction : this.options.annexB ? g.SloppyFunctionAnnexB : g.SloppyFunction, { at: this.state.startLoc }), this.parseFunctionStatement(n, !1, !s && i);
         case 80:
          return s || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t, n), !0);
         case 69:
          return this.parseIfStatement(n);
         case 70:
          return this.parseReturnStatement(n);
         case 71:
          return this.parseSwitchStatement(n);
         case 72:
          return this.parseThrowStatement(n);
         case 73:
          return this.parseTryStatement(n);
         case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? s || this.raise(g.UnexpectedLexicalDeclaration, { at: n }) : this.raise(g.AwaitUsingNotInAsyncContext, { at: n }), this.next(), this.parseVarStatement(n, "await using");
          break;
         case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(g.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : s || this.raise(g.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(n, "using");
         case 100: {
          if (this.state.containsEsc) break;
          let e = this.nextTokenStart(),
           t = this.codePointAtPos(e);
          if (91 !== t && ((!s && this.hasFollowingLineBreak()) || (!this.chStartsBindingIdentifier(t, e) && 123 !== t))) break;
         }
         case 75:
          s || this.raise(g.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
         case 74: {
          let e = this.state.value;
          return this.parseVarStatement(n, e);
         }
         case 92:
          return this.parseWhileStatement(n);
         case 76:
          return this.parseWithStatement(n);
         case 5:
          return this.parseBlock();
         case 13:
          return this.parseEmptyStatement(n);
         case 83: {
          let e = this.lookaheadCharCode();
          if (40 === e || 46 === e) break;
         }
         case 82: {
          let e;
          return !this.options.allowImportExportEverywhere && !a && this.raise(g.UnexpectedImportExport, { at: this.state.startLoc }), this.next(), 83 === r ? ((e = this.parseImport(n)), "ImportDeclaration" === e.type && (!e.importKind || "value" === e.importKind) && (this.sawUnambiguousESM = !0)) : ((e = this.parseExport(n, t)), (("ExportNamedDeclaration" === e.type && (!e.exportKind || "value" === e.exportKind)) || ("ExportAllDeclaration" === e.type && (!e.exportKind || "value" === e.exportKind)) || "ExportDefaultDeclaration" === e.type) && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(e), e;
         }
         default:
          if (this.isAsyncFunction()) return s || this.raise(g.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(n, !0, !s && i);
        }
        let o = this.state.value,
         u = this.parseExpression();
        return $(r) && "Identifier" === u.type && this.eat(14) ? this.parseLabeledStatement(n, o, u, e) : this.parseExpressionStatement(n, u, t);
       }
       assertModuleNodeAllowed(e) {
        !this.options.allowImportExportEverywhere && !this.inModule && this.raise(g.ImportOutsideModule, { at: e });
       }
       decoratorsEnabledBeforeExport() {
        return !!this.hasPlugin("decorators-legacy") || (this.hasPlugin("decorators") && !1 !== this.getPluginOption("decorators", "decoratorsBeforeExport"));
       }
       maybeTakeDecorators(e, t, r) {
        return e && (t.decorators && t.decorators.length > 0 ? ("boolean" != typeof this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorsBeforeAfterExport, { at: t.decorators[0] }), t.decorators.unshift(...e)) : (t.decorators = e), this.resetStartLocationFromNode(t, e[0]), r && this.resetStartLocationFromNode(r, t)), t;
       }
       canHaveLeadingDecorator() {
        return this.match(80);
       }
       parseDecorators(e) {
        let t = [];
        do {
         t.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(g.DecoratorExportClass, { at: this.state.startLoc });
        else if (!this.canHaveLeadingDecorator()) throw this.raise(g.UnexpectedLeadingDecorator, { at: this.state.startLoc });
        return t;
       }
       parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        let e = this.startNode();
        if ((this.next(), this.hasPlugin("decorators"))) {
         let t,
          r = this.state.startLoc;
         if (this.match(10)) {
          let r = this.state.startLoc;
          this.next(), (t = this.parseExpression()), this.expect(11), (t = this.wrapParenthesis(r, t));
          let n = this.state.startLoc;
          (e.expression = this.parseMaybeDecoratorArguments(t)), !1 === this.getPluginOption("decorators", "allowCallParenthesized") && e.expression !== t && this.raise(g.DecoratorArgumentsOutsideParentheses, { at: n });
         } else {
          for (t = this.parseIdentifier(!1); this.eat(16); ) {
           let e = this.startNodeAt(r);
           (e.object = t), this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), (e.property = this.parsePrivateName())) : (e.property = this.parseIdentifier(!0)), (e.computed = !1), (t = this.finishNode(e, "MemberExpression"));
          }
          e.expression = this.parseMaybeDecoratorArguments(t);
         }
        } else e.expression = this.parseExprSubscripts();
        return this.finishNode(e, "Decorator");
       }
       parseMaybeDecoratorArguments(e) {
        if (this.eat(10)) {
         let t = this.startNodeAtNode(e);
         return (t.callee = e), (t.arguments = this.parseCallExpressionArguments(11, !1)), this.toReferencedList(t.arguments), this.finishNode(t, "CallExpression");
        }
        return e;
       }
       parseBreakContinueStatement(e, t) {
        return this.next(), this.isLineTerminator() ? (e.label = null) : ((e.label = this.parseIdentifier()), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? "BreakStatement" : "ContinueStatement");
       }
       verifyBreakContinue(e, t) {
        let r;
        for (r = 0; r < this.state.labels.length; ++r) {
         let n = this.state.labels[r];
         if ((null == e.label || n.name === e.label.name) && ((null != n.kind && (t || "loop" === n.kind)) || (e.label && t))) break;
        }
        if (r === this.state.labels.length) {
         let r = t ? "BreakStatement" : "ContinueStatement";
         this.raise(g.IllegalBreakContinue, { at: e, type: r });
        }
       }
       parseDebuggerStatement(e) {
        return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
       }
       parseHeaderExpression() {
        this.expect(10);
        let e = this.parseExpression();
        return this.expect(11), e;
       }
       parseDoWhileStatement(e) {
        return this.next(), this.state.labels.push(qt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.expect(92), (e.test = this.parseHeaderExpression()), this.eat(13), this.finishNode(e, "DoWhileStatement");
       }
       parseForStatement(e) {
        this.next(), this.state.labels.push(qt);
        let t = null;
        if ((this.isAwaitAllowed() && this.eatContextual(96) && (t = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))) return null !== t && this.unexpected(t), this.parseFor(e, null);
        let r = this.isContextual(100);
        {
         let n = this.isContextual(96) && this.startsAwaitUsing(),
          s = n || (this.isContextual(107) && this.startsUsingForOf()),
          i = (r && this.hasFollowingBindingAtom()) || s;
         if (this.match(74) || this.match(75) || i) {
          let r,
           i = this.startNode();
          n ? ((r = "await using"), this.isAwaitAllowed() || this.raise(g.AwaitUsingNotInAsyncContext, { at: this.state.startLoc }), this.next()) : (r = this.state.value), this.next(), this.parseVar(i, !0, r);
          let a = this.finishNode(i, "VariableDeclaration"),
           o = this.match(58);
          return o && s && this.raise(g.ForInUsing, { at: a }), (o || this.isContextual(102)) && 1 === a.declarations.length ? this.parseForIn(e, a, t) : (null !== t && this.unexpected(t), this.parseFor(e, a));
         }
        }
        let n = this.isContextual(95),
         s = new st(),
         i = this.parseExpression(!0, s),
         a = this.isContextual(102);
        if ((a && (r && this.raise(g.ForOfLet, { at: i }), null === t && n && "Identifier" === i.type && this.raise(g.ForOfAsync, { at: i })), a || this.match(58))) {
         this.checkDestructuringPrivate(s), this.toAssignable(i, !0);
         let r = a ? "ForOfStatement" : "ForInStatement";
         return this.checkLVal(i, { in: { type: r } }), this.parseForIn(e, i, t);
        }
        return this.checkExpressionErrors(s, !0), null !== t && this.unexpected(t), this.parseFor(e, i);
       }
       parseFunctionStatement(e, t, r) {
        return this.next(), this.parseFunction(e, 1 | (r ? 2 : 0) | (t ? 8 : 0));
       }
       parseIfStatement(e) {
        return this.next(), (e.test = this.parseHeaderExpression()), (e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration()), (e.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null), this.finishNode(e, "IfStatement");
       }
       parseReturnStatement(e) {
        return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(g.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? (e.argument = null) : ((e.argument = this.parseExpression()), this.semicolon()), this.finishNode(e, "ReturnStatement");
       }
       parseSwitchStatement(e) {
        this.next(), (e.discriminant = this.parseHeaderExpression());
        let t,
         r = (e.cases = []);
        this.expect(5), this.state.labels.push(Ut), this.scope.enter(0);
        for (let n; !this.match(8); )
         if (this.match(61) || this.match(65)) {
          let e = this.match(61);
          t && this.finishNode(t, "SwitchCase"), r.push((t = this.startNode())), (t.consequent = []), this.next(), e ? (t.test = this.parseExpression()) : (n && this.raise(g.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), (n = !0), (t.test = null)), this.expect(14);
         } else t ? t.consequent.push(this.parseStatementListItem()) : this.unexpected();
        return this.scope.exit(), t && this.finishNode(t, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchStatement");
       }
       parseThrowStatement(e) {
        return this.next(), this.hasPrecedingLineBreak() && this.raise(g.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), (e.argument = this.parseExpression()), this.semicolon(), this.finishNode(e, "ThrowStatement");
       }
       parseCatchClauseParam() {
        let e = this.parseBindingAtom();
        return this.scope.enter(this.options.annexB && "Identifier" === e.type ? 8 : 0), this.checkLVal(e, { in: { type: "CatchClause" }, binding: 9 }), e;
       }
       parseTryStatement(e) {
        if ((this.next(), (e.block = this.parseBlock()), (e.handler = null), this.match(62))) {
         let t = this.startNode();
         this.next(), this.match(10) ? (this.expect(10), (t.param = this.parseCatchClauseParam()), this.expect(11)) : ((t.param = null), this.scope.enter(0)), (t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))), this.scope.exit(), (e.handler = this.finishNode(t, "CatchClause"));
        }
        return (e.finalizer = this.eat(67) ? this.parseBlock() : null), !e.handler && !e.finalizer && this.raise(g.NoCatchOrFinally, { at: e }), this.finishNode(e, "TryStatement");
       }
       parseVarStatement(e, t, r = !1) {
        return this.next(), this.parseVar(e, !1, t, r), this.semicolon(), this.finishNode(e, "VariableDeclaration");
       }
       parseWhileStatement(e) {
        return this.next(), (e.test = this.parseHeaderExpression()), this.state.labels.push(qt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
       }
       parseWithStatement(e) {
        return this.state.strict && this.raise(g.StrictWith, { at: this.state.startLoc }), this.next(), (e.object = this.parseHeaderExpression()), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.finishNode(e, "WithStatement");
       }
       parseEmptyStatement(e) {
        return this.next(), this.finishNode(e, "EmptyStatement");
       }
       parseLabeledStatement(e, t, r, n) {
        for (let a of this.state.labels) a.name === t && this.raise(g.LabelRedeclaration, { at: r, labelName: t });
        let s = (i = this.state.type) >= 90 && i <= 92 ? "loop" : this.match(71) ? "switch" : null;
        var i;
        for (let a = this.state.labels.length - 1; a >= 0; a--) {
         let t = this.state.labels[a];
         if (t.statementStart !== e.start) break;
         (t.statementStart = this.state.start), (t.kind = s);
        }
        return this.state.labels.push({ name: t, kind: s, statementStart: this.state.start }), (e.body = 8 & n ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement()), this.state.labels.pop(), (e.label = r), this.finishNode(e, "LabeledStatement");
       }
       parseExpressionStatement(e, t, r) {
        return (e.expression = t), this.semicolon(), this.finishNode(e, "ExpressionStatement");
       }
       parseBlock(e = !1, t = !0, r) {
        let n = this.startNode();
        return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(0), this.parseBlockBody(n, e, !1, 8, r), t && this.scope.exit(), this.finishNode(n, "BlockStatement");
       }
       isValidDirective(e) {
        return "ExpressionStatement" === e.type && "StringLiteral" === e.expression.type && !e.expression.extra.parenthesized;
       }
       parseBlockBody(e, t, r, n, s) {
        let i = (e.body = []),
         a = (e.directives = []);
        this.parseBlockOrModuleBlockBody(i, t ? a : void 0, r, n, s);
       }
       parseBlockOrModuleBlockBody(e, t, r, n, s) {
        let i = this.state.strict,
         a = !1,
         o = !1;
        for (; !this.match(n); ) {
         let n = r ? this.parseModuleItem() : this.parseStatementListItem();
         if (t && !o) {
          if (this.isValidDirective(n)) {
           let e = this.stmtToDirective(n);
           t.push(e), !a && "use strict" === e.value.value && ((a = !0), this.setStrict(!0));
           continue;
          }
          (o = !0), this.state.strictErrors.clear();
         }
         e.push(n);
        }
        null == s || s.call(this, a), i || this.setStrict(!1), this.next();
       }
       parseFor(e, t) {
        return (e.init = t), this.semicolon(!1), (e.test = this.match(13) ? null : this.parseExpression()), this.semicolon(!1), (e.update = this.match(11) ? null : this.parseExpression()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
       }
       parseForIn(e, t, r) {
        let n = this.match(58);
        return this.next(), n ? null !== r && this.unexpected(r) : (e.await = null !== r), "VariableDeclaration" === t.type && null != t.declarations[0].init && (!n || !this.options.annexB || this.state.strict || "var" !== t.kind || "Identifier" !== t.declarations[0].id.type) && this.raise(g.ForInOfLoopInitializer, { at: t, type: n ? "ForInStatement" : "ForOfStatement" }), "AssignmentPattern" === t.type && this.raise(g.InvalidLhs, { at: t, ancestor: { type: "ForStatement" } }), (e.left = t), (e.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, n ? "ForInStatement" : "ForOfStatement");
       }
       parseVar(e, t, r, n = !1) {
        let s = (e.declarations = []);
        for (e.kind = r; ; ) {
         let e = this.startNode();
         if ((this.parseVarId(e, r), (e.init = this.eat(29) ? (t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()) : null), null === e.init && !n && ("Identifier" === e.id.type || (t && (this.match(58) || this.isContextual(102))) ? "const" === r && !(this.match(58) || this.isContextual(102)) && this.raise(g.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" }) : this.raise(g.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" })), s.push(this.finishNode(e, "VariableDeclarator")), !this.eat(12))) break;
        }
        return e;
       }
       parseVarId(e, t) {
        let r = this.parseBindingAtom();
        this.checkLVal(r, { in: { type: "VariableDeclarator" }, binding: "var" === t ? 5 : 8201 }), (e.id = r);
       }
       parseAsyncFunctionExpression(e) {
        return this.parseFunction(e, 8);
       }
       parseFunction(e, t = 0) {
        let r = 2 & t,
         n = !!(1 & t),
         s = n && !(4 & t),
         i = !!(8 & t);
        this.initFunction(e, i), this.match(55) && (r && this.raise(g.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), (e.generator = !0)), n && (e.id = this.parseFunctionId(s));
        let a = this.state.maybeInArrowParameters;
        return (
         (this.state.maybeInArrowParameters = !1),
         this.scope.enter(2),
         this.prodParam.enter(rt(i, e.generator)),
         n || (e.id = this.parseFunctionId()),
         this.parseFunctionParams(e, !1),
         this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(e, n ? "FunctionDeclaration" : "FunctionExpression");
         }),
         this.prodParam.exit(),
         this.scope.exit(),
         n && !r && this.registerFunctionStatementId(e),
         (this.state.maybeInArrowParameters = a),
         e
        );
       }
       parseFunctionId(e) {
        return e || $(this.state.type) ? this.parseIdentifier() : null;
       }
       parseFunctionParams(e, t) {
        this.expect(10), this.expressionScope.enter(new Ye(3)), (e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0))), this.expressionScope.exit();
       }
       registerFunctionStatementId(e) {
        e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? (this.scope.treatFunctionsAsVar ? 5 : 8201) : 17, e.id.loc.start);
       }
       parseClass(e, t, r) {
        this.next();
        let n = this.state.strict;
        return (this.state.strict = !0), this.parseClassId(e, t, r), this.parseClassSuper(e), (e.body = this.parseClassBody(!!e.superClass, n)), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
       }
       isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
       }
       isClassMethod() {
        return this.match(10);
       }
       isNonstaticConstructor(e) {
        return !(e.computed || e.static || ("constructor" !== e.key.name && "constructor" !== e.key.value));
       }
       parseClassBody(e, t) {
        this.classScope.enter();
        let r = { hadConstructor: !1, hadSuperClass: e },
         n = [],
         s = this.startNode();
        if (
         ((s.body = []),
         this.expect(5),
         this.withSmartMixTopicForbiddingContext(() => {
          for (; !this.match(8); ) {
           if (this.eat(13)) {
            if (n.length > 0) throw this.raise(g.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
            continue;
           }
           if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
           }
           let e = this.startNode();
           n.length && ((e.decorators = n), this.resetStartLocationFromNode(e, n[0]), (n = [])), this.parseClassMember(s, e, r), "constructor" === e.kind && e.decorators && e.decorators.length > 0 && this.raise(g.DecoratorConstructor, { at: e });
          }
         }),
         (this.state.strict = t),
         this.next(),
         n.length)
        )
         throw this.raise(g.TrailingDecorator, { at: this.state.startLoc });
        return this.classScope.exit(), this.finishNode(s, "ClassBody");
       }
       parseClassMemberFromModifier(e, t) {
        let r = this.parseIdentifier(!0);
        if (this.isClassMethod()) {
         let n = t;
         return (n.kind = "method"), (n.computed = !1), (n.key = r), (n.static = !1), this.pushClassMethod(e, n, !1, !1, !1, !1), !0;
        }
        if (this.isClassProperty()) {
         let n = t;
         return (n.computed = !1), (n.key = r), (n.static = !1), e.body.push(this.parseClassProperty(n)), !0;
        }
        return this.resetPreviousNodeTrailingComments(r), !1;
       }
       parseClassMember(e, t, r) {
        let n = this.isContextual(106);
        if (n) {
         if (this.parseClassMemberFromModifier(e, t)) return;
         if (this.eat(5)) return void this.parseClassStaticBlock(e, t);
        }
        this.parseClassMemberWithIsStatic(e, t, r, n);
       }
       parseClassMemberWithIsStatic(e, t, r, n) {
        let s = t,
         i = t,
         a = t,
         o = t,
         u = t,
         l = s,
         p = s;
        if (((t.static = n), this.parsePropertyNamePrefixOperator(t), this.eat(55))) {
         l.kind = "method";
         let t = this.match(138);
         return this.parseClassElementName(l), t ? void this.pushClassPrivateMethod(e, i, !0, !1) : (this.isNonstaticConstructor(s) && this.raise(g.ConstructorIsGenerator, { at: s.key }), void this.pushClassMethod(e, s, !0, !1, !1, !1));
        }
        let c = $(this.state.type) && !this.state.containsEsc,
         h = this.match(138),
         d = this.parseClassElementName(t),
         f = this.state.startLoc;
        if ((this.parsePostMemberNameModifiers(p), this.isClassMethod())) {
         if (((l.kind = "method"), h)) return void this.pushClassPrivateMethod(e, i, !1, !1);
         let n = this.isNonstaticConstructor(s),
          a = !1;
         n && ((s.kind = "constructor"), r.hadConstructor && !this.hasPlugin("typescript") && this.raise(g.DuplicateConstructor, { at: d }), n && this.hasPlugin("typescript") && t.override && this.raise(g.OverrideOnConstructor, { at: d }), (r.hadConstructor = !0), (a = r.hadSuperClass)), this.pushClassMethod(e, s, !1, !1, n, a);
        } else if (this.isClassProperty()) h ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a);
        else if (c && "async" === d.name && !this.isLineTerminator()) {
         this.resetPreviousNodeTrailingComments(d);
         let t = this.eat(55);
         p.optional && this.unexpected(f), (l.kind = "method");
         let r = this.match(138);
         this.parseClassElementName(l), this.parsePostMemberNameModifiers(p), r ? this.pushClassPrivateMethod(e, i, t, !0) : (this.isNonstaticConstructor(s) && this.raise(g.ConstructorIsAsync, { at: s.key }), this.pushClassMethod(e, s, t, !0, !1, !1));
        } else if (!c || ("get" !== d.name && "set" !== d.name) || (this.match(55) && this.isLineTerminator()))
         if (c && "accessor" === d.name && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d);
          let t = this.match(138);
          this.parseClassElementName(a), this.pushClassAccessorProperty(e, u, t);
         } else this.isLineTerminator() ? (h ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a)) : this.unexpected();
        else {
         this.resetPreviousNodeTrailingComments(d), (l.kind = d.name);
         let t = this.match(138);
         this.parseClassElementName(s), t ? this.pushClassPrivateMethod(e, i, !1, !1) : (this.isNonstaticConstructor(s) && this.raise(g.ConstructorIsAccessor, { at: s.key }), this.pushClassMethod(e, s, !1, !1, !1, !1)), this.checkGetterSetterParams(s);
        }
       }
       parseClassElementName(e) {
        let { type: t, value: r } = this.state;
        if (((132 === t || 133 === t) && e.static && "prototype" === r && this.raise(g.StaticPrototype, { at: this.state.startLoc }), 138 === t)) {
         "constructor" === r && this.raise(g.ConstructorClassPrivateField, { at: this.state.startLoc });
         let t = this.parsePrivateName();
         return (e.key = t), t;
        }
        return this.parsePropertyName(e);
       }
       parseClassStaticBlock(e, t) {
        var r;
        this.scope.enter(208);
        let n = this.state.labels;
        (this.state.labels = []), this.prodParam.enter(0);
        let s = (t.body = []);
        this.parseBlockOrModuleBlockBody(s, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), (this.state.labels = n), e.body.push(this.finishNode(t, "StaticBlock")), null != (r = t.decorators) && r.length && this.raise(g.DecoratorStaticBlock, { at: t });
       }
       pushClassProperty(e, t) {
        !t.computed && ("constructor" === t.key.name || "constructor" === t.key.value) && this.raise(g.ConstructorClassField, { at: t.key }), e.body.push(this.parseClassProperty(t));
       }
       pushClassPrivateProperty(e, t) {
        let r = this.parseClassPrivateProperty(t);
        e.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
       }
       pushClassAccessorProperty(e, t, r) {
        if (!r && !t.computed) {
         let e = t.key;
         ("constructor" === e.name || "constructor" === e.value) && this.raise(g.ConstructorClassField, { at: e });
        }
        let n = this.parseClassAccessorProperty(t);
        e.body.push(n), r && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
       }
       pushClassMethod(e, t, r, n, s, i) {
        e.body.push(this.parseMethod(t, r, n, s, i, "ClassMethod", !0));
       }
       pushClassPrivateMethod(e, t, r, n) {
        let s = this.parseMethod(t, r, n, !1, !1, "ClassPrivateMethod", !0);
        e.body.push(s);
        let i = "get" === s.kind ? (s.static ? 6 : 2) : "set" === s.kind ? (s.static ? 5 : 1) : 0;
        this.declareClassPrivateMethodInScope(s, i);
       }
       declareClassPrivateMethodInScope(e, t) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
       }
       parsePostMemberNameModifiers(e) {}
       parseClassPrivateProperty(e) {
        return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
       }
       parseClassProperty(e) {
        return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
       }
       parseClassAccessorProperty(e) {
        return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
       }
       parseInitializer(e) {
        this.scope.enter(80), this.expressionScope.enter(et()), this.prodParam.enter(0), (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null), this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
       }
       parseClassId(e, t, r, n = 8331) {
        if ($(this.state.type)) (e.id = this.parseIdentifier()), t && this.declareNameFromIdentifier(e.id, n);
        else {
         if (!r && t) throw this.raise(g.MissingClassName, { at: this.state.startLoc });
         e.id = null;
        }
       }
       parseClassSuper(e) {
        e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
       }
       parseExport(e, t) {
        let r = this.parseMaybeImportPhase(e, !0),
         n = this.maybeParseExportDefaultSpecifier(e, r),
         s = !n || this.eat(12),
         i = s && this.eatExportStar(e),
         a = i && this.maybeParseExportNamespaceSpecifier(e),
         o = s && (!a || this.eat(12)),
         u = n || i;
        if (i && !a) {
         if ((n && this.unexpected(), t)) throw this.raise(g.UnsupportedDecoratorExport, { at: e });
         return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
        }
        let l,
         p = this.maybeParseExportNamedSpecifiers(e);
        if ((n && s && !i && !p && this.unexpected(null, 5), a && o && this.unexpected(null, 98), u || p)) {
         if (((l = !1), t)) throw this.raise(g.UnsupportedDecoratorExport, { at: e });
         this.parseExportFrom(e, u);
        } else l = this.maybeParseExportDeclaration(e);
        if (u || p || l) {
         var c;
         let r = e;
         if ((this.checkExport(r, !0, !1, !!r.source), "ClassDeclaration" === (null == (c = r.declaration) ? void 0 : c.type))) this.maybeTakeDecorators(t, r.declaration, r);
         else if (t) throw this.raise(g.UnsupportedDecoratorExport, { at: e });
         return this.finishNode(r, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
         let r = e,
          n = this.parseExportDefaultExpression();
         if (((r.declaration = n), "ClassDeclaration" === n.type)) this.maybeTakeDecorators(t, n, r);
         else if (t) throw this.raise(g.UnsupportedDecoratorExport, { at: e });
         return this.checkExport(r, !0, !0), this.finishNode(r, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
       }
       eatExportStar(e) {
        return this.eat(55);
       }
       maybeParseExportDefaultSpecifier(e, t) {
        if (t || this.isExportDefaultSpecifier()) {
         this.expectPlugin("exportDefaultFrom", null == t ? void 0 : t.loc.start);
         let r = t || this.parseIdentifier(!0),
          n = this.startNodeAtNode(r);
         return (n.exported = r), (e.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")]), !0;
        }
        return !1;
       }
       maybeParseExportNamespaceSpecifier(e) {
        if (this.isContextual(93)) {
         e.specifiers || (e.specifiers = []);
         let t = this.startNodeAt(this.state.lastTokStartLoc);
         return this.next(), (t.exported = this.parseModuleExportName()), e.specifiers.push(this.finishNode(t, "ExportNamespaceSpecifier")), !0;
        }
        return !1;
       }
       maybeParseExportNamedSpecifiers(e) {
        if (this.match(5)) {
         e.specifiers || (e.specifiers = []);
         let t = "type" === e.exportKind;
         return e.specifiers.push(...this.parseExportSpecifiers(t)), (e.source = null), (e.declaration = null), this.hasPlugin("importAssertions") && (e.assertions = []), !0;
        }
        return !1;
       }
       maybeParseExportDeclaration(e) {
        return !!this.shouldParseExportDeclaration() && ((e.specifiers = []), (e.source = null), this.hasPlugin("importAssertions") && (e.assertions = []), (e.declaration = this.parseExportDeclaration(e)), !0);
       }
       isAsyncFunction() {
        if (!this.isContextual(95)) return !1;
        let e = this.nextTokenInLineStart();
        return this.isUnparsedContextual(e, "function");
       }
       parseExportDefaultExpression() {
        let e = this.startNode();
        if (this.match(68)) return this.next(), this.parseFunction(e, 5);
        if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e, 13);
        if (this.match(80)) return this.parseClass(e, !0, !0);
        if (this.match(26)) return this.hasPlugin("decorators") && !0 === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
        if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(g.UnsupportedDefaultExport, { at: this.state.startLoc });
        let t = this.parseMaybeAssignAllowIn();
        return this.semicolon(), t;
       }
       parseExportDeclaration(e) {
        return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
       }
       isExportDefaultSpecifier() {
        let { type: e } = this.state;
        if ($(e)) {
         if ((95 === e && !this.state.containsEsc) || 100 === e) return !1;
         if ((130 === e || 129 === e) && !this.state.containsEsc) {
          let { type: e } = this.lookahead();
          if (($(e) && 98 !== e) || 5 === e) return this.expectOnePlugin(["flow", "typescript"]), !1;
         }
        } else if (!this.match(65)) return !1;
        let t = this.nextTokenStart(),
         r = this.isUnparsedContextual(t, "from");
        if (44 === this.input.charCodeAt(t) || ($(this.state.type) && r)) return !0;
        if (this.match(65) && r) {
         let e = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
         return 34 === e || 39 === e;
        }
        return !1;
       }
       parseExportFrom(e, t) {
        this.eatContextual(98) ? ((e.source = this.parseImportSource()), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(e)) : t && this.unexpected(), this.semicolon();
       }
       shouldParseExportDeclaration() {
        let { type: e } = this.state;
        return 26 === e && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (!0 === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorBeforeExport, { at: this.state.startLoc }), !0) : 74 === e || 75 === e || 68 === e || 80 === e || this.isLet() || this.isAsyncFunction();
       }
       checkExport(e, t, r, n) {
        var s;
        if (t)
         if (r) {
          if ((this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom"))) {
           var i;
           let t = e.declaration;
           "Identifier" === t.type && "from" === t.name && t.end - t.start == 4 && (null == (i = t.extra) || !i.parenthesized) && this.raise(g.ExportDefaultFromAsIdentifier, { at: t });
          }
         } else if (null != (s = e.specifiers) && s.length)
          for (let a of e.specifiers) {
           let { exported: e } = a,
            t = "Identifier" === e.type ? e.name : e.value;
           if ((this.checkDuplicateExports(a, t), !n && a.local)) {
            let { local: e } = a;
            "Identifier" !== e.type ? this.raise(g.ExportBindingIsString, { at: a, localName: e.value, exportName: t }) : (this.checkReservedWord(e.name, e.loc.start, !0, !1), this.scope.checkLocalExport(e));
           }
          }
         else if (e.declaration)
          if ("FunctionDeclaration" === e.declaration.type || "ClassDeclaration" === e.declaration.type) {
           let t = e.declaration.id;
           if (!t) throw new Error("Assertion failure");
           this.checkDuplicateExports(e, t.name);
          } else if ("VariableDeclaration" === e.declaration.type) for (let a of e.declaration.declarations) this.checkDeclaration(a.id);
       }
       checkDeclaration(e) {
        if ("Identifier" === e.type) this.checkDuplicateExports(e, e.name);
        else if ("ObjectPattern" === e.type) for (let t of e.properties) this.checkDeclaration(t);
        else if ("ArrayPattern" === e.type) for (let t of e.elements) t && this.checkDeclaration(t);
        else "ObjectProperty" === e.type ? this.checkDeclaration(e.value) : "RestElement" === e.type ? this.checkDeclaration(e.argument) : "AssignmentPattern" === e.type && this.checkDeclaration(e.left);
       }
       checkDuplicateExports(e, t) {
        this.exportedIdentifiers.has(t) && ("default" === t ? this.raise(g.DuplicateDefaultExport, { at: e }) : this.raise(g.DuplicateExport, { at: e, exportName: t })), this.exportedIdentifiers.add(t);
       }
       parseExportSpecifiers(e) {
        let t = [],
         r = !0;
        for (this.expect(5); !this.eat(8); ) {
         if (r) r = !1;
         else if ((this.expect(12), this.eat(8))) break;
         let n = this.isContextual(130),
          s = this.match(133),
          i = this.startNode();
         (i.local = this.parseModuleExportName()), t.push(this.parseExportSpecifier(i, s, e, n));
        }
        return t;
       }
       parseExportSpecifier(e, t, r, n) {
        return this.eatContextual(93) ? (e.exported = this.parseModuleExportName()) : t ? (e.exported = ut(e.local)) : e.exported || (e.exported = ot(e.local)), this.finishNode(e, "ExportSpecifier");
       }
       parseModuleExportName() {
        if (this.match(133)) {
         let e = this.parseStringLiteral(this.state.value),
          t = e.value.match($t);
         return t && this.raise(g.ModuleExportNameHasLoneSurrogate, { at: e, surrogateCharCode: t[0].charCodeAt(0) }), e;
        }
        return this.parseIdentifier(!0);
       }
       isJSONModuleImport(e) {
        return null != e.assertions && e.assertions.some(({ key: e, value: t }) => "json" === t.value && ("Identifier" === e.type ? "type" === e.name : "type" === e.value));
       }
       checkImportReflection(e) {
        let { specifiers: t } = e,
         r = 1 === t.length ? t[0].type : null;
        if ("source" === e.phase) "ImportDefaultSpecifier" !== r && this.raise(g.SourcePhaseImportRequiresDefault, { at: t[0].loc.start });
        else if ("defer" === e.phase) "ImportNamespaceSpecifier" !== r && this.raise(g.DeferImportRequiresNamespace, { at: t[0].loc.start });
        else if (e.module) {
         var n;
         "ImportDefaultSpecifier" !== r && this.raise(g.ImportReflectionNotBinding, { at: t[0].loc.start }), (null == (n = e.assertions) ? void 0 : n.length) > 0 && this.raise(g.ImportReflectionHasAssertion, { at: e.specifiers[0].loc.start });
        }
       }
       checkJSONModuleImport(e) {
        if (this.isJSONModuleImport(e) && "ExportAllDeclaration" !== e.type) {
         let { specifiers: t } = e;
         if (null != t) {
          let e = t.find((e) => {
           let t;
           if (("ExportSpecifier" === e.type ? (t = e.local) : "ImportSpecifier" === e.type && (t = e.imported), void 0 !== t)) return "Identifier" === t.type ? "default" !== t.name : "default" !== t.value;
          });
          void 0 !== e && this.raise(g.ImportJSONBindingNotDefault, { at: e.loc.start });
         }
        }
       }
       isPotentialImportPhase(e) {
        return !e && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
       }
       applyImportPhase(e, t, r, n) {
        t || ("module" === r ? (this.expectPlugin("importReflection", n), (e.module = !0)) : this.hasPlugin("importReflection") && (e.module = !1), "source" === r ? (this.expectPlugin("sourcePhaseImports", n), (e.phase = "source")) : "defer" === r ? (this.expectPlugin("deferredImportEvaluation", n), (e.phase = "defer")) : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
       }
       parseMaybeImportPhase(e, t) {
        if (!this.isPotentialImportPhase(t)) return this.applyImportPhase(e, t, null), null;
        let r = this.parseIdentifier(!0),
         { type: n } = this.state;
        return (V(n) ? 98 !== n || 102 === this.lookaheadCharCode() : 12 !== n) ? (this.resetPreviousIdentifierLeadingComments(r), this.applyImportPhase(e, t, r.name, r.loc.start), null) : (this.applyImportPhase(e, t, null), r);
       }
       isPrecedingIdImportPhase(e) {
        let { type: t } = this.state;
        return $(t) ? 98 !== t || 102 === this.lookaheadCharCode() : 12 !== t;
       }
       parseImport(e) {
        return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
       }
       parseImportSpecifiersAndAfter(e, t) {
        e.specifiers = [];
        let r = !this.maybeParseDefaultImportSpecifier(e, t) || this.eat(12),
         n = r && this.maybeParseStarImportSpecifier(e);
        return r && !n && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
       }
       parseImportSourceAndAttributes(e) {
        return null != e.specifiers || (e.specifiers = []), (e.source = this.parseImportSource()), this.maybeParseImportAttributes(e), this.checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
       }
       parseImportSource() {
        return this.match(133) || this.unexpected(), this.parseExprAtom();
       }
       parseImportSpecifierLocal(e, t, r) {
        (t.local = this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r));
       }
       finishImportSpecifier(e, t, r = 8201) {
        return this.checkLVal(e.local, { in: { type: t }, binding: r }), this.finishNode(e, t);
       }
       parseImportAttributes() {
        this.expect(5);
        let e = [],
         t = new Set();
        do {
         if (this.match(8)) break;
         let r = this.startNode(),
          n = this.state.value;
         if ((t.has(n) && this.raise(g.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: n }), t.add(n), this.match(133) ? (r.key = this.parseStringLiteral(n)) : (r.key = this.parseIdentifier(!0)), this.expect(14), !this.match(133))) throw this.raise(g.ModuleAttributeInvalidValue, { at: this.state.startLoc });
         (r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, "ImportAttribute"));
        } while (this.eat(12));
        return this.expect(8), e;
       }
       parseModuleAttributes() {
        let e = [],
         t = new Set();
        do {
         let r = this.startNode();
         if (((r.key = this.parseIdentifier(!0)), "type" !== r.key.name && this.raise(g.ModuleAttributeDifferentFromType, { at: r.key }), t.has(r.key.name) && this.raise(g.ModuleAttributesWithDuplicateKeys, { at: r.key, key: r.key.name }), t.add(r.key.name), this.expect(14), !this.match(133))) throw this.raise(g.ModuleAttributeInvalidValue, { at: this.state.startLoc });
         (r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, "ImportAttribute"));
        } while (this.eat(12));
        return e;
       }
       maybeParseImportAttributes(e) {
        let t,
         r = !1;
        if (this.match(76)) {
         if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
         this.next(), this.hasPlugin("moduleAttributes") ? (t = this.parseModuleAttributes()) : (this.expectImportAttributesPlugin(), (t = this.parseImportAttributes())), (r = !0);
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin("importAttributes") ? (!0 !== this.getPluginOption("importAttributes", "deprecatedAssertSyntax") && this.raise(g.ImportAttributesUseAssert, { at: this.state.startLoc }), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), (t = this.parseImportAttributes());
        else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) t = [];
        else {
         if (!this.hasPlugin("moduleAttributes")) return;
         t = [];
        }
        !r && this.hasPlugin("importAssertions") ? (e.assertions = t) : (e.attributes = t);
       }
       maybeParseDefaultImportSpecifier(e, t) {
        if (t) {
         let r = this.startNodeAtNode(t);
         return (r.local = t), e.specifiers.push(this.finishImportSpecifier(r, "ImportDefaultSpecifier")), !0;
        }
        return !!V(this.state.type) && (this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0);
       }
       maybeParseStarImportSpecifier(e) {
        if (this.match(55)) {
         let t = this.startNode();
         return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, "ImportNamespaceSpecifier"), !0;
        }
        return !1;
       }
       parseNamedImportSpecifiers(e) {
        let t = !0;
        for (this.expect(5); !this.eat(8); ) {
         if (t) t = !1;
         else {
          if (this.eat(14)) throw this.raise(g.DestructureNamedImport, { at: this.state.startLoc });
          if ((this.expect(12), this.eat(8))) break;
         }
         let r = this.startNode(),
          n = this.match(133),
          s = this.isContextual(130);
         r.imported = this.parseModuleExportName();
         let i = this.parseImportSpecifier(r, n, "type" === e.importKind || "typeof" === e.importKind, s, void 0);
         e.specifiers.push(i);
        }
       }
       parseImportSpecifier(e, t, r, n, s) {
        if (this.eatContextual(93)) e.local = this.parseIdentifier();
        else {
         let { imported: r } = e;
         if (t) throw this.raise(g.ImportBindingIsString, { at: e, importName: r.value });
         this.checkReservedWord(r.name, e.loc.start, !0, !0), e.local || (e.local = ot(r));
        }
        return this.finishImportSpecifier(e, "ImportSpecifier", s);
       }
       isThisParam(e) {
        return "Identifier" === e.type && "this" === e.name;
       }
      },
      Wt = class extends zt {
       constructor(e, t) {
        (e = (function (e) {
         if (null == e) return Object.assign({}, jt);
         if (null != e.annexB && !1 !== e.annexB) throw new Error("The `annexB` option can only be set to `false`.");
         let t = {};
         for (let n of Object.keys(jt)) {
          var r;
          t[n] = null != (r = e[n]) ? r : jt[n];
         }
         return t;
        })(e)),
         super(e, t),
         (this.options = e),
         this.initializeScopes(),
         (this.plugins = (function (e) {
          let t = new Map();
          for (let r of e) {
           let [e, n] = Array.isArray(r) ? r : [r, {}];
           t.has(e) || t.set(e, n || {});
          }
          return t;
         })(this.options.plugins)),
         (this.filename = e.sourceFilename);
       }
       getScopeHandler() {
        return De;
       }
       parse() {
        this.enterInitialScopes();
        let e = this.startNode(),
         t = this.startNode();
        return this.nextToken(), (e.errors = null), this.parseTopLevel(e, t), (e.errors = this.state.errors), e;
       }
      };
     var Ht = (function (e) {
      let t = {};
      for (let r of Object.keys(e)) t[r] = Y(e[r]);
      return t;
     })(U);
     function Jt(e, t) {
      let r = Wt;
      return (
       null != e &&
        e.plugins &&
        ((function (e) {
         if (It(e, "decorators")) {
          if (It(e, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          let t = Nt(e, "decorators", "decoratorsBeforeExport");
          if (null != t && "boolean" != typeof t) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
          let r = Nt(e, "decorators", "allowCallParenthesized");
          if (null != r && "boolean" != typeof r) throw new Error("'allowCallParenthesized' must be a boolean.");
         }
         if (It(e, "flow") && It(e, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
         if (It(e, "placeholders") && It(e, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
         if (It(e, "pipelineOperator")) {
          let t = Nt(e, "pipelineOperator", "proposal");
          if (!Bt.includes(t)) {
           let e = Bt.map((e) => `"${e}"`).join(", ");
           throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e}.`);
          }
          let r = It(e, ["recordAndTuple", { syntaxType: "hash" }]);
          if ("hack" === t) {
           if (It(e, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
           if (It(e, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
           let t = Nt(e, "pipelineOperator", "topicToken");
           if (!_t.includes(t)) {
            let e = _t.map((e) => `"${e}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e}.`);
           }
           if ("#" === t && r) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          } else if ("smart" === t && r) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
         }
         if (It(e, "moduleAttributes")) {
          if (It(e, "importAssertions") || It(e, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
          if ("may-2020" !== Nt(e, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
         }
         if (It(e, "importAssertions") && It(e, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
         if (It(e, "recordAndTuple") && null != Nt(e, "recordAndTuple", "syntaxType") && !Lt.includes(Nt(e, "recordAndTuple", "syntaxType"))) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Lt.map((e) => `'${e}'`).join(", "));
         if (It(e, "asyncDoExpressions") && !It(e, "doExpressions")) {
          let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          throw ((e.missingPlugins = "doExpressions"), e);
         }
         if (It(e, "optionalChainingAssign") && "2023-07" !== Nt(e, "optionalChainingAssign", "version")) throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        })(e.plugins),
        (r = (function (e) {
         let t = Mt.filter((t) => It(e, t)),
          r = t.join("/"),
          n = Kt[r];
         if (!n) {
          n = Wt;
          for (let e of t) n = Ot[e](n);
          Kt[r] = n;
         }
         return n;
        })(e.plugins))),
       new r(e, t)
      );
     }
     var Kt = {};
     (e.parse = function (e, t) {
      var r;
      if ("unambiguous" !== (null == (r = t) ? void 0 : r.sourceType)) return Jt(t, e).parse();
      t = Object.assign({}, t);
      try {
       t.sourceType = "module";
       let r = Jt(t, e),
        n = r.parse();
       if (r.sawUnambiguousESM) return n;
       if (r.ambiguousScriptDifferentAst)
        try {
         return (t.sourceType = "script"), Jt(t, e).parse();
        } catch {}
       else n.program.sourceType = "script";
       return n;
      } catch (n) {
       try {
        return (t.sourceType = "script"), Jt(t, e).parse();
       } catch {}
       throw n;
      }
     }),
      (e.parseExpression = function (e, t) {
       let r = Jt(t, e);
       return r.options.strictMode && (r.state.strict = !0), r.getExpression();
      }),
      (e.tokTypes = Ht);
    }),
    h = l((e) => {
     Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.extract = function (e) {
       let t = e.match(n);
       return t ? t[0].trimLeft() : "";
      }),
      (e.parse = function (e) {
       return p(e).pragmas;
      }),
      (e.parseWithComments = p),
      (e.print = function ({ comments: e = "", pragmas: t = {} }) {
       let r = "\n",
        n = " *",
        s = Object.keys(t),
        i = s
         .flatMap((e) => c(e, t[e]))
         .map((e) => `${n} ${e}${r}`)
         .join("");
       if (!e) {
        if (0 === s.length) return "";
        if (1 === s.length && !Array.isArray(t[s[0]])) {
         let e = t[s[0]];
         return `/** ${c(s[0], e)[0]} */`;
        }
       }
       let a =
        e
         .split(r)
         .map((e) => `${n} ${e}`)
         .join(r) + r;
       return "/**\n" + (e ? a : "") + (e && s.length ? n + r : "") + i + " */";
      }),
      (e.strip = function (e) {
       let t = e.match(n);
       return t && t[0] ? e.substring(t[0].length) : e;
      });
     var t = /\*\/$/,
      r = /^\/\*\*?/,
      n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
      s = /(^|\s+)\/\/([^\r\n]*)/g,
      i = /^(\r?\n)+/,
      a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
      o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
      u = /(\r?\n|^) *\* ?/g,
      l = [];
     function p(e) {
      e = e.replace(r, "").replace(t, "").replace(u, "$1");
      let n = "";
      for (; n !== e; ) (n = e), (e = e.replace(a, "\n$1 $2\n"));
      e = e.replace(i, "").trimRight();
      let p,
       c = Object.create(null),
       h = e.replace(o, "").replace(i, "").trimRight();
      for (; (p = o.exec(e)); ) {
       let e = p[2].replace(s, "");
       "string" == typeof c[p[1]] || Array.isArray(c[p[1]]) ? (c[p[1]] = l.concat(c[p[1]], e)) : (c[p[1]] = e);
      }
      return { comments: h, pragmas: c };
     }
     function c(e, t) {
      return l.concat(t).map((t) => `@${e} ${t}`.trim());
     }
    }),
    d = {};
   ((e, t) => {
    for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
   })(d, { parsers: () => he });
   var f = p(c(), 1);
   function m(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   m(/\s/);
   var y = m(" \t"),
    g = (m(",; \t"), m(/[^\n\r]/));
   var D = function (e, t) {
    if (!1 === t) return !1;
    if ("/" === e.charAt(t) && "*" === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ("*" === e.charAt(r) && "/" === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var x = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ("\r" === e.charAt(t - 1) && "\n" === s) return t - 2;
     if ("\n" === s || "\r" === s || "\u2028" === s || "\u2029" === s) return t - 1;
    } else {
     if ("\r" === s && "\n" === e.charAt(t + 1)) return t + 2;
     if ("\n" === s || "\r" === s || "\u2028" === s || "\u2029" === s) return t + 1;
    }
    return t;
   };
   var b = function (e, t) {
    return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? g(e, t) : t);
   };
   var v = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = y(e, n)), (n = D(e, n)), (n = b(e, n)), (n = x(e, n));
    return n;
   };
   var E = function (e) {
    let t = [];
    for (let n of e)
     try {
      return n();
     } catch (r) {
      t.push(r);
     }
    throw Object.assign(new Error("All combinations failed"), { errors: t });
   };
   var C = function (e) {
     if (!e.startsWith("#!")) return "";
     let t = e.indexOf("\n");
     return -1 === t ? e : e.slice(0, t);
    },
    T = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || "string" == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var w = function (e) {
    return Array.isArray(e) && e.length > 0;
   };
   function S(e) {
    var t, r, n;
    let s = (null == (t = e.range) ? void 0 : t[0]) ?? e.start,
     i = null == (n = (null == (r = e.declaration) ? void 0 : r.decorators) ?? e.decorators) ? void 0 : n[0];
    return i ? Math.min(S(i), s) : s;
   }
   function A(e) {
    var t;
    return (null == (t = e.range) ? void 0 : t[1]) ?? e.end;
   }
   var F = (function (e) {
    let t = new Set(e);
    return (e) => t.has(null == e ? void 0 : e.type);
   })(["Block", "CommentBlock", "MultiLine"]);
   var k = function (e) {
    let t = `*${e.value}*`.split("\n");
    return t.length > 1 && t.every((e) => "*" === e.trimStart()[0]);
   };
   var P = function (e) {
     return F(e) && "*" === e.value[0] && /@(?:type|satisfies)\b/.test(e.value);
    },
    I = null;
   function N(e) {
    if (null !== I && (I.property, 1)) {
     let e = I;
     return (I = N.prototype = null), e;
    }
    return (I = N.prototype = e ?? Object.create(null)), new N();
   }
   for (let fe = 0; fe <= 10; fe++) N();
   var B = (function (e, t = "type") {
    return (
     (function (e) {
      N(e);
     })(e),
     function (r) {
      let n = r[t],
       s = e[n];
      if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
      return s;
     }
    );
   })({ ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] });
   var _ = function e(t, r) {
    if (null === t || "object" != typeof t) return t;
    if (Array.isArray(t)) {
     for (let n = 0; n < t.length; n++) t[n] = e(t[n], r);
     return t;
    }
    let n = B(t);
    for (let s = 0; s < n.length; s++) t[n[s]] = e(t[n[s]], r);
    return r(t) || t;
   };
   function L(e) {
    return "LogicalExpression" === e.type && "LogicalExpression" === e.right.type && e.operator === e.right.operator;
   }
   function O(e) {
    return L(e) ? O({ type: "LogicalExpression", operator: e.operator, left: O({ type: "LogicalExpression", operator: e.operator, left: e.left, right: e.right.left, range: [S(e.left), A(e.right.left)] }), right: e.right.right, range: [S(e), A(e)] }) : e;
   }
   var M = function (e, t) {
    let { parser: r, text: n } = t;
    if ("File" === e.type && e.program.interpreter) {
     let {
      program: { interpreter: t },
      comments: r,
     } = e;
     delete e.program.interpreter, r.unshift(t);
    }
    if ("babel" === r) {
     let t = new Set();
     (e = _(e, (e) => {
      var r;
      null != (r = e.leadingComments) && r.some(P) && t.add(S(e));
     })),
      (e = _(e, (e) => {
       if ("ParenthesizedExpression" === e.type) {
        let { expression: r } = e;
        if ("TypeCastExpression" === r.type) return (r.range = [...e.range]), r;
        let n = S(e);
        if (!t.has(n)) return (r.extra = { ...r.extra, parenthesized: !0 }), r;
       }
      }));
    }
    if (
     ((e = _(e, (t) => {
      var s;
      switch (t.type) {
       case "LogicalExpression":
        if (L(t)) return O(t);
        break;
       case "VariableDeclaration": {
        let e = T(!1, t.declarations, -1);
        null != e && e.init && ";" !== n[A(e)] && (t.range = [S(t), A(e)]);
        break;
       }
       case "TSParenthesizedType":
        return t.typeAnnotation;
       case "TSTypeParameter":
        if ("string" == typeof t.name) {
         let e = S(t);
         t.name = { type: "Identifier", name: t.name, range: [e, e + t.name.length] };
        }
        break;
       case "TopicReference":
        e.extra = { ...e.extra, __isUsingHackPipeline: !0 };
        break;
       case "ExportAllDeclaration":
        if ("meriyah" === r && "Identifier" === (null == (s = t.exported) ? void 0 : s.type)) {
         let { exported: e } = t,
          r = n.slice(S(e), A(e));
         (r.startsWith('"') || r.startsWith("'")) && (t.exported = { ...t.exported, type: "Literal", value: t.exported.name, raw: r });
        }
        break;
       case "TSUnionType":
       case "TSIntersectionType":
        if (1 === t.types.length) return t.types[0];
      }
     })),
     w(e.comments))
    ) {
     let t = T(!1, e.comments, -1);
     for (let r = e.comments.length - 2; r >= 0; r--) {
      let n = e.comments[r];
      A(n) === S(t) && F(n) && F(t) && k(n) && k(t) && (e.comments.splice(r + 1, 1), (n.value += "*//*" + t.value), (n.range = [S(n), A(t)])), (t = n);
     }
    }
    return "Program" === e.type && (e.range = [0, n.length]), e;
   };
   var j = function (e, t) {
    let r = new SyntaxError(e + " (" + t.loc.start.line + ":" + t.loc.start.column + ")");
    return Object.assign(r, t);
   };
   var R = function (e) {
     let {
       message: t,
       loc: { line: r, column: n },
       reasonCode: s,
      } = e,
      i = e;
     ("MissingPlugin" === s || "MissingOneOfPlugins" === s) && ((t = "Unexpected token."), (i = void 0));
     let a = ` (${r}:${n})`;
     return t.endsWith(a) && (t = t.slice(0, -a.length)), j(t, { loc: { start: { line: r, column: n + 1 } }, cause: i });
    },
    q = p(h(), 1);
   function U(e) {
    let { pragmas: t } = (function (e) {
     let t = C(e);
     t && (e = e.slice(t.length + 1));
     let r = (0, q.extract)(e),
      { pragmas: n, comments: s } = (0, q.parseWithComments)(r);
     return { shebang: t, text: e, pragmas: n, comments: s };
    })(e);
    return Object.prototype.hasOwnProperty.call(t, "prettier") || Object.prototype.hasOwnProperty.call(t, "format");
   }
   var $ = function (e) {
    return (e = "function" == typeof e ? { parse: e } : e), { astFormat: "estree", hasPragma: U, locStart: S, locEnd: A, ...e };
   };
   var V = function (e) {
    let { filepath: t } = e;
    if (t) {
     if (((t = t.toLowerCase()), t.endsWith(".cjs"))) return "script";
     if (t.endsWith(".mjs")) return "module";
    }
   };
   var z = function (e, t) {
     let { type: r = "JsExpressionRoot", rootMarker: n, text: s } = t,
      { tokens: i, comments: a } = e;
     return delete e.tokens, delete e.comments, { tokens: i, comments: a, type: r, node: e, range: [0, s.length], rootMarker: n };
    },
    W = (e) =>
     $(
      (function ({ isExpression: e = !1, optionsCombinations: t }) {
       return (r, n = {}) => {
        if (
         ("babel" === n.parser || "__babel_estree" === n.parser) &&
         (function (e, t) {
          var r;
          if (null != (r = t.filepath) && r.endsWith(".js.flow")) return !0;
          let n = C(e);
          n && (e = e.slice(n.length));
          let s = v(e, 0);
          return !1 !== s && (e = e.slice(0, s)), Y.test(e);
         })(r, n)
        )
         return (n.parser = "babel-flow"), se.parse(r, n);
        let s = t;
        "script" === (n.__babelSourceType ?? V(n)) && (s = s.map((e) => ({ ...e, sourceType: "script" }))), /#[[{]/.test(r) && (s = s.map((e) => X([J], e)));
        let i = /%[A-Z]/.test(r);
        r.includes("|>") ? (s = (i ? [...G, K] : G).flatMap((e) => s.map((t) => X([e], t)))) : i && (s = s.map((e) => X([K], e)));
        let a,
         o = e ? f.parseExpression : f.parse;
        try {
         a = E(
          s.map(
           (e) => () =>
            (function (e, t, r) {
             let n = e(t, r),
              s = n.errors.find((e) => !Q.has(e.reasonCode));
             if (s) throw s;
             return n;
            })(o, r, e),
          ),
         );
        } catch ({ errors: [u] }) {
         throw R(u);
        }
        return e && (a = z(a, { text: r, rootMarker: n.rootMarker })), M(a, { parser: "babel", text: r });
       };
      })(e),
     ),
    H = { sourceType: "module", allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: !0 }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }]], tokens: !0, ranges: !0 },
    J = ["recordAndTuple", { syntaxType: "hash" }],
    K = "v8intrinsic",
    G = [
     ["pipelineOperator", { proposal: "hack", topicToken: "%" }],
     ["pipelineOperator", { proposal: "minimal" }],
     ["pipelineOperator", { proposal: "fsharp" }],
    ],
    X = (e, t = H) => ({ ...t, plugins: [...t.plugins, ...e] }),
    Y = /@(?:no)?flow\b/;
   var Q = new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DuplicateAccessibilityModifier", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]),
    Z = [X(["jsx"])],
    ee = W({ optionsCombinations: Z }),
    te = W({ optionsCombinations: [X(["jsx", "typescript"]), X(["typescript"])] }),
    re = W({ isExpression: !0, optionsCombinations: [X(["jsx"])] }),
    ne = W({ isExpression: !0, optionsCombinations: [X(["typescript"])] }),
    se = W({ optionsCombinations: [X(["jsx", ["flow", { all: !0, enums: !0 }], "flowComments"])] }),
    ie = W({ optionsCombinations: Z.map((e) => X(["estree"], e)) }),
    ae = { babel: ee, "babel-flow": se, "babel-ts": te, __js_expression: re, __ts_expression: ne, __vue_expression: re, __vue_ts_expression: ne, __vue_event_binding: ee, __vue_ts_event_binding: te, __babel_estree: ie },
    oe = p(c(), 1);
   function ue(e = {}) {
    let { allowComments: t = !0 } = e;
    return function (e) {
     let r;
     try {
      r = (0, oe.parseExpression)(e, { tokens: !0, ranges: !0, attachComment: !1 });
     } catch (n) {
      throw R(n);
     }
     if (!t && w(r.comments)) throw le(r.comments[0], "Comment");
     return pe(r), z(r, { type: "JsonRoot", text: e });
    };
   }
   function le(e, t) {
    let [r, n] = [e.loc.start, e.loc.end].map(({ line: e, column: t }) => ({ line: e, column: t + 1 }));
    return j(`${t} is not allowed in JSON.`, { loc: { start: r, end: n } });
   }
   function pe(e) {
    switch (e.type) {
     case "ArrayExpression":
      for (let t of e.elements) null !== t && pe(t);
      return;
     case "ObjectExpression":
      for (let t of e.properties) pe(t);
      return;
     case "ObjectProperty":
      if (e.computed) throw le(e.key, "Computed key");
      if (e.shorthand) throw le(e.key, "Shorthand property");
      return "Identifier" !== e.key.type && pe(e.key), void pe(e.value);
     case "UnaryExpression": {
      let { operator: t, argument: r } = e;
      if ("+" !== t && "-" !== t) throw le(e, `Operator '${e.operator}'`);
      if ("NumericLiteral" === r.type || ("Identifier" === r.type && ("Infinity" === r.name || "NaN" === r.name))) return;
      throw le(r, `Operator '${t}' before '${r.type}'`);
     }
     case "Identifier":
      if ("Infinity" !== e.name && "NaN" !== e.name && "undefined" !== e.name) throw le(e, `Identifier '${e.name}'`);
      return;
     case "TemplateLiteral":
      if (w(e.expressions)) throw le(e.expressions[0], "'TemplateLiteral' with expression");
      for (let t of e.quasis) pe(t);
      return;
     case "NullLiteral":
     case "BooleanLiteral":
     case "NumericLiteral":
     case "StringLiteral":
     case "TemplateElement":
      return;
     default:
      throw le(e, `'${e.type}'`);
    }
   }
   var ce = ue(),
    he = { ...ae, ...{ json: $({ parse: ce, hasPragma: () => !0 }), json5: $(ce), jsonc: $(ce), "json-stringify": $({ parse: ue({ allowComments: !1 }), astFormat: "estree-json" }) } },
    de = d;
  },
  59560: (e, t, r) => {
   r.d(t, { ZP: () => _o });
   var n,
    s,
    i = Object.create,
    a = Object.defineProperty,
    o = Object.getOwnPropertyDescriptor,
    u = Object.getOwnPropertyNames,
    l = Object.getPrototypeOf,
    p = Object.prototype.hasOwnProperty,
    c = (e, t) => {
     for (var r in t) a(e, r, { get: t[r], enumerable: !0 });
    },
    h = (e, t, r) => {
     if (!t.has(e)) throw TypeError("Cannot " + r);
    },
    d = (e, t, r) => (h(e, t, "read from private field"), r ? r.call(e) : t.get(e)),
    f =
     ((n = (e) => {
      Object.defineProperty(e, "__esModule", { value: !0 }),
       (e.extract = function (e) {
        let t = e.match(n);
        return t ? t[0].trimLeft() : "";
       }),
       (e.parse = function (e) {
        return p(e).pragmas;
       }),
       (e.parseWithComments = p),
       (e.print = function ({ comments: e = "", pragmas: t = {} }) {
        let r = "\n",
         n = " *",
         s = Object.keys(t),
         i = s
          .flatMap((e) => c(e, t[e]))
          .map((e) => `${n} ${e}${r}`)
          .join("");
        if (!e) {
         if (0 === s.length) return "";
         if (1 === s.length && !Array.isArray(t[s[0]])) {
          let e = t[s[0]];
          return `/** ${c(s[0], e)[0]} */`;
         }
        }
        let a =
         e
          .split(r)
          .map((e) => `${n} ${e}`)
          .join(r) + r;
        return "/**\n" + (e ? a : "") + (e && s.length ? n + r : "") + i + " */";
       }),
       (e.strip = function (e) {
        let t = e.match(n);
        return t && t[0] ? e.substring(t[0].length) : e;
       });
      var t = /\*\/$/,
       r = /^\/\*\*?/,
       n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
       s = /(^|\s+)\/\/([^\r\n]*)/g,
       i = /^(\r?\n)+/,
       a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
       o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
       u = /(\r?\n|^) *\* ?/g,
       l = [];
      function p(e) {
       e = e.replace(r, "").replace(t, "").replace(u, "$1");
       let n = "";
       for (; n !== e; ) (n = e), (e = e.replace(a, "\n$1 $2\n"));
       e = e.replace(i, "").trimRight();
       let p,
        c = Object.create(null),
        h = e.replace(o, "").replace(i, "").trimRight();
       for (; (p = o.exec(e)); ) {
        let e = p[2].replace(s, "");
        "string" == typeof c[p[1]] || Array.isArray(c[p[1]]) ? (c[p[1]] = l.concat(c[p[1]], e)) : (c[p[1]] = e);
       }
       return { comments: h, pragmas: c };
      }
      function c(e, t) {
       return l.concat(t).map((t) => `@${e} ${t}`.trim());
      }
     }),
     () => (s || n((s = { exports: {} }).exports, s), s.exports)),
    m = {};
   c(m, { languages: () => Bo, options: () => Io, printers: () => No });
   var y = {};
   c(y, { canAttachComment: () => Fn, embed: () => ps, experimentalFeatures: () => Eo, getCommentChildNodes: () => kn, getVisitorKeys: () => K, handleComments: () => Pr, insertPragma: () => ds, isBlockComment: () => X, isGap: () => In, massageAstNode: () => Tt, print: () => vo, printComment: () => kr, willPrintOwnComments: () => Pn });
   var g = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    D = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || "string" == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    },
    x = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/,
    b = (e) => x.test(e);
   var v = function (e) {
    return null !== e && "object" == typeof e;
   };
   function* E(e, t) {
    let { getVisitorKeys: r, filter: n = () => !0 } = t,
     s = (e) => v(e) && n(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) s(e) && (yield e);
     else s(t) && (yield t);
    }
   }
   function C(e, { getVisitorKeys: t, predicate: r }) {
    for (let n of (function* (e, t) {
     let r = [e];
     for (let n = 0; n < r.length; n++) {
      let e = r[n];
      for (let n of E(e, t)) yield n, r.push(n);
     }
    })(e, { getVisitorKeys: t }))
     if (r(n)) return !0;
    return !1;
   }
   var T = (e) =>
     !(
      (function (e) {
       return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
      })(e) ||
      (function (e) {
       return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9800 && e <= 9811) || 9855 === e || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12771) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 19903) || (e >= 19968 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || 94192 === e || 94193 === e || (e >= 94208 && e <= 100343) || (e >= 100352 && e <= 101589) || (e >= 101632 && e <= 101640) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128727) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129672) || (e >= 129680 && e <= 129725) || (e >= 129727 && e <= 129733) || (e >= 129742 && e <= 129755) || (e >= 129760 && e <= 129768) || (e >= 129776 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
      })(e)
     ),
    w = /[^\x20-\x7F]/;
   var S = function (e) {
    if (!e) return 0;
    if (!w.test(e)) return e.length;
    e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, "  ");
    let t = 0;
    for (let r of e) {
     let e = r.codePointAt(0);
     e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (t += T(e) ? 1 : 2);
    }
    return t;
   };
   function A(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   A(/\s/);
   var F = A(" \t"),
    k = A(",; \t"),
    P = A(/[^\n\r]/);
   var I = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ("\r" === e.charAt(t - 1) && "\n" === s) return t - 2;
     if ("\n" === s || "\r" === s || "\u2028" === s || "\u2029" === s) return t - 1;
    } else {
     if ("\r" === s && "\n" === e.charAt(t + 1)) return t + 2;
     if ("\n" === s || "\r" === s || "\u2028" === s || "\u2029" === s) return t + 1;
    }
    return t;
   };
   var N = function (e, t, r = {}) {
    let n = F(e, r.backwards ? t - 1 : t, r);
    return n !== I(e, n, r);
   };
   var B = function (e, t) {
    if (!1 === t) return !1;
    if ("/" === e.charAt(t) && "*" === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ("*" === e.charAt(r) && "/" === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var _ = function (e, t) {
    return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? P(e, t) : t);
   };
   var L = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = k(e, n)), (n = B(e, n)), (n = F(e, n));
    return (n = _(e, n)), (n = I(e, n)), !1 !== n && N(e, n);
   };
   var O = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    M = "'";
   var j = function (e, t) {
    let r = !0 === t || t === M ? M : '"',
     n = r === M ? '"' : M,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var R = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = g(!1, e, /\\(.)|(["'])/gs, (e, s, i) => (s === n ? s : i === t ? "\\" + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s) ? s : "\\" + s)));
    return t + s + t;
   };
   var q = function (e, t) {
    let r = e.slice(1, -1),
     n = "json" === t.parser || "jsonc" === t.parser || ("json5" === t.parser && "preserve" === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : j(r, t.singleQuote);
    return R(r, n, !("css" === t.parser || "less" === t.parser || "scss" === t.parser || t.__embeddedInHtml));
   };
   function U(e) {
    var t, r, n;
    let s = (null == (t = e.range) ? void 0 : t[0]) ?? e.start,
     i = null == (n = (null == (r = e.declaration) ? void 0 : r.decorators) ?? e.decorators) ? void 0 : n[0];
    return i ? Math.min(U(i), s) : s;
   }
   function $(e) {
    var t;
    return (null == (t = e.range) ? void 0 : t[1]) ?? e.end;
   }
   function V(e, t) {
    let r = U(e);
    return Number.isInteger(r) && r === U(t);
   }
   function z(e, t) {
    return (
     V(e, t) &&
     (function (e, t) {
      let r = $(e);
      return Number.isInteger(r) && r === $(t);
     })(e, t)
    );
   }
   var W = null;
   function H(e) {
    if (null !== W && (W.property, 1)) {
     let e = W;
     return (W = H.prototype = null), e;
    }
    return (W = H.prototype = e ?? Object.create(null)), new H();
   }
   for (let Lo = 0; Lo <= 10; Lo++) H();
   var J = function (e, t = "type") {
     return (
      (function (e) {
       H(e);
      })(e),
      function (r) {
       let n = r[t],
        s = e[n];
       if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
       return s;
      }
     );
    },
    K = J({ ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] });
   var G = function (e) {
     let t = new Set(e);
     return (e) => t.has(null == e ? void 0 : e.type);
    },
    X = G(["Block", "CommentBlock", "MultiLine"]),
    Y = G(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]);
   var Q = function (e, t) {
    return t.some((t) =>
     (function (e, t) {
      let r = t.split(".");
      for (let n = r.length - 1; n >= 0; n--) {
       let t = r[n];
       if (0 === n) return "Identifier" === e.type && e.name === t;
       if ("MemberExpression" !== e.type || e.optional || e.computed || "Identifier" !== e.property.type || e.property.name !== t) return !1;
       e = e.object;
      }
     })(e, t),
    );
   };
   var Z = function ({ type: e }) {
    return e.startsWith("TS") && e.endsWith("Keyword");
   };
   function ee(e, t) {
    return t(e) || C(e, { getVisitorKeys: K, predicate: t });
   }
   function te(e) {
    return "AssignmentExpression" === e.type || "BinaryExpression" === e.type || "LogicalExpression" === e.type || "NGPipeExpression" === e.type || "ConditionalExpression" === e.type || Fe(e) || ke(e) || "SequenceExpression" === e.type || "TaggedTemplateExpression" === e.type || "BindExpression" === e.type || ("UpdateExpression" === e.type && !e.prefix) || Dt(e) || "TSNonNullExpression" === e.type || "ChainExpression" === e.type;
   }
   function re(e) {
    return e.expressions ? e.expressions[0] : e.left ?? e.test ?? e.callee ?? e.object ?? e.tag ?? e.argument ?? e.expression;
   }
   function ne(e) {
    if (e.expressions) return ["expressions", 0];
    if (e.left) return ["left"];
    if (e.test) return ["test"];
    if (e.object) return ["object"];
    if (e.callee) return ["callee"];
    if (e.tag) return ["tag"];
    if (e.argument) return ["argument"];
    if (e.expression) return ["expression"];
    throw new Error("Unexpected node has no left side.");
   }
   var se = G(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]),
    ie = G(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]),
    ae = G(["ArrayExpression", "TupleExpression"]),
    oe = G(["ObjectExpression", "RecordExpression"]);
   function ue(e) {
    return "NumericLiteral" === e.type || ("Literal" === e.type && "number" == typeof e.value);
   }
   function le(e) {
    return "UnaryExpression" === e.type && ("+" === e.operator || "-" === e.operator) && ue(e.argument);
   }
   function pe(e) {
    return "StringLiteral" === e.type || ("Literal" === e.type && "string" == typeof e.value);
   }
   function ce(e) {
    return "RegExpLiteral" === e.type || ("Literal" === e.type && !!e.regex);
   }
   var he = G(["Literal", "BooleanLiteral", "BigIntLiteral", "DecimalLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]),
    de = G(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier", "Import"]),
    fe = G(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]),
    me = G(["FunctionExpression", "ArrowFunctionExpression"]);
   function ye(e) {
    return Fe(e) && "Identifier" === e.callee.type && ["async", "inject", "fakeAsync", "waitForAsync"].includes(e.callee.name);
   }
   var ge = G(["JSXElement", "JSXFragment"]);
   function De(e) {
    return "get" === e.kind || "set" === e.kind;
   }
   function xe(e) {
    return De(e) || V(e, e.value);
   }
   function be(e) {
    return !(("ObjectTypeProperty" !== e.type && "ObjectTypeInternalSlot" !== e.type) || "FunctionTypeAnnotation" !== e.value.type || e.static || xe(e));
   }
   var ve = G(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
   function Ee(e) {
    return ke(e) || ("BindExpression" === e.type && !!e.object);
   }
   var Ce = G(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
   function Te(e) {
    return Z(e) || Y(e) || Ce(e) || (("GenericTypeAnnotation" === e.type || "TSTypeReference" === e.type) && !e.typeParameters);
   }
   var we = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
   function Se(e, t) {
    if ("CallExpression" !== e.type) return !1;
    if (1 === e.arguments.length) {
     if (ye(e) && t && Se(t)) return me(e.arguments[0]);
     if (
      (function (e) {
       return "Identifier" === e.callee.type && 1 === e.arguments.length && /^(?:before|after)(?:Each|All)$/.test(e.callee.name);
      })(e)
     )
      return ye(e.arguments[0]);
    } else if (
     (2 === e.arguments.length || 3 === e.arguments.length) &&
     ("TemplateLiteral" === e.arguments[0].type || pe(e.arguments[0])) &&
     (function (e) {
      return Q(e, we);
     })(e.callee)
    )
     return (
      !(e.arguments[2] && !ue(e.arguments[2])) &&
      ((2 === e.arguments.length
       ? me(e.arguments[1])
       : (function (e) {
          return "FunctionExpression" === e.type || ("ArrowFunctionExpression" === e.type && "BlockStatement" === e.body.type);
         })(e.arguments[1]) && st(e.arguments[1]).length <= 1) ||
       ye(e.arguments[1]))
     );
    return !1;
   }
   var Ae = (e) => (t) => ("ChainExpression" === (null == t ? void 0 : t.type) && (t = t.expression), e(t)),
    Fe = Ae(G(["CallExpression", "OptionalCallExpression"])),
    ke = Ae(G(["MemberExpression", "OptionalMemberExpression"]));
   function Pe(e) {
    let t = "expressions";
    "TSTemplateLiteralType" === e.type && (t = "types");
    let r = e[t];
    return (
     0 !== r.length &&
     r.every((e) => {
      if (Ne(e) || Ie(e)) return !0;
     })
    );
   }
   function Ie(e, { maxDepth: t = Number.POSITIVE_INFINITY } = {}) {
    if (dt(e)) return !1;
    if ("ChainExpression" === e.type) return Ie(e.expression, { maxDepth: t });
    if (!ke(e)) return !1;
    let r = e,
     n = 0;
    for (; ke(r) && n++ <= t; ) if (!Ne(r.property) || ((r = r.object), dt(r))) return !1;
    return Ne(r);
   }
   function Ne(e) {
    return !dt(e) && (he(e) || de(e));
   }
   function Be(e, t = 5) {
    return _e(e, t) <= t;
   }
   function _e(e, t) {
    let r = 0;
    for (let n in e) {
     let s = e[n];
     if ((s && "object" == typeof s && "string" == typeof s.type && (r++, (r += _e(s, t - r))), r > t)) return r;
    }
    return r;
   }
   var Le = 0.25;
   function Oe(e, t) {
    let { printWidth: r } = t;
    if (dt(e)) return !1;
    let n = r * Le;
    if ("ThisExpression" === e.type || ("Identifier" === e.type && e.name.length <= n) || (le(e) && !dt(e.argument))) return !0;
    let s = ("Literal" === e.type && "regex" in e && e.regex.pattern) || ("RegExpLiteral" === e.type && e.pattern);
    return s ? s.length <= n : pe(e) ? q(He(e), t).length <= n : "TemplateLiteral" === e.type ? 0 === e.expressions.length && e.quasis[0].value.raw.length <= n && !e.quasis[0].value.raw.includes("\n") : "UnaryExpression" === e.type ? Oe(e.argument, { printWidth: r }) : "CallExpression" === e.type && 0 === e.arguments.length && "Identifier" === e.callee.type ? e.callee.name.length <= n - 2 : he(e);
   }
   function Me(e, t) {
    return ge(t) ? pt(t) : dt(t, ct.Leading, (t) => N(e, $(t)));
   }
   function je(e, t) {
    return "json" !== t.parser && "jsonc" !== t.parser && pe(e.key) && He(e.key).slice(1, -1) === e.key.value && ((b(e.key.value) && !(("babel-ts" === t.parser && "ClassProperty" === e.type) || ("typescript" === t.parser && "PropertyDefinition" === e.type))) || (Re(e.key.value) && String(Number(e.key.value)) === e.key.value && ("babel" === t.parser || "acorn" === t.parser || "espree" === t.parser || "meriyah" === t.parser || "__babel_estree" === t.parser)));
   }
   function Re(e) {
    return /^(?:\d+|\d+\.\d+)$/.test(e);
   }
   function qe(e) {
    return e.quasis.some((e) => e.value.raw.includes("\n"));
   }
   function Ue(e, t) {
    return (("TemplateLiteral" === e.type && qe(e)) || ("TaggedTemplateExpression" === e.type && qe(e.quasi))) && !N(t, U(e), { backwards: !0 });
   }
   function $e(e) {
    if (!dt(e)) return !1;
    let t = D(!1, ft(e, ct.Dangling), -1);
    return t && !X(t);
   }
   function Ve(e) {
    let { node: t, parent: r, key: n } = e;
    return "callee" === n && Fe(t) && Fe(r) && r.arguments.length > 0 && t.arguments.length > r.arguments.length;
   }
   var ze = new Set(["!", "-", "+", "~"]);
   function We(e, t = 2) {
    if (t <= 0) return !1;
    if ("ChainExpression" === e.type || "TSNonNullExpression" === e.type) return We(e.expression, t);
    let r = (e) => We(e, t - 1);
    if (ce(e)) return S(e.pattern ?? e.regex.pattern) <= 5;
    if (he(e) || de(e) || "ArgumentPlaceholder" === e.type) return !0;
    if ("TemplateLiteral" === e.type) return e.quasis.every((e) => !e.value.raw.includes("\n")) && e.expressions.every(r);
    if (oe(e)) return e.properties.every((e) => !e.computed && (e.shorthand || (e.value && r(e.value))));
    if (ae(e)) return e.elements.every((e) => null === e || r(e));
    if (yt(e)) {
     if ("ImportExpression" === e.type || We(e.callee, t)) {
      let n = at(e);
      return n.length <= t && n.every(r);
     }
     return !1;
    }
    return ke(e) ? We(e.object, t) && We(e.property, t) : !!(("UnaryExpression" === e.type && ze.has(e.operator)) || "UpdateExpression" === e.type) && We(e.argument, t);
   }
   function He(e) {
    var t;
    return (null == (t = e.extra) ? void 0 : t.raw) ?? e.raw;
   }
   function Je(e) {
    return e;
   }
   function Ke(e, t = "es5") {
    return ("es5" === e.trailingComma && "es5" === t) || ("all" === e.trailingComma && ("all" === t || "es5" === t));
   }
   function Ge(e, t) {
    switch (e.type) {
     case "BinaryExpression":
     case "LogicalExpression":
     case "AssignmentExpression":
     case "NGPipeExpression":
      return Ge(e.left, t);
     case "MemberExpression":
     case "OptionalMemberExpression":
      return Ge(e.object, t);
     case "TaggedTemplateExpression":
      return "FunctionExpression" !== e.tag.type && Ge(e.tag, t);
     case "CallExpression":
     case "OptionalCallExpression":
      return "FunctionExpression" !== e.callee.type && Ge(e.callee, t);
     case "ConditionalExpression":
      return Ge(e.test, t);
     case "UpdateExpression":
      return !e.prefix && Ge(e.argument, t);
     case "BindExpression":
      return e.object && Ge(e.object, t);
     case "SequenceExpression":
      return Ge(e.expressions[0], t);
     case "ChainExpression":
     case "TSSatisfiesExpression":
     case "TSAsExpression":
     case "TSNonNullExpression":
     case "AsExpression":
     case "AsConstExpression":
     case "SatisfiesExpression":
      return Ge(e.expression, t);
     default:
      return t(e);
    }
   }
   var Xe = { "==": !0, "!=": !0, "===": !0, "!==": !0 },
    Ye = { "*": !0, "/": !0, "%": !0 },
    Qe = { ">>": !0, ">>>": !0, "<<": !0 };
   function Ze(e, t) {
    return !(tt(t) !== tt(e) || "**" === e || (Xe[e] && Xe[t]) || ("%" === t && Ye[e]) || ("%" === e && Ye[t]) || (t !== e && Ye[t] && Ye[e]) || (Qe[e] && Qe[t]));
   }
   var et = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((e, t) => e.map((e) => [e, t])));
   function tt(e) {
    return et.get(e);
   }
   function rt(e) {
    var t;
    if (e.rest) return !0;
    let r = st(e);
    return "RestElement" === (null == (t = D(!1, r, -1)) ? void 0 : t.type);
   }
   var nt = new WeakMap();
   function st(e) {
    if (nt.has(e)) return nt.get(e);
    let t = [];
    return e.this && t.push(e.this), Array.isArray(e.parameters) ? t.push(...e.parameters) : Array.isArray(e.params) && t.push(...e.params), e.rest && t.push(e.rest), nt.set(e, t), t;
   }
   var it = new WeakMap();
   function at(e) {
    if (it.has(e)) return it.get(e);
    if ("ChainExpression" === e.type) return at(e.expression);
    let t = e.arguments;
    return "ImportExpression" === e.type && ((t = [e.source]), e.attributes && t.push(e.attributes), e.options && t.push(e.options)), it.set(e, t), t;
   }
   function ot(e, t) {
    let { node: r } = e;
    if ("ChainExpression" === r.type) return e.call(() => ot(e, t), "expression");
    "ImportExpression" === r.type ? (e.call((e) => t(e, 0), "source"), r.attributes && e.call((e) => t(e, 1), "attributes"), r.options && e.call((e) => t(e, 1), "options")) : e.each(t, "arguments");
   }
   function ut(e, t) {
    let r = [];
    if (("ChainExpression" === e.type && r.push("expression"), "ImportExpression" === e.type)) {
     if (0 === t || t === (e.attributes || e.options ? -2 : -1)) return [...r, "source"];
     if (e.attributes && (1 === t || -1 === t)) return [...r, "attributes"];
     if (e.options && (1 === t || -1 === t)) return [...r, "options"];
     throw new RangeError("Invalid argument index");
    }
    if ((t < 0 && (t = e.arguments.length + t), t < 0 || t >= e.arguments.length)) throw new RangeError("Invalid argument index");
    return [...r, "arguments", t];
   }
   function lt(e) {
    return "prettier-ignore" === e.value.trim() && !e.unignore;
   }
   function pt(e) {
    return (null == e ? void 0 : e.prettierIgnore) || dt(e, ct.PrettierIgnore);
   }
   var ct = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 },
    ht = (e, t) => {
     if (("function" == typeof e && ((t = e), (e = 0)), e || t)) return (r, n, s) => !((e & ct.Leading && !r.leading) || (e & ct.Trailing && !r.trailing) || (e & ct.Dangling && (r.leading || r.trailing)) || (e & ct.Block && !X(r)) || (e & ct.Line && !se(r)) || (e & ct.First && 0 !== n) || (e & ct.Last && n !== s.length - 1) || (e & ct.PrettierIgnore && !lt(r)) || (t && !t(r)));
    };
   function dt(e, t, r) {
    if (!O(null == e ? void 0 : e.comments)) return !1;
    let n = ht(t, r);
    return !n || e.comments.some(n);
   }
   function ft(e, t, r) {
    if (!Array.isArray(null == e ? void 0 : e.comments)) return [];
    let n = ht(t, r);
    return n ? e.comments.filter(n) : e.comments;
   }
   var mt = (e, { originalText: t }) => L(t, $(e));
   function yt(e) {
    return Fe(e) || "NewExpression" === e.type || "ImportExpression" === e.type;
   }
   function gt(e) {
    return e && ("ObjectProperty" === e.type || ("Property" === e.type && !e.method && "init" === e.kind));
   }
   var Dt = G(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]),
    xt = G(["UnionTypeAnnotation", "TSUnionType"]),
    bt = G(["IntersectionTypeAnnotation", "TSIntersectionType"]),
    vt = new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]),
    Et = (e) => {
     for (let t of e.quasis) delete t.value;
    };
   function Ct(e, t, r) {
    var n, s;
    if (("Program" === e.type && delete t.sourceType, ("BigIntLiteral" === e.type || "BigIntLiteralTypeAnnotation" === e.type) && t.value && (t.value = t.value.toLowerCase()), ("BigIntLiteral" === e.type || "Literal" === e.type) && t.bigint && (t.bigint = t.bigint.toLowerCase()), "DecimalLiteral" === e.type && (t.value = Number(t.value)), "Literal" === e.type && t.decimal && (t.decimal = Number(t.decimal)), "EmptyStatement" === e.type || "JSXText" === e.type || ("JSXExpressionContainer" === e.type && ("Literal" === e.expression.type || "StringLiteral" === e.expression.type) && " " === e.expression.value))) return null;
    if ((("Property" === e.type || "ObjectProperty" === e.type || "MethodDefinition" === e.type || "ClassProperty" === e.type || "ClassMethod" === e.type || "PropertyDefinition" === e.type || "TSDeclareMethod" === e.type || "TSPropertySignature" === e.type || "ObjectTypeProperty" === e.type) && "object" == typeof e.key && e.key && ("Literal" === e.key.type || "NumericLiteral" === e.key.type || "StringLiteral" === e.key.type || "Identifier" === e.key.type) && delete t.key, "JSXElement" === e.type && "style" === e.openingElement.name.name && e.openingElement.attributes.some((e) => "JSXAttribute" === e.type && "jsx" === e.name.name))) for (let { type: a, expression: o } of t.children) "JSXExpressionContainer" === a && "TemplateLiteral" === o.type && Et(o);
    "JSXAttribute" === e.type && "css" === e.name.name && "JSXExpressionContainer" === e.value.type && "TemplateLiteral" === e.value.expression.type && Et(t.value.expression), "JSXAttribute" === e.type && "Literal" === (null == (n = e.value) ? void 0 : n.type) && /["']|&quot;|&apos;/.test(e.value.value) && (t.value.value = g(!1, t.value.value, /["']|&quot;|&apos;/g, '"'));
    let i = e.expression || e.callee;
    if ("Decorator" === e.type && "CallExpression" === i.type && "Component" === i.callee.name && 1 === i.arguments.length) {
     let r = e.expression.arguments[0].properties;
     for (let [e, n] of t.expression.arguments[0].properties.entries())
      switch (r[e].key.name) {
       case "styles":
        ae(n.value) && Et(n.value.elements[0]);
        break;
       case "template":
        "TemplateLiteral" === n.value.type && Et(n.value);
      }
    }
    if (("TaggedTemplateExpression" === e.type && ("MemberExpression" === e.tag.type || ("Identifier" === e.tag.type && ("gql" === e.tag.name || "graphql" === e.tag.name || "css" === e.tag.name || "md" === e.tag.name || "markdown" === e.tag.name || "html" === e.tag.name)) || "CallExpression" === e.tag.type) && Et(t.quasi), "TemplateLiteral" === e.type && ((null != (s = e.leadingComments) && s.some((e) => X(e) && ["GraphQL", "HTML"].some((t) => e.value === ` ${t} `))) || ("CallExpression" === r.type && "graphql" === r.callee.name) || !e.leadingComments) && Et(t), ("TSIntersectionType" === e.type || "TSUnionType" === e.type) && 1 === e.types.length)) return t.types[0];
    "ChainExpression" === e.type && "TSNonNullExpression" === e.expression.type && ([t.type, t.expression.type] = [t.expression.type, t.type]);
   }
   Ct.ignoredProperties = vt;
   var Tt = Ct,
    wt = "string",
    St = "array",
    At = "cursor",
    Ft = "indent",
    kt = "align",
    Pt = "trim",
    It = "group",
    Nt = "fill",
    Bt = "if-break",
    _t = "indent-if-break",
    Lt = "line-suffix",
    Ot = "line-suffix-boundary",
    Mt = "line",
    jt = "label",
    Rt = "break-parent",
    qt = new Set([At, Ft, kt, Pt, It, Nt, Bt, _t, Lt, Ot, Mt, jt, Rt]);
   var Ut = function (e) {
    if ("string" == typeof e) return wt;
    if (Array.isArray(e)) return St;
    if (!e) return;
    let { type: t } = e;
    return qt.has(t) ? t : void 0;
   };
   function $t(e) {
    let t = null === e ? "null" : typeof e;
    if ("string" !== t && "object" !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (Ut(e)) throw new Error("doc is valid.");
    let r = Object.prototype.toString.call(e);
    if ("[object Object]" !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e))([...qt].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var Vt = class extends Error {
     name = "InvalidDocError";
     constructor(e) {
      super($t(e)), (this.doc = e);
     }
    },
    zt = Vt,
    Wt = {};
   var Ht = function (e, t, r, n) {
     let s = [e];
     for (; s.length > 0; ) {
      let e = s.pop();
      if (e === Wt) {
       r(s.pop());
       continue;
      }
      r && s.push(e, Wt);
      let i = Ut(e);
      if (!i) throw new zt(e);
      if (!1 !== (null == t ? void 0 : t(e)))
       switch (i) {
        case St:
        case Nt: {
         let t = i === St ? e : e.parts;
         for (let e = t.length - 1; e >= 0; --e) s.push(t[e]);
         break;
        }
        case Bt:
         s.push(e.flatContents, e.breakContents);
         break;
        case It:
         if (n && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) s.push(e.expandedStates[t]);
         else s.push(e.contents);
         break;
        case kt:
        case Ft:
        case _t:
        case jt:
        case Lt:
         s.push(e.contents);
         break;
        case wt:
        case At:
        case Pt:
        case Ot:
        case Mt:
        case Rt:
         break;
        default:
         throw new zt(e);
       }
     }
    },
    Jt = () => {},
    Kt = Jt,
    Gt = Jt;
   function Xt(e) {
    return Kt(e), { type: Ft, contents: e };
   }
   function Yt(e, t) {
    return Kt(t), { type: kt, contents: t, n: e };
   }
   function Qt(e, t = {}) {
    return Kt(e), Gt(t.expandedStates, !0), { type: It, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function Zt(e) {
    return Yt(Number.NEGATIVE_INFINITY, e);
   }
   function er(e) {
    return Yt(-1, e);
   }
   function tr(e, t) {
    return Qt(e[0], { ...t, expandedStates: e });
   }
   function rr(e) {
    return Gt(e), { type: Nt, parts: e };
   }
   function nr(e, t = "", r = {}) {
    return Kt(e), "" !== t && Kt(t), { type: Bt, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   function sr(e, t) {
    return Kt(e), { type: _t, contents: e, groupId: t.groupId, negate: t.negate };
   }
   function ir(e) {
    return Kt(e), { type: Lt, contents: e };
   }
   var ar = { type: Ot },
    or = { type: Rt },
    ur = { type: Mt, hard: !0 },
    lr = { type: Mt },
    pr = { type: Mt, soft: !0 },
    cr = [ur, or],
    hr = [{ type: Mt, hard: !0, literal: !0 }, or],
    dr = { type: At };
   function fr(e, t) {
    Kt(e), Gt(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   function mr(e, t) {
    return Kt(t), e ? { type: jt, label: e, contents: t } : t;
   }
   var yr = (e) => {
    if (Array.isArray(e)) return e;
    if (e.type !== Nt) throw new Error(`Expect doc to be 'array' or '${Nt}'.`);
    return e.parts;
   };
   function gr(e, t) {
    if ("string" == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (Ut(e)) {
       case St:
        return t(e.map(n));
       case Nt:
        return t({ ...e, parts: e.parts.map(n) });
       case Bt:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case It: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case kt:
       case Ft:
       case _t:
       case jt:
       case Lt:
        return t({ ...e, contents: n(e.contents) });
       case wt:
       case At:
       case Pt:
       case Ot:
       case Mt:
       case Rt:
        return t(e);
       default:
        throw new zt(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function Dr(e, t, r) {
    let n = r,
     s = !1;
    return (
     Ht(e, function (e) {
      if (s) return !1;
      let r = t(e);
      void 0 !== r && ((s = !0), (n = r));
     }),
     n
    );
   }
   function xr(e) {
    if ((e.type === It && e.break) || (e.type === Mt && e.hard) || e.type === Rt) return !0;
   }
   function br(e) {
    return Dr(e, xr, !1);
   }
   function vr(e) {
    if (e.length > 0) {
     let t = D(!1, e, -1);
     !t.expandedStates && !t.break && (t.break = "propagated");
    }
    return null;
   }
   function Er(e) {
    return e.type !== Mt || e.hard ? (e.type === Bt ? e.flatContents : e) : e.soft ? "" : " ";
   }
   function Cr(e) {
    return gr(e, Er);
   }
   function Tr(e) {
    return gr(e, (e) =>
     (function (e) {
      switch (Ut(e)) {
       case Nt:
        if (e.parts.every((e) => "" === e)) return "";
        break;
       case It:
        if (!(e.contents || e.id || e.break || e.expandedStates)) return "";
        if (e.contents.type === It && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
        break;
       case kt:
       case Ft:
       case _t:
       case Lt:
        if (!e.contents) return "";
        break;
       case Bt:
        if (!e.flatContents && !e.breakContents) return "";
        break;
       case St: {
        let t = [];
        for (let r of e) {
         if (!r) continue;
         let [e, ...n] = Array.isArray(r) ? r : [r];
         "string" == typeof e && "string" == typeof D(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...n);
        }
        return 0 === t.length ? "" : 1 === t.length ? t[0] : t;
       }
       case wt:
       case At:
       case Pt:
       case Ot:
       case Mt:
       case jt:
       case Rt:
        break;
       default:
        throw new zt(e);
      }
      return e;
     })(e),
    );
   }
   function wr(e, t = hr) {
    return gr(e, (e) => ("string" == typeof e ? fr(t, e.split("\n")) : e));
   }
   function Sr(e) {
    if (e.type === Mt) return !0;
   }
   function Ar(e, t) {
    return e.type === jt ? { ...e, contents: t(e.contents) } : t(e);
   }
   var Fr = function (e) {
    let t = `*${e.value}*`.split("\n");
    return t.length > 1 && t.every((e) => "*" === e.trimStart()[0]);
   };
   function kr(e, t) {
    let r = e.node;
    if (se(r)) return t.originalText.slice(U(r), $(r)).trimEnd();
    if (X(r))
     return Fr(r)
      ? (function (e) {
         let t = e.value.split("\n");
         return [
          "/*",
          fr(
           cr,
           t.map((e, r) => (0 === r ? e.trimEnd() : " " + (r < t.length - 1 ? e.trim() : e.trimStart()))),
          ),
          "*/",
         ];
        })(r)
      : ["/*", wr(r.value), "*/"];
    throw new Error("Not a comment: " + JSON.stringify(r));
   }
   var Pr = {};
   function Ir(e, t) {
    (e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || "(unknown type)",
       r = String(e.name || (e.id && ("object" == typeof e.id ? e.id.name : e.id)) || (e.key && ("object" == typeof e.key ? e.key.name : e.key)) || (e.value && ("object" == typeof e.value ? "" : String(e.value))) || e.operator || "");
      return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t + (r ? " " + r : "");
     })(e));
   }
   function Nr(e, t) {
    (t.leading = !0), (t.trailing = !1), Ir(e, t);
   }
   function Br(e, t, r) {
    (t.leading = !1), (t.trailing = !1), r && (t.marker = r), Ir(e, t);
   }
   function _r(e, t) {
    (t.leading = !1), (t.trailing = !0), Ir(e, t);
   }
   c(Pr, { endOfLine: () => qr, ownLine: () => Rr, remaining: () => Ur });
   var Lr = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = F(e, n)), (n = B(e, n)), (n = _(e, n)), (n = I(e, n));
    return n;
   };
   var Or = function (e, t) {
    let r = Lr(e, t);
    return !1 === r ? "" : e.charAt(r);
   };
   var Mr = function (e, t, r) {
    for (let n = t; n < r; ++n) if ("\n" === e.charAt(n)) return !0;
    return !1;
   };
   var jr = function (e) {
    return X(e) && "*" === e.value[0] && /@(?:type|satisfies)\b/.test(e.value);
   };
   function Rr(e) {
    return [vn, Xr, on, Kr, Wr, Hr, Jr, Zr, fn, cn, dn, mn, yn, tn, un, ln, Gr, wn].some((t) => t(e));
   }
   function qr(e) {
    return [zr, on, Xr, mn, Wr, Hr, Jr, Zr, un, pn, hn, dn, xn, ln, Cn, Tn].some((t) => t(e));
   }
   function Ur(e) {
    return [vn, Wr, Hr, Yr, an, tn, dn, sn, nn, En, ln, bn].some((t) => t(e));
   }
   function $r(e, t) {
    let r = (e.body || e.properties).find(({ type: e }) => "EmptyStatement" !== e);
    r ? Nr(r, t) : Br(e, t);
   }
   function Vr(e, t) {
    "BlockStatement" === e.type ? $r(e, t) : Nr(e, t);
   }
   function zr({ comment: e, followingNode: t }) {
    return !(!t || !jr(e)) && (Nr(t, e), !0);
   }
   function Wr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    if ("IfStatement" !== (null == r ? void 0 : r.type) || !n) return !1;
    if (")" === Or(s, $(e))) return _r(t, e), !0;
    if (t === r.consequent && n === r.alternate) {
     if ("BlockStatement" === t.type) _r(t, e);
     else {
      let n = se(e) || e.loc.start.line === e.loc.end.line,
       s = e.loc.start.line === t.loc.start.line;
      n && s ? _r(t, e) : Br(r, e);
     }
     return !0;
    }
    return "BlockStatement" === n.type ? ($r(n, e), !0) : "IfStatement" === n.type ? (Vr(n.consequent, e), !0) : r.consequent === n && (Nr(n, e), !0);
   }
   function Hr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    return !("WhileStatement" !== (null == r ? void 0 : r.type) || !n) && (")" === Or(s, $(e)) ? (_r(t, e), !0) : "BlockStatement" === n.type ? ($r(n, e), !0) : r.body === n && (Nr(n, e), !0));
   }
   function Jr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return !(("TryStatement" !== (null == r ? void 0 : r.type) && "CatchClause" !== (null == r ? void 0 : r.type)) || !n) && ("CatchClause" === r.type && t ? (_r(t, e), !0) : "BlockStatement" === n.type ? ($r(n, e), !0) : "TryStatement" === n.type ? (Vr(n.finalizer, e), !0) : "CatchClause" === n.type && (Vr(n.body, e), !0));
   }
   function Kr({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!ke(t) || "Identifier" !== (null == r ? void 0 : r.type)) && (Nr(t, e), !0);
   }
   function Gr({ comment: e, enclosingNode: t, followingNode: r, options: n }) {
    return !(!n.experimentalTernaries || ("ConditionalExpression" !== (null == t ? void 0 : t.type) && "ConditionalTypeAnnotation" !== (null == t ? void 0 : t.type) && "TSConditionalType" !== (null == t ? void 0 : t.type))) && ("ConditionalExpression" === (null == r ? void 0 : r.type) || "ConditionalTypeAnnotation" === (null == r ? void 0 : r.type) || "TSConditionalType" === (null == r ? void 0 : r.type)) && (Br(t, e), !0);
   }
   function Xr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s, options: i }) {
    let a = t && !Mr(s, $(t), U(e));
    return !((t && a) || ("ConditionalExpression" !== (null == r ? void 0 : r.type) && "ConditionalTypeAnnotation" !== (null == r ? void 0 : r.type) && "TSConditionalType" !== (null == r ? void 0 : r.type)) || !n) && (!i.experimentalTernaries || r.alternate !== n || (X(e) && !Mr(i.originalText, U(e), $(e))) ? (Nr(n, e), !0) : (Br(r, e), !0));
   }
   function Yr({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !(!gt(r) || !r.shorthand || r.key !== t || "AssignmentPattern" !== r.value.type) && (_r(r.value.left, e), !0);
   }
   var Qr = new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
   function Zr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    if (Qr.has(null == r ? void 0 : r.type)) {
     if (O(r.decorators) && "Decorator" !== (null == n ? void 0 : n.type)) return _r(D(!1, r.decorators, -1), e), !0;
     if (r.body && n === r.body) return $r(r.body, e), !0;
     if (n) {
      if (r.superClass && n === r.superClass && t && (t === r.id || t === r.typeParameters)) return _r(t, e), !0;
      for (let s of ["implements", "extends", "mixins"]) if (r[s] && n === r[s][0]) return !t || (t !== r.id && t !== r.typeParameters && t !== r.superClass) ? Br(r, e, s) : _r(t, e), !0;
     }
    }
    return !1;
   }
   var en = new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
   function tn({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    return ((r && t && "(" === Or(n, $(e)) && ("Property" === r.type || "TSDeclareMethod" === r.type || "TSAbstractMethodDefinition" === r.type) && "Identifier" === t.type && r.key === t && ":" !== Or(n, $(t))) || !("Decorator" !== (null == t ? void 0 : t.type) || !en.has(null == r ? void 0 : r.type))) && (_r(t, e), !0);
   }
   var rn = new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
   function nn({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    return "(" === Or(n, $(e)) && !(!t || !rn.has(null == r ? void 0 : r.type)) && (_r(t, e), !0);
   }
   function sn({ comment: e, enclosingNode: t, text: r }) {
    if ("ArrowFunctionExpression" !== (null == t ? void 0 : t.type)) return !1;
    let n = Lr(r, $(e));
    return !1 !== n && "=>" === r.slice(n, n + 2) && (Br(t, e), !0);
   }
   function an({ comment: e, enclosingNode: t, text: r }) {
    return ")" === Or(r, $(e)) && (t && ((Sn(t) && 0 === st(t).length) || (yt(t) && 0 === at(t).length)) ? (Br(t, e), !0) : ("MethodDefinition" === (null == t ? void 0 : t.type) || "TSAbstractMethodDefinition" === (null == t ? void 0 : t.type)) && 0 === st(t.value).length && (Br(t.value, e), !0));
   }
   function on({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    return "FunctionTypeParam" === (null == t ? void 0 : t.type) && "FunctionTypeAnnotation" === (null == r ? void 0 : r.type) && "FunctionTypeParam" !== (null == n ? void 0 : n.type) ? (_r(t, e), !0) : ("Identifier" !== (null == t ? void 0 : t.type) && "AssignmentPattern" !== (null == t ? void 0 : t.type) && "ObjectPattern" !== (null == t ? void 0 : t.type) && "ArrayPattern" !== (null == t ? void 0 : t.type) && "RestElement" !== (null == t ? void 0 : t.type) && "TSParameterProperty" !== (null == t ? void 0 : t.type)) || !Sn(r) || ")" !== Or(s, $(e)) ? !(X(e) || ("FunctionDeclaration" !== (null == r ? void 0 : r.type) && "FunctionExpression" !== (null == r ? void 0 : r.type) && "ObjectMethod" !== (null == r ? void 0 : r.type)) || "BlockStatement" !== (null == n ? void 0 : n.type) || r.body !== n || Lr(s, $(e)) !== U(n)) && ($r(n, e), !0) : (_r(t, e), !0);
   }
   function un({ comment: e, enclosingNode: t }) {
    return "LabeledStatement" === (null == t ? void 0 : t.type) && (Nr(t, e), !0);
   }
   function ln({ comment: e, enclosingNode: t }) {
    return !(("ContinueStatement" !== (null == t ? void 0 : t.type) && "BreakStatement" !== (null == t ? void 0 : t.type)) || t.label) && (_r(t, e), !0);
   }
   function pn({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !!(Fe(r) && t && r.callee === t && r.arguments.length > 0) && (Nr(r.arguments[0], e), !0);
   }
   function cn({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return xt(r) ? (lt(e) && ((n.prettierIgnore = !0), (e.unignore = !0)), !!t && (_r(t, e), !0)) : (xt(n) && lt(e) && ((n.types[0].prettierIgnore = !0), (e.unignore = !0)), !1);
   }
   function hn({ comment: e, enclosingNode: t }) {
    return !!gt(t) && (Nr(t, e), !0);
   }
   function dn({ comment: e, enclosingNode: t, followingNode: r, ast: n, isLastComment: s }) {
    var i;
    return 0 === (null == (i = null == n ? void 0 : n.body) ? void 0 : i.length) ? (s ? Br(n, e) : Nr(n, e), !0) : "Program" !== (null == t ? void 0 : t.type) || 0 !== t.body.length || O(t.directives) ? "Program" === (null == r ? void 0 : r.type) && 0 === r.body.length && "ModuleExpression" === (null == t ? void 0 : t.type) && (Br(r, e), !0) : (s ? Br(t, e) : Nr(t, e), !0);
   }
   function fn({ comment: e, enclosingNode: t }) {
    return ("ForInStatement" === (null == t ? void 0 : t.type) || "ForOfStatement" === (null == t ? void 0 : t.type)) && (Nr(t, e), !0);
   }
   function mn({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    if ("ImportSpecifier" === (null == r ? void 0 : r.type) || "ExportSpecifier" === (null == r ? void 0 : r.type)) return Nr(r, e), !0;
    let s = "ImportSpecifier" === (null == t ? void 0 : t.type) && "ImportDeclaration" === (null == r ? void 0 : r.type),
     i = "ExportSpecifier" === (null == t ? void 0 : t.type) && "ExportNamedDeclaration" === (null == r ? void 0 : r.type);
    return !((!s && !i) || !N(n, $(e))) && (_r(t, e), !0);
   }
   function yn({ comment: e, enclosingNode: t }) {
    return "AssignmentPattern" === (null == t ? void 0 : t.type) && (Nr(t, e), !0);
   }
   var gn = new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]),
    Dn = new Set(["ObjectExpression", "RecordExpression", "ArrayExpression", "TupleExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
   function xn({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!gn.has(null == t ? void 0 : t.type) || !r || (!Dn.has(r.type) && !X(e))) && (Nr(r, e), !0);
   }
   function bn({ comment: e, enclosingNode: t, followingNode: r, text: n }) {
    return !(r || ("TSMethodSignature" !== (null == t ? void 0 : t.type) && "TSDeclareFunction" !== (null == t ? void 0 : t.type) && "TSAbstractMethodDefinition" !== (null == t ? void 0 : t.type)) || ";" !== Or(n, $(e))) && (_r(t, e), !0);
   }
   function vn({ comment: e, enclosingNode: t, followingNode: r }) {
    if (lt(e) && "TSMappedType" === (null == t ? void 0 : t.type) && "TSTypeParameter" === (null == r ? void 0 : r.type) && r.constraint) return (t.prettierIgnore = !0), (e.unignore = !0), !0;
   }
   function En({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return "TSMappedType" === (null == r ? void 0 : r.type) && ("TSTypeParameter" === (null == n ? void 0 : n.type) && n.name ? (Nr(n.name, e), !0) : !("TSTypeParameter" !== (null == t ? void 0 : t.type) || !t.constraint) && (_r(t.constraint, e), !0));
   }
   function Cn({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!t || "SwitchCase" !== t.type || t.test || !r || r !== t.consequent[0]) && ("BlockStatement" === r.type && se(e) ? $r(r, e) : Br(t, e), !0);
   }
   function Tn({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return !(!xt(t) || ((("TSArrayType" !== r.type && "ArrayTypeAnnotation" !== r.type) || n) && !bt(r))) && (_r(D(!1, t.types, -1), e), !0);
   }
   function wn({ comment: e, enclosingNode: t, precedingNode: r, followingNode: n }) {
    if (("ObjectPattern" === (null == t ? void 0 : t.type) || "ArrayPattern" === (null == t ? void 0 : t.type)) && "TSTypeAnnotation" === (null == n ? void 0 : n.type)) return r ? _r(r, e) : Br(t, e), !0;
   }
   var Sn = G(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]),
    An = new Set(["EmptyStatement", "TemplateElement", "Import", "TSEmptyBodyFunctionExpression", "ChainExpression"]);
   function Fn(e) {
    return !An.has(e.type);
   }
   function kn(e, t) {
    var r;
    if (("typescript" === t.parser || "flow" === t.parser || "acorn" === t.parser || "espree" === t.parser || "meriyah" === t.parser || "__babel_estree" === t.parser) && "MethodDefinition" === e.type && "FunctionExpression" === (null == (r = e.value) ? void 0 : r.type) && 0 === st(e.value).length && !e.value.returnType && !O(e.value.typeParameters) && e.value.body) return [...(e.decorators || []), e.key, e.value.body];
   }
   function Pn(e) {
    let { node: t, parent: r } = e;
    return (ge(t) || (r && ("JSXSpreadAttribute" === r.type || "JSXSpreadChild" === r.type || xt(r) || (("ClassDeclaration" === r.type || "ClassExpression" === r.type) && r.superClass === t)))) && (!pt(t) || xt(r));
   }
   function In(e, { parser: t }) {
    if ("flow" === t || "babel-flow" === t) return "" === (e = g(!1, e, /[\s(]/g, "")) || "/*" === e || "/*::" === e;
   }
   var Nn = Symbol("MODE_BREAK"),
    Bn = Symbol("MODE_FLAT"),
    _n = Symbol("cursor");
   function Ln(e, t) {
    return Mn(e, { type: "indent" }, t);
   }
   function On(e, t, r) {
    return t === Number.NEGATIVE_INFINITY ? e.root || { value: "", length: 0, queue: [] } : t < 0 ? Mn(e, { type: "dedent" }, r) : t ? ("root" === t.type ? { ...e, root: e } : Mn(e, { type: "string" == typeof t ? "stringAlign" : "numberAlign", n: t }, r)) : e;
   }
   function Mn(e, t, r) {
    let n = "dedent" === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     s = "",
     i = 0,
     a = 0,
     o = 0;
    for (let d of n)
     switch (d.type) {
      case "indent":
       p(), r.useTabs ? u(1) : l(r.tabWidth);
       break;
      case "stringAlign":
       p(), (s += d.n), (i += d.n.length);
       break;
      case "numberAlign":
       (a += 1), (o += d.n);
       break;
      default:
       throw new Error(`Unexpected type '${d.type}'`);
     }
    return c(), { ...e, value: s, length: i, queue: n };
    function u(e) {
     (s += "\t".repeat(e)), (i += r.tabWidth * e);
    }
    function l(e) {
     (s += " ".repeat(e)), (i += e);
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     o > 0 && l(o), h();
    }
    function h() {
     (a = 0), (o = 0);
    }
   }
   function jn(e) {
    let t = 0,
     r = 0,
     n = e.length;
    e: for (; n--; ) {
     let s = e[n];
     if (s !== _n)
      for (let r = s.length - 1; r >= 0; r--) {
       let i = s[r];
       if (" " !== i && "\t" !== i) {
        e[n] = s.slice(0, r + 1);
        break e;
       }
       t++;
      }
     else r++;
    }
    if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(_n);
    return t;
   }
   function Rn(e, t, r, n, s, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = [e],
     u = [];
    for (; r >= 0; ) {
     if (0 === o.length) {
      if (0 === a) return !0;
      o.push(t[--a]);
      continue;
     }
     let { mode: e, doc: l } = o.pop();
     switch (Ut(l)) {
      case wt:
       u.push(l), (r -= S(l));
       break;
      case St:
      case Nt: {
       let t = yr(l);
       for (let r = t.length - 1; r >= 0; r--) o.push({ mode: e, doc: t[r] });
       break;
      }
      case Ft:
      case kt:
      case _t:
      case jt:
       o.push({ mode: e, doc: l.contents });
       break;
      case Pt:
       r += jn(u);
       break;
      case It: {
       if (i && l.break) return !1;
       let t = l.break ? Nn : e,
        r = l.expandedStates && t === Nn ? D(!1, l.expandedStates, -1) : l.contents;
       o.push({ mode: t, doc: r });
       break;
      }
      case Bt: {
       let t = (l.groupId ? s[l.groupId] || Bn : e) === Nn ? l.breakContents : l.flatContents;
       t && o.push({ mode: e, doc: t });
       break;
      }
      case Mt:
       if (e === Nn || l.hard) return !0;
       l.soft || (u.push(" "), r--);
       break;
      case Lt:
       n = !0;
       break;
      case Ot:
       if (n) return !1;
     }
    }
    return !1;
   }
   function qn(e, t) {
    let r = {},
     n = t.printWidth,
     s = (function (e) {
      switch (e) {
       case "cr":
        return "\r";
       case "crlf":
        return "\r\n";
       default:
        return "\n";
      }
     })(t.endOfLine),
     i = 0,
     a = [{ ind: { value: "", length: 0, queue: [] }, mode: Nn, doc: e }],
     o = [],
     u = !1,
     l = [],
     p = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      Ht(
       e,
       function (e) {
        if ((e.type === Rt && vr(r), e.type === It)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === It && r.pop().break && vr(r);
       },
       !0,
      );
     })(e);
     a.length > 0;

    ) {
     let { ind: e, mode: c, doc: h } = a.pop();
     switch (Ut(h)) {
      case wt: {
       let e = "\n" !== s ? g(!1, h, "\n", s) : h;
       o.push(e), a.length > 0 && (i += S(e));
       break;
      }
      case St:
       for (let t = h.length - 1; t >= 0; t--) a.push({ ind: e, mode: c, doc: h[t] });
       break;
      case At:
       if (p >= 2) throw new Error("There are too many 'cursor' in doc.");
       o.push(_n), p++;
       break;
      case Ft:
       a.push({ ind: Ln(e, t), mode: c, doc: h.contents });
       break;
      case kt:
       a.push({ ind: On(e, h.n, t), mode: c, doc: h.contents });
       break;
      case Pt:
       i -= jn(o);
       break;
      case It:
       switch (c) {
        case Bn:
         if (!u) {
          a.push({ ind: e, mode: h.break ? Nn : Bn, doc: h.contents });
          break;
         }
        case Nn: {
         u = !1;
         let t = { ind: e, mode: Bn, doc: h.contents },
          s = n - i,
          o = l.length > 0;
         if (!h.break && Rn(t, a, s, o, r)) a.push(t);
         else if (h.expandedStates) {
          let t = D(!1, h.expandedStates, -1);
          if (h.break) {
           a.push({ ind: e, mode: Nn, doc: t });
           break;
          }
          for (let n = 1; n < h.expandedStates.length + 1; n++) {
           if (n >= h.expandedStates.length) {
            a.push({ ind: e, mode: Nn, doc: t });
            break;
           }
           {
            let t = h.expandedStates[n],
             i = { ind: e, mode: Bn, doc: t };
            if (Rn(i, a, s, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ ind: e, mode: Nn, doc: h.contents });
         break;
        }
       }
       h.id && (r[h.id] = D(!1, a, -1).mode);
       break;
      case Nt: {
       let t = n - i,
        { parts: s } = h;
       if (0 === s.length) break;
       let [o, u] = s,
        p = { ind: e, mode: Bn, doc: o },
        d = { ind: e, mode: Nn, doc: o },
        f = Rn(p, [], t, l.length > 0, r, !0);
       if (1 === s.length) {
        f ? a.push(p) : a.push(d);
        break;
       }
       let m = { ind: e, mode: Bn, doc: u },
        y = { ind: e, mode: Nn, doc: u };
       if (2 === s.length) {
        f ? a.push(m, p) : a.push(y, d);
        break;
       }
       s.splice(0, 2);
       let g = { ind: e, mode: c, doc: rr(s) },
        D = s[0];
       Rn({ ind: e, mode: Bn, doc: [o, u, D] }, [], t, l.length > 0, r, !0) ? a.push(g, m, p) : f ? a.push(g, y, p) : a.push(g, y, d);
       break;
      }
      case Bt:
      case _t: {
       let t = h.groupId ? r[h.groupId] : c;
       if (t === Nn) {
        let t = h.type === Bt ? h.breakContents : h.negate ? h.contents : Xt(h.contents);
        t && a.push({ ind: e, mode: c, doc: t });
       }
       if (t === Bn) {
        let t = h.type === Bt ? h.flatContents : h.negate ? Xt(h.contents) : h.contents;
        t && a.push({ ind: e, mode: c, doc: t });
       }
       break;
      }
      case Lt:
       l.push({ ind: e, mode: c, doc: h.contents });
       break;
      case Ot:
       l.length > 0 && a.push({ ind: e, mode: c, doc: ur });
       break;
      case Mt:
       switch (c) {
        case Bn:
         if (!h.hard) {
          h.soft || (o.push(" "), (i += 1));
          break;
         }
         u = !0;
        case Nn:
         if (l.length > 0) {
          a.push({ ind: e, mode: c, doc: h }, ...l.reverse()), (l.length = 0);
          break;
         }
         h.literal ? (e.root ? (o.push(s, e.root.value), (i = e.root.length)) : (o.push(s), (i = 0))) : ((i -= jn(o)), o.push(s + e.value), (i = e.length));
       }
       break;
      case jt:
       a.push({ ind: e, mode: c, doc: h.contents });
       break;
      case Rt:
       break;
      default:
       throw new zt(h);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let c = o.indexOf(_n);
    if (-1 !== c) {
     let e = o.indexOf(_n, c + 1),
      t = o.slice(0, c).join(""),
      r = o.slice(c + 1, e).join("");
     return { formatted: t + r + o.slice(e + 1).join(""), cursorNodeStart: t.length, cursorNodeText: r };
    }
    return { formatted: o.join("") };
   }
   var Un = function (e, t, r = 0) {
    let n = 0;
    for (let s = r; s < e.length; ++s) "\t" === e[s] ? (n = n + t - (n % t)) : n++;
    return n;
   };
   var $n = function (e, t) {
    let r = e.lastIndexOf("\n");
    return -1 === r ? 0 : Un(e.slice(r + 1).match(/^[\t ]*/)[0], t);
   };
   function Vn(e, t, r) {
    let { node: n } = e;
    if (
     "TemplateLiteral" === n.type &&
     (function ({ node: e, parent: t }) {
      let r = /^[fx]?(?:describe|it|test)$/;
      return "TaggedTemplateExpression" === t.type && t.quasi === e && "MemberExpression" === t.tag.type && "Identifier" === t.tag.property.type && "each" === t.tag.property.name && (("Identifier" === t.tag.object.type && r.test(t.tag.object.name)) || ("MemberExpression" === t.tag.object.type && "Identifier" === t.tag.object.property.type && ("only" === t.tag.object.property.name || "skip" === t.tag.object.property.name) && "Identifier" === t.tag.object.object.type && r.test(t.tag.object.object.name)));
     })(e)
    ) {
     let n = (function (e, t, r) {
      let { node: n } = e,
       s = n.quasis[0].value.raw.trim().split(/\s*\|\s*/);
      if (s.length > 1 || s.some((e) => e.length > 0)) {
       t.__inJestEach = !0;
       let i = e.map(r, "expressions");
       t.__inJestEach = !1;
       let a = [],
        o = i.map((e) => "${" + qn(e, { ...t, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"),
        u = [{ hasLineBreak: !1, cells: [] }];
       for (let e = 1; e < n.quasis.length; e++) {
        let t = D(!1, u, -1),
         r = o[e - 1];
        t.cells.push(r), r.includes("\n") && (t.hasLineBreak = !0), n.quasis[e].value.raw.includes("\n") && u.push({ hasLineBreak: !1, cells: [] });
       }
       let l = Math.max(s.length, ...u.map((e) => e.cells.length)),
        p = Array.from({ length: l }).fill(0),
        c = [{ cells: s }, ...u.filter((e) => e.cells.length > 0)];
       for (let { cells: e } of c.filter((e) => !e.hasLineBreak)) for (let [t, r] of e.entries()) p[t] = Math.max(p[t], S(r));
       return (
        a.push(
         ar,
         "`",
         Xt([
          cr,
          fr(
           cr,
           c.map((e) =>
            fr(
             " | ",
             e.cells.map((t, r) => (e.hasLineBreak ? t : t + " ".repeat(p[r] - S(t)))),
            ),
           ),
          ),
         ]),
         cr,
         "`",
        ),
        a
       );
      }
     })(e, r, t);
     if (n) return n;
    }
    let s = "expressions";
    "TSTemplateLiteralType" === n.type && (s = "types");
    let i = [],
     a = e.map(t, s),
     o = Pe(n);
    o && (a = a.map((e) => qn(e, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted)), i.push(ar, "`");
    let u = 0;
    return (
     e.each(({ index: e, node: l }) => {
      if ((i.push(t()), l.tail)) return;
      let { tabWidth: p } = r,
       c = l.value.raw,
       h = c.includes("\n") ? $n(c, p) : u;
      u = h;
      let d = a[e];
      if (!o) {
       let t = n[s][e],
        i = Mr(r.originalText, $(l), U(n.quasis[e + 1]));
       if (!i) {
        let e = qn(d, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted;
        e.includes("\n") ? (i = !0) : (d = e);
       }
       i && (dt(t) || ke(t) || "ConditionalExpression" === t.type || "SequenceExpression" === t.type || Dt(t) || ve(t)) && (d = [Xt([pr, d]), pr]);
      }
      let f =
       0 === h && c.endsWith("\n")
        ? Yt(Number.NEGATIVE_INFINITY, d)
        : (function (e, t, r) {
           Kt(e);
           let n = e;
           if (t > 0) {
            for (let e = 0; e < Math.floor(t / r); ++e) n = Xt(n);
            (n = Yt(t % r, n)), (n = Yt(Number.NEGATIVE_INFINITY, n));
           }
           return n;
          })(d, h, p);
      i.push(Qt(["${", f, ar, "}"]));
     }, "quasis"),
     i.push("`"),
     i
    );
   }
   function zn(e, t) {
    return e.map(
     (e) =>
      (function (e, t) {
       let { node: r } = e,
        n = t();
       return dt(r) && (n = Qt([Xt([pr, n]), pr])), ["${", n, ar, "}"];
      })(e, t),
     "expressions",
    );
   }
   function Wn(e, t) {
    return gr(e, (e) => ("string" == typeof e ? (t ? g(!1, e, /(\\*)`/g, "$1$1\\`") : Hn(e)) : e));
   }
   function Hn(e) {
    return g(!1, e, /([\\`]|\${)/g, "\\$1");
   }
   var Jn = [(e, t) => "ObjectExpression" === e.type && "properties" === t, (e, t) => "CallExpression" === e.type && "Identifier" === e.callee.type && "Component" === e.callee.name && "arguments" === t, (e, t) => "Decorator" === e.type && "expression" === t];
   function Kn(e, t) {
    return dt(e, ct.Block | ct.Leading, ({ value: e }) => e === ` ${t} `);
   }
   function Gn({ node: e, parent: t }, r) {
    return (
     Kn(e, r) ||
     ((function (e) {
      return "AsConstExpression" === e.type || ("TSAsExpression" === e.type && "TSTypeReference" === e.typeAnnotation.type && "Identifier" === e.typeAnnotation.typeName.type && "const" === e.typeAnnotation.typeName.name);
     })(t) &&
      Kn(t, r))
    );
   }
   async function Xn(e, t, r) {
    let { node: n } = r,
     s = n.quasis.map((e) => e.value.raw),
     i = 0,
     a = s.reduce((e, t, r) => (0 === r ? t : e + "@prettier-placeholder-" + i++ + "-id" + t), ""),
     o = (function (e, t) {
      if (!O(t)) return e;
      let r = 0,
       n = gr(Tr(e), (e) => ("string" == typeof e && e.includes("@prettier-placeholder") ? e.split(/@prettier-placeholder-(\d+)-id/).map((e, n) => (n % 2 == 0 ? wr(e) : (r++, t[e]))) : e));
      return t.length === r ? n : null;
     })(await e(a, { parser: "scss" }), zn(r, t));
    if (!o) throw new Error("Couldn't insert all the expressions");
    return ["`", Xt([cr, o]), pr, "`"];
   }
   function Yn(e) {
    return "Identifier" === e.type && "styled" === e.name;
   }
   function Qn(e) {
    return /^[A-Z]/.test(e.object.name) && "extend" === e.property.name;
   }
   var Zn = function (e) {
    if (
     (function ({ node: e, parent: t, grandparent: r }) {
      return (r && e.quasis && "JSXExpressionContainer" === t.type && "JSXElement" === r.type && "style" === r.openingElement.name.name && r.openingElement.attributes.some((e) => "JSXAttribute" === e.type && "jsx" === e.name.name)) || ("TaggedTemplateExpression" === (null == t ? void 0 : t.type) && "Identifier" === t.tag.type && "css" === t.tag.name) || ("TaggedTemplateExpression" === (null == t ? void 0 : t.type) && "MemberExpression" === t.tag.type && "css" === t.tag.object.name && ("global" === t.tag.property.name || "resolve" === t.tag.property.name));
     })(e) ||
     (function ({ parent: e }) {
      if (!e || "TaggedTemplateExpression" !== e.type) return !1;
      let t = "ParenthesizedExpression" === e.tag.type ? e.tag.expression : e.tag;
      switch (t.type) {
       case "MemberExpression":
        return Yn(t.object) || Qn(t);
       case "CallExpression":
        return Yn(t.callee) || ("MemberExpression" === t.callee.type && (("MemberExpression" === t.callee.object.type && (Yn(t.callee.object.object) || Qn(t.callee.object))) || ("CallExpression" === t.callee.object.type && Yn(t.callee.object.callee))));
       case "Identifier":
        return "css" === t.name;
       default:
        return !1;
      }
     })(e) ||
     (function ({ parent: e, grandparent: t }) {
      return "JSXAttribute" === (null == t ? void 0 : t.type) && "JSXExpressionContainer" === e.type && "JSXIdentifier" === t.name.type && "css" === t.name.name;
     })(e) ||
     (function (e) {
      return e.match(
       (e) => "TemplateLiteral" === e.type,
       (e, t) => ae(e) && "elements" === t,
       (e, t) => gt(e) && "Identifier" === e.key.type && "styles" === e.key.name && "value" === t,
       ...Jn,
      );
     })(e)
    )
     return Xn;
   };
   async function es(e, t, r) {
    let { node: n } = r,
     s = n.quasis.length,
     i = zn(r, t),
     a = [];
    for (let o = 0; o < s; o++) {
     let t = 0 === o,
      r = o === s - 1,
      u = n.quasis[o].value.cooked,
      l = u.split("\n"),
      p = l.length,
      c = i[o],
      h = p > 2 && "" === l[0].trim() && "" === l[1].trim(),
      d = p > 2 && "" === l[p - 1].trim() && "" === l[p - 2].trim(),
      f = l.every((e) => /^\s*(?:#[^\n\r]*)?$/.test(e));
     if (!r && /#[^\n\r]*$/.test(l[p - 1])) return null;
     let m = null;
     (m = f ? ts(l) : await e(u, { parser: "graphql" })), m ? ((m = Wn(m, !1)), !t && h && a.push(""), a.push(m), !r && d && a.push("")) : !t && !r && h && a.push(""), c && a.push(c);
    }
    return ["`", Xt([cr, fr(cr, a)]), cr, "`"];
   }
   function ts(e) {
    let t = [],
     r = !1,
     n = e.map((e) => e.trim());
    for (let [s, i] of n.entries()) "" !== i && ("" === n[s - 1] && r ? t.push([cr, i]) : t.push(i), (r = !0));
    return 0 === t.length ? null : fr(cr, t);
   }
   var rs = function (e) {
     if (
      (function ({ node: e, parent: t }) {
       return Gn({ node: e, parent: t }, "GraphQL") || (t && (("TaggedTemplateExpression" === t.type && (("MemberExpression" === t.tag.type && "graphql" === t.tag.object.name && "experimental" === t.tag.property.name) || ("Identifier" === t.tag.type && ("gql" === t.tag.name || "graphql" === t.tag.name)))) || ("CallExpression" === t.type && "Identifier" === t.callee.type && "graphql" === t.callee.name)));
      })(e)
     )
      return es;
    },
    ns = 0;
   async function ss(e, t, r, n, s) {
    let { node: i } = n,
     a = ns;
    ns = (ns + 1) >>> 0;
    let o = (e) => `PRETTIER_HTML_PLACEHOLDER_${e}_${a}_IN_JS`,
     u = i.quasis.map((e, t, r) => (t === r.length - 1 ? e.value.cooked : e.value.cooked + o(t))).join(""),
     l = zn(n, r),
     p = new RegExp(o("(\\d+)"), "g"),
     c = 0,
     h = gr(
      await t(u, {
       parser: e,
       __onHtmlRoot(e) {
        c = e.children.length;
       },
      }),
      (e) => {
       if ("string" != typeof e) return e;
       let t = [],
        r = e.split(p);
       for (let n = 0; n < r.length; n++) {
        let e = r[n];
        if (n % 2 == 0) {
         e && ((e = Hn(e)), s.__embeddedInHtml && (e = g(!1, e, /<\/(?=script\b)/gi, "<\\/")), t.push(e));
         continue;
        }
        let i = Number(e);
        t.push(l[i]);
       }
       return t;
      },
     ),
     d = /^\s/.test(u) ? " " : "",
     f = /\s$/.test(u) ? " " : "",
     m = "ignore" === s.htmlWhitespaceSensitivity ? cr : d && f ? lr : null;
    return m ? Qt(["`", Xt([m, Qt(h)]), m, "`"]) : mr({ hug: !1 }, Qt(["`", d, c > 1 ? Xt(Qt(h)) : Qt(h), f, "`"]));
   }
   var is = ss.bind(void 0, "html"),
    as = ss.bind(void 0, "angular");
   var os = function (e) {
    return (function (e) {
     return (
      Gn(e, "HTML") ||
      e.match(
       (e) => "TemplateLiteral" === e.type,
       (e, t) => "TaggedTemplateExpression" === e.type && "Identifier" === e.tag.type && "html" === e.tag.name && "quasi" === t,
      )
     );
    })(e)
     ? is
     : (function (e) {
          return e.match(
           (e) => "TemplateLiteral" === e.type,
           (e, t) => gt(e) && "Identifier" === e.key.type && "template" === e.key.name && "value" === t,
           ...Jn,
          );
         })(e)
       ? as
       : void 0;
   };
   async function us(e, t, r) {
    let { node: n } = r,
     s = g(!1, n.quasis[0].value.raw, /((?:\\\\)*)\\`/g, (e, t) => "\\".repeat(t.length / 2) + "`"),
     i = (function (e) {
      let t = e.match(/^([^\S\n]*)\S/m);
      return null === t ? "" : t[1];
     })(s),
     a = "" !== i;
    a && (s = g(!1, s, new RegExp(`^${i}`, "gm"), ""));
    let o = Wn(await e(s, { parser: "markdown", __inJsTemplate: !0 }), !0);
    return ["`", a ? Xt([pr, o]) : [hr, Zt(o)], pr, "`"];
   }
   var ls = function (e) {
    if (
     (function ({ node: e, parent: t }) {
      return "TaggedTemplateExpression" === (null == t ? void 0 : t.type) && 1 === e.quasis.length && "Identifier" === t.tag.type && ("md" === t.tag.name || "markdown" === t.tag.name);
     })(e)
    )
     return us;
   };
   var ps = function (e) {
     let t,
      { node: r } = e;
     if (
      "TemplateLiteral" === r.type &&
      !(function ({ quasis: e }) {
       return e.some(({ value: { cooked: e } }) => null === e);
      })(r)
     )
      for (let n of [Zn, rs, os, ls])
       if (((t = n(e)), t))
        return 1 === r.quasis.length && "" === r.quasis[0].value.raw.trim()
         ? "``"
         : async (...e) => {
            let r = await t(...e);
            return r && mr({ embed: !0, ...r.label }, r);
           };
    },
    cs = ((e, t, r) => (
     (r = null != e ? i(l(e)) : {}),
     ((e, t, r, n) => {
      if ((t && "object" == typeof t) || "function" == typeof t) for (let s of u(t)) !p.call(e, s) && s !== r && a(e, s, { get: () => t[s], enumerable: !(n = o(t, s)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : a(r, "default", { value: e, enumerable: !0 }), e)
    ))(f(), 1);
   var hs = function (e) {
    if (!e.startsWith("#!")) return "";
    let t = e.indexOf("\n");
    return -1 === t ? e : e.slice(0, t);
   };
   function ds(e) {
    let {
      shebang: t,
      text: r,
      pragmas: n,
      comments: s,
     } = (function (e) {
      let t = hs(e);
      t && (e = e.slice(t.length + 1));
      let r = (0, cs.extract)(e),
       { pragmas: n, comments: s } = (0, cs.parseWithComments)(r);
      return { shebang: t, text: e, pragmas: n, comments: s };
     })(e),
     i = (0, cs.strip)(r);
    return (t ? `${t}\n` : "") + (0, cs.print)({ pragmas: { format: "", ...n }, comments: s.trimStart() }) + (i.startsWith("\n") ? "\n" : "\n\n") + i;
   }
   var fs = function (e, t) {
    let { originalText: r, [Symbol.for("comments")]: n, locStart: s, locEnd: i, [Symbol.for("printedComments")]: a } = t,
     { node: o } = e,
     u = s(o),
     l = i(o);
    for (let p of n) s(p) >= u && i(p) <= l && a.add(p);
    return r.slice(u, l);
   };
   function ms(e, t) {
    var r, n, s, i, a, o, u;
    if (e.isRoot) return !1;
    let { node: l, key: p, parent: c } = e;
    if (
     t.__isInHtmlInterpolation &&
     !t.bracketSpacing &&
     (function (e) {
      return oe(e);
     })(l) &&
     gs(e)
    )
     return !0;
    if (ys(l)) return !1;
    if ("Identifier" === l.type) {
     if ((null != (r = l.extra) && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(l.name)) || ("left" === p && (("async" === l.name && !c.await) || "let" === l.name) && "ForOfStatement" === c.type)) return !0;
     if ("let" === l.name) {
      let t = null == (n = e.findAncestor((e) => "ForOfStatement" === e.type)) ? void 0 : n.left;
      if (t && Ge(t, (e) => e === l)) return !0;
     }
     if ("object" === p && "let" === l.name && "MemberExpression" === c.type && c.computed && !c.optional) {
      let t = e.findAncestor((e) => "ExpressionStatement" === e.type || "ForStatement" === e.type || "ForInStatement" === e.type),
       r = t ? ("ExpressionStatement" === t.type ? t.expression : "ForStatement" === t.type ? t.init : t.left) : void 0;
      if (r && Ge(r, (e) => e === l)) return !0;
     }
     if ("expression" === p)
      switch (l.name) {
       case "await":
       case "interface":
       case "module":
       case "using":
       case "yield":
       case "let":
       case "type": {
        let t = e.findAncestor((e) => !Dt(e));
        if (t !== c && "ExpressionStatement" === t.type) return !0;
       }
      }
     return !1;
    }
    if ("ObjectExpression" === l.type || "FunctionExpression" === l.type || "ClassExpression" === l.type || "DoExpression" === l.type) {
     let t = null == (s = e.findAncestor((e) => "ExpressionStatement" === e.type)) ? void 0 : s.expression;
     if (t && Ge(t, (e) => e === l)) return !0;
    }
    if ("ObjectExpression" === l.type) {
     let t = null == (i = e.findAncestor((e) => "ArrowFunctionExpression" === e.type)) ? void 0 : i.body;
     if (t && "SequenceExpression" !== t.type && "AssignmentExpression" !== t.type && Ge(t, (e) => e === l)) return !0;
    }
    switch (c.type) {
     case "ParenthesizedExpression":
      return !1;
     case "ClassDeclaration":
     case "ClassExpression":
      if ("superClass" === p && ("ArrowFunctionExpression" === l.type || "AssignmentExpression" === l.type || "AwaitExpression" === l.type || "BinaryExpression" === l.type || "ConditionalExpression" === l.type || "LogicalExpression" === l.type || "NewExpression" === l.type || "ObjectExpression" === l.type || "SequenceExpression" === l.type || "TaggedTemplateExpression" === l.type || "UnaryExpression" === l.type || "UpdateExpression" === l.type || "YieldExpression" === l.type || "TSNonNullExpression" === l.type || ("ClassExpression" === l.type && O(l.decorators)))) return !0;
      break;
     case "ExportDefaultDeclaration":
      return Ds(e, t) || "SequenceExpression" === l.type;
     case "Decorator":
      if ("expression" === p) {
       if (ke(l) && l.computed) return !0;
       let e = !1,
        r = !1,
        n = l;
       for (; n; )
        switch (n.type) {
         case "MemberExpression":
          (r = !0), (n = n.object);
          break;
         case "CallExpression":
          if (r || e) return "typescript" !== t.parser;
          (e = !0), (n = n.callee);
          break;
         case "Identifier":
          return !1;
         case "TaggedTemplateExpression":
          return "typescript" !== t.parser;
         default:
          return !0;
        }
       return !0;
      }
      break;
     case "TypeAnnotation":
      if (
       e.match(void 0, void 0, (e, t) => "returnType" === t && "ArrowFunctionExpression" === e.type) &&
       (function (e) {
        return ee(e, (e) => "ObjectTypeAnnotation" === e.type && ee(e, (e) => "FunctionTypeAnnotation" === e.type));
       })(l)
      )
       return !0;
      break;
     case "BinaryExpression":
      if ("left" === p && ("in" === c.operator || "instanceof" === c.operator) && "UnaryExpression" === l.type) return !0;
    }
    switch (l.type) {
     case "UpdateExpression":
      if ("UnaryExpression" === c.type) return l.prefix && (("++" === l.operator && "+" === c.operator) || ("--" === l.operator && "-" === c.operator));
     case "UnaryExpression":
      switch (c.type) {
       case "UnaryExpression":
        return l.operator === c.operator && ("+" === l.operator || "-" === l.operator);
       case "BindExpression":
       case "TaggedTemplateExpression":
       case "TSNonNullExpression":
        return !0;
       case "MemberExpression":
       case "OptionalMemberExpression":
        return "object" === p;
       case "NewExpression":
       case "CallExpression":
       case "OptionalCallExpression":
        return "callee" === p;
       case "BinaryExpression":
        return "left" === p && "**" === c.operator;
       default:
        return !1;
      }
     case "BinaryExpression":
      if (
       "UpdateExpression" === c.type ||
       ("in" === l.operator &&
        (function (e) {
         let t = 0,
          { node: r } = e;
         for (; r; ) {
          let n = e.getParentNode(t++);
          if ("ForStatement" === (null == n ? void 0 : n.type) && n.init === r) return !0;
          r = n;
         }
         return !1;
        })(e))
      )
       return !0;
      if ("|>" === l.operator && null != (a = l.extra) && a.parenthesized) {
       let t = e.grandparent;
       if ("BinaryExpression" === t.type && "|>" === t.operator) return !0;
      }
     case "TSTypeAssertion":
     case "TSAsExpression":
     case "TSSatisfiesExpression":
     case "AsExpression":
     case "AsConstExpression":
     case "SatisfiesExpression":
     case "LogicalExpression":
      switch (c.type) {
       case "TSAsExpression":
       case "TSSatisfiesExpression":
       case "AsExpression":
       case "AsConstExpression":
       case "SatisfiesExpression":
        return !Dt(l);
       case "ConditionalExpression":
        return Dt(l);
       case "CallExpression":
       case "NewExpression":
       case "OptionalCallExpression":
        return "callee" === p;
       case "ClassExpression":
       case "ClassDeclaration":
        return "superClass" === p;
       case "TSTypeAssertion":
       case "TaggedTemplateExpression":
       case "UnaryExpression":
       case "JSXSpreadAttribute":
       case "SpreadElement":
       case "BindExpression":
       case "AwaitExpression":
       case "TSNonNullExpression":
       case "UpdateExpression":
        return !0;
       case "MemberExpression":
       case "OptionalMemberExpression":
        return "object" === p;
       case "AssignmentExpression":
       case "AssignmentPattern":
        return "left" === p && ("TSTypeAssertion" === l.type || Dt(l));
       case "LogicalExpression":
        if ("LogicalExpression" === l.type) return c.operator !== l.operator;
       case "BinaryExpression": {
        let { operator: e, type: t } = l;
        if (!e && "TSTypeAssertion" !== t) return !0;
        let r = tt(e),
         n = c.operator,
         s = tt(n);
        return (
         s > r ||
         ("right" === p && s === r) ||
         (s === r && !Ze(n, e)) ||
         (s < r && "%" === e
          ? "+" === n || "-" === n
          : !!(function (e) {
             return !!Qe[e] || "|" === e || "^" === e || "&" === e;
            })(n))
        );
       }
       default:
        return !1;
      }
     case "SequenceExpression":
      switch (c.type) {
       case "ReturnStatement":
       case "ForStatement":
        return !1;
       case "ExpressionStatement":
        return "expression" !== p;
       case "ArrowFunctionExpression":
        return "body" !== p;
       default:
        return !0;
      }
     case "YieldExpression":
      if ("AwaitExpression" === c.type) return !0;
     case "AwaitExpression":
      switch (c.type) {
       case "TaggedTemplateExpression":
       case "UnaryExpression":
       case "LogicalExpression":
       case "SpreadElement":
       case "TSAsExpression":
       case "TSSatisfiesExpression":
       case "TSNonNullExpression":
       case "AsExpression":
       case "AsConstExpression":
       case "SatisfiesExpression":
       case "BindExpression":
        return !0;
       case "MemberExpression":
       case "OptionalMemberExpression":
        return "object" === p;
       case "NewExpression":
       case "CallExpression":
       case "OptionalCallExpression":
        return "callee" === p;
       case "ConditionalExpression":
        return "test" === p;
       case "BinaryExpression":
        return !(!l.argument && "|>" === c.operator);
       default:
        return !1;
      }
     case "TSFunctionType":
      if (
       e.match(
        (e) => "TSFunctionType" === e.type,
        (e, t) => "typeAnnotation" === t && "TSTypeAnnotation" === e.type,
        (e, t) => "returnType" === t && "ArrowFunctionExpression" === e.type,
       )
      )
       return !0;
     case "TSConditionalType":
     case "TSConstructorType":
      if ("extendsType" === p && "TSConditionalType" === c.type) {
       if ("TSConditionalType" === l.type) return !0;
       let { typeAnnotation: e } = l.returnType || l.typeAnnotation;
       if (("TSTypePredicate" === e.type && e.typeAnnotation && (e = e.typeAnnotation.typeAnnotation), "TSInferType" === e.type && e.typeParameter.constraint)) return !0;
      }
      if ("checkType" === p && "TSConditionalType" === c.type) return !0;
     case "TSUnionType":
     case "TSIntersectionType":
      if (("TSUnionType" === c.type || "TSIntersectionType" === c.type) && c.types.length > 1 && (!l.types || l.types.length > 1)) return !0;
     case "TSInferType":
      if ("TSInferType" === l.type && "TSRestType" === c.type) return !1;
     case "TSTypeOperator":
      return "TSArrayType" === c.type || "TSOptionalType" === c.type || "TSRestType" === c.type || ("objectType" === p && "TSIndexedAccessType" === c.type) || "TSTypeOperator" === c.type || ("TSTypeAnnotation" === c.type && e.grandparent.type.startsWith("TSJSDoc"));
     case "TSTypeQuery":
      return ("objectType" === p && "TSIndexedAccessType" === c.type) || ("elementType" === p && "TSArrayType" === c.type);
     case "TypeofTypeAnnotation":
      return ("objectType" === p && ("IndexedAccessType" === c.type || "OptionalIndexedAccessType" === c.type)) || ("elementType" === p && "ArrayTypeAnnotation" === c.type);
     case "ArrayTypeAnnotation":
      return "NullableTypeAnnotation" === c.type;
     case "IntersectionTypeAnnotation":
     case "UnionTypeAnnotation":
      return "ArrayTypeAnnotation" === c.type || "NullableTypeAnnotation" === c.type || "IntersectionTypeAnnotation" === c.type || "UnionTypeAnnotation" === c.type || ("objectType" === p && ("IndexedAccessType" === c.type || "OptionalIndexedAccessType" === c.type));
     case "InferTypeAnnotation":
     case "NullableTypeAnnotation":
      return "ArrayTypeAnnotation" === c.type || ("objectType" === p && ("IndexedAccessType" === c.type || "OptionalIndexedAccessType" === c.type));
     case "FunctionTypeAnnotation": {
      if (
       e.match(
        void 0,
        (e, t) => "typeAnnotation" === t && "TypeAnnotation" === e.type,
        (e, t) => "returnType" === t && "ArrowFunctionExpression" === e.type,
       ) ||
       e.match(
        void 0,
        (e, t) => "typeAnnotation" === t && "TypePredicate" === e.type,
        (e, t) => "typeAnnotation" === t && "TypeAnnotation" === e.type,
        (e, t) => "returnType" === t && "ArrowFunctionExpression" === e.type,
       )
      )
       return !0;
      let t = "NullableTypeAnnotation" === c.type ? e.grandparent : c;
      return (
       "UnionTypeAnnotation" === t.type ||
       "IntersectionTypeAnnotation" === t.type ||
       "ArrayTypeAnnotation" === t.type ||
       ("objectType" === p && ("IndexedAccessType" === t.type || "OptionalIndexedAccessType" === t.type)) ||
       ("checkType" === p && "ConditionalTypeAnnotation" === c.type) ||
       ("extendsType" === p && "ConditionalTypeAnnotation" === c.type && "InferTypeAnnotation" === l.returnType.type && l.returnType.typeParameter.bound) ||
       "NullableTypeAnnotation" === t.type ||
       ("FunctionTypeParam" === c.type &&
        null === c.name &&
        st(l).some((e) => {
         var t;
         return "NullableTypeAnnotation" === (null == (t = e.typeAnnotation) ? void 0 : t.type);
        }))
      );
     }
     case "ConditionalTypeAnnotation":
      if (("extendsType" === p && "ConditionalTypeAnnotation" === c.type && "ConditionalTypeAnnotation" === l.type) || ("checkType" === p && "ConditionalTypeAnnotation" === c.type)) return !0;
     case "OptionalIndexedAccessType":
      return "objectType" === p && "IndexedAccessType" === c.type;
     case "StringLiteral":
     case "NumericLiteral":
     case "Literal":
      if ("string" == typeof l.value && "ExpressionStatement" === c.type && !c.directive) {
       let t = e.grandparent;
       return "Program" === t.type || "BlockStatement" === t.type;
      }
      return "object" === p && "MemberExpression" === c.type && "number" == typeof l.value;
     case "AssignmentExpression": {
      let t = e.grandparent;
      return ("body" === p && "ArrowFunctionExpression" === c.type) || (("key" !== p || ("ClassProperty" !== c.type && "PropertyDefinition" !== c.type) || !c.computed) && (("init" !== p && "update" !== p) || "ForStatement" !== c.type) && ("ExpressionStatement" === c.type ? "ObjectPattern" === l.left.type : !(("key" === p && "TSPropertySignature" === c.type) || "AssignmentExpression" === c.type || ("SequenceExpression" === c.type && "ForStatement" === t.type && (t.init === c || t.update === c)) || ("value" === p && "Property" === c.type && "ObjectPattern" === t.type && t.properties.includes(c)) || "NGChainedExpression" === c.type)));
     }
     case "ConditionalExpression":
      switch (c.type) {
       case "TaggedTemplateExpression":
       case "UnaryExpression":
       case "SpreadElement":
       case "BinaryExpression":
       case "LogicalExpression":
       case "NGPipeExpression":
       case "ExportDefaultDeclaration":
       case "AwaitExpression":
       case "JSXSpreadAttribute":
       case "TSTypeAssertion":
       case "TypeCastExpression":
       case "TSAsExpression":
       case "TSSatisfiesExpression":
       case "AsExpression":
       case "AsConstExpression":
       case "SatisfiesExpression":
       case "TSNonNullExpression":
        return !0;
       case "NewExpression":
       case "CallExpression":
       case "OptionalCallExpression":
        return "callee" === p;
       case "ConditionalExpression":
        return !t.experimentalTernaries && "test" === p;
       case "MemberExpression":
       case "OptionalMemberExpression":
        return "object" === p;
       default:
        return !1;
      }
     case "FunctionExpression":
      switch (c.type) {
       case "NewExpression":
       case "CallExpression":
       case "OptionalCallExpression":
        return "callee" === p;
       case "TaggedTemplateExpression":
        return !0;
       default:
        return !1;
      }
     case "ArrowFunctionExpression":
      switch (c.type) {
       case "BinaryExpression":
        return "|>" !== c.operator || (null == (o = l.extra) ? void 0 : o.parenthesized);
       case "NewExpression":
       case "CallExpression":
       case "OptionalCallExpression":
        return "callee" === p;
       case "MemberExpression":
       case "OptionalMemberExpression":
        return "object" === p;
       case "TSAsExpression":
       case "TSSatisfiesExpression":
       case "AsExpression":
       case "AsConstExpression":
       case "SatisfiesExpression":
       case "TSNonNullExpression":
       case "BindExpression":
       case "TaggedTemplateExpression":
       case "UnaryExpression":
       case "LogicalExpression":
       case "AwaitExpression":
       case "TSTypeAssertion":
        return !0;
       case "ConditionalExpression":
        return "test" === p;
       default:
        return !1;
      }
     case "ClassExpression":
      return "NewExpression" === c.type && "callee" === p;
     case "OptionalMemberExpression":
     case "OptionalCallExpression":
     case "CallExpression":
     case "MemberExpression":
      if (
       (function (e) {
        let { node: t, parent: r, grandparent: n, key: s } = e;
        return !!(
         (("OptionalMemberExpression" === t.type || "OptionalCallExpression" === t.type) && (("object" === s && "MemberExpression" === r.type) || ("callee" === s && ("CallExpression" === r.type || "NewExpression" === r.type)) || ("TSNonNullExpression" === r.type && "MemberExpression" === n.type && n.object === r))) ||
         (e.match(
          () => "CallExpression" === t.type || "MemberExpression" === t.type,
          (e, t) => "expression" === t && "ChainExpression" === e.type,
         ) &&
          (e.match(void 0, void 0, (e, t) => ("callee" === t && (("CallExpression" === e.type && !e.optional) || "NewExpression" === e.type)) || ("object" === t && "MemberExpression" === e.type && !e.optional)) ||
           e.match(
            void 0,
            void 0,
            (e, t) => "expression" === t && "TSNonNullExpression" === e.type,
            (e, t) => "object" === t && "MemberExpression" === e.type,
           ))) ||
         e.match(
          () => "CallExpression" === t.type || "MemberExpression" === t.type,
          (e, t) => "expression" === t && "TSNonNullExpression" === e.type,
          (e, t) => "expression" === t && "ChainExpression" === e.type,
          (e, t) => "object" === t && "MemberExpression" === e.type,
         )
        );
       })(e)
      )
       return !0;
     case "TaggedTemplateExpression":
     case "TSNonNullExpression":
      if ("callee" === p && ("BindExpression" === c.type || "NewExpression" === c.type)) {
       let e = l;
       for (; e; )
        switch (e.type) {
         case "CallExpression":
         case "OptionalCallExpression":
          return !0;
         case "MemberExpression":
         case "OptionalMemberExpression":
         case "BindExpression":
          e = e.object;
          break;
         case "TaggedTemplateExpression":
          e = e.tag;
          break;
         case "TSNonNullExpression":
          e = e.expression;
          break;
         default:
          return !1;
        }
      }
      return !1;
     case "BindExpression":
      return ("callee" === p && ("BindExpression" === c.type || "NewExpression" === c.type)) || ("object" === p && ke(c));
     case "NGPipeExpression":
      return !("NGRoot" === c.type || "NGMicrosyntaxExpression" === c.type || ("ObjectProperty" === c.type && (null == (u = l.extra) || !u.parenthesized)) || ae(c) || ("arguments" === p && Fe(c)) || ("right" === p && "NGPipeExpression" === c.type) || ("property" === p && "MemberExpression" === c.type) || "AssignmentExpression" === c.type);
     case "JSXFragment":
     case "JSXElement":
      return "callee" === p || ("left" === p && "BinaryExpression" === c.type && "<" === c.operator) || (!ae(c) && "ArrowFunctionExpression" !== c.type && "AssignmentExpression" !== c.type && "AssignmentPattern" !== c.type && "BinaryExpression" !== c.type && "NewExpression" !== c.type && "ConditionalExpression" !== c.type && "ExpressionStatement" !== c.type && "JsExpressionRoot" !== c.type && "JSXAttribute" !== c.type && "JSXElement" !== c.type && "JSXExpressionContainer" !== c.type && "JSXFragment" !== c.type && "LogicalExpression" !== c.type && !Fe(c) && !gt(c) && "ReturnStatement" !== c.type && "ThrowStatement" !== c.type && "TypeCastExpression" !== c.type && "VariableDeclarator" !== c.type && "YieldExpression" !== c.type);
     case "TSInstantiationExpression":
      return "object" === p && ke(c);
    }
    return !1;
   }
   var ys = G(["BlockStatement", "BreakStatement", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
   function gs(e) {
    let { parent: t, key: r } = e;
    switch (t.type) {
     case "NGPipeExpression":
      if ("arguments" === r && e.isLast) return e.callParent(gs);
      break;
     case "ObjectProperty":
      if ("value" === r) return e.callParent(() => "properties" === e.key && e.isLast);
      break;
     case "BinaryExpression":
     case "LogicalExpression":
      if ("right" === r) return e.callParent(gs);
      break;
     case "ConditionalExpression":
      if ("alternate" === r) return e.callParent(gs);
      break;
     case "UnaryExpression":
      if (t.prefix) return e.callParent(gs);
    }
    return !1;
   }
   function Ds(e, t) {
    let { node: r, parent: n } = e;
    return "FunctionExpression" === r.type || "ClassExpression" === r.type ? "ExportDefaultDeclaration" === n.type || !ms(e, t) : !(!te(r) || ("ExportDefaultDeclaration" !== n.type && ms(e, t))) && e.call(() => Ds(e, t), ...ne(r));
   }
   var xs = ms;
   var bs = function (e, t) {
     let r = t - 1;
     return (r = F(e, r, { backwards: !0 })), (r = I(e, r, { backwards: !0 })), (r = F(e, r, { backwards: !0 })), r !== I(e, r, { backwards: !0 });
    },
    vs = () => !0;
   function Es(e, t) {
    return (e.node.printed = !0), t.printer.printComment(e, t);
   }
   function Cs(e, t, r = {}) {
    let { node: n } = e;
    if (!O(null == n ? void 0 : n.comments)) return "";
    let { indent: s = !1, marker: i, filter: a = vs } = r,
     o = [];
    if (
     (e.each(({ node: r }) => {
      r.leading || r.trailing || r.marker !== i || !a(r) || o.push(Es(e, t));
     }, "comments"),
     0 === o.length)
    )
     return "";
    let u = fr(cr, o);
    return s ? Xt([cr, u]) : u;
   }
   function Ts(e, t) {
    let r = e.node;
    if (!r) return {};
    let n = t[Symbol.for("printedComments")];
    if (0 === (r.comments || []).filter((e) => !n.has(e)).length) return { leading: "", trailing: "" };
    let s,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (null != n && n.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           var r;
           let n = e.node,
            s = [Es(e, t)],
            { printer: i, originalText: a, locStart: o, locEnd: u } = t;
           if (null == (r = i.isBlockComment) ? void 0 : r.call(i, n)) {
            let e = N(a, u(n)) ? (N(a, o(n), { backwards: !0 }) ? cr : lr) : " ";
            s.push(e);
           } else s.push(cr);
           let l = I(a, F(a, u(n)));
           return !1 !== l && N(a, l) && s.push(cr), s;
          })(e, t),
         )
       : u &&
         ((s = (function (e, t, r) {
          var n;
          let s = e.node,
           i = Es(e, t),
           { printer: a, originalText: o, locStart: u } = t,
           l = null == (n = a.isBlockComment) ? void 0 : n.call(a, s);
          if ((null != r && r.hasLineSuffix && (null == r || !r.isBlock)) || N(o, u(s), { backwards: !0 })) {
           let e = bs(o, u(s));
           return { doc: ir([cr, e ? cr : "", i]), isBlock: l, hasLineSuffix: !0 };
          }
          return !l || (null != r && r.hasLineSuffix) ? { doc: [ir([" ", i]), or], isBlock: l, hasLineSuffix: !0 } : { doc: [" ", i], isBlock: l, hasLineSuffix: !1 };
         })(e, t, s)),
         a.push(s.doc));
     }, "comments"),
     { leading: i, trailing: a }
    );
   }
   function ws(e, t, r) {
    let { leading: n, trailing: s } = Ts(e, r);
    return n || s ? Ar(t, (e) => [n, e, s]) : t;
   }
   var Ss = class extends Error {
     name = "UnexpectedNodeError";
     constructor(e, t, r = "type") {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    },
    As = Ss;
   var Fs;
   Fs = new WeakMap();
   var ks = class {
     constructor(e) {
      ((e, t, r) => {
       if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
       t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, Fs, void 0),
       ((e, t, r, n) => {
        h(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r);
       })(this, Fs, new Set(e));
     }
     getLeadingWhitespaceCount(e) {
      let t = d(this, Fs),
       r = 0;
      for (let n = 0; n < e.length && t.has(e.charAt(n)); n++) r++;
      return r;
     }
     getTrailingWhitespaceCount(e) {
      let t = d(this, Fs),
       r = 0;
      for (let n = e.length - 1; n >= 0 && t.has(e.charAt(n)); n--) r++;
      return r;
     }
     getLeadingWhitespace(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(0, t);
     }
     getTrailingWhitespace(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(e.length - t);
     }
     hasLeadingWhitespace(e) {
      return d(this, Fs).has(e.charAt(0));
     }
     hasTrailingWhitespace(e) {
      return d(this, Fs).has(D(!1, e, -1));
     }
     trimStart(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(t);
     }
     trimEnd(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(0, e.length - t);
     }
     trim(e) {
      return this.trimEnd(this.trimStart(e));
     }
     split(e, t = !1) {
      let r = `[${(function (e) {
        if ("string" != typeof e) throw new TypeError("Expected a string");
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
       })([...d(this, Fs)].join(""))}]+`,
       n = new RegExp(t ? `(${r})` : r);
      return e.split(n);
     }
     hasWhitespaceCharacter(e) {
      let t = d(this, Fs);
      return Array.prototype.some.call(e, (e) => t.has(e));
     }
     hasNonWhitespaceCharacter(e) {
      let t = d(this, Fs);
      return Array.prototype.some.call(e, (e) => !t.has(e));
     }
     isWhitespaceOnly(e) {
      let t = d(this, Fs);
      return Array.prototype.every.call(e, (e) => t.has(e));
     }
    },
    Ps = new ks(" \n\r\t"),
    Is = (e) => "" === e || e === lr || e === cr || e === pr;
   function Ns(e, t, r) {
    var n, s, i;
    let { node: a } = e;
    if (
     "JSXElement" === a.type &&
     (function (e) {
      if (0 === e.children.length) return !0;
      if (e.children.length > 1) return !1;
      let t = e.children[0];
      return "JSXText" === t.type && !Rs(t);
     })(a)
    )
     return [r("openingElement"), r("closingElement")];
    let o = "JSXElement" === a.type ? r("openingElement") : r("openingFragment"),
     u = "JSXElement" === a.type ? r("closingElement") : r("closingFragment");
    if (1 === a.children.length && "JSXExpressionContainer" === a.children[0].type && ("TemplateLiteral" === a.children[0].expression.type || "TaggedTemplateExpression" === a.children[0].expression.type)) return [o, ...e.map(r, "children"), u];
    a.children = a.children.map((e) =>
     (function (e) {
      return "JSXExpressionContainer" === e.type && pe(e.expression) && " " === e.expression.value && !dt(e.expression);
     })(e)
      ? { type: "JSXText", value: " ", raw: " " }
      : e,
    );
    let l = a.children.some(ge),
     p = a.children.filter((e) => "JSXExpressionContainer" === e.type).length > 1,
     c = "JSXElement" === a.type && a.openingElement.attributes.length > 1,
     h = br(o) || l || c || p,
     d = "mdx" === e.parent.rootMarker,
     f = t.singleQuote ? "{' '}" : '{" "}',
     m = d ? " " : nr([f, pr], " "),
     y = (function (e, t, r, n, s) {
      let i = [];
      return (
       e.each(({ node: e, next: t }) => {
        if ("JSXText" === e.type) {
         let r = He(e);
         if (Rs(e)) {
          let a,
           o = Ps.split(r, !0);
          if (("" === o[0] && (i.push(""), o.shift(), /\n/.test(o[0]) ? i.push(_s(s, o[1], e, t)) : i.push(n), o.shift()), "" === D(!1, o, -1) && (o.pop(), (a = o.pop())), 0 === o.length)) return;
          for (let [e, t] of o.entries()) e % 2 == 1 ? i.push(lr) : i.push(t);
          void 0 !== a ? (/\n/.test(a) ? i.push(_s(s, D(!1, i, -1), e, t)) : i.push(n)) : i.push(Bs(s, D(!1, i, -1), e, t));
         } else /\n/.test(r) ? r.match(/\n/g).length > 1 && i.push("", cr) : i.push("", n);
        } else {
         let n = r();
         if ((i.push(n), t && Rs(t))) {
          let r = Ps.trim(He(t)),
           [n] = Ps.split(r);
          i.push(Bs(s, n, e, t));
         } else i.push(cr);
        }
       }, "children"),
       i
      );
     })(e, 0, r, m, "fbt" === (null == (s = null == (n = a.openingElement) ? void 0 : n.name) ? void 0 : s.name)),
     g = a.children.some((e) => Rs(e));
    for (let D = y.length - 2; D >= 0; D--) {
     let e = "" === y[D] && "" === y[D + 1],
      t = y[D] === cr && "" === y[D + 1] && y[D + 2] === cr,
      r = (y[D] === pr || y[D] === cr) && "" === y[D + 1] && y[D + 2] === m,
      n = y[D] === m && "" === y[D + 1] && (y[D + 2] === pr || y[D + 2] === cr),
      s = y[D] === m && "" === y[D + 1] && y[D + 2] === m,
      i = (y[D] === pr && "" === y[D + 1] && y[D + 2] === cr) || (y[D] === cr && "" === y[D + 1] && y[D + 2] === pr);
     (t && g) || e || r || s || i ? y.splice(D, 2) : n && y.splice(D + 1, 2);
    }
    for (; y.length > 0 && Is(D(!1, y, -1)); ) y.pop();
    for (; y.length > 1 && Is(y[0]) && Is(y[1]); ) y.shift(), y.shift();
    let x = [];
    for (let [D, E] of y.entries()) {
     if (E === m) {
      if (1 === D && "" === y[D - 1]) {
       if (2 === y.length) {
        x.push(f);
        continue;
       }
       x.push([f, cr]);
       continue;
      }
      if (D === y.length - 1) {
       x.push(f);
       continue;
      }
      if ("" === y[D - 1] && y[D - 2] === cr) {
       x.push(f);
       continue;
      }
     }
     x.push(E), br(E) && (h = !0);
    }
    let b = g ? rr(x) : Qt(x, { shouldBreak: !0 });
    if (("JSXText" === (null == (i = t.cursorNode) ? void 0 : i.type) && a.children.includes(t.cursorNode) && (b = [dr, b, dr]), d)) return b;
    let v = Qt([o, Xt([cr, b]), cr, u]);
    return h ? v : tr([Qt([o, ...y, u]), v]);
   }
   function Bs(e, t, r, n) {
    return e ? "" : ("JSXElement" === r.type && !r.closingElement) || ("JSXElement" === (null == n ? void 0 : n.type) && !n.closingElement) ? (1 === t.length ? pr : cr) : pr;
   }
   function _s(e, t, r, n) {
    return e ? cr : 1 === t.length ? (("JSXElement" === r.type && !r.closingElement) || ("JSXElement" === (null == n ? void 0 : n.type) && !n.closingElement) ? cr : pr) : cr;
   }
   var Ls = new Set(["ArrayExpression", "TupleExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
   function Os(e, t, r) {
    return e.selfClosing
     ? [lr, "/>"]
     : (function (e, t, r) {
          let n = e.attributes.length > 0 && dt(D(!1, e.attributes, -1), ct.Trailing);
          return (0 === e.attributes.length && !r) || ((t.bracketSameLine || t.jsxBracketSameLine) && (!r || e.attributes.length > 0) && !n);
         })(e, t, r)
       ? [">"]
       : [pr, ">"];
   }
   function Ms(e, t, r) {
    return (function (e, t, r) {
     let { parent: n } = e;
     if (Ls.has(n.type)) return t;
     let s = e.match(
       void 0,
       (e) => "ArrowFunctionExpression" === e.type,
       Fe,
       (e) => "JSXExpressionContainer" === e.type,
      ),
      i = xs(e, r);
     return Qt([i ? "" : nr("("), Xt([pr, t]), pr, i ? "" : nr(")")], { shouldBreak: s });
    })(e, ws(e, Ns(e, t, r), t), t);
   }
   function js(e, t, r) {
    let { node: n } = e;
    if (n.type.startsWith("JSX"))
     switch (n.type) {
      case "JSXAttribute":
       return (function (e, t, r) {
        let { node: n } = e,
         s = [];
        if ((s.push(r("name")), n.value)) {
         let i;
         if (pe(n.value)) {
          let r = He(n.value),
           s = g(!1, g(!1, r.slice(1, -1), "&apos;", "'"), "&quot;", '"'),
           a = j(s, t.jsxSingleQuote);
          (s = '"' === a ? g(!1, s, '"', "&quot;") : g(!1, s, "'", "&apos;")), (i = e.call(() => ws(e, wr(a + s + a), t), "value"));
         } else i = r("value");
         s.push("=", i);
        }
        return s;
       })(e, t, r);
      case "JSXIdentifier":
       return n.name;
      case "JSXNamespacedName":
       return fr(":", [r("namespace"), r("name")]);
      case "JSXMemberExpression":
       return fr(".", [r("object"), r("property")]);
      case "JSXSpreadAttribute":
      case "JSXSpreadChild":
       return (function (e, t, r) {
        let { node: n } = e;
        return [
         "{",
         e.call(
          ({ node: n }) => {
           let s = ["...", r()];
           return dt(n) && Pn(e) ? [Xt([pr, ws(e, s, t)]), pr] : s;
          },
          "JSXSpreadAttribute" === n.type ? "argument" : "expression",
         ),
         "}",
        ];
       })(e, t, r);
      case "JSXExpressionContainer":
       return (function (e, t, r) {
        let { node: n } = e,
         s = (e, t) => "JSXEmptyExpression" === e.type || (!dt(e) && (ae(e) || oe(e) || "ArrowFunctionExpression" === e.type || ("AwaitExpression" === e.type && (s(e.argument, e) || "JSXElement" === e.argument.type)) || Fe(e) || ("ChainExpression" === e.type && Fe(e.expression)) || "FunctionExpression" === e.type || "TemplateLiteral" === e.type || "TaggedTemplateExpression" === e.type || "DoExpression" === e.type || (ge(t) && ("ConditionalExpression" === e.type || ve(e)))));
        return s(n.expression, e.parent) ? Qt(["{", r("expression"), ar, "}"]) : Qt(["{", Xt([pr, r("expression")]), pr, ar, "}"]);
       })(e, 0, r);
      case "JSXFragment":
      case "JSXElement":
       return Ms(e, t, r);
      case "JSXOpeningElement":
       return (function (e, t, r) {
        var n, s;
        let { node: i } = e,
         a = dt(i.name) || dt(i.typeParameters) || dt(i.typeArguments);
        if (i.selfClosing && 0 === i.attributes.length && !a) return ["<", r("name"), i.typeArguments ? r("typeArguments") : r("typeParameters"), " />"];
        if (1 === (null == (n = i.attributes) ? void 0 : n.length) && i.attributes[0].value && pe(i.attributes[0].value) && !i.attributes[0].value.value.includes("\n") && !a && !dt(i.attributes[0])) return Qt(["<", r("name"), i.typeArguments ? r("typeArguments") : r("typeParameters"), " ", ...e.map(r, "attributes"), i.selfClosing ? " />" : ">"]);
        let o = null == (s = i.attributes) ? void 0 : s.some((e) => e.value && pe(e.value) && e.value.value.includes("\n")),
         u = t.singleAttributePerLine && i.attributes.length > 1 ? cr : lr;
        return Qt(["<", r("name"), i.typeArguments ? r("typeArguments") : r("typeParameters"), Xt(e.map(() => [u, r()], "attributes")), ...Os(i, t, a)], { shouldBreak: o });
       })(e, t, r);
      case "JSXClosingElement":
       return (function (e, t, r) {
        let { node: n } = e,
         s = [];
        s.push("</");
        let i = r("name");
        return dt(n.name, ct.Leading | ct.Line) ? s.push(Xt([cr, i]), cr) : dt(n.name, ct.Leading | ct.Block) ? s.push(" ", i) : s.push(i), s.push(">"), s;
       })(e, 0, r);
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
       return (function (e, t) {
        let { node: r } = e,
         n = dt(r),
         s = dt(r, ct.Line),
         i = "JSXOpeningFragment" === r.type;
        return [i ? "<" : "</", Xt([s ? cr : n && !i ? " " : "", Cs(e, t)]), s ? cr : "", ">"];
       })(e, t);
      case "JSXEmptyExpression":
       return (function (e, t) {
        let { node: r } = e,
         n = dt(r, ct.Line);
        return [Cs(e, t, { indent: n }), n ? cr : ""];
       })(e, t);
      case "JSXText":
       throw new Error("JSXText should be handled by JSXElement");
      default:
       throw new As(n, "JSX");
     }
   }
   function Rs(e) {
    return "JSXText" === e.type && (Ps.hasNonWhitespaceCharacter(He(e)) || !/\n/.test(He(e)));
   }
   var qs = function (e) {
     return (
      pt(e.node) ||
      (function (e) {
       let { node: t, parent: r } = e;
       if (!ge(t) || !ge(r)) return !1;
       let n,
        { index: s, siblings: i } = e;
       for (let a = s; a > 0; a--) {
        let e = i[a - 1];
        if ("JSXText" !== e.type || Rs(e)) {
         n = e;
         break;
        }
       }
       return "JSXExpressionContainer" === (null == n ? void 0 : n.type) && "JSXEmptyExpression" === n.expression.type && pt(n.expression);
      })(e)
     );
    },
    Us = 0;
   function $s(e, t, r) {
    var n;
    let { node: s, parent: i, grandparent: a, key: o } = e,
     u = "body" !== o && ("IfStatement" === i.type || "WhileStatement" === i.type || "SwitchStatement" === i.type || "DoWhileStatement" === i.type),
     l = "|>" === s.operator && (null == (n = e.root.extra) ? void 0 : n.__isUsingHackPipeline),
     p = Vs(e, r, t, !1, u);
    if (u) return p;
    if (l) return Qt(p);
    if ((Fe(i) && i.callee === s) || "UnaryExpression" === i.type || (ke(i) && !i.computed)) return Qt([Xt([pr, ...p]), pr]);
    let c = "ReturnStatement" === i.type || "ThrowStatement" === i.type || ("JSXExpressionContainer" === i.type && "JSXAttribute" === a.type) || ("|" !== s.operator && "JsExpressionRoot" === i.type) || ("NGPipeExpression" !== s.type && (("NGRoot" === i.type && "__ng_binding" === t.parser) || ("NGMicrosyntaxExpression" === i.type && "NGMicrosyntax" === a.type && 1 === a.body.length))) || (s === i.body && "ArrowFunctionExpression" === i.type) || (s !== i.body && "ForStatement" === i.type) || ("ConditionalExpression" === i.type && "ReturnStatement" !== a.type && "ThrowStatement" !== a.type && !Fe(a)) || "TemplateLiteral" === i.type,
     h = "AssignmentExpression" === i.type || "VariableDeclarator" === i.type || "ClassProperty" === i.type || "PropertyDefinition" === i.type || "TSAbstractPropertyDefinition" === i.type || "ClassPrivateProperty" === i.type || gt(i),
     d = ve(s.left) && Ze(s.operator, s.left.operator);
    if (c || (zs(s) && !d) || (!zs(s) && h)) return Qt(p);
    if (0 === p.length) return "";
    let f = ge(s.right),
     m = p.findIndex((e) => "string" != typeof e && !Array.isArray(e) && e.type === It),
     y = p.slice(0, -1 === m ? 1 : m + 1),
     g = p.slice(y.length, f ? -1 : void 0),
     x = Symbol("logicalChain-" + ++Us),
     b = Qt([...y, Xt(g)], { id: x });
    return f ? Qt([b, sr(D(!1, p, -1), { groupId: x })]) : b;
   }
   function Vs(e, t, r, n, s) {
    var i;
    let { node: a } = e;
    if (!ve(a)) return [Qt(t())];
    let o = [];
    Ze(a.operator, a.left.operator) ? (o = e.call((e) => Vs(e, t, r, !0, s), "left")) : o.push(Qt(t("left")));
    let u,
     l = zs(a),
     p =
      ("|>" === a.operator ||
       "NGPipeExpression" === a.type ||
       (function (e, t) {
        return ("__vue_expression" === t.parser || "__vue_ts_expression" === t.parser) && Ws(e.node) && !e.hasAncestor((e) => !Ws(e) && "JsExpressionRoot" !== e.type);
       })(e, r)) &&
      !Me(r.originalText, a.right),
     c = "NGPipeExpression" === a.type ? "|" : a.operator,
     h =
      "NGPipeExpression" === a.type && a.arguments.length > 0
       ? Qt(
          Xt([
           pr,
           ": ",
           fr(
            [lr, ": "],
            e.map(() => Yt(2, Qt(t())), "arguments"),
           ),
          ]),
         )
       : "";
    if (l) u = [c, " ", t("right"), h];
    else {
     let n = "|>" === c && (null == (i = e.root.extra) ? void 0 : i.__isUsingHackPipeline) ? e.call((e) => Vs(e, t, r, !0, s), "right") : t("right");
     u = [p ? lr : "", c, p ? " " : lr, n, h];
    }
    let { parent: d } = e,
     f = dt(a.left, ct.Trailing | ct.Line),
     m = f || (!(s && "LogicalExpression" === a.type) && d.type !== a.type && a.left.type !== a.type && a.right.type !== a.type);
    if ((o.push(p ? "" : " ", m ? Qt(u, { shouldBreak: f }) : u), n && dt(a))) {
     let t = Tr(ws(e, o, r));
     return Array.isArray(t) || t.type === Nt ? yr(t) : [t];
    }
    return o;
   }
   function zs(e) {
    return "LogicalExpression" === e.type && !!((oe(e.right) && e.right.properties.length > 0) || (ae(e.right) && e.right.elements.length > 0) || ge(e.right));
   }
   var Ws = (e) => "BinaryExpression" === e.type && "|" === e.operator;
   function Hs(e, t, r) {
    let { node: n } = e;
    if (n.type.startsWith("NG"))
     switch (n.type) {
      case "NGRoot":
       return [r("node"), dt(n.node) ? " //" + ft(n.node)[0].value.trimEnd() : ""];
      case "NGPipeExpression":
       return $s(e, t, r);
      case "NGChainedExpression":
       return Qt(
        fr(
         [";", lr],
         e.map(
          () =>
           (function ({ node: e }) {
            return ee(e, Ks);
           })(e)
            ? r()
            : ["(", r(), ")"],
          "expressions",
         ),
        ),
       );
      case "NGEmptyExpression":
       return "";
      case "NGMicrosyntax":
       return e.map(() => [e.isFirst ? "" : Js(e) ? " " : [";", lr], r()], "body");
      case "NGMicrosyntaxKey":
       return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);
      case "NGMicrosyntaxExpression":
       return [r("expression"), null === n.alias ? "" : [" as ", r("alias")]];
      case "NGMicrosyntaxKeyedExpression": {
       let { index: t, parent: s } = e,
        i = Js(e) || (((1 === t && ("then" === n.key.name || "else" === n.key.name || "as" === n.key.name)) || ((2 === t || 3 === t) && (("else" === n.key.name && "NGMicrosyntaxKeyedExpression" === s.body[t - 1].type && "then" === s.body[t - 1].key.name) || "track" === n.key.name))) && "NGMicrosyntaxExpression" === s.body[0].type);
       return [r("key"), i ? " " : ": ", r("expression")];
      }
      case "NGMicrosyntaxLet":
       return ["let ", r("key"), null === n.value ? "" : [" = ", r("value")]];
      case "NGMicrosyntaxAs":
       return [r("key"), " as ", r("alias")];
      default:
       throw new As(n, "Angular");
     }
   }
   function Js({ node: e, index: t }) {
    return "NGMicrosyntaxKeyedExpression" === e.type && "of" === e.key.name && 1 === t;
   }
   var Ks = G(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
   function Gs(e, t, r) {
    let { node: n } = e;
    return Qt([fr(lr, e.map(r, "decorators")), Ys(n, t) ? cr : lr]);
   }
   function Xs(e, t, r) {
    return Qs(e.node) ? [fr(cr, e.map(r, "declaration", "decorators")), cr] : "";
   }
   function Ys(e, t) {
    return e.decorators.some((e) => N(t.originalText, $(e)));
   }
   function Qs(e) {
    var t;
    if ("ExportDefaultDeclaration" !== e.type && "ExportNamedDeclaration" !== e.type && "DeclareExportDeclaration" !== e.type) return !1;
    let r = null == (t = e.declaration) ? void 0 : t.decorators;
    return O(r) && V(e, r[0]);
   }
   var Zs = class extends Error {
    name = "ArgExpansionBailout";
   };
   function ei(e, t = !1) {
    return (
     (oe(e) && (e.properties.length > 0 || dt(e))) ||
     (ae(e) && (e.elements.length > 0 || dt(e))) ||
     ("TSTypeAssertion" === e.type && ei(e.expression)) ||
     (Dt(e) && ei(e.expression)) ||
     "FunctionExpression" === e.type ||
     ("ArrowFunctionExpression" === e.type &&
      (!e.returnType ||
       !e.returnType.typeAnnotation ||
       "TSTypeReference" !== e.returnType.typeAnnotation.type ||
       (function (e) {
        return "BlockStatement" === e.type && (e.body.some((e) => "EmptyStatement" !== e.type) || dt(e, ct.Dangling));
       })(e.body)) &&
      ("BlockStatement" === e.body.type || ("ArrowFunctionExpression" === e.body.type && ei(e.body, !0)) || oe(e.body) || ae(e.body) || (!t && (Fe(e.body) || "ConditionalExpression" === e.body.type)) || ge(e.body))) ||
     "DoExpression" === e.type ||
     "ModuleExpression" === e.type
    );
   }
   function ti(e) {
    var t;
    if ("ParenthesizedExpression" === e.type) return ti(e.expression);
    if (Dt(e) || "TypeCastExpression" === e.type) {
     let { typeAnnotation: r } = e;
     return "TypeAnnotation" === r.type && (r = r.typeAnnotation), "TSArrayType" === r.type && ((r = r.elementType), "TSArrayType" === r.type && (r = r.elementType)), ("GenericTypeAnnotation" === r.type || "TSTypeReference" === r.type) && 1 === (null == (t = r.typeParameters) ? void 0 : t.params.length) && (r = r.typeParameters.params[0]), Te(r) && We(e.expression, 1);
    }
    return !(yt(e) && at(e).length > 1) && (ve(e) ? We(e.left, 1) && We(e.right, 1) : ce(e) || We(e));
   }
   var ri = function (e, t, r) {
     let { node: n } = e,
      s = at(n);
     if (0 === s.length) return ["(", Cs(e, t), ")"];
     if (
      (function (e) {
       return 2 === e.length && "ArrowFunctionExpression" === e[0].type && 0 === st(e[0]).length && "BlockStatement" === e[0].body.type && "ArrayExpression" === e[1].type && !e.some((e) => dt(e));
      })(s)
     )
      return ["(", r(["arguments", 0]), ", ", r(["arguments", 1]), ")"];
     let i = !1,
      a = s.length - 1,
      o = [];
     ot(e, ({ node: e }, n) => {
      let s = r();
      n === a || (mt(e, t) ? ((i = !0), (s = [s, ",", cr, cr])) : (s = [s, ",", lr])), o.push(s);
     });
     let u = "ImportExpression" !== n.type && "Import" !== n.callee.type && Ke(t, "all") ? "," : "";
     function l() {
      return Qt(["(", Xt([lr, ...o]), u, lr, ")"], { shouldBreak: !0 });
     }
     if (
      i ||
      ("Decorator" !== e.parent.type &&
       (function (e) {
        if (e.length <= 1) return !1;
        let t = 0;
        for (let r of e)
         if (me(r)) {
          if (((t += 1), t > 1)) return !0;
         } else if (Fe(r)) for (let e of at(r)) if (me(e)) return !0;
        return !1;
       })(s))
     )
      return l();
     if (
      (function (e) {
       if (2 !== e.length) return !1;
       let [t, r] = e;
       return (
        !(
         "ModuleExpression" !== t.type ||
         !(function (e) {
          return "ObjectExpression" === e.type && 1 === e.properties.length && gt(e.properties[0]) && "Identifier" === e.properties[0].key.type && "type" === e.properties[0].key.name && pe(e.properties[0].value) && "module" === e.properties[0].value.value;
         })(r)
        ) ||
        (!dt(t) && ("FunctionExpression" === t.type || ("ArrowFunctionExpression" === t.type && "BlockStatement" === t.body.type)) && "FunctionExpression" !== r.type && "ArrowFunctionExpression" !== r.type && "ConditionalExpression" !== r.type && ti(r) && !ei(r))
       );
      })(s)
     ) {
      let e,
       t = o.slice(1);
      if (t.some(br)) return l();
      try {
       e = r(ut(n, 0), { expandFirstArg: !0 });
      } catch (c) {
       if (c instanceof Zs) return l();
       throw c;
      }
      return br(e) ? [or, tr([["(", Qt(e, { shouldBreak: !0 }), ", ", ...t, ")"], l()])] : tr([["(", e, ", ", ...t, ")"], ["(", Qt(e, { shouldBreak: !0 }), ", ", ...t, ")"], l()]);
     }
     if (
      (function (e, t, r) {
       var n, s;
       let i = D(!1, e, -1);
       if (1 === e.length) {
        let e = D(!1, t, -1);
        if (null != (n = e.label) && n.embed && !1 !== (null == (s = e.label) ? void 0 : s.hug)) return !0;
       }
       let a = D(!1, e, -2);
       return !dt(i, ct.Leading) && !dt(i, ct.Trailing) && ei(i) && (!a || a.type !== i.type) && (2 !== e.length || "ArrowFunctionExpression" !== a.type || !ae(i)) && !(e.length > 1 && Xi(i, r));
      })(s, o, t)
     ) {
      let e,
       t = o.slice(0, -1);
      if (t.some(br)) return l();
      try {
       e = r(ut(n, -1), { expandLastArg: !0 });
      } catch (c) {
       if (c instanceof Zs) return l();
       throw c;
      }
      return br(e) ? [or, tr([["(", ...t, Qt(e, { shouldBreak: !0 }), ")"], l()])] : tr([["(", ...t, e, ")"], ["(", ...t, Qt(e, { shouldBreak: !0 }), ")"], l()]);
     }
     let p = ["(", Xt([pr, ...o]), nr(u), pr, ")"];
     return Ve(e) ? p : Qt(p, { shouldBreak: o.some(br) || i });
    },
    ni = (e) => (("ChainExpression" === e.type || "TSNonNullExpression" === e.type) && (e = e.expression), Fe(e) && at(e).length > 0);
   function si(e, t, r) {
    let n = r("property"),
     { node: s } = e,
     i = ji(e);
    return s.computed ? (!s.property || ue(s.property) ? [i, "[", n, "]"] : Qt([i, "[", Xt([pr, n]), pr, "]"])) : [i, ".", n];
   }
   var ii = function e(t, r, n) {
    if ("ChainExpression" === t.node.type) return t.call(() => e(t, r, n), "expression");
    let { parent: s } = t,
     i = !s || "ExpressionStatement" === s.type,
     a = [];
    function o(e) {
     let { originalText: t } = r,
      n = Lr(t, $(e));
     return ")" === t.charAt(n) ? !1 !== n && L(t, n + 1) : mt(e, r);
    }
    function u(e) {
     let { node: t } = e;
     if ("ChainExpression" === t.type) return e.call(() => u(e), "expression");
     if (Fe(t) && (Ee(t.callee) || Fe(t.callee))) {
      let s = o(t);
      a.unshift({ node: t, hasTrailingEmptyLine: s, printed: [ws(e, [ji(e), zi(e, r, n), ri(e, r, n)], r), s ? cr : ""] }), e.call((e) => u(e), "callee");
     } else Ee(t) ? (a.unshift({ node: t, needsParens: xs(e, r), printed: ws(e, ke(t) ? si(e, 0, n) : Wi(e, r, n), r) }), e.call((e) => u(e), "object")) : "TSNonNullExpression" === t.type ? (a.unshift({ node: t, printed: ws(e, "!", r) }), e.call((e) => u(e), "expression")) : a.unshift({ node: t, printed: n() });
    }
    let { node: l } = t;
    a.unshift({ node: l, printed: [ji(t), zi(t, r, n), ri(t, r, n)] }), l.callee && t.call((e) => u(e), "callee");
    let p = [],
     c = [a[0]],
     h = 1;
    for (; h < a.length && ("TSNonNullExpression" === a[h].node.type || Fe(a[h].node) || (ke(a[h].node) && a[h].node.computed && ue(a[h].node.property))); ++h) c.push(a[h]);
    if (!Fe(a[0].node)) for (; h + 1 < a.length && Ee(a[h].node) && Ee(a[h + 1].node); ++h) c.push(a[h]);
    p.push(c), (c = []);
    let d = !1;
    for (; h < a.length; ++h) {
     if (d && Ee(a[h].node)) {
      if (a[h].node.computed && ue(a[h].node.property)) {
       c.push(a[h]);
       continue;
      }
      p.push(c), (c = []), (d = !1);
     }
     (Fe(a[h].node) || "ImportExpression" === a[h].node.type) && (d = !0), c.push(a[h]), dt(a[h].node, ct.Trailing) && (p.push(c), (c = []), (d = !1));
    }
    function f(e) {
     return /^[A-Z]|^[$_]+$/.test(e);
    }
    c.length > 0 && p.push(c);
    let m =
     p.length >= 2 &&
     !dt(p[1][0].node) &&
     (function (e) {
      var t;
      let n = null == (t = e[1][0]) ? void 0 : t.node.computed;
      if (1 === e[0].length) {
       let t = e[0][0].node;
       return (
        "ThisExpression" === t.type ||
        ("Identifier" === t.type &&
         (f(t.name) ||
          (i &&
           (function (e) {
            return e.length <= r.tabWidth;
           })(t.name)) ||
          n))
       );
      }
      let s = D(!1, e[0], -1).node;
      return ke(s) && "Identifier" === s.property.type && (f(s.property.name) || n);
     })(p);
    function y(e) {
     let t = e.map((e) => e.printed);
     return e.length > 0 && D(!1, e, -1).needsParens ? ["(", ...t, ")"] : t;
    }
    let g = p.map(y),
     x = g,
     b = m ? 3 : 2,
     v = p.flat(),
     E = v.slice(1, -1).some((e) => dt(e.node, ct.Leading)) || v.slice(0, -1).some((e) => dt(e.node, ct.Trailing)) || (p[b] && dt(p[b][0].node, ct.Leading));
    if (p.length <= b && !E && !p.some((e) => D(!1, e, -1).hasTrailingEmptyLine)) return Ve(t) ? x : Qt(x);
    let C = D(!1, p[m ? 1 : 0], -1).node,
     T = !Fe(C) && o(C),
     w = [y(p[0]), m ? p.slice(1, 2).map(y) : "", T ? cr : "", ((A = p.slice(m ? 2 : 1)), 0 === A.length ? "" : Xt([cr, fr(cr, A.map(y))]))],
     S = a.map(({ node: e }) => e).filter(Fe);
    var A;
    let F;
    return (
     (F =
      E ||
      (S.length > 2 && S.some((e) => !e.arguments.every((e) => We(e)))) ||
      g.slice(0, -1).some(br) ||
      (function () {
       let e = D(!1, D(!1, p, -1), -1).node,
        t = D(!1, g, -1);
       return Fe(e) && br(t) && S.slice(0, -1).some((e) => e.arguments.some(me));
      })()
       ? Qt(w)
       : [br(x) || T ? or : "", tr([x, w])]),
     mr({ memberChain: !0 }, F)
    );
   };
   function ai(e, t, r) {
    var n;
    let { node: s, parent: i } = e,
     a = "NewExpression" === s.type,
     o = "ImportExpression" === s.type,
     u = ji(e),
     l = at(s),
     p = 1 === l.length && Ue(l[0], t.originalText);
    if (
     p ||
     (l.length > 0 &&
      !a &&
      !o &&
      ((function (e, t) {
       if ("Identifier" !== e.callee.type) return !1;
       if ("require" === e.callee.name) {
        let t = at(e);
        return (1 === t.length && pe(t[0])) || t.length > 1;
       }
       if ("define" === e.callee.name) {
        let r = at(e);
        return "ExpressionStatement" === t.type && (1 === r.length || (2 === r.length && "ArrayExpression" === r[0].type) || (3 === r.length && pe(r[0]) && "ArrayExpression" === r[1].type));
       }
       return !1;
      })(s, i) ||
       Se(s, i)))
    ) {
     let s = [];
     if (
      (ot(e, () => {
       s.push(r());
      }),
      !p || null == (n = s[0].label) || !n.embed)
     )
      return [a ? "new " : "", r("callee"), u, zi(e, t, r), "(", fr(", ", s), ")"];
    }
    if (!o && !a && Ee(s.callee) && !e.call((e) => xs(e, t), "callee", ...("ChainExpression" === s.callee.type ? ["expression"] : []))) return ii(e, t, r);
    let c = [a ? "new " : "", o ? oi(s) : r("callee"), u, zi(e, t, r), ri(e, t, r)];
    return o || Fe(s.callee) ? Qt(c) : c;
   }
   function oi(e) {
    return e.phase ? `import.${e.phase}` : "import";
   }
   function ui(e, t, r, n, s, i) {
    let a = (function (e, t, r, n, s) {
      let { node: i } = e,
       a = i[s];
      if (!a) return "only-left";
      let o = !li(a);
      if (e.match(li, pi, (e) => !o || ("ExpressionStatement" !== e.type && "VariableDeclaration" !== e.type))) return o ? ("ArrowFunctionExpression" === a.type && "ArrowFunctionExpression" === a.body.type ? "chain-tail-arrow-chain" : "chain-tail") : "chain";
      if ((!o && li(a.right)) || Me(t.originalText, a)) return "break-after-operator";
      if (("CallExpression" === a.type && "require" === a.callee.name) || "json5" === t.parser || "jsonc" === t.parser || "json" === t.parser) return "never-break-after-operator";
      let u = (function (e) {
       return Dr(e, Sr, !1);
      })(n);
      if (
       (function (e) {
        if (pi(e)) {
         let t = e.left || e.id;
         return (
          "ObjectPattern" === t.type &&
          t.properties.length > 2 &&
          t.properties.some((e) => {
           var t;
           return gt(e) && (!e.shorthand || "AssignmentPattern" === (null == (t = e.value) ? void 0 : t.type));
          })
         );
        }
        return !1;
       })(i) ||
       (function (e) {
        if ("VariableDeclarator" !== e.type) return !1;
        let { typeAnnotation: t } = e.id;
        if (!t || !t.typeAnnotation) return !1;
        let r = fi(t.typeAnnotation);
        return O(r) && r.length > 1 && r.some((e) => O(fi(e)) || "TSConditionalType" === e.type);
       })(i) ||
       (hi(i) && u)
      )
       return "break-lhs";
      let l = (function (e, t, r) {
       return !!gt(e) && ((t = Tr(t)), "string" == typeof t && S(t) < r.tabWidth + 3);
      })(i, n, t);
      return e.call(
       () =>
        (function (e, t, r, n) {
         let s = e.node;
         if (ve(s) && !zs(s)) return !0;
         switch (s.type) {
          case "StringLiteralTypeAnnotation":
          case "SequenceExpression":
           return !0;
          case "TSConditionalType":
          case "ConditionalTypeAnnotation":
           if (
            !t.experimentalTernaries &&
            !(function (e) {
             function t(e) {
              switch (e.type) {
               case "FunctionTypeAnnotation":
               case "GenericTypeAnnotation":
               case "TSFunctionType":
               case "TSTypeReference":
                return !!e.typeParameters;
               default:
                return !1;
              }
             }
             return t(e.checkType) || t(e.extendsType);
            })(s)
           )
            break;
           return !0;
          case "ConditionalExpression": {
           if (!t.experimentalTernaries) {
            let { test: e } = s;
            return ve(e) && !zs(e);
           }
           let { consequent: e, alternate: r } = s;
           return "ConditionalExpression" === e.type || "ConditionalExpression" === r.type;
          }
          case "ClassExpression":
           return O(s.decorators);
         }
         if (n) return !1;
         let i = s,
          a = [];
         for (;;)
          if ("UnaryExpression" === i.type || "AwaitExpression" === i.type || ("YieldExpression" === i.type && null !== i.argument)) (i = i.argument), a.push("argument");
          else {
           if ("TSNonNullExpression" !== i.type) break;
           (i = i.expression), a.push("expression");
          }
         return !(!pe(i) && !e.call(() => mi(e, t, r), ...a));
        })(e, t, r, l),
       s,
      )
       ? "break-after-operator"
       : (function (e) {
            let t = (function (e) {
             var t;
             if (ci(e)) return null == (t = e.typeParameters) ? void 0 : t.params;
            })(e);
            if (O(t)) {
             let r = "TSTypeAliasDeclaration" === e.type ? "constraint" : "bound";
             if (t.length > 1 && t.some((e) => e[r] || e.default)) return !0;
            }
            return !1;
           })(i)
         ? "break-lhs"
         : u || (!l && "TemplateLiteral" !== a.type && "TaggedTemplateExpression" !== a.type && "BooleanLiteral" !== a.type && !ue(a) && "ClassExpression" !== a.type)
           ? "fluid"
           : "never-break-after-operator";
     })(e, t, r, n, i),
     o = i ? r(i, { assignmentLayout: a }) : "";
    switch (a) {
     case "break-after-operator":
      return Qt([Qt(n), s, Qt(Xt([lr, o]))]);
     case "never-break-after-operator":
      return Qt([Qt(n), s, " ", o]);
     case "fluid": {
      let e = Symbol("assignment");
      return Qt([Qt(n), s, Qt(Xt(lr), { id: e }), ar, sr(o, { groupId: e })]);
     }
     case "break-lhs":
      return Qt([n, s, " ", Qt(o)]);
     case "chain":
      return [Qt(n), s, lr, o];
     case "chain-tail":
      return [Qt(n), s, Xt([lr, o])];
     case "chain-tail-arrow-chain":
      return [Qt(n), s, o];
     case "only-left":
      return n;
    }
   }
   function li(e) {
    return "AssignmentExpression" === e.type;
   }
   function pi(e) {
    return li(e) || "VariableDeclarator" === e.type;
   }
   var ci = G(["TSTypeAliasDeclaration", "TypeAlias"]);
   function hi(e) {
    var t;
    return "VariableDeclarator" === e.type && "ArrowFunctionExpression" === (null == (t = e.init) ? void 0 : t.type);
   }
   var di = G(["TSTypeReference", "GenericTypeAnnotation"]);
   function fi(e) {
    var t;
    if (di(e)) return null == (t = e.typeParameters) ? void 0 : t.params;
   }
   function mi(e, t, r, n = !1) {
    var s;
    let { node: i } = e,
     a = () => mi(e, t, r, !0);
    if ("ChainExpression" === i.type || "TSNonNullExpression" === i.type) return e.call(a, "expression");
    if (Fe(i)) {
     if (null != (s = ai(e, t, r).label) && s.memberChain) return !1;
     let n = at(i);
     return (
      !(
       !(0 === n.length || (1 === n.length && Oe(n[0], t))) ||
       (function (e, t) {
        let r = (function (e) {
         var t;
         return null == (t = e.typeParameters ?? e.typeArguments) ? void 0 : t.params;
        })(e);
        if (O(r)) {
         if (r.length > 1) return !0;
         if (1 === r.length) {
          let e = r[0];
          if (xt(e) || bt(e) || "TSTypeLiteral" === e.type || "ObjectTypeAnnotation" === e.type) return !0;
         }
         if (br(t(e.typeParameters ? "typeParameters" : "typeArguments"))) return !0;
        }
        return !1;
       })(i, r)
      ) && e.call(a, "callee")
     );
    }
    return ke(i) ? e.call(a, "object") : n && ("Identifier" === i.type || "ThisExpression" === i.type);
   }
   function yi(e, t, r, n, s) {
    let i = e.node,
     a = st(i),
     o = s ? zi(e, r, t) : "";
    if (0 === a.length) return [o, "(", Cs(e, r, { filter: (e) => ")" === Or(r.originalText, $(e)) }), ")"];
    let { parent: u } = e,
     l = Se(u),
     p = gi(i),
     c = [];
    if (
     ((function (e, t) {
      let { node: r } = e,
       n = 0,
       s = (e) => t(e, n++);
      r.this && e.call(s, "this"), Array.isArray(r.parameters) ? e.each(s, "parameters") : Array.isArray(r.params) && e.each(s, "params"), r.rest && e.call(s, "rest");
     })(e, (e, n) => {
      let s = n === a.length - 1;
      s && i.rest && c.push("..."), c.push(t()), !s && (c.push(","), l || p ? c.push(" ") : mt(a[n], r) ? c.push(cr, cr) : c.push(lr));
     }),
     n &&
      !(function (e) {
       return e.match(
        (e) => "ArrowFunctionExpression" === e.type && "BlockStatement" === e.body.type,
        (e, t) => {
         if ("CallExpression" === e.type && "arguments" === t && 1 === e.arguments.length && "CallExpression" === e.callee.type) {
          let t = e.callee.callee;
          return "Identifier" === t.type || ("MemberExpression" === t.type && !t.computed && "Identifier" === t.object.type && "Identifier" === t.property.type);
         }
         return !1;
        },
        (e, t) => ("VariableDeclarator" === e.type && "init" === t) || ("ExportDefaultDeclaration" === e.type && "declaration" === t) || ("TSExportAssignment" === e.type && "expression" === t) || ("AssignmentExpression" === e.type && "right" === t && "MemberExpression" === e.left.type && "Identifier" === e.left.object.type && "module" === e.left.object.name && "Identifier" === e.left.property.type && "exports" === e.left.property.name),
        (e) => "VariableDeclaration" !== e.type || ("const" === e.kind && 1 === e.declarations.length),
       );
      })(e))
    ) {
     if (br(o) || br(c)) throw new Zs();
     return Qt([Cr(o), "(", Cr(c), ")"]);
    }
    let h = a.every((e) => !O(e.decorators));
    return (p && h) || l
     ? [o, "(", ...c, ")"]
     : (be(u) ||
          (function (e) {
           return !(("TypeAnnotation" !== e.type && "TSTypeAnnotation" !== e.type) || "FunctionTypeAnnotation" !== e.typeAnnotation.type || e.static || V(e, e.typeAnnotation));
          })(u) ||
          "TypeAlias" === u.type ||
          "UnionTypeAnnotation" === u.type ||
          "IntersectionTypeAnnotation" === u.type ||
          ("FunctionTypeAnnotation" === u.type && u.returnType === i)) &&
         1 === a.length &&
         null === a[0].name &&
         i.this !== a[0] &&
         a[0].typeAnnotation &&
         null === i.typeParameters &&
         Te(a[0].typeAnnotation) &&
         !i.rest
       ? "always" === r.arrowParens
         ? ["(", ...c, ")"]
         : c
       : [o, "(", Xt([pr, ...c]), nr(!rt(i) && Ke(r, "all") ? "," : ""), pr, ")"];
   }
   function gi(e) {
    if (!e) return !1;
    let t = st(e);
    if (1 !== t.length) return !1;
    let [r] = t;
    return !dt(r) && ("ObjectPattern" === r.type || "ArrayPattern" === r.type || ("Identifier" === r.type && r.typeAnnotation && ("TypeAnnotation" === r.typeAnnotation.type || "TSTypeAnnotation" === r.typeAnnotation.type) && fe(r.typeAnnotation.typeAnnotation)) || ("FunctionTypeParam" === r.type && fe(r.typeAnnotation) && r !== e.rest) || ("AssignmentPattern" === r.type && ("ObjectPattern" === r.left.type || "ArrayPattern" === r.left.type) && ("Identifier" === r.right.type || (oe(r.right) && 0 === r.right.properties.length) || (ae(r.right) && 0 === r.right.elements.length))));
   }
   function Di(e, t) {
    var r;
    let n = (function (e) {
     let t;
     return e.returnType ? ((t = e.returnType), t.typeAnnotation && (t = t.typeAnnotation)) : e.typeAnnotation && (t = e.typeAnnotation), t;
    })(e);
    if (!n) return !1;
    let s = null == (r = e.typeParameters) ? void 0 : r.params;
    if (s) {
     if (s.length > 1) return !1;
     if (1 === s.length) {
      let e = s[0];
      if (e.constraint || e.default) return !1;
     }
    }
    return 1 === st(e).length && (fe(n) || br(t));
   }
   var xi = G(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]),
    bi = G(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
   function vi(e) {
    return (
     !(!Te(e) && !fe(e)) ||
     (!!xt(e) &&
      (function (e) {
       let { types: t } = e;
       if (t.some((e) => dt(e))) return !1;
       let r = t.find((e) => bi(e));
       return !!r && t.every((e) => e === r || xi(e));
      })(e))
    );
   }
   function Ei(e, t, r) {
    let n = t.semi ? ";" : "",
     { node: s } = e,
     i = [Ui(e)];
    return i.push("type ", r("id"), r("typeParameters")), [ui(e, t, r, i, " =", "TSTypeAliasDeclaration" === s.type ? "typeAnnotation" : "right"), n];
   }
   function Ci(e, t, r) {
    let n = !1;
    return Qt(
     e.map(({ isFirst: e, previous: t, node: s, index: i }) => {
      let a = r();
      if (e) return a;
      let o = fe(s),
       u = fe(t);
      return u && o ? [" & ", n ? Xt(a) : a] : u || o ? (i > 1 && (n = !0), [" & ", i > 1 ? Xt(a) : a]) : Xt([" &", lr, a]);
     }, "types"),
    );
   }
   function Ti(e, t, r) {
    let { node: n } = e,
     { parent: s } = e,
     i = !("TypeParameterInstantiation" === s.type || ("TSConditionalType" === s.type && t.experimentalTernaries) || ("ConditionalTypeAnnotation" === s.type && t.experimentalTernaries) || "TSTypeParameterInstantiation" === s.type || "GenericTypeAnnotation" === s.type || "TSTypeReference" === s.type || "TSTypeAssertion" === s.type || "TupleTypeAnnotation" === s.type || "TSTupleType" === s.type || ("FunctionTypeParam" === s.type && !s.name && e.grandparent.this !== s) || (("TypeAlias" === s.type || "VariableDeclarator" === s.type || "TSTypeAliasDeclaration" === s.type) && Me(t.originalText, n))),
     a = vi(n),
     o = e.map((e) => {
      let n = r();
      return a || (n = Yt(2, n)), ws(e, n, t);
     }, "types");
    if (a) return fr(" | ", o);
    let u = [nr([i && !Me(t.originalText, n) ? lr : "", "| "]), fr([lr, "| "], o)];
    return xs(e, t) ? Qt([Xt(u), pr]) : ("TupleTypeAnnotation" === s.type || "TSTupleType" === s.type) && s["TupleTypeAnnotation" === s.type && s.types ? "types" : "elementTypes"].length > 1 ? Qt([Xt([nr(["(", pr]), u]), pr, nr(")")]) : Qt(i ? Xt(u) : u);
   }
   function wi(e, t, r) {
    let { node: n } = e,
     s = [Vi(e)];
    ("TSConstructorType" === n.type || "TSConstructSignatureDeclaration" === n.type) && s.push("new ");
    let i = yi(e, r, t, !1, !0),
     a = [];
    return (
     "FunctionTypeAnnotation" === n.type
      ? a.push(
         (function (e) {
          var t;
          let { node: r, parent: n } = e;
          return "FunctionTypeAnnotation" === r.type && (be(n) || !((("ObjectTypeProperty" === n.type || "ObjectTypeInternalSlot" === n.type) && !n.variance && !n.optional && V(n, r)) || "ObjectTypeCallProperty" === n.type || "DeclareFunction" === (null == (t = e.getParentNode(2)) ? void 0 : t.type)));
         })(e)
          ? " => "
          : ": ",
         r("returnType"),
        )
      : a.push(Ni(e, r, n.returnType ? "returnType" : "typeAnnotation")),
     Di(n, a) && (i = Qt(i)),
     s.push(i, a),
     Qt(s)
    );
   }
   function Si(e, t, r) {
    return [r("objectType"), ji(e), "[", r("indexType"), "]"];
   }
   function Ai(e, t, r) {
    return ["infer ", r("typeParameter")];
   }
   function Fi(e, t, r) {
    let { node: n } = e;
    return [n.postfix ? "" : r, Ni(e, t), n.postfix ? r : ""];
   }
   function ki(e, t, r) {
    let { node: n } = e;
    return ["...", ...("TupleTypeSpreadElement" === n.type && n.label ? [r("label"), ": "] : []), r("typeAnnotation")];
   }
   function Pi(e, t, r) {
    let { node: n } = e;
    return [n.variance ? r("variance") : "", r("label"), n.optional ? "?" : "", ": ", r("elementType")];
   }
   var Ii = new WeakSet();
   function Ni(e, t, r = "typeAnnotation") {
    let {
     node: { [r]: n },
    } = e;
    if (!n) return "";
    let s = !1;
    if ("TSTypeAnnotation" === n.type || "TypeAnnotation" === n.type) {
     let t = e.call(Bi, r);
     ("=>" === t || (":" === t && dt(n, ct.Leading))) && (s = !0), Ii.add(n);
    }
    return s ? [" ", t(r)] : t(r);
   }
   var Bi = (e) =>
    e.match(
     (e) => "TSTypeAnnotation" === e.type,
     (e, t) => !(("returnType" !== t && "typeAnnotation" !== t) || ("TSFunctionType" !== e.type && "TSConstructorType" !== e.type)),
    )
     ? "=>"
     : e.match(
          (e) => "TSTypeAnnotation" === e.type,
          (e, t) => "typeAnnotation" === t && ("TSJSDocNullableType" === e.type || "TSJSDocNonNullableType" === e.type || "TSTypePredicate" === e.type),
         ) ||
         e.match(
          (e) => "TypeAnnotation" === e.type,
          (e, t) => "typeAnnotation" === t && "Identifier" === e.type,
          (e, t) => "id" === t && "DeclareFunction" === e.type,
         ) ||
         e.match(
          (e) => "TypeAnnotation" === e.type,
          (e, t) => "bound" === t && "TypeParameter" === e.type && e.usesExtendsBound,
         )
       ? ""
       : ":";
   function _i(e, t, r) {
    let n = Bi(e);
    return n ? [n, " ", r("typeAnnotation")] : r("typeAnnotation");
   }
   function Li(e) {
    return [e("elementType"), "[]"];
   }
   function Oi({ node: e }, t) {
    let r = "TSTypeQuery" === e.type ? "exprName" : "argument",
     n = "TSTypeQuery" === e.type ? "typeParameters" : "typeArguments";
    return ["typeof ", t(r), t(n)];
   }
   function Mi(e, t) {
    let { node: r } = e;
    return [r.asserts ? "asserts " : "", t("parameterName"), r.typeAnnotation ? [" is ", Ni(e, t)] : ""];
   }
   function ji(e) {
    let { node: t } = e;
    return !t.optional || ("Identifier" === t.type && t === e.parent.key) ? "" : Fe(t) || (ke(t) && t.computed) || "OptionalIndexedAccessType" === t.type ? "?." : "?";
   }
   function Ri(e) {
    return e.node.definite || e.match(void 0, (e, t) => "id" === t && "VariableDeclarator" === e.type && e.definite) ? "!" : "";
   }
   var qi = new Set(["DeclareClass", "DeclareFunction", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
   function Ui(e) {
    let { node: t } = e;
    return t.declare || (qi.has(t.type) && "DeclareExportDeclaration" !== e.parent.type) ? "declare " : "";
   }
   var $i = new Set(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
   function Vi({ node: e }) {
    return e.abstract || $i.has(e.type) ? "abstract " : "";
   }
   function zi(e, t, r) {
    let n = e.node;
    return n.typeArguments ? r("typeArguments") : n.typeParameters ? r("typeParameters") : "";
   }
   function Wi(e, t, r) {
    return ["::", r("callee")];
   }
   function Hi(e, t, r) {
    return "EmptyStatement" === e.type ? ";" : "BlockStatement" === e.type || r ? [" ", t] : Xt([lr, t]);
   }
   function Ji(e, t) {
    return ["...", t("argument"), Ni(e, t)];
   }
   function Ki(e) {
    return e.accessibility ? e.accessibility + " " : "";
   }
   function Gi(e, t, r) {
    let { node: n } = e,
     s = [],
     i = "TupleExpression" === n.type ? "#[" : "[",
     a = "TupleTypeAnnotation" === n.type && n.types ? "types" : "TSTupleType" === n.type || "TupleTypeAnnotation" === n.type ? "elementTypes" : "elements",
     o = n[a];
    if (0 === o.length)
     s.push(
      (function (e, t, r, n) {
       let { node: s } = e;
       return dt(s, ct.Dangling) ? Qt([r, Cs(e, t, { indent: !0 }), pr, n]) : [r, n];
      })(e, t, i, "]"),
     );
    else {
     let u = D(!1, o, -1),
      l = "RestElement" !== (null == u ? void 0 : u.type),
      p = null === u,
      c = Symbol("array"),
      h =
       !t.__inJestEach &&
       o.length > 1 &&
       o.every((e, t, r) => {
        let n = null == e ? void 0 : e.type;
        if (!ae(e) && !oe(e)) return !1;
        let s = r[t + 1];
        if (s && n !== s.type) return !1;
        let i = ae(e) ? "elements" : "properties";
        return e[i] && e[i].length > 1;
       }),
      d = Xi(n, t),
      f = l ? (p ? "," : Ke(t) ? (d ? nr(",", "", { groupId: c }) : nr(",")) : "") : "";
     s.push(Qt([i, Xt([pr, d ? Zi(e, t, r, f) : [Qi(e, t, a, r), f], Cs(e, t)]), pr, "]"], { shouldBreak: h, id: c }));
    }
    return s.push(ji(e), Ni(e, r)), s;
   }
   function Xi(e, t) {
    return ae(e) && e.elements.length > 1 && e.elements.every((e) => e && (ue(e) || (le(e) && !dt(e.argument))) && !dt(e, ct.Trailing | ct.Line, (e) => !N(t.originalText, U(e), { backwards: !0 })));
   }
   function Yi({ node: e }, { originalText: t }) {
    let r = (e) => ("," === t[e] ? e : r(((e) => B(t, _(t, e)))(e + 1)));
    return L(t, r($(e)));
   }
   function Qi(e, t, r, n) {
    let s = [];
    return (
     e.each(({ node: r, isLast: i }) => {
      s.push(r ? Qt(n()) : ""), i || s.push([",", lr, r && Yi(e, t) ? pr : ""]);
     }, r),
     s
    );
   }
   function Zi(e, t, r, n) {
    let s = [];
    return (
     e.each(({ isLast: i, next: a }) => {
      s.push([r(), i ? n : ","]), i || s.push(Yi(e, t) ? [cr, cr] : dt(a, ct.Leading | ct.Line) ? cr : lr);
     }, "elements"),
     rr(s)
    );
   }
   var ea = new Proxy(() => {}, { get: () => ea }),
    ta = ea;
   var ra = function (e) {
     return e
      .toLowerCase()
      .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2")
      .replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1")
      .replace(/^([+-])?\./, "$10.")
      .replace(/(\.\d+?)0+(?=e|$)/, "$1")
      .replace(/\.(?=e|$)/, "");
    },
    na = new WeakMap();
   function sa(e, t, r) {
    let { node: n } = e;
    if (n.computed) return ["[", r("key"), "]"];
    let { parent: s } = e,
     { key: i } = n;
    if ("consistent" === t.quoteProps && !na.has(s)) {
     let e = (s.properties || s.body || s.members).some((e) => !e.computed && e.key && pe(e.key) && !je(e, t));
     na.set(s, e);
    }
    if (("Identifier" === i.type || (ue(i) && Re(ra(He(i))) && String(i.value) === ra(He(i)) && "typescript" !== t.parser && "babel-ts" !== t.parser)) && ("json" === t.parser || "jsonc" === t.parser || ("consistent" === t.quoteProps && na.get(s)))) {
     let r = q(JSON.stringify("Identifier" === i.type ? i.name : i.value.toString()), t);
     return e.call((e) => ws(e, r, t), "key");
    }
    return je(n, t) && ("as-needed" === t.quoteProps || ("consistent" === t.quoteProps && !na.get(s))) ? e.call((e) => ws(e, /^\d/.test(i.value) ? ra(i.value) : i.value, t), "key") : r("key");
   }
   var ia = (e) => "FunctionExpression" === e.node.type && "value" === e.key && ((e) => "ObjectMethod" === e.type || "ClassMethod" === e.type || "ClassPrivateMethod" === e.type || "MethodDefinition" === e.type || "TSAbstractMethodDefinition" === e.type || "TSDeclareMethod" === e.type || (("Property" === e.type || "ObjectProperty" === e.type) && (e.method || "get" === e.kind || "set" === e.kind)))(e.parent);
   function aa(e, t, r, n) {
    if (ia(e)) return ua(e, r, t);
    let { node: s } = e,
     i = !1;
    if (("FunctionDeclaration" === s.type || "FunctionExpression" === s.type) && null != n && n.expandLastArg) {
     let { parent: t } = e;
     Fe(t) && (at(t).length > 1 || st(s).every((e) => "Identifier" === e.type && !e.typeAnnotation)) && (i = !0);
    }
    let a = [Ui(e), s.async ? "async " : "", `function${s.generator ? "*" : ""} `, s.id ? t("id") : ""],
     o = yi(e, t, r, i),
     u = pa(e, t),
     l = Di(s, u);
    return a.push(zi(e, 0, t), Qt([l ? Qt(o) : o, u]), s.body ? " " : "", t("body")), r.semi && (s.declare || !s.body) && a.push(";"), a;
   }
   function oa(e, t, r) {
    let { node: n } = e,
     { kind: s } = n,
     i = n.value || n,
     a = [];
    return s && "init" !== s && "method" !== s && "constructor" !== s ? (ta.ok("get" === s || "set" === s), a.push(s, " ")) : i.async && a.push("async "), i.generator && a.push("*"), a.push(sa(e, t, r), n.optional || n.key.optional ? "?" : "", n === i ? ua(e, t, r) : r("value")), a;
   }
   function ua(e, t, r) {
    let { node: n } = e,
     s = yi(e, r, t),
     i = pa(e, r),
     a = (function (e) {
      let t = st(e);
      return t.length > 1 && t.some((e) => "TSParameterProperty" === e.type);
     })(n),
     o = Di(n, i),
     u = [zi(e, 0, r), Qt([a ? Qt(s, { shouldBreak: !0 }) : o ? Qt(s) : s, i])];
    return n.body ? u.push(" ", r("body")) : u.push(t.semi ? ";" : ""), u;
   }
   function la(e, t) {
    if ("always" === t.arrowParens) return !1;
    if ("avoid" === t.arrowParens) {
     let { node: t } = e;
     return (function (e) {
      let t = st(e);
      return !(1 !== t.length || e.typeParameters || dt(e, ct.Dangling) || "Identifier" !== t[0].type || t[0].typeAnnotation || dt(t[0]) || t[0].optional || e.predicate || e.returnType);
     })(t);
    }
    return !1;
   }
   function pa(e, t) {
    let { node: r } = e,
     n = [Ni(e, t, "returnType")];
    return r.predicate && n.push(t("predicate")), n;
   }
   function ca(e, t, r) {
    let { node: n } = e,
     s = t.semi ? ";" : "",
     i = [];
    if (n.argument) {
     let e = r("argument");
     !(function (e, t) {
      if (Me(e.originalText, t) || (dt(t, ct.Leading, (t) => Mr(e.originalText, U(t), $(t))) && !ge(t))) return !0;
      if (te(t)) {
       let r,
        n = t;
       for (; (r = re(n)); ) if (((n = r), Me(e.originalText, n))) return !0;
      }
      return !1;
     })(t, n.argument)
      ? (ve(n.argument) || "SequenceExpression" === n.argument.type || (t.experimentalTernaries && "ConditionalExpression" === n.argument.type && ("ConditionalExpression" === n.argument.consequent.type || "ConditionalExpression" === n.argument.alternate.type))) && (e = Qt([nr("("), Xt([pr, e]), pr, nr(")")]))
      : (e = ["(", Xt([cr, e]), cr, ")"]),
      i.push(" ", e);
    }
    let a = dt(n, ct.Dangling),
     o = s && a && dt(n, ct.Last | ct.Line);
    return o && i.push(s), a && i.push(" ", Cs(e, t)), o || i.push(s), i;
   }
   var ha = new WeakMap();
   function da(e) {
    return ha.has(e) || ha.set(e, "ConditionalExpression" === e.type && !Ge(e, (e) => "ObjectExpression" === e.type)), ha.get(e);
   }
   var fa = (e) => "SequenceExpression" === e.type;
   function ma(e, t, r, n = {}) {
    let s,
     i,
     a = [],
     o = [],
     u = !1,
     l = !n.expandLastArg && "ArrowFunctionExpression" === e.node.body.type;
    !(function p() {
     let { node: c } = e,
      h = (function (e, t, r, n) {
       let { node: s } = e,
        i = [];
       if ((s.async && i.push("async "), la(e, t))) i.push(r(["params", 0]));
       else {
        let s = n.expandLastArg || n.expandFirstArg,
         a = pa(e, r);
        if (s) {
         if (br(a)) throw new Zs();
         a = Qt(Cr(a));
        }
        i.push(Qt([yi(e, r, t, s, !0), a]));
       }
       let a = Cs(e, t, {
        filter(e) {
         let r = Lr(t.originalText, $(e));
         return !1 !== r && "=>" === t.originalText.slice(r, r + 2);
        },
       });
       return a && i.push(" ", a), i;
      })(e, t, r, n);
     if (0 === a.length) a.push(h);
     else {
      let { leading: r, trailing: n } = Ts(e, t);
      a.push([r, h]), o.unshift(n);
     }
     l && (u || (u = (c.returnType && st(c).length > 0) || c.typeParameters || st(c).some((e) => "Identifier" !== e.type))), l && "ArrowFunctionExpression" === c.body.type ? e.call(p, "body") : ((s = r("body", n)), (i = c.body));
    })();
    let p,
     c =
      !Me(t.originalText, i) &&
      (fa(i) ||
       (function (e, t, r) {
        var n, s;
        return ae(e) || oe(e) || "ArrowFunctionExpression" === e.type || "DoExpression" === e.type || "BlockStatement" === e.type || ge(e) || (!1 !== (null == (n = t.label) ? void 0 : n.hug) && ((null == (s = t.label) ? void 0 : s.embed) || Ue(e, r.originalText)));
       })(i, s, t) ||
       (!u && da(i))),
     h = "callee" === e.key && yt(e.parent),
     d = Symbol("arrow-chain"),
     f = (function (e, t, { signatureDocs: r, shouldBreak: n }) {
      if (1 === r.length) return r[0];
      let { parent: s, key: i } = e;
      return ("callee" !== i && yt(s)) || ve(s) ? Qt([r[0], " =>", Xt([lr, fr([" =>", lr], r.slice(1))])], { shouldBreak: n }) : ("callee" === i && yt(s)) || t.assignmentLayout ? Qt(fr([" =>", lr], r), { shouldBreak: n }) : Qt(Xt(fr([" =>", lr], r)), { shouldBreak: n });
     })(e, n, { signatureDocs: a, shouldBreak: u }),
     m = !1;
    return (
     l && (h || n.assignmentLayout) && ((m = !0), (p = "chain-tail-arrow-chain" === n.assignmentLayout || (h && !c))),
     (s = (function (e, t, r, { bodyDoc: n, bodyComments: s, functionBody: i, shouldPutBodyOnSameLine: a }) {
      let { node: o, parent: u } = e,
       l = r.expandLastArg && Ke(t, "all") ? nr(",") : "",
       p = (!r.expandLastArg && "JSXExpressionContainer" !== u.type) || dt(o) ? "" : pr;
      return a && da(i) ? [" ", Qt([nr("", "("), Xt([pr, n]), nr("", ")"), l, p]), s] : (fa(i) && (n = Qt(["(", Xt([pr, n]), pr, ")"])), a ? [" ", n, s] : [Xt([lr, n, s]), l, p]);
     })(e, t, n, { bodyDoc: s, bodyComments: o, functionBody: i, shouldPutBodyOnSameLine: c })),
     Qt([Qt(m ? Xt([pr, f]) : f, { shouldBreak: p, id: d }), " =>", l ? sr(s, { groupId: d }) : Qt(s), l && h ? nr(pr, "", { groupId: d }) : ""])
    );
   }
   var ya = (e, t, r) => {
    if (!e || null != t) {
     if (t.findLast) return t.findLast(r);
     for (let e = t.length - 1; e >= 0; e--) {
      let n = t[e];
      if (r(n, e, t)) return n;
     }
    }
   };
   function ga(e, t, r, n) {
    let { node: s } = e,
     i = [],
     a = ya(!1, s[n], (e) => "EmptyStatement" !== e.type);
    return (
     e.each(({ node: e }) => {
      "EmptyStatement" !== e.type && (i.push(r()), e !== a && (i.push(cr), mt(e, t) && i.push(cr)));
     }, n),
     i
    );
   }
   function Da(e, t, r) {
    let { node: n } = e,
     s = [];
    "StaticBlock" === n.type && s.push("static "), s.push("{");
    let i = xa(e, t, r);
    if (i) s.push(Xt([cr, i]), cr);
    else {
     let { parent: t } = e,
      r = e.grandparent;
     "ArrowFunctionExpression" === t.type || "FunctionExpression" === t.type || "FunctionDeclaration" === t.type || "ObjectMethod" === t.type || "ClassMethod" === t.type || "ClassPrivateMethod" === t.type || "ForStatement" === t.type || "WhileStatement" === t.type || "DoWhileStatement" === t.type || "DoExpression" === t.type || ("CatchClause" === t.type && !r.finalizer) || "TSModuleDeclaration" === t.type || "TSDeclareFunction" === t.type || "StaticBlock" === n.type || s.push(cr);
    }
    return s.push("}"), s;
   }
   function xa(e, t, r) {
    var n;
    let { node: s } = e,
     i = O(s.directives),
     a = s.body.some((e) => "EmptyStatement" !== e.type),
     o = dt(s, ct.Dangling);
    if (!i && !a && !o) return "";
    let u = [];
    return i && (u.push(ga(e, t, r, "directives")), (a || o) && (u.push(cr), mt(D(!1, s.directives, -1), t) && u.push(cr))), a && u.push(ga(e, t, r, "body")), o && u.push(Cs(e, t)), "Program" === s.type && "ModuleExpression" !== (null == (n = e.parent) ? void 0 : n.type) && u.push(cr), u;
   }
   var ba = function (e) {
    let t = new WeakMap();
    return function (r) {
     return t.has(r) || t.set(r, Symbol(e)), t.get(r);
    };
   };
   function va(e) {
    switch (e) {
     case null:
      return "";
     case "PlusOptional":
      return "+?";
     case "MinusOptional":
      return "-?";
     case "Optional":
      return "?";
    }
   }
   function Ea(e, t) {
    return "+" === e || "-" === e ? e + t : t;
   }
   var Ca = ba("typeParameters");
   function Ta(e, t, r, n) {
    let { node: s } = e;
    if (!s[n]) return "";
    if (!Array.isArray(s[n])) return r(n);
    let i = e.getNode(2),
     a = i && Se(i),
     o = e.match(
      (e) => !(1 === e[n].length && fe(e[n][0])),
      void 0,
      (e, t) => "typeAnnotation" === t,
      (e) => "Identifier" === e.type,
      hi,
     );
    if (0 === s[n].length || (!o && (a || (1 === s[n].length && ("NullableTypeAnnotation" === s[n][0].type || vi(s[n][0])))))) return ["<", fr(", ", e.map(r, n)), wa(e, t), ">"];
    let u =
     "TSTypeParameterInstantiation" === s.type
      ? ""
      : (function (e, t, r) {
           let { node: n } = e;
           return 1 === st(n).length && n.type.startsWith("TS") && !n[r][0].constraint && "ArrowFunctionExpression" === e.parent.type && !(t.filepath && /\.ts$/.test(t.filepath));
          })(e, t, n)
        ? ","
        : Ke(t)
          ? nr(",")
          : "";
    return Qt(["<", Xt([pr, fr([",", lr], e.map(r, n))]), u, pr, ">"], { id: Ca(s) });
   }
   function wa(e, t) {
    let { node: r } = e;
    if (!dt(r, ct.Dangling)) return "";
    let n = !dt(r, ct.Line),
     s = Cs(e, t, { indent: !n });
    return n ? s : [s, cr];
   }
   function Sa(e, t, r) {
    let { node: n, parent: s } = e,
     i = ["TSTypeParameter" === n.type && n.const ? "const " : ""],
     a = "TSTypeParameter" === n.type ? r("name") : n.name;
    if ("TSMappedType" === s.type)
     return (
      s.readonly && i.push(Ea(s.readonly, "readonly"), " "),
      i.push("[", a),
      n.constraint && i.push(" in ", r("constraint")),
      s.nameType &&
       i.push(
        " as ",
        e.callParent(() => r("nameType")),
       ),
      i.push("]"),
      i
     );
    if ((n.variance && i.push(r("variance")), n.in && i.push("in "), n.out && i.push("out "), i.push(a), n.bound && (n.usesExtendsBound && i.push(" extends "), i.push(Ni(e, r, "bound"))), n.constraint)) {
     let e = Symbol("constraint");
     i.push(" extends", Qt(Xt(lr), { id: e }), ar, sr(r("constraint"), { groupId: e }));
    }
    return n.default && i.push(" = ", r("default")), Qt(i);
   }
   var Aa = G(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
   function Fa(e, t, r) {
    let { node: n } = e,
     s = [Ui(e), Vi(e), "class"],
     i = dt(n.id, ct.Trailing) || dt(n.typeParameters, ct.Trailing) || dt(n.superClass) || O(n.extends) || O(n.mixins) || O(n.implements),
     a = [],
     o = [];
    if ((n.id && a.push(" ", r("id")), a.push(r("typeParameters")), n.superClass)) {
     let n = [Ba(e, t, r), r("superTypeParameters")],
      s = e.call((e) => ["extends ", ws(e, n, t)], "superClass");
     i ? o.push(lr, Qt(s)) : o.push(" ", s);
    } else o.push(Na(e, t, r, "extends"));
    if ((o.push(Na(e, t, r, "mixins"), Na(e, t, r, "implements")), i)) {
     let e;
     (e = Ia(n) ? [...a, Xt(o)] : Xt([...a, o])), s.push(Qt(e, { id: ka(n) }));
    } else s.push(...a, ...o);
    return s.push(" ", r("body")), s;
   }
   var ka = ba("heritageGroup");
   function Pa(e) {
    return nr(cr, "", { groupId: ka(e) });
   }
   function Ia(e) {
    return (
     e.typeParameters &&
     !dt(e.typeParameters, ct.Trailing | ct.Line) &&
     !(function (e) {
      return ["extends", "mixins", "implements"].reduce((t, r) => t + (Array.isArray(e[r]) ? e[r].length : 0), e.superClass ? 1 : 0) > 1;
     })(e)
    );
   }
   function Na(e, t, r, n) {
    let { node: s } = e;
    if (!O(s[n])) return "";
    let i = Cs(e, t, { marker: n });
    return [Ia(s) ? nr(" ", lr, { groupId: Ca(s.typeParameters) }) : lr, i, i && cr, n, Qt(Xt([lr, fr([",", lr], e.map(r, n))]))];
   }
   function Ba(e, t, r) {
    let n = r("superClass"),
     { parent: s } = e;
    return "AssignmentExpression" === s.type ? Qt(nr(["(", Xt([pr, n]), pr, ")"], n)) : n;
   }
   function _a(e, t, r) {
    let { node: n } = e,
     s = [];
    return O(n.decorators) && s.push(Gs(e, t, r)), s.push(Ki(n)), n.static && s.push("static "), s.push(Vi(e)), n.override && s.push("override "), s.push(oa(e, t, r)), s;
   }
   function La(e, t, r) {
    let { node: n } = e,
     s = [],
     i = t.semi ? ";" : "";
    return O(n.decorators) && s.push(Gs(e, t, r)), s.push(Ki(n), Ui(e)), n.static && s.push("static "), s.push(Vi(e)), n.override && s.push("override "), n.readonly && s.push("readonly "), n.variance && s.push(r("variance")), ("ClassAccessorProperty" === n.type || "AccessorProperty" === n.type || "TSAbstractAccessorProperty" === n.type) && s.push("accessor "), s.push(sa(e, t, r), ji(e), Ri(e), Ni(e, r)), [ui(e, t, r, s, " =", "TSAbstractPropertyDefinition" === n.type || "TSAbstractAccessorProperty" === n.type ? void 0 : "value"), i];
   }
   function Oa(e, t, r) {
    let { node: n } = e,
     s = [];
    return (
     e.each(({ node: e, next: n, isLast: i }) => {
      s.push(r()),
       !t.semi &&
        Aa(e) &&
        (function (e, t) {
         var r;
         let { type: n, name: s } = e.key;
         if (!(e.computed || "Identifier" !== n || ("static" !== s && "get" !== s && "set" !== s) || e.value || e.typeAnnotation)) return !0;
         if (!t || t.static || t.accessibility) return !1;
         if (!t.computed) {
          let e = null == (r = t.key) ? void 0 : r.name;
          if ("in" === e || "instanceof" === e) return !0;
         }
         if (Aa(t) && t.variance && !t.static && !t.declare) return !0;
         switch (t.type) {
          case "ClassProperty":
          case "PropertyDefinition":
          case "TSAbstractPropertyDefinition":
           return t.computed;
          case "MethodDefinition":
          case "TSAbstractMethodDefinition":
          case "ClassMethod":
          case "ClassPrivateMethod": {
           if ((t.value ? t.value.async : t.async) || "get" === t.kind || "set" === t.kind) return !1;
           let e = t.value ? t.value.generator : t.generator;
           return !(!t.computed && !e);
          }
          case "TSIndexSignature":
           return !0;
         }
         return !1;
        })(e, n) &&
        s.push(";"),
       i || (s.push(cr), mt(e, t) && s.push(cr));
     }, "body"),
     dt(n, ct.Dangling) && s.push(Cs(e, t)),
     [O(n.body) ? Pa(e.parent) : "", "{", s.length > 0 ? [Xt([cr, s]), cr] : "", "}"]
    );
   }
   function Ma(e, t) {
    if (t.semi || Ra(e, t) || Ua(e, t)) return !1;
    let { node: r, key: n, parent: s } = e;
    return !("ExpressionStatement" !== r.type || (("body" !== n || ("Program" !== s.type && "BlockStatement" !== s.type && "StaticBlock" !== s.type && "TSModuleBlock" !== s.type)) && ("consequent" !== n || "SwitchCase" !== s.type)) || !e.call(() => ja(e, t), "expression"));
   }
   function ja(e, t) {
    let { node: r } = e;
    switch (r.type) {
     case "ParenthesizedExpression":
     case "TypeCastExpression":
     case "ArrayExpression":
     case "ArrayPattern":
     case "TemplateLiteral":
     case "TemplateElement":
     case "RegExpLiteral":
      return !0;
     case "ArrowFunctionExpression":
      if (!la(e, t)) return !0;
      break;
     case "UnaryExpression": {
      let { prefix: e, operator: t } = r;
      if (e && ("+" === t || "-" === t)) return !0;
      break;
     }
     case "BindExpression":
      if (!r.object) return !0;
      break;
     case "Literal":
      if (r.regex) return !0;
      break;
     default:
      if (ge(r)) return !0;
    }
    return !!xs(e, t) || (!!te(r) && e.call(() => ja(e, t), ...ne(r)));
   }
   function Ra({ node: e, parent: t }, r) {
    return ("markdown" === r.parentParser || "mdx" === r.parentParser) && "ExpressionStatement" === e.type && ge(e.expression) && "Program" === t.type && 1 === t.body.length;
   }
   function qa(e) {
    switch (e.type) {
     case "MemberExpression":
      switch (e.property.type) {
       case "Identifier":
       case "NumericLiteral":
       case "StringLiteral":
        return qa(e.object);
      }
      return !1;
     case "Identifier":
      return !0;
     default:
      return !1;
    }
   }
   function Ua({ node: e, parent: t }, r) {
    return ("__vue_event_binding" === r.parser || "__vue_ts_event_binding" === r.parser) && "ExpressionStatement" === e.type && "Program" === t.type && 1 === t.body.length;
   }
   function $a(e, t, r) {
    let n = [r("expression")];
    return Ua(e, t) ? qa(e.node.expression) && n.push(";") : Ra(e, t) || (t.semi && n.push(";")), n;
   }
   function Va(e) {
    return e.toLowerCase();
   }
   function za({ pattern: e, flags: t }) {
    return `/${e}/${(t = [...t].sort().join(""))}`;
   }
   function Wa(e, t) {
    let r = e.slice(1, -1);
    if (r.includes('"') || r.includes("'")) return e;
    let n = t.singleQuote ? "'" : '"';
    return n + r + n;
   }
   var Ha = function (e, t, r) {
    let n = e.originalText.slice(t, r);
    for (let s of e[Symbol.for("comments")]) {
     let e = U(s);
     if (e > r) break;
     let i = $(s);
     if (i < t) continue;
     let a = i - e;
     n = n.slice(0, e - t) + " ".repeat(a) + n.slice(i - t);
    }
    return n;
   };
   var Ja = (e) => "ExportDefaultDeclaration" === e.type || ("DeclareExportDeclaration" === e.type && e.default);
   function Ka(e, t, r) {
    let { node: n } = e,
     s = [Xs(e, 0, r), Ui(e), "export", Ja(n) ? " default" : ""],
     { declaration: i, exported: a } = n;
    return (
     dt(n, ct.Dangling) && (s.push(" ", Cs(e, t)), $e(n) && s.push(cr)),
     i
      ? s.push(" ", r("declaration"))
      : (s.push(
         (function (e) {
          return Xa(e.exportKind);
         })(n),
        ),
        "ExportAllDeclaration" === n.type || "DeclareExportAllDeclaration" === n.type ? (s.push(" *"), a && s.push(" as ", r("exported"))) : s.push(Za(e, t, r)),
        s.push(Qa(e, t, r), to(e, t, r))),
     s.push(
      (function (e, t) {
       return t.semi && (!e.declaration || (Ja(e) && !Ga(e.declaration))) ? ";" : "";
      })(n, t),
     ),
     s
    );
   }
   var Ga = G(["ClassDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareFunction", "TSDeclareFunction", "EnumDeclaration"]);
   function Xa(e, t = !0) {
    return e && "value" !== e ? `${t ? " " : ""}${e}${t ? "" : " "}` : "";
   }
   function Ya(e, t) {
    return Xa(e.importKind, t);
   }
   function Qa(e, t, r) {
    let { node: n } = e;
    if (!n.source) return "";
    let s = [];
    return eo(n, t) && s.push(" from"), s.push(" ", r("source")), s;
   }
   function Za(e, t, r) {
    let { node: n } = e;
    if (!eo(n, t)) return "";
    let s = [" "];
    if (O(n.specifiers)) {
     let i = [],
      a = [];
     e.each(() => {
      let t = e.node.type;
      if ("ExportNamespaceSpecifier" === t || "ExportDefaultSpecifier" === t || "ImportNamespaceSpecifier" === t || "ImportDefaultSpecifier" === t) i.push(r());
      else {
       if ("ExportSpecifier" !== t && "ImportSpecifier" !== t) throw new As(n, "specifier");
       a.push(r());
      }
     }, "specifiers"),
      s.push(fr(", ", i)),
      a.length > 0 && (i.length > 0 && s.push(", "), a.length > 1 || i.length > 0 || n.specifiers.some((e) => dt(e)) ? s.push(Qt(["{", Xt([t.bracketSpacing ? lr : pr, fr([",", lr], a)]), nr(Ke(t) ? "," : ""), t.bracketSpacing ? lr : pr, "}"])) : s.push(["{", t.bracketSpacing ? " " : "", ...a, t.bracketSpacing ? " " : "", "}"]));
    } else s.push("{}");
    return s;
   }
   function eo(e, t) {
    return !("ImportDeclaration" === e.type && !O(e.specifiers) && "type" !== e.importKind) || Ha(t, U(e), U(e.source)).trimEnd().endsWith("from");
   }
   function to(e, t, r) {
    let { node: n } = e;
    if (!n.source) return "";
    let s = (function (e, t) {
     var r, n;
     if (null != (r = e.extra) && r.deprecatedAssertSyntax) return "assert";
     let s = Ha(t, $(e.source), null != (n = e.attributes) && n[0] ? U(e.attributes[0]) : $(e)).trimStart();
     return s.startsWith("assert") ? "assert" : s.startsWith("with") || O(e.attributes) ? "with" : void 0;
    })(n, t);
    if (!s) return "";
    let i = [` ${s} {`];
    return O(n.attributes) && (t.bracketSpacing && i.push(" "), i.push(fr(", ", e.map(r, "attributes"))), t.bracketSpacing && i.push(" ")), i.push("}"), i;
   }
   function ro(e, t, r) {
    let { node: n } = e,
     { type: s } = n,
     i = s.startsWith("Import"),
     a = i ? "imported" : "local",
     o = i ? "local" : "exported",
     u = n[a],
     l = n[o],
     p = "",
     c = "";
    return (
     "ExportNamespaceSpecifier" === s || "ImportNamespaceSpecifier" === s ? (p = "*") : u && (p = r(a)),
     l &&
      !(function (e) {
       if ("ImportSpecifier" !== e.type && "ExportSpecifier" !== e.type) return !1;
       let { local: t, ["ImportSpecifier" === e.type ? "imported" : "exported"]: r } = e;
       if (t.type !== r.type || !z(t, r)) return !1;
       if (pe(t)) return t.value === r.value && He(t) === He(r);
       if ("Identifier" === t.type) return t.name === r.name;
       return !1;
      })(n) &&
      (c = r(o)),
     [Xa("ImportSpecifier" === s ? n.importKind : n.exportKind, !1), p, p && c ? " as " : "", c]
    );
   }
   function no(e, t, r) {
    var n;
    let s = t.semi ? ";" : "",
     { node: i } = e,
     a = "ObjectTypeAnnotation" === i.type,
     o = "TSEnumDeclaration" === i.type || "EnumBooleanBody" === i.type || "EnumNumberBody" === i.type || "EnumStringBody" === i.type || "EnumSymbolBody" === i.type,
     u = ["TSTypeLiteral" === i.type || o ? "members" : "TSInterfaceBody" === i.type ? "body" : "properties"];
    a && u.push("indexers", "callProperties", "internalSlots");
    let l = u.flatMap((t) => e.map(({ node: e }) => ({ node: e, printed: r(), loc: U(e) }), t));
    u.length > 1 && l.sort((e, t) => e.loc - t.loc);
    let { parent: p, key: c } = e,
     h = a && "body" === c && ("InterfaceDeclaration" === p.type || "DeclareInterface" === p.type || "DeclareClass" === p.type),
     d = "TSInterfaceBody" === i.type || o || h || ("ObjectPattern" === i.type && "FunctionDeclaration" !== p.type && "FunctionExpression" !== p.type && "ArrowFunctionExpression" !== p.type && "ObjectMethod" !== p.type && "ClassMethod" !== p.type && "ClassPrivateMethod" !== p.type && "AssignmentPattern" !== p.type && "CatchClause" !== p.type && i.properties.some((e) => e.value && ("ObjectPattern" === e.value.type || "ArrayPattern" === e.value.type))) || ("ObjectPattern" !== i.type && l.length > 0 && Mr(t.originalText, U(i), l[0].loc)),
     f = h ? ";" : "TSInterfaceBody" === i.type || "TSTypeLiteral" === i.type ? nr(s, ";") : ",",
     m = "RecordExpression" === i.type ? "#{" : i.exact ? "{|" : "{",
     y = i.exact ? "|}" : "}",
     g = [],
     x = l.map((e) => {
      let r = [...g, Qt(e.printed)];
      return (g = [f, lr]), ("TSPropertySignature" === e.node.type || "TSMethodSignature" === e.node.type || "TSConstructSignatureDeclaration" === e.node.type || "TSCallSignatureDeclaration" === e.node.type) && dt(e.node, ct.PrettierIgnore) && g.shift(), mt(e.node, t) && g.push(cr), r;
     });
    if (i.inexact || i.hasUnknownMembers) {
     let r;
     if (dt(i, ct.Dangling)) {
      let n = dt(i, ct.Line);
      r = [Cs(e, t), n || N(t.originalText, $(D(!1, ft(i), -1))) ? cr : lr, "..."];
     } else r = ["..."];
     x.push([...g, ...r]);
    }
    let b,
     v = null == (n = D(!1, l, -1)) ? void 0 : n.node,
     E = !(i.inexact || i.hasUnknownMembers || (v && ("RestElement" === v.type || (("TSPropertySignature" === v.type || "TSCallSignatureDeclaration" === v.type || "TSMethodSignature" === v.type || "TSConstructSignatureDeclaration" === v.type) && dt(v, ct.PrettierIgnore)))));
    if (0 === x.length) {
     if (!dt(i, ct.Dangling)) return [m, y, Ni(e, r)];
     b = Qt([m, Cs(e, t, { indent: !0 }), pr, y, ji(e), Ni(e, r)]);
    } else b = [h && O(i.properties) ? Pa(p) : "", m, Xt([t.bracketSpacing ? lr : pr, ...x]), nr(E && ("," !== f || Ke(t)) ? f : ""), t.bracketSpacing ? lr : pr, y, ji(e), Ni(e, r)];
    return e.match((e) => "ObjectPattern" === e.type && !O(e.decorators), so) ||
     (fe(i) &&
      (e.match(
       void 0,
       (e, t) => "typeAnnotation" === t,
       (e, t) => "typeAnnotation" === t,
       so,
      ) ||
       e.match(void 0, (e, t) => "FunctionTypeParam" === e.type && "typeAnnotation" === t, so))) ||
     (!d &&
      e.match(
       (e) => "ObjectPattern" === e.type,
       (e) => "AssignmentExpression" === e.type || "VariableDeclarator" === e.type,
      ))
     ? b
     : Qt(b, { shouldBreak: d });
   }
   function so(e, t) {
    return ("params" === t || "parameters" === t || "this" === t || "rest" === t) && gi(e);
   }
   function io(e, t, r) {
    let { node: n } = e,
     s = "ConditionalExpression" === n.type,
     i = s ? "alternate" : "falseType",
     { parent: a } = e,
     o = s ? r("test") : [r("checkType"), " ", "extends", " ", r("extendsType")];
    return a.type === n.type && a[i] === n ? Yt(2, o) : o;
   }
   var ao = new Map([
    ["AssignmentExpression", "right"],
    ["VariableDeclarator", "init"],
    ["ReturnStatement", "argument"],
    ["ThrowStatement", "argument"],
    ["UnaryExpression", "argument"],
    ["YieldExpression", "argument"],
    ["AwaitExpression", "argument"],
   ]);
   function oo(e, t, r) {
    let n,
     s,
     { node: i } = e,
     a = "ConditionalExpression" === i.type,
     o = a ? "consequent" : "trueType",
     u = a ? "alternate" : "falseType",
     l = a ? ["test"] : ["checkType", "extendsType"],
     p = i[o],
     c = i[u],
     h = [],
     d = !1,
     { parent: f } = e,
     m = f.type === i.type && l.some((e) => f[e] === i),
     y = f.type === i.type && !m,
     g = 0;
    do {
     (s = n || i), (n = e.getParentNode(g)), g++;
    } while (n && n.type === i.type && l.every((e) => n[e] !== s));
    let D = n || f,
     x = s;
    if (
     a &&
     (ge(i[l[0]]) ||
      ge(p) ||
      ge(c) ||
      (function (e) {
       let t = [e];
       for (let r = 0; r < t.length; r++) {
        let e = t[r];
        for (let r of ["test", "consequent", "alternate"]) {
         let n = e[r];
         if (ge(n)) return !0;
         "ConditionalExpression" === n.type && t.push(n);
        }
       }
       return !1;
      })(x))
    ) {
     (d = !0), (y = !0);
     let e = (e) => [nr("("), Xt([pr, e]), pr, nr(")")],
      t = (e) => "NullLiteral" === e.type || ("Literal" === e.type && null === e.value) || ("Identifier" === e.type && "undefined" === e.name);
     h.push(" ? ", t(p) ? r(o) : e(r(o)), " : ", c.type === i.type || t(c) ? r(u) : e(r(u)));
    } else {
     let e = (e) => (t.useTabs ? Xt(r(e)) : Yt(2, r(e))),
      n = [lr, "? ", p.type === i.type ? nr("", "(") : "", e(o), p.type === i.type ? nr("", ")") : "", lr, ": ", e(u)];
     h.push(f.type !== i.type || f[u] === i || m ? n : t.useTabs ? er(Xt(n)) : Yt(Math.max(0, t.tabWidth - 2), n));
    }
    let b = [o, u, ...l].some((e) => dt(i[e], (e) => X(e) && Mr(t.originalText, U(e), $(e)))),
     v = !d && (ke(f) || ("NGPipeExpression" === f.type && f.left === i)) && !f.computed,
     E = (function (e) {
      let { node: t } = e;
      if ("ConditionalExpression" !== t.type) return !1;
      let r,
       n = t;
      for (let s = 0; !r; s++) {
       let t = e.getParentNode(s);
       ("ChainExpression" === t.type && t.expression === n) || (Fe(t) && t.callee === n) || (ke(t) && t.object === n) || ("TSNonNullExpression" === t.type && t.expression === n) ? (n = t) : ("NewExpression" === t.type && t.callee === n) || (Dt(t) && t.expression === n) ? ((r = e.getParentNode(s + 1)), (n = t)) : (r = t);
      }
      return n !== t && r[ao.get(r.type)] === n;
     })(e),
     C = ((T = [io(e, 0, r), y ? h : Xt(h), a && v && !E ? pr : ""]), f === D ? Qt(T, { shouldBreak: b }) : b ? [T, or] : T);
    var T;
    return m || E ? Qt([Xt([pr, C]), pr]) : C;
   }
   var uo = new Map([
    ["AssignmentExpression", "right"],
    ["VariableDeclarator", "init"],
    ["ReturnStatement", "argument"],
    ["ThrowStatement", "argument"],
    ["UnaryExpression", "argument"],
    ["YieldExpression", "argument"],
    ["AwaitExpression", "argument"],
   ]);
   var lo = (e) => [nr("("), Xt([pr, e]), pr, nr(")")];
   function po(e, t, r, n) {
    if (!t.experimentalTernaries) return oo(e, t, r);
    let s,
     i,
     { node: a } = e,
     o = "ConditionalExpression" === a.type,
     u = "TSConditionalType" === a.type || "ConditionalTypeAnnotation" === a.type,
     l = o ? "consequent" : "trueType",
     p = o ? "alternate" : "falseType",
     c = o ? ["test"] : ["checkType", "extendsType"],
     h = a[l],
     d = a[p],
     f = c.map((e) => a[e]),
     { parent: m } = e,
     y = m.type === a.type,
     g = y && c.some((e) => m[e] === a),
     D = y && m[p] === a,
     x = h.type === a.type,
     b = d.type === a.type,
     v = b || D,
     E = t.tabWidth > 2 || t.useTabs,
     C = 0;
    do {
     (i = s || a), (s = e.getParentNode(C)), C++;
    } while (s && s.type === a.type && c.every((e) => s[e] !== i));
    let T = s || m,
     w = n && n.assignmentLayout && "break-after-operator" !== n.assignmentLayout && ("AssignmentExpression" === m.type || "VariableDeclarator" === m.type || "ClassProperty" === m.type || "PropertyDefinition" === m.type || "ClassPrivateProperty" === m.type || "ObjectProperty" === m.type || "Property" === m.type),
     S = ("ReturnStatement" === m.type || "ThrowStatement" === m.type) && !(x || b),
     A = o && "JSXExpressionContainer" === T.type && "JSXAttribute" !== e.grandparent.type,
     F = (function (e) {
      let { node: t } = e;
      if ("ConditionalExpression" !== t.type) return !1;
      let r,
       n = t;
      for (let s = 0; !r; s++) {
       let t = e.getParentNode(s);
       ("ChainExpression" === t.type && t.expression === n) || (Fe(t) && t.callee === n) || (ke(t) && t.object === n) || ("TSNonNullExpression" === t.type && t.expression === n) ? (n = t) : ("NewExpression" === t.type && t.callee === n) || (Dt(t) && t.expression === n) ? ((r = e.getParentNode(s + 1)), (n = t)) : (r = t);
      }
      return n !== t && r[uo.get(r.type)] === n;
     })(e),
     k = (function (e, t) {
      return (ke(t) || ("NGPipeExpression" === t.type && t.left === e)) && !t.computed;
     })(a, m),
     P = u && xs(e, t),
     I = E ? (t.useTabs ? "\t" : " ".repeat(t.tabWidth - 1)) : "",
     N =
      (function (e, t, r, n) {
       return [...e.map((e) => ft(e)), ft(t), ft(r)].flat().some((e) => X(e) && Mr(n.originalText, U(e), $(e)));
      })(f, h, d, t) ||
      x ||
      b,
     B = !v && !y && !u && (A ? "NullLiteral" === h.type || ("Literal" === h.type && null === h.value) : Oe(h, t) && Be(a.test, 3)),
     _ = v || D || (u && !y) || (y && o && Be(a.test, 1)) || B,
     L = [];
    !x &&
     dt(h, ct.Dangling) &&
     e.call((e) => {
      L.push(Cs(e, t), cr);
     }, "consequent");
    let O = [];
    dt(a.test, ct.Dangling) &&
     e.call((e) => {
      O.push(Cs(e, t));
     }, "test"),
     !b &&
      dt(d, ct.Dangling) &&
      e.call((e) => {
       O.push(Cs(e, t));
      }, "alternate"),
     dt(a, ct.Dangling) && O.push(Cs(e, t));
    let M = Symbol("test"),
     j = Symbol("consequent"),
     R = Symbol("test-and-consequent"),
     q = o ? [lo(r("test")), "ConditionalExpression" === a.test.type ? or : ""] : [r("checkType"), " ", "extends", " ", "TSConditionalType" === a.extendsType.type || "ConditionalTypeAnnotation" === a.extendsType.type || "TSMappedType" === a.extendsType.type ? r("extendsType") : Qt(lo(r("extendsType")))],
     V = Qt([q, " ?"], { id: M }),
     z = r(l),
     W = Xt([x || (A && (ge(h) || y || v)) ? cr : lr, L, z]),
     H = _ ? Qt([V, v ? W : nr(W, Qt(W, { id: j }), { groupId: M })], { id: R }) : [V, W],
     J = r(p),
     K = B ? nr(J, er(lo(J)), { groupId: R }) : J,
     G = [H, O.length > 0 ? [Xt([cr, O]), cr] : b ? cr : B ? nr(lr, " ", { groupId: R }) : lr, ":", b ? " " : E ? (_ ? nr(I, nr(v || B ? " " : I, " "), { groupId: R }) : nr(I, " ")) : " ", b ? K : Qt([Xt(K), A && !B ? pr : ""]), k && !F ? pr : "", N ? or : ""];
    return w && !N ? Qt(Xt([pr, Qt(G)])) : w || S ? Qt(Xt(G)) : F || (u && g) ? Qt([Xt([pr, G]), P ? pr : ""]) : m === T ? Qt(G) : G;
   }
   function co(e, t, r, n) {
    let { node: s } = e;
    if (he(s))
     return (function (e, t) {
      let { node: r } = e;
      switch (r.type) {
       case "RegExpLiteral":
        return za(r);
       case "BigIntLiteral":
        return Va(r.extra.raw);
       case "NumericLiteral":
        return ra(r.extra.raw);
       case "StringLiteral":
        return wr(q(r.extra.raw, t));
       case "NullLiteral":
        return "null";
       case "BooleanLiteral":
        return String(r.value);
       case "DecimalLiteral":
        return ra(r.value) + "m";
       case "DirectiveLiteral":
        return Wa(r.extra.raw, t);
       case "Literal": {
        if (r.regex) return za(r.regex);
        if (r.bigint) return Va(r.raw);
        if (r.decimal) return ra(r.decimal) + "m";
        let { value: n } = r;
        return "number" == typeof n
         ? ra(r.raw)
         : "string" == typeof n
           ? (function (e) {
              if ("expression" !== e.key) return;
              let { parent: t } = e;
              return "ExpressionStatement" === t.type && t.directive;
             })(e)
             ? Wa(r.raw, t)
             : wr(q(r.raw, t))
           : String(n);
       }
      }
     })(e, t);
    let i = t.semi ? ";" : "",
     a = [];
    switch (s.type) {
     case "JsExpressionRoot":
      return r("node");
     case "JsonRoot":
      return [r("node"), cr];
     case "File":
      return (
       (function (e, t, r) {
        if (t.__isVueBindings || t.__isVueForBindingLeft) {
         let n = e.map(r, "program", "body", 0, "params");
         if (1 === n.length) return n[0];
         let s = fr([",", lr], n);
         return t.__isVueForBindingLeft ? ["(", Xt([pr, Qt(s)]), pr, ")"] : s;
        }
        if (t.__isEmbeddedTypescriptGenericParameters) {
         let t = e.map(r, "program", "body", 0, "typeParameters", "params");
         return fr([",", lr], t);
        }
       })(e, t, r) ?? r("program")
      );
     case "Program":
      return xa(e, t, r);
     case "EmptyStatement":
      return "";
     case "ExpressionStatement":
      return $a(e, t, r);
     case "ChainExpression":
      return r("expression");
     case "ParenthesizedExpression":
      return dt(s.expression) || (!oe(s.expression) && !ae(s.expression)) ? Qt(["(", Xt([pr, r("expression")]), pr, ")"]) : ["(", r("expression"), ")"];
     case "AssignmentExpression":
      return (function (e, t, r) {
       let { node: n } = e;
       return ui(e, t, r, r("left"), [" ", n.operator], "right");
      })(e, t, r);
     case "VariableDeclarator":
      return (function (e, t, r) {
       return ui(e, t, r, r("id"), " =", "init");
      })(e, t, r);
     case "BinaryExpression":
     case "LogicalExpression":
      return $s(e, t, r);
     case "AssignmentPattern":
      return [r("left"), " = ", r("right")];
     case "OptionalMemberExpression":
     case "MemberExpression":
      return (function (e, t, r) {
       var n;
       let s = r("object"),
        i = si(e, 0, r),
        { node: a } = e,
        o = e.findAncestor((e) => !(ke(e) || "TSNonNullExpression" === e.type)),
        u = e.findAncestor((e) => !("ChainExpression" === e.type || "TSNonNullExpression" === e.type)),
        l = (o && ("NewExpression" === o.type || "BindExpression" === o.type || ("AssignmentExpression" === o.type && "Identifier" !== o.left.type))) || a.computed || ("Identifier" === a.object.type && "Identifier" === a.property.type && !ke(u)) || (("AssignmentExpression" === u.type || "VariableDeclarator" === u.type) && (ni(a.object) || (null == (n = s.label) ? void 0 : n.memberChain)));
       return mr(s.label, [s, l ? i : Qt(Xt([pr, i]))]);
      })(e, 0, r);
     case "MetaProperty":
      return [r("meta"), ".", r("property")];
     case "BindExpression":
      return s.object && a.push(r("object")), a.push(Qt(Xt([pr, Wi(0, 0, r)]))), a;
     case "Identifier":
      return [s.name, ji(e), Ri(e), Ni(e, r)];
     case "V8IntrinsicIdentifier":
      return ["%", s.name];
     case "SpreadElement":
     case "SpreadElementPattern":
     case "SpreadPropertyPattern":
     case "RestElement":
      return Ji(e, r);
     case "FunctionDeclaration":
     case "FunctionExpression":
      return aa(e, r, t, n);
     case "ArrowFunctionExpression":
      return ma(e, t, r, n);
     case "YieldExpression":
      return a.push("yield"), s.delegate && a.push("*"), s.argument && a.push(" ", r("argument")), a;
     case "AwaitExpression":
      if ((a.push("await"), s.argument)) {
       a.push(" ", r("argument"));
       let { parent: t } = e;
       if ((Fe(t) && t.callee === s) || (ke(t) && t.object === s)) {
        a = [Xt([pr, ...a]), pr];
        let t = e.findAncestor((e) => "AwaitExpression" === e.type || "BlockStatement" === e.type);
        if ("AwaitExpression" !== (null == t ? void 0 : t.type) || !Ge(t.argument, (e) => e === s)) return Qt(a);
       }
      }
      return a;
     case "ExportDefaultDeclaration":
     case "ExportNamedDeclaration":
     case "ExportAllDeclaration":
      return Ka(e, t, r);
     case "ImportDeclaration":
      return (function (e, t, r) {
       let { node: n } = e;
       return ["import", n.module ? " module" : "", n.phase ? ` ${n.phase}` : "", Ya(n), Za(e, t, r), Qa(e, t, r), to(e, t, r), t.semi ? ";" : ""];
      })(e, t, r);
     case "ImportSpecifier":
     case "ExportSpecifier":
     case "ImportNamespaceSpecifier":
     case "ExportNamespaceSpecifier":
     case "ImportDefaultSpecifier":
     case "ExportDefaultSpecifier":
      return ro(e, 0, r);
     case "ImportAttribute":
      return [r("key"), ": ", r("value")];
     case "Import":
      return "import";
     case "BlockStatement":
     case "StaticBlock":
      return Da(e, t, r);
     case "ClassBody":
      return Oa(e, t, r);
     case "ThrowStatement":
      return (function (e, t, r) {
       return ["throw", ca(e, t, r)];
      })(e, t, r);
     case "ReturnStatement":
      return (function (e, t, r) {
       return ["return", ca(e, t, r)];
      })(e, t, r);
     case "NewExpression":
     case "ImportExpression":
     case "OptionalCallExpression":
     case "CallExpression":
      return ai(e, t, r);
     case "ObjectExpression":
     case "ObjectPattern":
     case "RecordExpression":
      return no(e, t, r);
     case "ObjectProperty":
     case "Property":
      return s.method || "get" === s.kind || "set" === s.kind
       ? oa(e, t, r)
       : (function (e, t, r) {
          let { node: n } = e;
          return n.shorthand ? r("value") : ui(e, t, r, sa(e, t, r), ":", "value");
         })(e, t, r);
     case "ObjectMethod":
      return oa(e, t, r);
     case "Decorator":
      return ["@", r("expression")];
     case "ArrayExpression":
     case "ArrayPattern":
     case "TupleExpression":
      return Gi(e, t, r);
     case "SequenceExpression": {
      let { parent: t } = e;
      if ("ExpressionStatement" === t.type || "ForStatement" === t.type) {
       let t = [];
       return (
        e.each(({ isFirst: e }) => {
         e ? t.push(r()) : t.push(",", Xt([lr, r()]));
        }, "expressions"),
        Qt(t)
       );
      }
      return Qt(fr([",", lr], e.map(r, "expressions")));
     }
     case "ThisExpression":
      return "this";
     case "Super":
      return "super";
     case "Directive":
      return [r("value"), i];
     case "UnaryExpression":
      return a.push(s.operator), /[a-z]$/.test(s.operator) && a.push(" "), dt(s.argument) ? a.push(Qt(["(", Xt([pr, r("argument")]), pr, ")"])) : a.push(r("argument")), a;
     case "UpdateExpression":
      return a.push(r("argument"), s.operator), s.prefix && a.reverse(), a;
     case "ConditionalExpression":
      return po(e, t, r, n);
     case "VariableDeclaration": {
      let t,
       n = e.map(r, "declarations"),
       o = e.parent,
       u = "ForStatement" === o.type || "ForInStatement" === o.type || "ForOfStatement" === o.type,
       l = s.declarations.some((e) => e.init);
      return 1 !== n.length || dt(s.declarations[0]) ? n.length > 0 && (t = Xt(n[0])) : (t = n[0]), (a = [Ui(e), s.kind, t ? [" ", t] : "", Xt(n.slice(1).map((e) => [",", l && !u ? cr : lr, e]))]), (u && o.body !== s) || a.push(i), Qt(a);
     }
     case "WithStatement":
      return Qt(["with (", r("object"), ")", Hi(s.body, r("body"))]);
     case "IfStatement": {
      let n = Hi(s.consequent, r("consequent")),
       i = Qt(["if (", Qt([Xt([pr, r("test")]), pr]), ")", n]);
      if ((a.push(i), s.alternate)) {
       let n = dt(s.consequent, ct.Trailing | ct.Line) || $e(s),
        i = "BlockStatement" === s.consequent.type && !n;
       a.push(i ? " " : cr), dt(s, ct.Dangling) && a.push(Cs(e, t), n ? cr : " "), a.push("else", Qt(Hi(s.alternate, r("alternate"), "IfStatement" === s.alternate.type)));
      }
      return a;
     }
     case "ForStatement": {
      let n = Hi(s.body, r("body")),
       i = Cs(e, t),
       a = i ? [i, pr] : "";
      return s.init || s.test || s.update ? [a, Qt(["for (", Qt([Xt([pr, r("init"), ";", lr, r("test"), ";", lr, r("update")]), pr]), ")", n])] : [a, Qt(["for (;;)", n])];
     }
     case "WhileStatement":
      return Qt(["while (", Qt([Xt([pr, r("test")]), pr]), ")", Hi(s.body, r("body"))]);
     case "ForInStatement":
      return Qt(["for (", r("left"), " in ", r("right"), ")", Hi(s.body, r("body"))]);
     case "ForOfStatement":
      return Qt(["for", s.await ? " await" : "", " (", r("left"), " of ", r("right"), ")", Hi(s.body, r("body"))]);
     case "DoWhileStatement":
      return (a = [Qt(["do", Hi(s.body, r("body"))])]), "BlockStatement" === s.body.type ? a.push(" ") : a.push(cr), a.push("while (", Qt([Xt([pr, r("test")]), pr]), ")", i), a;
     case "DoExpression":
      return [s.async ? "async " : "", "do ", r("body")];
     case "BreakStatement":
     case "ContinueStatement":
      return a.push("BreakStatement" === s.type ? "break" : "continue"), s.label && a.push(" ", r("label")), a.push(i), a;
     case "LabeledStatement":
      return "EmptyStatement" === s.body.type ? [r("label"), ":;"] : [r("label"), ": ", r("body")];
     case "TryStatement":
      return ["try ", r("block"), s.handler ? [" ", r("handler")] : "", s.finalizer ? [" finally ", r("finalizer")] : ""];
     case "CatchClause":
      if (s.param) {
       let e = dt(s.param, (e) => !X(e) || (e.leading && N(t.originalText, $(e))) || (e.trailing && N(t.originalText, U(e), { backwards: !0 }))),
        n = r("param");
       return ["catch ", e ? ["(", Xt([pr, n]), pr, ") "] : ["(", n, ") "], r("body")];
      }
      return ["catch ", r("body")];
     case "SwitchStatement":
      return [
       Qt(["switch (", Xt([pr, r("discriminant")]), pr, ")"]),
       " {",
       s.cases.length > 0
        ? Xt([
           cr,
           fr(
            cr,
            e.map(({ node: e, isLast: n }) => [r(), !n && mt(e, t) ? cr : ""], "cases"),
           ),
          ])
        : "",
       cr,
       "}",
      ];
     case "SwitchCase": {
      s.test ? a.push("case ", r("test"), ":") : a.push("default:"), dt(s, ct.Dangling) && a.push(" ", Cs(e, t));
      let n = s.consequent.filter((e) => "EmptyStatement" !== e.type);
      if (n.length > 0) {
       let s = ga(e, t, r, "consequent");
       a.push(1 === n.length && "BlockStatement" === n[0].type ? [" ", s] : Xt([cr, s]));
      }
      return a;
     }
     case "DebuggerStatement":
      return ["debugger", i];
     case "ClassDeclaration":
     case "ClassExpression":
      return Fa(e, t, r);
     case "ClassMethod":
     case "ClassPrivateMethod":
     case "MethodDefinition":
      return _a(e, t, r);
     case "ClassProperty":
     case "PropertyDefinition":
     case "ClassPrivateProperty":
     case "ClassAccessorProperty":
     case "AccessorProperty":
      return La(e, t, r);
     case "TemplateElement":
      return wr(s.value.raw);
     case "TemplateLiteral":
      return Vn(e, r, t);
     case "TaggedTemplateExpression":
      return (function (e) {
       let t = e("quasi");
       return mr(t.label && { tagged: !0, ...t.label }, [e("tag"), e("typeParameters"), ar, t]);
      })(r);
     case "PrivateIdentifier":
      return ["#", s.name];
     case "PrivateName":
      return ["#", r("id")];
     case "TopicReference":
      return "%";
     case "ArgumentPlaceholder":
      return "?";
     case "ModuleExpression": {
      a.push("module {");
      let e = r("body");
      return e && a.push(Xt([cr, e]), cr), a.push("}"), a;
     }
     default:
      throw new As(s, "ESTree");
    }
   }
   function ho(e, t, r) {
    let { parent: n, node: s, key: i } = e,
     a = [r("expression")];
    switch (s.type) {
     case "AsConstExpression":
      a.push(" as const");
      break;
     case "AsExpression":
     case "TSAsExpression":
      a.push(" as ", r("typeAnnotation"));
      break;
     case "SatisfiesExpression":
     case "TSSatisfiesExpression":
      a.push(" satisfies ", r("typeAnnotation"));
    }
    return ("callee" === i && Fe(n)) || ("object" === i && ke(n)) ? Qt([Xt([pr, ...a]), pr]) : a;
   }
   function fo(e, t, r) {
    return no(e, r, t);
   }
   function mo(e, t) {
    let { node: r } = e,
     n = t("id");
    r.computed && (n = ["[", n, "]"]);
    let s = "";
    return r.initializer && (s = t("initializer")), r.init && (s = t("init")), s ? [n, " = ", s] : n;
   }
   function yo(e, t, r) {
    let { node: n } = e;
    return [Ui(e), n.const ? "const " : "", "enum ", t("id"), " ", "TSEnumDeclaration" === n.type ? fo(e, t, r) : t("body")];
   }
   function go(e, t, r) {
    let { node: n } = e,
     s = [Ui(e), "interface"],
     i = [],
     a = [];
    "InterfaceTypeAnnotation" !== n.type && i.push(" ", r("id"), r("typeParameters"));
    let o = n.typeParameters && !dt(n.typeParameters, ct.Trailing | ct.Line);
    return O(n.extends) && a.push(o ? nr(" ", lr, { groupId: Ca(n.typeParameters) }) : lr, "extends ", (1 === n.extends.length ? Je : Xt)(fr([",", lr], e.map(r, "extends")))), dt(n.id, ct.Trailing) || O(n.extends) ? (o ? s.push(Qt([...i, Xt(a)])) : s.push(Qt(Xt([...i, ...a])))) : s.push(...i, ...a), s.push(" ", r("body")), Qt(s);
   }
   function Do(e, t, r) {
    let { node: n } = e;
    if (Y(n)) return n.type.slice(0, -14).toLowerCase();
    let s = t.semi ? ";" : "";
    switch (n.type) {
     case "DeclareClass":
      return Fa(e, t, r);
     case "DeclareFunction":
      return [Ui(e), "function ", r("id"), r("predicate"), s];
     case "DeclareModule":
      return ["declare module ", r("id"), " ", r("body")];
     case "DeclareModuleExports":
      return ["declare module.exports", Ni(e, r), s];
     case "DeclareVariable":
      return [Ui(e), n.kind ?? "var", " ", r("id"), s];
     case "DeclareExportDeclaration":
     case "DeclareExportAllDeclaration":
      return Ka(e, t, r);
     case "DeclareOpaqueType":
     case "OpaqueType":
      return (function (e, t, r) {
       let n = t.semi ? ";" : "",
        { node: s } = e,
        i = [Ui(e), "opaque type ", r("id"), r("typeParameters")];
       return s.supertype && i.push(": ", r("supertype")), s.impltype && i.push(" = ", r("impltype")), i.push(n), i;
      })(e, t, r);
     case "DeclareTypeAlias":
     case "TypeAlias":
      return Ei(e, t, r);
     case "IntersectionTypeAnnotation":
      return Ci(e, 0, r);
     case "UnionTypeAnnotation":
      return Ti(e, t, r);
     case "ConditionalTypeAnnotation":
      return po(e, t, r);
     case "InferTypeAnnotation":
      return Ai(0, 0, r);
     case "FunctionTypeAnnotation":
      return wi(e, t, r);
     case "TupleTypeAnnotation":
      return Gi(e, t, r);
     case "TupleTypeLabeledElement":
      return Pi(e, 0, r);
     case "TupleTypeSpreadElement":
      return ki(e, 0, r);
     case "GenericTypeAnnotation":
      return [r("id"), Ta(e, t, r, "typeParameters")];
     case "IndexedAccessType":
     case "OptionalIndexedAccessType":
      return Si(e, 0, r);
     case "TypeAnnotation":
      return _i(e, 0, r);
     case "TypeParameter":
      return Sa(e, 0, r);
     case "TypeofTypeAnnotation":
      return Oi(e, r);
     case "ExistsTypeAnnotation":
      return "*";
     case "ArrayTypeAnnotation":
      return Li(r);
     case "DeclareEnum":
     case "EnumDeclaration":
      return yo(e, r, t);
     case "EnumBooleanBody":
     case "EnumNumberBody":
     case "EnumStringBody":
     case "EnumSymbolBody":
      return (function (e, t, r) {
       let n,
        { node: s } = e;
       if ("EnumSymbolBody" === s.type || s.explicitType)
        switch (s.type) {
         case "EnumBooleanBody":
          n = "boolean";
          break;
         case "EnumNumberBody":
          n = "number";
          break;
         case "EnumStringBody":
          n = "string";
          break;
         case "EnumSymbolBody":
          n = "symbol";
        }
       return [n ? `of ${n} ` : "", fo(e, t, r)];
      })(e, r, t);
     case "EnumBooleanMember":
     case "EnumNumberMember":
     case "EnumStringMember":
     case "EnumDefaultedMember":
      return mo(e, r);
     case "FunctionTypeParam": {
      let t = n.name ? r("name") : e.parent.this === n ? "this" : "";
      return [t, ji(e), t ? ": " : "", r("typeAnnotation")];
     }
     case "DeclareInterface":
     case "InterfaceDeclaration":
     case "InterfaceTypeAnnotation":
      return go(e, 0, r);
     case "ClassImplements":
     case "InterfaceExtends":
      return [r("id"), r("typeParameters")];
     case "NullableTypeAnnotation":
      return ["?", r("typeAnnotation")];
     case "Variance": {
      let { kind: e } = n;
      return ta.ok("plus" === e || "minus" === e), "plus" === e ? "+" : "-";
     }
     case "KeyofTypeAnnotation":
      return ["keyof ", r("argument")];
     case "ObjectTypeCallProperty":
      return [n.static ? "static " : "", r("value")];
     case "ObjectTypeMappedTypeProperty":
      return (function (e, t, r) {
       let { node: n } = e;
       return Qt([n.variance ? r("variance") : "", "[", Xt([r("keyTparam"), " in ", r("sourceType")]), "]", va(n.optional), ": ", r("propType")]);
      })(e, 0, r);
     case "ObjectTypeIndexer":
      return [n.static ? "static " : "", n.variance ? r("variance") : "", "[", r("id"), n.id ? ": " : "", r("key"), "]: ", r("value")];
     case "ObjectTypeProperty": {
      let s = "";
      return n.proto ? (s = "proto ") : n.static && (s = "static "), [s, De(n) ? n.kind + " " : "", n.variance ? r("variance") : "", sa(e, t, r), ji(e), xe(n) ? "" : ": ", r("value")];
     }
     case "ObjectTypeAnnotation":
      return no(e, t, r);
     case "ObjectTypeInternalSlot":
      return [n.static ? "static " : "", "[[", r("id"), "]]", ji(e), n.method ? "" : ": ", r("value")];
     case "ObjectTypeSpreadProperty":
      return Ji(e, r);
     case "QualifiedTypeofIdentifier":
     case "QualifiedTypeIdentifier":
      return [r("qualification"), ".", r("id")];
     case "NullLiteralTypeAnnotation":
      return "null";
     case "BooleanLiteralTypeAnnotation":
      return String(n.value);
     case "StringLiteralTypeAnnotation":
      return wr(q(He(n), t));
     case "NumberLiteralTypeAnnotation":
      return ra(n.raw ?? n.extra.raw);
     case "BigIntLiteralTypeAnnotation":
      return Va(n.raw ?? n.extra.raw);
     case "TypeCastExpression":
      return ["(", r("expression"), Ni(e, r), ")"];
     case "TypePredicate":
      return Mi(e, r);
     case "TypeParameterDeclaration":
     case "TypeParameterInstantiation":
      return Ta(e, t, r, "params");
     case "InferredPredicate":
     case "DeclaredPredicate":
      return ["predicate" !== e.key || "DeclareFunction" === e.parent.type || e.parent.returnType ? " " : ": ", "%checks", ...("DeclaredPredicate" === n.type ? ["(", r("value"), ")"] : [])];
     case "AsExpression":
     case "AsConstExpression":
     case "SatisfiesExpression":
      return ho(e, 0, r);
    }
   }
   function xo(e, t, r) {
    var n;
    let { node: s } = e;
    if (!s.type.startsWith("TS")) return;
    if (Z(s)) return s.type.slice(2, -7).toLowerCase();
    let i = t.semi ? ";" : "",
     a = [];
    switch (s.type) {
     case "TSThisType":
      return "this";
     case "TSTypeAssertion": {
      let e = !(ae(s.expression) || oe(s.expression)),
       t = Qt(["<", Xt([pr, r("typeAnnotation")]), pr, ">"]),
       n = [nr("("), Xt([pr, r("expression")]), pr, nr(")")];
      return e
       ? tr([
          [t, r("expression")],
          [t, Qt(n, { shouldBreak: !0 })],
          [t, r("expression")],
         ])
       : Qt([t, r("expression")]);
     }
     case "TSDeclareFunction":
      return aa(e, r, t);
     case "TSExportAssignment":
      return ["export = ", r("expression"), i];
     case "TSModuleBlock":
      return Da(e, t, r);
     case "TSInterfaceBody":
     case "TSTypeLiteral":
      return no(e, t, r);
     case "TSTypeAliasDeclaration":
      return Ei(e, t, r);
     case "TSQualifiedName":
      return [r("left"), ".", r("right")];
     case "TSAbstractMethodDefinition":
     case "TSDeclareMethod":
      return _a(e, t, r);
     case "TSAbstractAccessorProperty":
     case "TSAbstractPropertyDefinition":
      return La(e, t, r);
     case "TSInterfaceHeritage":
     case "TSClassImplements":
     case "TSExpressionWithTypeArguments":
     case "TSInstantiationExpression":
      return [r("expression"), r("typeParameters")];
     case "TSTemplateLiteralType":
      return Vn(e, r, t);
     case "TSNamedTupleMember":
      return Pi(e, 0, r);
     case "TSRestType":
      return ki(e, 0, r);
     case "TSOptionalType":
      return [r("typeAnnotation"), "?"];
     case "TSInterfaceDeclaration":
      return go(e, 0, r);
     case "TSTypeParameterDeclaration":
     case "TSTypeParameterInstantiation":
      return Ta(e, t, r, "params");
     case "TSTypeParameter":
      return Sa(e, 0, r);
     case "TSAsExpression":
     case "TSSatisfiesExpression":
      return ho(e, 0, r);
     case "TSArrayType":
      return Li(r);
     case "TSPropertySignature":
      return [s.readonly ? "readonly " : "", sa(e, t, r), ji(e), Ni(e, r)];
     case "TSParameterProperty":
      return [Ki(s), s.static ? "static " : "", s.override ? "override " : "", s.readonly ? "readonly " : "", r("parameter")];
     case "TSTypeQuery":
      return Oi(e, r);
     case "TSIndexSignature": {
      let n = s.parameters.length > 1 ? nr(Ke(t) ? "," : "") : "",
       a = Qt([Xt([pr, fr([", ", pr], e.map(r, "parameters"))]), n, pr]),
       o = "ClassBody" === e.parent.type && "body" === e.key;
      return [o && s.static ? "static " : "", s.readonly ? "readonly " : "", "[", s.parameters ? a : "", "]", Ni(e, r), o ? i : ""];
     }
     case "TSTypePredicate":
      return Mi(e, r);
     case "TSNonNullExpression":
      return [r("expression"), "!"];
     case "TSImportType":
      return [s.isTypeOf ? "typeof " : "", "import(", r("argument"), ")", s.qualifier ? [".", r("qualifier")] : "", Ta(e, t, r, s.typeArguments ? "typeArguments" : "typeParameters")];
     case "TSLiteralType":
      return r("literal");
     case "TSIndexedAccessType":
      return Si(e, 0, r);
     case "TSTypeOperator":
      return [s.operator, " ", r("typeAnnotation")];
     case "TSMappedType":
      return (function (e, t, r) {
       let { node: n } = e,
        s = Mr(t.originalText, U(n), U(n.typeParameter));
       return Qt(["{", Xt([t.bracketSpacing ? lr : pr, Qt([r("typeParameter"), n.optional ? Ea(n.optional, "?") : "", n.typeAnnotation ? ": " : "", r("typeAnnotation")]), t.semi ? nr(";") : ""]), Cs(e, t), t.bracketSpacing ? lr : pr, "}"], { shouldBreak: s });
      })(e, t, r);
     case "TSMethodSignature": {
      let n = s.kind && "method" !== s.kind ? `${s.kind} ` : "";
      a.push(Ki(s), n, s.computed ? "[" : "", r("key"), s.computed ? "]" : "", ji(e));
      let i = yi(e, r, t, !1, !0),
       o = s.returnType ? "returnType" : "typeAnnotation",
       u = s[o],
       l = u ? Ni(e, r, o) : "",
       p = Di(s, l);
      return a.push(p ? Qt(i) : i), u && a.push(Qt(l)), Qt(a);
     }
     case "TSNamespaceExportDeclaration":
      return ["export as namespace ", r("id"), t.semi ? ";" : ""];
     case "TSEnumDeclaration":
      return yo(e, r, t);
     case "TSEnumMember":
      return mo(e, r);
     case "TSImportEqualsDeclaration":
      return [s.isExport ? "export " : "", "import ", Ya(s, !1), r("id"), " = ", r("moduleReference"), t.semi ? ";" : ""];
     case "TSExternalModuleReference":
      return ["require(", r("expression"), ")"];
     case "TSModuleDeclaration": {
      let { parent: o } = e,
       u = "TSModuleDeclaration" === o.type,
       l = "TSModuleDeclaration" === (null == (n = s.body) ? void 0 : n.type);
      if (u) a.push(".");
      else if ((a.push(Ui(e)), "global" !== s.kind && !s.global)) {
       let e = s.kind ?? (pe(s.id) || Ha(t, U(s), U(s.id)).trim().endsWith("module") ? "module" : "namespace");
       a.push(e, " ");
      }
      return a.push(r("id")), l ? a.push(r("body")) : s.body ? a.push(" ", Qt(r("body"))) : a.push(i), a;
     }
     case "TSConditionalType":
      return po(e, t, r);
     case "TSInferType":
      return Ai(0, 0, r);
     case "TSIntersectionType":
      return Ci(e, 0, r);
     case "TSUnionType":
      return Ti(e, t, r);
     case "TSFunctionType":
     case "TSCallSignatureDeclaration":
     case "TSConstructorType":
     case "TSConstructSignatureDeclaration":
      return wi(e, t, r);
     case "TSTupleType":
      return Gi(e, t, r);
     case "TSTypeReference":
      return [r("typeName"), Ta(e, t, r, "typeParameters")];
     case "TSTypeAnnotation":
      return _i(e, 0, r);
     case "TSEmptyBodyFunctionExpression":
      return ua(e, t, r);
     case "TSJSDocAllType":
      return "*";
     case "TSJSDocUnknownType":
      return "?";
     case "TSJSDocNullableType":
      return Fi(e, r, "?");
     case "TSJSDocNonNullableType":
      return Fi(e, r, "!");
     default:
      throw new As(s, "TypeScript");
    }
   }
   var bo = G(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
   var vo = function (e, t, r, n) {
     var s;
     e.isRoot && (null == (s = t.__onHtmlBindingRoot) || s.call(t, e.node, t));
     let i = (function (e, t, r, n) {
      if (qs(e)) return fs(e, t);
      for (let s of [Hs, js, Do, xo, co]) {
       let i = s(e, t, r, n);
       if (void 0 !== i) return i;
      }
     })(e, t, r, n);
     if (!i) return "";
     let { node: a } = e;
     if (bo(a)) return i;
     let o = O(a.decorators),
      u = (function (e, t, r) {
       let { node: n, parent: s } = e,
        { decorators: i } = n;
       if (!O(i) || Qs(s) || qs(e)) return "";
       let a = "ClassExpression" === n.type || "ClassDeclaration" === n.type || Ys(n, t);
       return ["declaration" === e.key && ie(s) ? cr : a ? or : "", fr(lr, e.map(r, "decorators")), lr];
      })(e, t, r),
      l = "ClassExpression" === a.type;
     if (o && !l) return Ar(i, (e) => Qt([u, e]));
     let p = xs(e, t),
      c = Ma(e, t);
     return u || p || c ? Ar(i, (e) => [c ? ";" : "", p ? "(" : "", p && l && o ? [Xt([lr, u, e]), lr] : [u, e], p ? ")" : ""]) : i;
    },
    Eo = { avoidAstMutation: !0 },
    Co = {};
   c(Co, { getVisitorKeys: () => To, massageAstNode: () => Fo, print: () => wo });
   var To = J({ JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] });
   function wo(e, t, r) {
    let { node: n } = e;
    switch (n.type) {
     case "JsonRoot":
      return [r("node"), cr];
     case "ArrayExpression": {
      if (0 === n.elements.length) return "[]";
      let t = e.map(() => (null === e.node ? "null" : r()), "elements");
      return ["[", Xt([cr, fr([",", cr], t)]), cr, "]"];
     }
     case "ObjectExpression":
      return 0 === n.properties.length ? "{}" : ["{", Xt([cr, fr([",", cr], e.map(r, "properties"))]), cr, "}"];
     case "ObjectProperty":
      return [r("key"), ": ", r("value")];
     case "UnaryExpression":
      return ["+" === n.operator ? "" : n.operator, r("argument")];
     case "NullLiteral":
      return "null";
     case "BooleanLiteral":
      return n.value ? "true" : "false";
     case "StringLiteral":
      return JSON.stringify(n.value);
     case "NumericLiteral":
      return So(e) ? JSON.stringify(String(n.value)) : JSON.stringify(n.value);
     case "Identifier":
      return So(e) ? JSON.stringify(n.name) : n.name;
     case "TemplateLiteral":
      return r(["quasis", 0]);
     case "TemplateElement":
      return JSON.stringify(n.value.cooked);
     default:
      throw new As(n, "JSON");
    }
   }
   function So(e) {
    return "key" === e.key && "ObjectProperty" === e.parent.type;
   }
   var Ao = new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
   function Fo(e, t) {
    let { type: r } = e;
    if ("ObjectProperty" !== r) {
     if ("UnaryExpression" === r && "+" === e.operator) return t.argument;
     if ("ArrayExpression" !== r) return "TemplateLiteral" === r ? { type: "StringLiteral", value: e.quasis[0].value.cooked } : void 0;
     for (let [r, n] of e.elements.entries()) null === n && t.elements.splice(r, 0, { type: "NullLiteral" });
    } else {
     let { key: r } = e;
     "Identifier" === r.type ? (t.key = { type: "StringLiteral", value: r.name }) : "NumericLiteral" === r.type && (t.key = { type: "StringLiteral", value: String(r.value) });
    }
   }
   Fo.ignoredProperties = Ao;
   var ko = {
     bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." },
     singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." },
     proseWrap: {
      category: "Common",
      type: "choice",
      default: "preserve",
      description: "How to wrap prose.",
      choices: [
       { value: "always", description: "Wrap prose if it exceeds the print width." },
       { value: "never", description: "Do not wrap prose." },
       { value: "preserve", description: "Wrap prose as-is." },
      ],
     },
     bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." },
     singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." },
    },
    Po = "JavaScript",
    Io = {
     arrowParens: {
      category: Po,
      type: "choice",
      default: "always",
      description: "Include parentheses around a sole arrow function parameter.",
      choices: [
       { value: "always", description: "Always include parens. Example: `(x) => x`" },
       { value: "avoid", description: "Omit parens when possible. Example: `x => x`" },
      ],
     },
     bracketSameLine: ko.bracketSameLine,
     bracketSpacing: ko.bracketSpacing,
     jsxBracketSameLine: { category: Po, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" },
     semi: { category: Po, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." },
     experimentalTernaries: { category: Po, type: "boolean", default: !1, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." },
     singleQuote: ko.singleQuote,
     jsxSingleQuote: { category: Po, type: "boolean", default: !1, description: "Use single quotes in JSX." },
     quoteProps: {
      category: Po,
      type: "choice",
      default: "as-needed",
      description: "Change when properties in objects are quoted.",
      choices: [
       { value: "as-needed", description: "Only add quotes around object properties where required." },
       { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." },
       { value: "preserve", description: "Respect the input use of quotes in object properties." },
      ],
     },
     trailingComma: {
      category: Po,
      type: "choice",
      default: "all",
      description: "Print trailing commas wherever possible when multi-line.",
      choices: [
       { value: "all", description: "Trailing commas wherever possible (including function arguments)." },
       { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" },
       { value: "none", description: "No trailing commas." },
      ],
     },
     singleAttributePerLine: ko.singleAttributePerLine,
    },
    No = { estree: y, "estree-json": Co },
    Bo = [
     { linguistLanguageId: 183, name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".wxs"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"] },
     { linguistLanguageId: 183, name: "Flow", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: [], extensions: [".js.flow"], filenames: [], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"] },
     { linguistLanguageId: 183, name: "JSX", type: "programming", tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0, aliases: void 0, extensions: [".jsx"], filenames: void 0, interpreters: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript" },
     { linguistLanguageId: 378, name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] },
     { linguistLanguageId: 94901924, name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] },
     { linguistLanguageId: 174, name: "JSON.stringify", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"], parsers: ["json-stringify"], vscodeLanguageIds: ["json"] },
     { linguistLanguageId: 174, name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "flake.lock", "mcmod.info", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], parsers: ["json"], vscodeLanguageIds: ["json"] },
     { linguistLanguageId: 423, name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: ["devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json"], parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"] },
     { linguistLanguageId: 175, name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"] },
    ],
    _o = m;
  },
  80486: (e, t, r) => {
   r.d(t, { ZP: () => fs });
   var n = Object.defineProperty,
    s = (e, t) => {
     for (var r in t) n(e, r, { get: t[r], enumerable: !0 });
    },
    i = (e, t, r) => {
     if (!t.has(e)) throw TypeError("Cannot " + r);
    },
    a = (e, t, r) => (i(e, t, "read from private field"), r ? r.call(e) : t.get(e)),
    o = {};
   s(o, { languages: () => Sr, options: () => kr, parsers: () => Pr, printers: () => ds });
   var u = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    l = "string",
    p = "array",
    c = "cursor",
    h = "indent",
    d = "align",
    f = "trim",
    m = "group",
    y = "fill",
    g = "if-break",
    D = "indent-if-break",
    x = "line-suffix",
    b = "line-suffix-boundary",
    v = "line",
    E = "label",
    C = "break-parent",
    T = new Set([c, h, d, f, m, y, g, D, x, b, v, E, C]);
   var w = function (e) {
    if ("string" == typeof e) return l;
    if (Array.isArray(e)) return p;
    if (!e) return;
    let { type: t } = e;
    return T.has(t) ? t : void 0;
   };
   function S(e) {
    let t = null === e ? "null" : typeof e;
    if ("string" !== t && "object" !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (w(e)) throw new Error("doc is valid.");
    let r = Object.prototype.toString.call(e);
    if ("[object Object]" !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e))([...T].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var A = class extends Error {
     name = "InvalidDocError";
     constructor(e) {
      super(S(e)), (this.doc = e);
     }
    },
    F = () => {},
    k = F,
    P = F;
   function I(e) {
    return k(e), { type: h, contents: e };
   }
   function N(e, t) {
    return k(t), { type: d, contents: t, n: e };
   }
   function B(e, t = {}) {
    return k(e), P(t.expandedStates, !0), { type: m, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function _(e) {
    return P(e), { type: y, parts: e };
   }
   function L(e, t = "", r = {}) {
    return k(e), "" !== t && k(t), { type: g, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   var O = { type: C },
    M = { type: v },
    j = { type: v, soft: !0 },
    R = [{ type: v, hard: !0 }, O],
    q = [{ type: v, hard: !0, literal: !0 }, O];
   function U(e, t) {
    k(e), P(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   var $ = (e, t, r) => {
    if (!e || null != t) return Array.isArray(t) || "string" == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
   };
   function V(e, t) {
    if ("string" == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (w(e)) {
       case p:
        return t(e.map(n));
       case y:
        return t({ ...e, parts: e.parts.map(n) });
       case g:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case m: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case d:
       case h:
       case D:
       case E:
       case x:
        return t({ ...e, contents: n(e.contents) });
       case l:
       case c:
       case f:
       case b:
       case v:
       case C:
        return t(e);
       default:
        throw new A(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function z(e) {
    return V(e, (e) =>
     (function (e) {
      switch (w(e)) {
       case y:
        if (e.parts.every((e) => "" === e)) return "";
        break;
       case m:
        if (!(e.contents || e.id || e.break || e.expandedStates)) return "";
        if (e.contents.type === m && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
        break;
       case d:
       case h:
       case D:
       case x:
        if (!e.contents) return "";
        break;
       case g:
        if (!e.flatContents && !e.breakContents) return "";
        break;
       case p: {
        let t = [];
        for (let r of e) {
         if (!r) continue;
         let [e, ...n] = Array.isArray(r) ? r : [r];
         "string" == typeof e && "string" == typeof $(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...n);
        }
        return 0 === t.length ? "" : 1 === t.length ? t[0] : t;
       }
       case l:
       case c:
       case f:
       case b:
       case v:
       case E:
       case C:
        break;
       default:
        throw new A(e);
      }
      return e;
     })(e),
    );
   }
   function W(e, t = q) {
    return V(e, (e) => ("string" == typeof e ? U(t, e.split("\n")) : e));
   }
   var H = "'";
   var J = function (e, t) {
    let r = !0 === t || t === H ? H : '"',
     n = r === H ? '"' : H,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var K;
   K = new WeakMap();
   var G = class {
     constructor(e) {
      ((e, t, r) => {
       if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
       t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, K, void 0),
       ((e, t, r, n) => {
        i(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r);
       })(this, K, new Set(e));
     }
     getLeadingWhitespaceCount(e) {
      let t = a(this, K),
       r = 0;
      for (let n = 0; n < e.length && t.has(e.charAt(n)); n++) r++;
      return r;
     }
     getTrailingWhitespaceCount(e) {
      let t = a(this, K),
       r = 0;
      for (let n = e.length - 1; n >= 0 && t.has(e.charAt(n)); n--) r++;
      return r;
     }
     getLeadingWhitespace(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(0, t);
     }
     getTrailingWhitespace(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(e.length - t);
     }
     hasLeadingWhitespace(e) {
      return a(this, K).has(e.charAt(0));
     }
     hasTrailingWhitespace(e) {
      return a(this, K).has($(!1, e, -1));
     }
     trimStart(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(t);
     }
     trimEnd(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(0, e.length - t);
     }
     trim(e) {
      return this.trimEnd(this.trimStart(e));
     }
     split(e, t = !1) {
      let r = `[${(function (e) {
        if ("string" != typeof e) throw new TypeError("Expected a string");
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
       })([...a(this, K)].join(""))}]+`,
       n = new RegExp(t ? `(${r})` : r);
      return e.split(n);
     }
     hasWhitespaceCharacter(e) {
      let t = a(this, K);
      return Array.prototype.some.call(e, (e) => t.has(e));
     }
     hasNonWhitespaceCharacter(e) {
      let t = a(this, K);
      return Array.prototype.some.call(e, (e) => !t.has(e));
     }
     isWhitespaceOnly(e) {
      let t = a(this, K);
      return Array.prototype.every.call(e, (e) => t.has(e));
     }
    },
    X = new G(["\t", "\n", "\f", "\r", " "]),
    Y = class extends Error {
     name = "UnexpectedNodeError";
     constructor(e, t, r = "type") {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    };
   var Q = function (e) {
     return "front-matter" === (null == e ? void 0 : e.type);
    },
    Z = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]),
    ee = new Set(["if", "else if", "for", "switch", "case"]);
   function te(e, t) {
    var r;
    if ("text" === e.type || "comment" === e.type || Q(e) || "yaml" === e.type || "toml" === e.type) return null;
    if (("attribute" === e.type && delete t.value, "docType" === e.type && delete t.value, "angularControlFlowBlock" === e.type && null != (r = t.parameters) && r.children)) for (let n of t.parameters.children) ee.has(e.name) ? delete n.expression : (n.expression = n.expression.trim());
    "angularIcuExpression" === e.type && (t.switchValue = e.switchValue.trim());
   }
   te.ignoredProperties = Z;
   var re = te;
   var ne = async function (e, t) {
    if ("yaml" === e.lang) {
     let r = e.value.trim(),
      n = r ? await t(r, { parser: "yaml" }) : "";
     return (function (e) {
      return N({ type: "root" }, e);
     })([e.startDelimiter, R, n, n ? R : "", e.endDelimiter]);
    }
   };
   function se(e, t = !0) {
    return [I([j, e]), t ? j : ""];
   }
   function ie(e, t) {
    let r = "NGRoot" === e.type ? ("NGMicrosyntax" === e.node.type && 1 === e.node.body.length && "NGMicrosyntaxExpression" === e.node.body[0].type ? e.node.body[0].expression : e.node) : "JsExpressionRoot" === e.type ? e.node : e;
    return r && ("ObjectExpression" === r.type || "ArrayExpression" === r.type || (("__vue_expression" === t.parser || "__vue_ts_expression" === t.parser) && ("TemplateLiteral" === r.type || "StringLiteral" === r.type)));
   }
   async function ae(e, t, r, n) {
    r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
    let s = !0;
    n &&
     (r.__onHtmlBindingRoot = (e, t) => {
      s = n(e, t);
     });
    let i = await t(e, r, t);
    return s ? B(i) : se(i);
   }
   var oe = function (e, t, r, n) {
     let { node: s } = r,
      i = n.originalText.slice(s.sourceSpan.start.offset, s.sourceSpan.end.offset);
     return /^\s*$/.test(i) ? "" : ae(i, e, { parser: "__ng_directive", __isInHtmlAttribute: !1, trailingComma: "none" }, ie);
    },
    ue = (e) => String(e).split(/[/\\]/).pop();
   function le(e, t) {
    if (!t) return;
    let r = ue(t).toLowerCase();
    return e.find(({ filenames: e }) => (null == e ? void 0 : e.some((e) => e.toLowerCase() === r))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.some((e) => r.endsWith(e))));
   }
   var pe = function (e, t) {
     let r = e.plugins.flatMap((e) => e.languages ?? []),
      n =
       (function (e, t) {
        if (t) return e.find(({ name: e }) => e.toLowerCase() === t) ?? e.find(({ aliases: e }) => (null == e ? void 0 : e.includes(t))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.includes(`.${t}`)));
       })(r, t.language) ??
       le(r, t.physicalFile) ??
       le(r, t.file) ??
       void t.physicalFile;
     return null == n ? void 0 : n.parsers[0];
    },
    ce = "inline",
    he = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", marquee: "inline-block", source: "block", track: "block", details: "block", summary: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" },
    de = "normal",
    fe = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
   var me = function (e) {
     return "element" === e.type && !e.hasExplicitNamespace && !["html", "svg"].includes(e.namespace);
    },
    ye = (e) => ((e) => u(!1, e, /^[\t\f\r ]*\n/g, ""))(X.trimEnd(e)),
    ge = (e) => {
     let t = e,
      r = X.getLeadingWhitespace(t);
     r && (t = t.slice(r.length));
     let n = X.getTrailingWhitespace(t);
     return n && (t = t.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: t };
    };
   function De(e, t) {
    return !!(("ieConditionalComment" === e.type && e.lastChild && !e.lastChild.isSelfClosing && !e.lastChild.endSourceSpan) || ("ieConditionalComment" === e.type && !e.complete) || (je(e) && e.children.some((e) => "text" !== e.type && "interpolation" !== e.type)) || (He(e, t) && !ve(e) && "interpolation" !== e.type));
   }
   function xe(e) {
    return (
     !("attribute" === e.type || !e.parent || !e.prev) &&
     (function (e) {
      return "comment" === e.type && "prettier-ignore" === e.value.trim();
     })(e.prev)
    );
   }
   function be(e) {
    return "text" === e.type || "comment" === e.type;
   }
   function ve(e) {
    return "element" === e.type && ("script" === e.fullName || "style" === e.fullName || "svg:style" === e.fullName || "svg:script" === e.fullName || (me(e) && ("script" === e.name || "style" === e.name)));
   }
   function Ee(e) {
    return Re(e).startsWith("pre");
   }
   function Ce(e, t) {
    var r, n;
    let s = !(
     Q(e) ||
     "angularControlFlowBlock" === e.type ||
     ((("text" !== e.type && "interpolation" !== e.type) || !e.prev || ("text" !== e.prev.type && "interpolation" !== e.prev.type)) &&
      (!e.parent ||
       "none" === e.parent.cssDisplay ||
       (!je(e.parent) &&
        ((!e.prev &&
         ("root" === e.parent.type ||
          (je(e) && e.parent) ||
          ve(e.parent) ||
          ze(e.parent, t) ||
          !(function (e) {
           return !Me(e) && "inline-block" !== e;
          })(e.parent.cssDisplay))) ||
         (e.prev &&
          !(function (e) {
           return !Me(e);
          })(e.prev.cssDisplay))))))
    );
    return s && !e.prev && null != (n = null == (r = e.parent) ? void 0 : r.tagDefinition) && n.ignoreFirstLf ? "interpolation" === e.type : s;
   }
   function Te(e, t) {
    return (
     !Q(e) &&
     "angularControlFlowBlock" !== e.type &&
     (!(("text" !== e.type && "interpolation" !== e.type) || !e.next || ("text" !== e.next.type && "interpolation" !== e.next.type)) ||
      (!(!e.parent || "none" === e.parent.cssDisplay) &&
       (!!je(e.parent) ||
        !(
         (!e.next &&
          ("root" === e.parent.type ||
           (je(e) && e.parent) ||
           ve(e.parent) ||
           ze(e.parent, t) ||
           !(function (e) {
            return !Me(e) && "inline-block" !== e;
           })(e.parent.cssDisplay))) ||
         (e.next &&
          !(function (e) {
           return !Me(e);
          })(e.next.cssDisplay))
        ))))
    );
   }
   function we(e) {
    return (
     (function (e) {
      return !Me(e) && "inline-block" !== e;
     })(e.cssDisplay) && !ve(e)
    );
   }
   function Se(e) {
    return Q(e) || (e.next && e.sourceSpan.end && e.sourceSpan.end.line + 1 < e.next.sourceSpan.start.line);
   }
   function Ae(e) {
    return (
     Fe(e) ||
     ("element" === e.type &&
      e.children.length > 0 &&
      (["body", "script", "style"].includes(e.name) ||
       e.children.some((e) =>
        (function (e) {
         var t;
         return null == (t = e.children) ? void 0 : t.some((e) => "text" !== e.type);
        })(e),
       ))) ||
     (e.firstChild && e.firstChild === e.lastChild && "text" !== e.firstChild.type && Ie(e.firstChild) && (!e.lastChild.isTrailingSpaceSensitive || Ne(e.lastChild)))
    );
   }
   function Fe(e) {
    return "element" === e.type && e.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e.name) || (e.cssDisplay.startsWith("table") && "table-cell" !== e.cssDisplay));
   }
   function ke(e) {
    return (
     Be(e) ||
     (e.prev &&
      (function (e) {
       return Be(e) || ("element" === e.type && "br" === e.fullName) || Pe(e);
      })(e.prev)) ||
     Pe(e)
    );
   }
   function Pe(e) {
    return Ie(e) && Ne(e);
   }
   function Ie(e) {
    return e.hasLeadingSpaces && (e.prev ? e.prev.sourceSpan.end.line < e.sourceSpan.start.line : "root" === e.parent.type || e.parent.startSourceSpan.end.line < e.sourceSpan.start.line);
   }
   function Ne(e) {
    return e.hasTrailingSpaces && (e.next ? e.next.sourceSpan.start.line > e.sourceSpan.end.line : "root" === e.parent.type || (e.parent.endSourceSpan && e.parent.endSourceSpan.start.line > e.sourceSpan.end.line));
   }
   function Be(e) {
    switch (e.type) {
     case "ieConditionalComment":
     case "comment":
     case "directive":
      return !0;
     case "element":
      return ["script", "select"].includes(e.name);
    }
    return !1;
   }
   function _e(e) {
    return e.lastChild ? _e(e.lastChild) : e;
   }
   function Le(e) {
    if (e)
     switch (e) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "application/javascript":
       return "babel";
      case "application/x-typescript":
       return "typescript";
      case "text/markdown":
       return "markdown";
      case "text/html":
       return "html";
      case "text/x-handlebars-template":
       return "glimmer";
      default:
       if (e.endsWith("json") || e.endsWith("importmap") || "speculationrules" === e) return "json";
     }
   }
   function Oe(e, t) {
    return (
     (function (e, t) {
      let { name: r, attrMap: n } = e;
      if ("script" !== r || Object.prototype.hasOwnProperty.call(n, "src")) return;
      let { type: s, lang: i } = e.attrMap;
      return i || s ? pe(t, { language: i }) ?? Le(s) : "babel";
     })(e, t) ??
     (function (e, t) {
      if ("style" !== e.name) return;
      let { lang: r } = e.attrMap;
      return r ? pe(t, { language: r }) : "css";
     })(e, t) ??
     (function (e, t) {
      if (!He(e, t)) return;
      let { attrMap: r } = e;
      if (Object.prototype.hasOwnProperty.call(r, "src")) return;
      let { type: n, lang: s } = r;
      return pe(t, { language: s }) ?? Le(n);
     })(e, t)
    );
   }
   function Me(e) {
    return "block" === e || "list-item" === e || e.startsWith("table");
   }
   function je(e) {
    return Re(e).startsWith("pre");
   }
   function Re(e) {
    return ("element" === e.type && (!e.namespace || me(e)) && fe[e.name]) || de;
   }
   function qe(
    e,
    t = (function (e) {
     let t = Number.POSITIVE_INFINITY;
     for (let r of e.split("\n")) {
      if (0 === r.length) continue;
      let e = X.getLeadingWhitespaceCount(r);
      if (0 === e) return 0;
      r.length !== e && e < t && (t = e);
     }
     return t === Number.POSITIVE_INFINITY ? 0 : t;
    })(e),
   ) {
    return 0 === t
     ? e
     : e
        .split("\n")
        .map((e) => e.slice(t))
        .join("\n");
   }
   function Ue(e) {
    return u(!1, u(!1, e, "&apos;", "'"), "&quot;", '"');
   }
   function $e(e) {
    return Ue(e.value);
   }
   var Ve = new Set(["template", "style", "script"]);
   function ze(e, t) {
    return We(e, t) && !Ve.has(e.fullName);
   }
   function We(e, t) {
    return "vue" === t.parser && "element" === e.type && "root" === e.parent.type && "html" !== e.fullName.toLowerCase();
   }
   function He(e, t) {
    return We(e, t) && (ze(e, t) || (e.attrMap.lang && "html" !== e.attrMap.lang));
   }
   function Je(e, t = e.value) {
    return e.parent.isWhitespaceSensitive ? (e.parent.isIndentationSensitive ? W(t) : W(qe(ye(t)), R)) : U(M, X.split(t));
   }
   function Ke(e, t) {
    return We(e, t) && "script" === e.name;
   }
   var Ge = /{{(.+?)}}/s;
   function Xe({ parser: e }) {
    return (t, r, n) => ae($e(n.node), t, { parser: e, trailingComma: "none" }, ie);
   }
   var Ye = Xe({ parser: "__ng_action" }),
    Qe = Xe({ parser: "__ng_binding" }),
    Ze = Xe({ parser: "__ng_directive" });
   var et = function (e, t) {
    if ("angular" !== t.parser) return;
    let { node: r } = e,
     n = r.fullName;
    if ((n.startsWith("(") && n.endsWith(")")) || n.startsWith("on-")) return Ye;
    if ((n.startsWith("[") && n.endsWith("]")) || /^bind(?:on)?-/.test(n) || /^ng-(?:if|show|hide|class|style)$/.test(n)) return Qe;
    if (n.startsWith("*")) return Ze;
    let s = $e(r);
    return /^i18n(?:-.+)?$/.test(n)
     ? () => se(_(Je(r, s.trim())), !s.includes("@@"))
     : Ge.test(s)
       ? (e) =>
          (async function (e, t) {
           let r = [];
           for (let [n, s] of e.split(Ge).entries())
            if (n % 2 == 0) r.push(W(s));
            else
             try {
              r.push(B(["{{", I([M, await ae(s, t, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0, trailingComma: "none" })]), M, "}}"]));
             } catch {
              r.push("{{", W(s), "}}");
             }
           return r;
          })(s, e)
       : void 0;
   };
   var tt = function (e, t) {
    let { node: r } = e,
     n = $e(r);
    if ("class" === r.fullName && !t.parentParser && !n.includes("{{")) return () => n.trim().split(/\s+/).join(" ");
   };
   function rt(e) {
    return "\t" === e || "\n" === e || "\f" === e || "\r" === e || " " === e;
   }
   var nt = /^[ \t\n\r\u000c]+/,
    st = /^[, \t\n\r\u000c]+/,
    it = /^[^ \t\n\r\u000c]+/,
    at = /[,]+$/,
    ot = /^\d+$/,
    ut = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
   var lt = function (e) {
    let t,
     r,
     n,
     s,
     i,
     a,
     o = e.length,
     u = 0;
    function l(t) {
     let r,
      n = t.exec(e.substring(u));
     if (n) return ([r] = n), (u += r.length), r;
    }
    let p = [];
    for (;;) {
     if ((l(st), u >= o)) {
      if (0 === p.length) throw new Error("Must contain one or more image candidate strings.");
      return p;
     }
     (a = u), (t = l(it)), (r = []), "," === t.slice(-1) ? ((t = t.replace(at, "")), h()) : c();
    }
    function c() {
     for (l(nt), n = "", s = "in descriptor"; ; ) {
      if (((i = e.charAt(u)), "in descriptor" === s))
       if (rt(i)) n && (r.push(n), (n = ""), (s = "after descriptor"));
       else {
        if ("," === i) return (u += 1), n && r.push(n), void h();
        if ("(" === i) (n += i), (s = "in parens");
        else {
         if ("" === i) return n && r.push(n), void h();
         n += i;
        }
       }
      else if ("in parens" === s)
       if (")" === i) (n += i), (s = "in descriptor");
       else {
        if ("" === i) return r.push(n), void h();
        n += i;
       }
      else if ("after descriptor" === s && !rt(i)) {
       if ("" === i) return void h();
       (s = "in descriptor"), (u -= 1);
      }
      u += 1;
     }
    }
    function h() {
     let n,
      s,
      i,
      o,
      u,
      l,
      c,
      h,
      d,
      f = !1,
      m = {};
     for (o = 0; o < r.length; o++) (u = r[o]), (l = u[u.length - 1]), (c = u.substring(0, u.length - 1)), (h = parseInt(c, 10)), (d = parseFloat(c)), ot.test(c) && "w" === l ? ((n || s) && (f = !0), 0 === h ? (f = !0) : (n = h)) : ut.test(c) && "x" === l ? ((n || s || i) && (f = !0), d < 0 ? (f = !0) : (s = d)) : ot.test(c) && "h" === l ? ((i || s) && (f = !0), 0 === h ? (f = !0) : (i = h)) : (f = !0);
     if (f) throw new Error(`Invalid srcset descriptor found in "${e}" at "${u}".`);
     (m.source = { value: t, startOffset: a }), n && (m.width = { value: n }), s && (m.density = { value: s }), i && (m.height = { value: i }), p.push(m);
    }
   };
   var pt = { width: "w", height: "h", density: "x" },
    ct = Object.keys(pt);
   var ht = function (e) {
    if ("srcset" === e.node.fullName && ("img" === e.parent.fullName || "source" === e.parent.fullName))
     return () =>
      (function (e) {
       let t = lt(e),
        r = ct.filter((e) => t.some((t) => Object.prototype.hasOwnProperty.call(t, e)));
       if (r.length > 1) throw new Error("Mixed descriptor in srcset is not supported");
       let [n] = r,
        s = pt[n],
        i = t.map((e) => e.source.value),
        a = Math.max(...i.map((e) => e.length)),
        o = t.map((e) => (e[n] ? String(e[n].value) : "")),
        u = o.map((e) => {
         let t = e.indexOf(".");
         return -1 === t ? e.length : t;
        }),
        l = Math.max(...u);
       return se(
        U(
         [",", M],
         i.map((e, t) => {
          let r = [e],
           n = o[t];
          if (n) {
           let i = a - e.length + 1,
            o = l - u[t],
            p = " ".repeat(i + o);
           r.push(L(p, " "), n + s);
          }
          return r;
         }),
        ),
       );
      })($e(e.node));
   };
   function dt(e, t) {
    let { node: r } = e,
     n = $e(e.node).trim();
    if ("style" === r.fullName && !t.parentParser && !n.includes("{{")) return async (e) => se(await e(n, { parser: "css", __isHTMLStyleAttribute: !0 }));
   }
   var ft = new WeakMap();
   var mt = function (e, t) {
    let { root: r } = e;
    return (
     ft.has(r) ||
      ft.set(
       r,
       r.children.some((e) => Ke(e, t) && ["ts", "typescript"].includes(e.attrMap.lang)),
      ),
     ft.get(r)
    );
   };
   function yt(e, t, r) {
    let { node: n } = r;
    return ae(`type T<${$e(n)}> = any`, e, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: !0 }, ie);
   }
   async function gt(e, t, r, n) {
    let s = $e(r.node),
     {
      left: i,
      operator: a,
      right: o,
     } = (function (e) {
      let t = /(.*?)\s+(in|of)\s+(.*)/s,
       r = /,([^,\]}]*)(?:,([^,\]}]*))?$/,
       n = /^\(|\)$/g,
       s = e.match(t);
      if (!s) return;
      let i = {};
      if (((i.for = s[3].trim()), !i.for)) return;
      let a = u(!1, s[1].trim(), n, ""),
       o = a.match(r);
      o ? ((i.alias = a.replace(r, "")), (i.iterator1 = o[1].trim()), o[2] && (i.iterator2 = o[2].trim())) : (i.alias = a);
      let l = [i.alias, i.iterator1, i.iterator2];
      if (!l.some((e, t) => !e && (0 === t || l.slice(t + 1).some(Boolean)))) return { left: l.filter(Boolean).join(","), operator: s[2], right: i.for };
     })(s),
     l = mt(r, n);
    return [B(await ae(`function _(${i}) {}`, e, { parser: l ? "babel-ts" : "babel", __isVueForBindingLeft: !0 })), " ", a, " ", await ae(o, e, { parser: l ? "__ts_expression" : "__js_expression" })];
   }
   function Dt(e, t, { parseWithTs: r }) {
    return ae(e, t, { parser: r ? "__ts_expression" : "__js_expression" }, ie);
   }
   var xt = function (e, t) {
    if ("vue" !== t.parser) return;
    let { node: r } = e,
     n = r.fullName;
    if ("v-for" === n) return gt;
    if ("generic" === n && Ke(r.parent, t)) return yt;
    let s = $e(r),
     i = mt(e, t);
    return (function (e) {
     let t = e.fullName;
     return "#" === t.charAt(0) || "slot-scope" === t || "v-slot" === t || t.startsWith("v-slot:");
    })(r) ||
     (function (e, t) {
      let r = e.parent;
      if (!We(r, t)) return !1;
      let n = r.fullName,
       s = e.fullName;
      return ("script" === n && "setup" === s) || ("style" === n && "vars" === s);
     })(r, t)
     ? (e) =>
        (function (e, t, { parseWithTs: r }) {
         return ae(`function _(${e}) {}`, t, { parser: r ? "babel-ts" : "babel", __isVueBindings: !0 });
        })(s, e, { parseWithTs: i })
     : n.startsWith("@") || n.startsWith("v-on:")
       ? (e) =>
          (function (e, t, { parseWithTs: r }) {
           return (function (e) {
            let t = e.trim();
            return /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/.test(t) || /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$_a-z][\w$]*])*$/i.test(t);
           })(e)
            ? Dt(e, t, { parseWithTs: r })
            : ae(e, t, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, ie);
          })(s, e, { parseWithTs: i })
       : n.startsWith(":") || n.startsWith("v-bind:")
         ? (e) =>
            (function (e, t, { parseWithTs: r }) {
             return ae(e, t, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, ie);
            })(s, e, { parseWithTs: i })
         : n.startsWith("v-")
           ? (e) => Dt(s, e, { parseWithTs: i })
           : void 0;
   };
   function bt(e) {
    return async (t, r, n, s) => {
     let i = await e(t, r, n, s);
     if (i) return (i = V(i, (e) => ("string" == typeof e ? u(!1, e, '"', "&quot;") : e))), [n.node.rawName, '="', B(i), '"'];
    };
   }
   var vt = function (e, t) {
     let { node: r } = e;
     if (r.value) {
      if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(t.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || ("lwc" === t.parser && r.value.startsWith("{") && r.value.endsWith("}"))) return [r.rawName, "=", r.value];
      for (let r of [ht, dt, tt, xt, et]) {
       let n = r(e, t);
       if (n) return bt(n);
      }
     }
    },
    Et = new Proxy(() => {}, { get: () => Et }),
    Ct = Et;
   var Tt = function (e) {
    return Array.isArray(e) && e.length > 0;
   };
   function wt(e) {
    return e.sourceSpan.start.offset;
   }
   function St(e) {
    return e.sourceSpan.end.offset;
   }
   function At(e, t) {
    return [e.isSelfClosing ? "" : Ft(e, t), kt(e, t)];
   }
   function Ft(e, t) {
    return e.lastChild && Mt(e.lastChild) ? "" : [Pt(e, t), Nt(e, t)];
   }
   function kt(e, t) {
    return (e.next ? Lt(e.next) : Ot(e.parent)) ? "" : [Bt(e, t), It(e, t)];
   }
   function Pt(e, t) {
    return Ot(e) ? Bt(e.lastChild, t) : "";
   }
   function It(e, t) {
    return Mt(e) ? Nt(e.parent, t) : jt(e) ? Wt(e.next) : "";
   }
   function Nt(e, t) {
    if ((Ct(!e.isSelfClosing), _t(e, t))) return "";
    switch (e.type) {
     case "ieConditionalComment":
      return "<!";
     case "element":
      if (e.hasHtmComponentClosingTag) return "<//";
     default:
      return `</${e.rawName}`;
    }
   }
   function Bt(e, t) {
    if (_t(e, t)) return "";
    switch (e.type) {
     case "ieConditionalComment":
     case "ieConditionalEndComment":
      return "[endif]--\x3e";
     case "ieConditionalStartComment":
      return "]>\x3c!--\x3e";
     case "interpolation":
      return "}}";
     case "angularIcuExpression":
      return "}";
     case "element":
      if (e.isSelfClosing) return "/>";
     default:
      return ">";
    }
   }
   function _t(e, t) {
    return !e.isSelfClosing && !e.endSourceSpan && (xe(e) || De(e.parent, t));
   }
   function Lt(e) {
    return e.prev && "docType" !== e.prev.type && "angularControlFlowBlock" !== e.type && !be(e.prev) && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
   }
   function Ot(e) {
    var t;
    return (null == (t = e.lastChild) ? void 0 : t.isTrailingSpaceSensitive) && !e.lastChild.hasTrailingSpaces && !be(_e(e.lastChild)) && !je(e);
   }
   function Mt(e) {
    return !e.next && !e.hasTrailingSpaces && e.isTrailingSpaceSensitive && be(_e(e));
   }
   function jt(e) {
    return e.next && !be(e.next) && be(e) && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces;
   }
   function Rt(e) {
    return !e.prev && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
   }
   function qt(e, t, r) {
    var n;
    let { node: s } = e;
    if (!Tt(s.attrs)) return s.isSelfClosing ? " " : "";
    let i =
      "comment" === (null == (n = s.prev) ? void 0 : n.type) &&
      (function (e) {
       let t = e.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
       return !!t && (!t[1] || t[1].split(/\s+/));
      })(s.prev.value),
     a = "boolean" == typeof i ? () => i : Array.isArray(i) ? (e) => i.includes(e.rawName) : () => !1,
     o = e.map(({ node: e }) => (a(e) ? W(t.originalText.slice(wt(e), St(e))) : r()), "attrs"),
     u = "element" === s.type && "script" === s.fullName && 1 === s.attrs.length && "src" === s.attrs[0].fullName && 0 === s.children.length,
     l = t.singleAttributePerLine && s.attrs.length > 1 && !We(s, t) ? R : M,
     p = [I([u ? " " : M, U(l, o)])];
    return (s.firstChild && Rt(s.firstChild)) || (s.isSelfClosing && Ot(s.parent)) || u ? p.push(s.isSelfClosing ? " " : "") : p.push(t.bracketSameLine ? (s.isSelfClosing ? " " : "") : s.isSelfClosing ? M : j), p;
   }
   function Ut(e) {
    return e.firstChild && Rt(e.firstChild) ? "" : Ht(e);
   }
   function $t(e, t, r) {
    let { node: n } = e;
    return [Vt(n, t), qt(e, t, r), n.isSelfClosing ? "" : Ut(n)];
   }
   function Vt(e, t) {
    return e.prev && jt(e.prev) ? "" : [zt(e, t), Wt(e)];
   }
   function zt(e, t) {
    return Rt(e) ? Ht(e.parent) : Lt(e) ? Bt(e.prev, t) : "";
   }
   function Wt(e) {
    switch (e.type) {
     case "ieConditionalComment":
     case "ieConditionalStartComment":
      return `\x3c!--[if ${e.condition}`;
     case "ieConditionalEndComment":
      return "\x3c!--<!";
     case "interpolation":
      return "{{";
     case "docType":
      return "html" === e.value ? "<!doctype" : "<!DOCTYPE";
     case "angularIcuExpression":
      return "{";
     case "element":
      if (e.condition) return `\x3c!--[if ${e.condition}]>\x3c!--\x3e<${e.rawName}`;
     default:
      return `<${e.rawName}`;
    }
   }
   function Ht(e) {
    switch ((Ct(!e.isSelfClosing), e.type)) {
     case "ieConditionalComment":
      return "]>";
     case "element":
      if (e.condition) return ">\x3c!--<![endif]--\x3e";
     default:
      return ">";
    }
   }
   var Jt = function (e, t) {
     if (!e.endSourceSpan) return "";
     let r = e.startSourceSpan.end.offset;
     e.firstChild && Rt(e.firstChild) && (r -= Ht(e).length);
     let n = e.endSourceSpan.start.offset;
     return e.lastChild && Mt(e.lastChild) ? (n += Nt(e, t).length) : Ot(e) && (n -= Bt(e.lastChild, t).length), t.originalText.slice(r, n);
    },
    Kt = new Set(["if", "else if", "for", "switch", "case"]);
   var Gt = function (e, t) {
     let { node: r } = e;
     switch (r.type) {
      case "element":
       if (ve(r) || "interpolation" === r.type) return;
       if (!r.isSelfClosing && He(r, t)) {
        let n = Oe(r, t);
        return n
         ? async (s, i) => {
            let a = Jt(r, t),
             o = /^\s*$/.test(a),
             u = "";
            return o || ((u = await s(ye(a), { parser: n, __embeddedInHtml: !0 })), (o = "" === u)), [zt(r, t), B($t(e, t, i)), o ? "" : R, u, o ? "" : R, At(r, t), It(r, t)];
           }
         : void 0;
       }
       break;
      case "text":
       if (ve(r.parent)) {
        let e = Oe(r.parent, t);
        if (e)
         return async (n) => {
          let s = "markdown" === e ? qe(r.value.replace(/^[^\S\n]*\n/, "")) : r.value,
           i = { parser: e, __embeddedInHtml: !0 };
          if ("html" === t.parser && "babel" === e) {
           let e = "script",
            { attrMap: t } = r.parent;
           t && ("module" === t.type || ("text/babel" === t.type && "module" === t["data-type"])) && (e = "module"), (i.__babelSourceType = e);
          }
          return [O, zt(r, t), await n(s, i), It(r, t)];
         };
       } else if ("interpolation" === r.parent.type)
        return async (n) => {
         let s = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
         return "angular" === t.parser ? ((s.parser = "__ng_interpolation"), (s.trailingComma = "none")) : "vue" === t.parser ? (s.parser = mt(e, t) ? "__vue_ts_expression" : "__vue_expression") : (s.parser = "__js_expression"), [I([M, await n(r.value, s)]), r.parent.next && Lt(r.parent.next) ? " " : M];
        };
       break;
      case "attribute":
       return vt(e, t);
      case "front-matter":
       return (e) => ne(r, e);
      case "angularControlFlowBlockParameters":
       return Kt.has(e.parent.name) ? oe : void 0;
     }
    },
    Xt = null;
   function Yt(e) {
    if (null !== Xt && (Xt.property, 1)) {
     let e = Xt;
     return (Xt = Yt.prototype = null), e;
    }
    return (Xt = Yt.prototype = e ?? Object.create(null)), new Yt();
   }
   for (let ms = 0; ms <= 10; ms++) Yt();
   var Qt = function (e, t = "type") {
     return (
      (function (e) {
       Yt(e);
      })(e),
      function (r) {
       let n = r[t],
        s = e[n];
       if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
       return s;
      }
     );
    },
    Zt = Qt({ "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] });
   function er(e) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e);
   }
   var tr = new Map([
    ["if", new Set(["else if", "else"])],
    ["else if", new Set(["else if", "else"])],
    ["for", new Set(["empty"])],
    ["defer", new Set(["placeholder", "error", "loading"])],
    ["placeholder", new Set(["placeholder", "error", "loading"])],
    ["error", new Set(["placeholder", "error", "loading"])],
    ["loading", new Set(["placeholder", "error", "loading"])],
   ]);
   function rr(e) {
    let t = St(e);
    return "element" === e.type && !e.endSourceSpan && Tt(e.children) ? Math.max(t, rr($(!1, e.children, -1))) : t;
   }
   function nr(e, t, r) {
    let n = e.node;
    if (xe(n)) {
     let e = rr(n);
     return [zt(n, t), W(X.trimEnd(t.originalText.slice(wt(n) + (n.prev && jt(n.prev) ? Wt(n).length : 0), e - (n.next && Lt(n.next) ? Bt(n, t).length : 0)))), It(n, t)];
    }
    return r();
   }
   function sr(e, t) {
    return be(e) && be(t) ? (e.isTrailingSpaceSensitive ? (e.hasTrailingSpaces ? (ke(t) ? R : M) : "") : ke(t) ? R : j) : (jt(e) && (xe(t) || t.firstChild || t.isSelfClosing || ("element" === t.type && t.attrs.length > 0))) || ("element" === e.type && e.isSelfClosing && Lt(t)) ? "" : !t.isLeadingSpaceSensitive || ke(t) || (Lt(t) && e.lastChild && Mt(e.lastChild) && e.lastChild.lastChild && Mt(e.lastChild.lastChild)) ? R : t.hasLeadingSpaces ? M : j;
   }
   function ir(e, t, r) {
    let { node: n } = e;
    if (Fe(n))
     return [
      O,
      ...e.map((e) => {
       let n = e.node,
        s = n.prev ? sr(n.prev, n) : "";
       return [s ? [s, Se(n.prev) ? R : ""] : "", nr(e, t, r)];
      }, "children"),
     ];
    let s = n.children.map(() => Symbol(""));
    return e.map((e, n) => {
     let i = e.node;
     if (be(i)) {
      if (i.prev && be(i.prev)) {
       let n = sr(i.prev, i);
       if (n) return Se(i.prev) ? [R, R, nr(e, t, r)] : [n, nr(e, t, r)];
      }
      return nr(e, t, r);
     }
     let a = [],
      o = [],
      u = [],
      l = [],
      p = i.prev ? sr(i.prev, i) : "",
      c = i.next ? sr(i, i.next) : "";
     return p && (Se(i.prev) ? a.push(R, R) : p === R ? a.push(R) : be(i.prev) ? o.push(p) : o.push(L("", j, { groupId: s[n - 1] }))), c && (Se(i) ? be(i.next) && l.push(R, R) : c === R ? be(i.next) && l.push(R) : u.push(c)), [...a, B([...o, B([nr(e, t, r), ...u], { id: s[n] })]), ...l];
    }, "children");
   }
   function ar(e, t, r) {
    let { node: n } = e,
     s = [];
    (function (e) {
     let { previous: t } = e;
     return "angularControlFlowBlock" === (null == t ? void 0 : t.type) && !xe(t) && !or(t);
    })(e) && s.push("} "),
     s.push("@", n.name),
     n.parameters && s.push(" (", B(r("parameters")), ")"),
     s.push(" {");
    let i = or(n);
    return n.children.length > 0 ? ((n.firstChild.hasLeadingSpaces = !0), (n.lastChild.hasTrailingSpaces = !0), s.push(I([R, ir(e, t, r)])), i && s.push(R, "}")) : i && s.push("}"), B(s, { shouldBreak: !0 });
   }
   function or(e) {
    var t, r;
    return !("angularControlFlowBlock" === (null == (t = e.next) ? void 0 : t.type) && null != (r = tr.get(e.name)) && r.has(e.next.name));
   }
   function ur(e, t, r) {
    let { node: n } = e;
    if (De(n, t)) return [zt(n, t), B($t(e, t, r)), W(Jt(n, t)), ...At(n, t), It(n, t)];
    let s = 1 === n.children.length && ("interpolation" === n.firstChild.type || "angularIcuExpression" === n.firstChild.type) && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces,
     i = Symbol("element-attr-group-id"),
     a = (s) => B([B($t(e, t, r), { id: i }), s, At(n, t)]);
    return 0 === n.children.length
     ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? M : "")
     : a([
        Ae(n) ? O : "",
        ((o = [
         s
          ? L(j, "", { groupId: i })
          : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive
            ? M
            : "text" === n.firstChild.type && n.isWhitespaceSensitive && n.isIndentationSensitive
              ? (function (e) {
                 return N(Number.NEGATIVE_INFINITY, e);
                })(j)
              : j,
         ir(e, t, r),
        ]),
        s
         ? (function (e, t) {
            return k(e), { type: D, contents: e, groupId: t.groupId, negate: t.negate };
           })(o, { groupId: i })
         : (!ve(n) && !ze(n, t)) || "root" !== n.parent.type || "vue" !== t.parser || t.vueIndentScriptAndStyle
           ? I(o)
           : o),
        (n.next ? Lt(n.next) : Ot(n.parent)) ? (n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "") : s ? L(j, "", { groupId: i }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? M : ("comment" === n.lastChild.type || ("text" === n.lastChild.type && n.isWhitespaceSensitive && n.isIndentationSensitive)) && new RegExp(`\\n[\\t ]{${t.tabWidth * (e.ancestors.length - 1)}}$`).test(n.lastChild.value) ? "" : j,
       ]);
    var o;
   }
   function lr(e) {
    return (e >= 9 && e <= 32) || 160 == e;
   }
   function pr(e) {
    return 48 <= e && e <= 57;
   }
   function cr(e) {
    return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
   }
   function hr(e) {
    return 10 === e || 13 === e;
   }
   function dr(e) {
    return 48 <= e && e <= 55;
   }
   function fr(e) {
    return 39 === e || 34 === e || 96 === e;
   }
   var mr = /-+([a-z0-9])/g;
   var yr,
    gr,
    Dr = class e {
     constructor(e, t, r, n) {
      (this.file = e), (this.offset = t), (this.line = r), (this.col = n);
     }
     toString() {
      return null != this.offset ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
     }
     moveBy(t) {
      let r = this.file.content,
       n = r.length,
       s = this.offset,
       i = this.line,
       a = this.col;
      for (; s > 0 && t < 0; )
       if ((s--, t++, 10 == r.charCodeAt(s))) {
        i--;
        let e = r.substring(0, s - 1).lastIndexOf(String.fromCharCode(10));
        a = e > 0 ? s - e : s;
       } else a--;
      for (; s < n && t > 0; ) {
       let e = r.charCodeAt(s);
       s++, t--, 10 == e ? (i++, (a = 0)) : a++;
      }
      return new e(this.file, s, i, a);
     }
     getContext(e, t) {
      let r = this.file.content,
       n = this.offset;
      if (null != n) {
       n > r.length - 1 && (n = r.length - 1);
       let s = n,
        i = 0,
        a = 0;
       for (; i < e && n > 0 && (n--, i++, "\n" != r[n] || ++a != t); );
       for (i = 0, a = 0; i < e && s < r.length - 1 && (s++, i++, "\n" != r[s] || ++a != t); );
       return { before: r.substring(n, this.offset), after: r.substring(this.offset, s + 1) };
      }
      return null;
     }
    },
    xr = class {
     constructor(e, t) {
      (this.content = e), (this.url = t);
     }
    },
    br = class {
     constructor(e, t, r = e, n = null) {
      (this.start = e), (this.end = t), (this.fullStart = r), (this.details = n);
     }
     toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
     }
    };
   ((gr = yr || (yr = {}))[(gr.WARNING = 0)] = "WARNING"), (gr[(gr.ERROR = 1)] = "ERROR");
   var vr = class {
     constructor(e, t, r = yr.ERROR) {
      (this.span = e), (this.msg = t), (this.level = r);
     }
     contextualMessage() {
      let e = this.span.start.getContext(100, 3);
      return e ? `${this.msg} ("${e.before}[${yr[this.level]} ->]${e.after}")` : this.msg;
     }
     toString() {
      let e = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${e}`;
     }
    },
    Er = [
     function (e) {
      e.walk((e) => {
       if ("element" === e.type && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && "text" === e.children[0].type && "\n" === e.children[0].value[0]) {
        let t = e.children[0];
        1 === t.value.length ? e.removeChild(t) : (t.value = t.value.slice(1));
       }
      });
     },
     function (e) {
      let t = (e) => {
       var t, r;
       return "element" === e.type && "ieConditionalStartComment" === (null == (t = e.prev) ? void 0 : t.type) && e.prev.sourceSpan.end.offset === e.startSourceSpan.start.offset && "ieConditionalEndComment" === (null == (r = e.firstChild) ? void 0 : r.type) && e.firstChild.sourceSpan.start.offset === e.startSourceSpan.end.offset;
      };
      e.walk((e) => {
       if (e.children)
        for (let r = 0; r < e.children.length; r++) {
         let n = e.children[r];
         if (!t(n)) continue;
         let s = n.prev,
          i = n.firstChild;
         e.removeChild(s), r--;
         let a = new br(s.sourceSpan.start, i.sourceSpan.end),
          o = new br(a.start, n.sourceSpan.end);
         (n.condition = s.condition), (n.sourceSpan = o), (n.startSourceSpan = a), n.removeChild(i);
        }
      });
     },
     function (e) {
      return (function (e, t, r) {
       e.walk((e) => {
        if (e.children)
         for (let n = 0; n < e.children.length; n++) {
          let s = e.children[n];
          if ("text" !== s.type && !t(s)) continue;
          "text" !== s.type && ((s.type = "text"), (s.value = r(s)));
          let i = s.prev;
          !i || "text" !== i.type || ((i.value += s.value), (i.sourceSpan = new br(i.sourceSpan.start, s.sourceSpan.end)), e.removeChild(s), n--);
         }
       });
      })(
       e,
       (e) => "cdata" === e.type,
       (e) => `<![CDATA[${e.value}]]>`,
      );
     },
     function (e, t) {
      if ("html" === t.parser) return;
      let r = /{{(.+?)}}/s;
      e.walk((e) => {
       if (
        (function (e) {
         return e.children && !ve(e);
        })(e)
       )
        for (let t of e.children) {
         if ("text" !== t.type) continue;
         let n = t.sourceSpan.start,
          s = null,
          i = t.value.split(r);
         for (let r = 0; r < i.length; r++, n = s) {
          let a = i[r];
          r % 2 != 0 ? ((s = n.moveBy(a.length + 4)), e.insertChildBefore(t, { type: "interpolation", sourceSpan: new br(n, s), children: 0 === a.length ? [] : [{ type: "text", value: a, sourceSpan: new br(n.moveBy(2), s.moveBy(-2)) }] })) : ((s = n.moveBy(a.length)), a.length > 0 && e.insertChildBefore(t, { type: "text", value: a, sourceSpan: new br(n, s) }));
         }
         e.removeChild(t);
        }
      });
     },
     function (e) {
      e.walk((e) => {
       if (!e.children) return;
       if (0 === e.children.length || (1 === e.children.length && "text" === e.children[0].type && 0 === X.trim(e.children[0].value).length)) return (e.hasDanglingSpaces = e.children.length > 0), void (e.children = []);
       let t = (function (e) {
         return ve(e) || "interpolation" === e.type || Ee(e);
        })(e),
        r = Ee(e);
       if (!t)
        for (let n = 0; n < e.children.length; n++) {
         let t = e.children[n];
         if ("text" !== t.type) continue;
         let { leadingWhitespace: r, text: s, trailingWhitespace: i } = ge(t.value),
          a = t.prev,
          o = t.next;
         s ? ((t.value = s), (t.sourceSpan = new br(t.sourceSpan.start.moveBy(r.length), t.sourceSpan.end.moveBy(-i.length))), r && (a && (a.hasTrailingSpaces = !0), (t.hasLeadingSpaces = !0)), i && ((t.hasTrailingSpaces = !0), o && (o.hasLeadingSpaces = !0))) : (e.removeChild(t), n--, (r || i) && (a && (a.hasTrailingSpaces = !0), o && (o.hasLeadingSpaces = !0)));
        }
       (e.isWhitespaceSensitive = t), (e.isIndentationSensitive = r);
      });
     },
     function (e, t) {
      e.walk((e) => {
       e.cssDisplay = (function (e, t) {
        var r;
        if (We(e, t)) return "block";
        if ("comment" === (null == (r = e.prev) ? void 0 : r.type)) {
         let t = e.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
         if (t) return t[1];
        }
        let n = !1;
        if ("element" === e.type && "svg" === e.namespace) {
         if (
          !(function (e, t) {
           let r = e;
           for (; r; ) {
            if (t(r)) return !0;
            r = r.parent;
           }
           return !1;
          })(e, (e) => "svg:foreignObject" === e.fullName)
         )
          return "svg" === e.name ? "inline-block" : "block";
         n = !0;
        }
        switch (t.htmlWhitespaceSensitivity) {
         case "strict":
          return "inline";
         case "ignore":
          return "block";
         default:
          return ("element" === e.type && (!e.namespace || n || me(e)) && he[e.name]) || ce;
        }
       })(e, t);
      });
     },
     function (e) {
      e.walk((e) => {
       e.isSelfClosing = !e.children || ("element" === e.type && (e.tagDefinition.isVoid || (e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end)));
      });
     },
     function (e, t) {
      e.walk((e) => {
       "element" === e.type && (e.hasHtmComponentClosingTag = e.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t.originalText.slice(e.endSourceSpan.start.offset, e.endSourceSpan.end.offset)));
      });
     },
     function (e, t) {
      e.walk((e) => {
       let { children: r } = e;
       if (r) {
        if (0 === r.length) return void (e.isDanglingSpaceSensitive = we(e));
        for (let e of r) (e.isLeadingSpaceSensitive = Ce(e, t)), (e.isTrailingSpaceSensitive = Te(e, t));
        for (let e = 0; e < r.length; e++) {
         let t = r[e];
         (t.isLeadingSpaceSensitive = (0 === e || t.prev.isTrailingSpaceSensitive) && t.isLeadingSpaceSensitive), (t.isTrailingSpaceSensitive = (e === r.length - 1 || t.next.isLeadingSpaceSensitive) && t.isTrailingSpaceSensitive);
        }
       }
      });
     },
     function (e) {
      let t = (e) => {
       var t, r;
       return "element" === e.type && 0 === e.attrs.length && 1 === e.children.length && "text" === e.firstChild.type && !X.hasWhitespaceCharacter(e.children[0].value) && !e.firstChild.hasLeadingSpaces && !e.firstChild.hasTrailingSpaces && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces && "text" === (null == (t = e.prev) ? void 0 : t.type) && "text" === (null == (r = e.next) ? void 0 : r.type);
      };
      e.walk((e) => {
       if (e.children)
        for (let r = 0; r < e.children.length; r++) {
         let n = e.children[r];
         if (!t(n)) continue;
         let s = n.prev,
          i = n.next;
         (s.value += `<${n.rawName}>` + n.firstChild.value + `</${n.rawName}>` + i.value), (s.sourceSpan = new br(s.sourceSpan.start, i.sourceSpan.end)), (s.isTrailingSpaceSensitive = i.isTrailingSpaceSensitive), (s.hasTrailingSpaces = i.hasTrailingSpaces), e.removeChild(n), r--, e.removeChild(i);
        }
      });
     },
    ];
   var Cr = function (e, t) {
    for (let r of Er) r(e, t);
    return e;
   };
   var Tr = {
     preprocess: Cr,
     print: function (e, t, r) {
      let { node: n } = e;
      switch (n.type) {
       case "front-matter":
        return W(n.raw);
       case "root":
        return t.__onHtmlRoot && t.__onHtmlRoot(n), [B(ir(e, t, r)), R];
       case "element":
       case "ieConditionalComment":
        return ur(e, t, r);
       case "angularControlFlowBlock":
        return ar(e, t, r);
       case "angularControlFlowBlockParameters":
        return (function (e, t, r) {
         return [I([j, U([";", M], e.map(r, "children"))]), j];
        })(e, 0, r);
       case "angularControlFlowBlockParameter":
        return X.trim(n.expression);
       case "angularIcuExpression":
        return (function (e, t, r) {
         let { node: n } = e;
         return [Vt(n, t), B([n.switchValue.trim(), ", ", n.clause, n.cases.length > 0 ? [",", I([M, U(M, e.map(r, "cases"))])] : "", j]), kt(n, t)];
        })(e, t, r);
       case "angularIcuCase":
        return (function (e, t, r) {
         let { node: n } = e;
         return [n.value, " {", B([I([j, e.map(({ node: e }) => ("text" !== e.type || X.trim(e.value) ? r() : ""), "expression")]), j]), "}"];
        })(e, 0, r);
       case "ieConditionalStartComment":
       case "ieConditionalEndComment":
        return [Vt(n), kt(n)];
       case "interpolation":
        return [Vt(n, t), ...e.map(r, "children"), kt(n, t)];
       case "text": {
        if ("interpolation" === n.parent.type) {
         let e = /\n[^\S\n]*$/,
          t = e.test(n.value);
         return [W(t ? n.value.replace(e, "") : n.value), t ? R : ""];
        }
        let e = z([zt(n, t), ...Je(n), It(n, t)]);
        return Array.isArray(e) ? _(e) : e;
       }
       case "docType":
        return [B([Vt(n, t), " ", u(!1, n.value.replace(/^html\b/i, "html"), /\s+/g, " ")]), kt(n, t)];
       case "comment":
        return [zt(n, t), W(t.originalText.slice(wt(n), St(n))), It(n, t)];
       case "attribute": {
        if (null === n.value) return n.rawName;
        let e = Ue(n.value),
         t = J(e, '"');
        return [n.rawName, "=", t, W('"' === t ? u(!1, e, '"', "&quot;") : u(!1, e, "'", "&apos;")), t];
       }
       default:
        throw new Y(n, "HTML");
      }
     },
     insertPragma: function (e) {
      return "\x3c!-- @format --\x3e\n\n" + e;
     },
     massageAstNode: re,
     embed: Gt,
     getVisitorKeys: Zt,
    },
    wr = Tr,
    Sr = [
     { linguistLanguageId: 146, name: "Angular", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".component.html"], parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [] },
     { linguistLanguageId: 146, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml", ".mjml"], parsers: ["html"], vscodeLanguageIds: ["html"] },
     { linguistLanguageId: 146, name: "Lightning Web Components", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [], parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [] },
     { linguistLanguageId: 391, name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"] },
    ],
    Ar = {
     bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." },
     singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." },
     proseWrap: {
      category: "Common",
      type: "choice",
      default: "preserve",
      description: "How to wrap prose.",
      choices: [
       { value: "always", description: "Wrap prose if it exceeds the print width." },
       { value: "never", description: "Do not wrap prose." },
       { value: "preserve", description: "Wrap prose as-is." },
      ],
     },
     bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." },
     singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." },
    },
    Fr = "HTML",
    kr = {
     bracketSameLine: Ar.bracketSameLine,
     htmlWhitespaceSensitivity: {
      category: Fr,
      type: "choice",
      default: "css",
      description: "How to handle whitespaces in HTML.",
      choices: [
       { value: "css", description: "Respect the default value of CSS display property." },
       { value: "strict", description: "Whitespaces are considered sensitive." },
       { value: "ignore", description: "Whitespaces are considered insensitive." },
      ],
     },
     singleAttributePerLine: Ar.singleAttributePerLine,
     vueIndentScriptAndStyle: { category: Fr, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." },
    },
    Pr = {};
   s(Pr, { angular: () => ps, html: () => ls, lwc: () => hs, vue: () => cs });
   var Ir, Nr;
   !(function (e) {
    (e[(e.Emulated = 0)] = "Emulated"), (e[(e.None = 2)] = "None"), (e[(e.ShadowDom = 3)] = "ShadowDom");
   })(Ir || (Ir = {})),
    (function (e) {
     (e[(e.OnPush = 0)] = "OnPush"), (e[(e.Default = 1)] = "Default");
    })(Nr || (Nr = {}));
   var Br,
    _r,
    Lr,
    Or,
    Mr = "custom-elements",
    jr = "no-errors-schema";
   function Rr(e) {
    if (":" != e[0]) return [null, e];
    let t = e.indexOf(":", 1);
    if (-1 === t) throw new Error(`Unsupported format "${e}" expecting ":namespace:name"`);
    return [e.slice(1, t), e.slice(t + 1)];
   }
   function qr(e) {
    return "ng-container" === Rr(e)[1];
   }
   function Ur(e) {
    return "ng-content" === Rr(e)[1];
   }
   function $r(e) {
    return null === e ? null : Rr(e)[0];
   }
   function Vr(e, t) {
    return e ? `:${e}:${t}` : t;
   }
   function zr() {
    return Or || ((Or = {}), Wr(Br.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), Wr(Br.STYLE, ["*|style"]), Wr(Br.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), Wr(Br.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Or;
   }
   function Wr(e, t) {
    for (let r of t) Or[r.toLowerCase()] = e;
   }
   !(function (e) {
    (e[(e.NONE = 0)] = "NONE"), (e[(e.HTML = 1)] = "HTML"), (e[(e.STYLE = 2)] = "STYLE"), (e[(e.SCRIPT = 3)] = "SCRIPT"), (e[(e.URL = 4)] = "URL"), (e[(e.RESOURCE_URL = 5)] = "RESOURCE_URL");
   })(Br || (Br = {})),
    (function (e) {
     (e[(e.Error = 0)] = "Error"), (e[(e.Warning = 1)] = "Warning"), (e[(e.Ignore = 2)] = "Ignore");
    })(_r || (_r = {})),
    (function (e) {
     (e[(e.RAW_TEXT = 0)] = "RAW_TEXT"), (e[(e.ESCAPABLE_RAW_TEXT = 1)] = "ESCAPABLE_RAW_TEXT"), (e[(e.PARSABLE_DATA = 2)] = "PARSABLE_DATA");
    })(Lr || (Lr = {}));
   var Hr = class {},
    Jr = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|"],
    Kr = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })),
    Gr = Array.from(Kr).reduce((e, [t, r]) => (e.set(t, r), e), new Map()),
    Xr = class extends Hr {
     constructor() {
      super(),
       (this._schema = new Map()),
       (this._eventSchema = new Map()),
       Jr.forEach((e) => {
        let t = new Map(),
         r = new Set(),
         [n, s] = e.split("|"),
         i = s.split(","),
         [a, o] = n.split("^");
        a.split(",").forEach((e) => {
         this._schema.set(e.toLowerCase(), t), this._eventSchema.set(e.toLowerCase(), r);
        });
        let u = o && this._schema.get(o.toLowerCase());
        if (u) {
         for (let [e, r] of u) t.set(e, r);
         for (let e of this._eventSchema.get(o.toLowerCase())) r.add(e);
        }
        i.forEach((e) => {
         if (e.length > 0)
          switch (e[0]) {
           case "*":
            r.add(e.substring(1));
            break;
           case "!":
            t.set(e.substring(1), "boolean");
            break;
           case "#":
            t.set(e.substring(1), "number");
            break;
           case "%":
            t.set(e.substring(1), "object");
            break;
           default:
            t.set(e, "string");
          }
        });
       });
     }
     hasProperty(e, t, r) {
      if (r.some((e) => e.name === jr)) return !0;
      if (e.indexOf("-") > -1) {
       if (qr(e) || Ur(e)) return !1;
       if (r.some((e) => e.name === Mr)) return !0;
      }
      return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(t);
     }
     hasElement(e, t) {
      return !!(t.some((e) => e.name === jr) || (e.indexOf("-") > -1 && (qr(e) || Ur(e) || t.some((e) => e.name === Mr)))) || this._schema.has(e.toLowerCase());
     }
     securityContext(e, t, r) {
      r && (t = this.getMappedPropName(t)), (e = e.toLowerCase()), (t = t.toLowerCase());
      let n = zr()[e + "|" + t];
      return n || ((n = zr()["*|" + t]), n || Br.NONE);
     }
     getMappedPropName(e) {
      return Kr.get(e) ?? e;
     }
     getDefaultComponentElementName() {
      return "ng-component";
     }
     validateProperty(e) {
      return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...\nIf '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
     }
     validateAttribute(e) {
      return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
     }
     allKnownElementNames() {
      return Array.from(this._schema.keys());
     }
     allKnownAttributesOfElement(e) {
      let t = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
      return Array.from(t.keys()).map((e) => Gr.get(e) ?? e);
     }
     allKnownEventsOfElement(e) {
      return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
     }
     normalizeAnimationStyleProperty(e) {
      return (function (e) {
       return e.replace(mr, (...e) => e[1].toUpperCase());
      })(e);
     }
     normalizeAnimationStyleValue(e, t, r) {
      let n = "",
       s = r.toString().trim(),
       i = null;
      if (
       (function (e) {
        switch (e) {
         case "width":
         case "height":
         case "minWidth":
         case "minHeight":
         case "maxWidth":
         case "maxHeight":
         case "left":
         case "top":
         case "bottom":
         case "right":
         case "fontSize":
         case "outlineWidth":
         case "outlineOffset":
         case "paddingTop":
         case "paddingLeft":
         case "paddingBottom":
         case "paddingRight":
         case "marginTop":
         case "marginLeft":
         case "marginBottom":
         case "marginRight":
         case "borderRadius":
         case "borderWidth":
         case "borderTopWidth":
         case "borderLeftWidth":
         case "borderRightWidth":
         case "borderBottomWidth":
         case "textIndent":
          return !0;
         default:
          return !1;
        }
       })(e) &&
       0 !== r &&
       "0" !== r
      )
       if ("number" == typeof r) n = "px";
       else {
        let e = r.match(/^[+-]?[\d\.]+([a-z]*)$/);
        e && 0 == e[1].length && (i = `Please provide a CSS unit value for ${t}:${r}`);
       }
      return { error: i, value: s + n };
     }
    };
   var Yr,
    Qr,
    Zr = class {
     constructor({ closedByChildren: e, implicitNamespacePrefix: t, contentType: r = Lr.PARSABLE_DATA, closedByParent: n = !1, isVoid: s = !1, ignoreFirstLf: i = !1, preventNamespaceInheritance: a = !1, canSelfClose: o = !1 } = {}) {
      (this.closedByChildren = {}), (this.closedByParent = !1), e && e.length > 0 && e.forEach((e) => (this.closedByChildren[e] = !0)), (this.isVoid = s), (this.closedByParent = n || s), (this.implicitNamespacePrefix = t || null), (this.contentType = r), (this.ignoreFirstLf = i), (this.preventNamespaceInheritance = a), (this.canSelfClose = o ?? s);
     }
     isClosedByChild(e) {
      return this.isVoid || e.toLowerCase() in this.closedByChildren;
     }
     getContentType(e) {
      return "object" == typeof this.contentType ? (void 0 === e ? void 0 : this.contentType[e]) ?? this.contentType.default : this.contentType;
     }
    };
   function en(e) {
    return (
     Qr ||
      ((Yr = new Zr({ canSelfClose: !0 })),
      (Qr = Object.assign(Object.create(null), { base: new Zr({ isVoid: !0 }), meta: new Zr({ isVoid: !0 }), area: new Zr({ isVoid: !0 }), embed: new Zr({ isVoid: !0 }), link: new Zr({ isVoid: !0 }), img: new Zr({ isVoid: !0 }), input: new Zr({ isVoid: !0 }), param: new Zr({ isVoid: !0 }), hr: new Zr({ isVoid: !0 }), br: new Zr({ isVoid: !0 }), source: new Zr({ isVoid: !0 }), track: new Zr({ isVoid: !0 }), wbr: new Zr({ isVoid: !0 }), p: new Zr({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: !0 }), thead: new Zr({ closedByChildren: ["tbody", "tfoot"] }), tbody: new Zr({ closedByChildren: ["tbody", "tfoot"], closedByParent: !0 }), tfoot: new Zr({ closedByChildren: ["tbody"], closedByParent: !0 }), tr: new Zr({ closedByChildren: ["tr"], closedByParent: !0 }), td: new Zr({ closedByChildren: ["td", "th"], closedByParent: !0 }), th: new Zr({ closedByChildren: ["td", "th"], closedByParent: !0 }), col: new Zr({ isVoid: !0 }), svg: new Zr({ implicitNamespacePrefix: "svg" }), foreignObject: new Zr({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: !0 }), math: new Zr({ implicitNamespacePrefix: "math" }), li: new Zr({ closedByChildren: ["li"], closedByParent: !0 }), dt: new Zr({ closedByChildren: ["dt", "dd"] }), dd: new Zr({ closedByChildren: ["dt", "dd"], closedByParent: !0 }), rb: new Zr({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rt: new Zr({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rtc: new Zr({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: !0 }), rp: new Zr({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), optgroup: new Zr({ closedByChildren: ["optgroup"], closedByParent: !0 }), option: new Zr({ closedByChildren: ["option", "optgroup"], closedByParent: !0 }), pre: new Zr({ ignoreFirstLf: !0 }), listing: new Zr({ ignoreFirstLf: !0 }), style: new Zr({ contentType: Lr.RAW_TEXT }), script: new Zr({ contentType: Lr.RAW_TEXT }), title: new Zr({ contentType: { default: Lr.ESCAPABLE_RAW_TEXT, svg: Lr.PARSABLE_DATA } }), textarea: new Zr({ contentType: Lr.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) })),
      new Xr().allKnownElementNames().forEach((e) => {
       !Qr[e] && null === $r(e) && (Qr[e] = new Zr({ canSelfClose: !1 }));
      })),
     Qr[e] ?? Yr
    );
   }
   var tn = class {
     constructor(e, t) {
      (this.sourceSpan = e), (this.i18n = t);
     }
    },
    rn = class extends tn {
     constructor(e, t, r, n) {
      super(t, n), (this.value = e), (this.tokens = r), (this.type = "text");
     }
     visit(e, t) {
      return e.visitText(this, t);
     }
    },
    nn = class extends tn {
     constructor(e, t, r, n) {
      super(t, n), (this.value = e), (this.tokens = r), (this.type = "cdata");
     }
     visit(e, t) {
      return e.visitCdata(this, t);
     }
    },
    sn = class extends tn {
     constructor(e, t, r, n, s, i) {
      super(n, i), (this.switchValue = e), (this.type = t), (this.cases = r), (this.switchValueSourceSpan = s);
     }
     visit(e, t) {
      return e.visitExpansion(this, t);
     }
    },
    an = class {
     constructor(e, t, r, n, s) {
      (this.value = e), (this.expression = t), (this.sourceSpan = r), (this.valueSourceSpan = n), (this.expSourceSpan = s), (this.type = "expansionCase");
     }
     visit(e, t) {
      return e.visitExpansionCase(this, t);
     }
    },
    on = class extends tn {
     constructor(e, t, r, n, s, i, a) {
      super(r, a), (this.name = e), (this.value = t), (this.keySpan = n), (this.valueSpan = s), (this.valueTokens = i), (this.type = "attribute");
     }
     visit(e, t) {
      return e.visitAttribute(this, t);
     }
     get nameSpan() {
      return this.keySpan;
     }
    },
    un = class extends tn {
     constructor(e, t, r, n, s, i = null, a = null, o) {
      super(n, o), (this.name = e), (this.attrs = t), (this.children = r), (this.startSourceSpan = s), (this.endSourceSpan = i), (this.nameSpan = a), (this.type = "element");
     }
     visit(e, t) {
      return e.visitElement(this, t);
     }
    },
    ln = class {
     constructor(e, t) {
      (this.value = e), (this.sourceSpan = t), (this.type = "comment");
     }
     visit(e, t) {
      return e.visitComment(this, t);
     }
    },
    pn = class {
     constructor(e, t) {
      (this.value = e), (this.sourceSpan = t), (this.type = "docType");
     }
     visit(e, t) {
      return e.visitDocType(this, t);
     }
    },
    cn = class {
     constructor(e, t, r, n, s, i = null) {
      (this.name = e), (this.parameters = t), (this.children = r), (this.sourceSpan = n), (this.startSourceSpan = s), (this.endSourceSpan = i), (this.type = "block");
     }
     visit(e, t) {
      return e.visitBlock(this, t);
     }
    },
    hn = class {
     constructor(e, t) {
      (this.expression = e), (this.sourceSpan = t), (this.type = "blockParameter"), (this.startSourceSpan = null), (this.endSourceSpan = null);
     }
     visit(e, t) {
      return e.visitBlockParameter(this, t);
     }
    };
   function dn(e, t, r = null) {
    let n = [],
     s = e.visit ? (t) => e.visit(t, r) || t.visit(e, r) : (t) => t.visit(e, r);
    return (
     t.forEach((e) => {
      let t = s(e);
      t && n.push(t);
     }),
     n
    );
   }
   var fn = class {
     constructor() {}
     visitElement(e, t) {
      this.visitChildren(t, (t) => {
       t(e.attrs), t(e.children);
      });
     }
     visitAttribute(e, t) {}
     visitText(e, t) {}
     visitCdata(e, t) {}
     visitComment(e, t) {}
     visitDocType(e, t) {}
     visitExpansion(e, t) {
      return this.visitChildren(t, (t) => {
       t(e.cases);
      });
     }
     visitExpansionCase(e, t) {}
     visitBlock(e, t) {
      this.visitChildren(t, (t) => {
       t(e.parameters), t(e.children);
      });
     }
     visitBlockParameter(e, t) {}
     visitChildren(e, t) {
      let r = [],
       n = this;
      return (
       t(function (t) {
        t && r.push(dn(n, t, e));
       }),
       Array.prototype.concat.apply([], r)
      );
     }
    },
    mn = { AElig: "\xc6", AMP: "&", amp: "&", Aacute: "\xc1", Abreve: "\u0102", Acirc: "\xc2", Acy: "\u0410", Afr: "\ud835\udd04", Agrave: "\xc0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2a53", Aogon: "\u0104", Aopf: "\ud835\udd38", ApplyFunction: "\u2061", af: "\u2061", Aring: "\xc5", angst: "\xc5", Ascr: "\ud835\udc9c", Assign: "\u2254", colone: "\u2254", coloneq: "\u2254", Atilde: "\xc3", Auml: "\xc4", Backslash: "\u2216", setminus: "\u2216", setmn: "\u2216", smallsetminus: "\u2216", ssetmn: "\u2216", Barv: "\u2ae7", Barwed: "\u2306", doublebarwedge: "\u2306", Bcy: "\u0411", Because: "\u2235", becaus: "\u2235", because: "\u2235", Bernoullis: "\u212c", Bscr: "\u212c", bernou: "\u212c", Beta: "\u0392", Bfr: "\ud835\udd05", Bopf: "\ud835\udd39", Breve: "\u02d8", breve: "\u02d8", Bumpeq: "\u224e", HumpDownHump: "\u224e", bump: "\u224e", CHcy: "\u0427", COPY: "\xa9", copy: "\xa9", Cacute: "\u0106", Cap: "\u22d2", CapitalDifferentialD: "\u2145", DD: "\u2145", Cayleys: "\u212d", Cfr: "\u212d", Ccaron: "\u010c", Ccedil: "\xc7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010a", Cedilla: "\xb8", cedil: "\xb8", CenterDot: "\xb7", centerdot: "\xb7", middot: "\xb7", Chi: "\u03a7", CircleDot: "\u2299", odot: "\u2299", CircleMinus: "\u2296", ominus: "\u2296", CirclePlus: "\u2295", oplus: "\u2295", CircleTimes: "\u2297", otimes: "\u2297", ClockwiseContourIntegral: "\u2232", cwconint: "\u2232", CloseCurlyDoubleQuote: "\u201d", rdquo: "\u201d", rdquor: "\u201d", CloseCurlyQuote: "\u2019", rsquo: "\u2019", rsquor: "\u2019", Colon: "\u2237", Proportion: "\u2237", Colone: "\u2a74", Congruent: "\u2261", equiv: "\u2261", Conint: "\u222f", DoubleContourIntegral: "\u222f", ContourIntegral: "\u222e", conint: "\u222e", oint: "\u222e", Copf: "\u2102", complexes: "\u2102", Coproduct: "\u2210", coprod: "\u2210", CounterClockwiseContourIntegral: "\u2233", awconint: "\u2233", Cross: "\u2a2f", Cscr: "\ud835\udc9e", Cup: "\u22d3", CupCap: "\u224d", asympeq: "\u224d", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040f", Dagger: "\u2021", ddagger: "\u2021", Darr: "\u21a1", Dashv: "\u2ae4", DoubleLeftTee: "\u2ae4", Dcaron: "\u010e", Dcy: "\u0414", Del: "\u2207", nabla: "\u2207", Delta: "\u0394", Dfr: "\ud835\udd07", DiacriticalAcute: "\xb4", acute: "\xb4", DiacriticalDot: "\u02d9", dot: "\u02d9", DiacriticalDoubleAcute: "\u02dd", dblac: "\u02dd", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "\u02dc", tilde: "\u02dc", Diamond: "\u22c4", diam: "\u22c4", diamond: "\u22c4", DifferentialD: "\u2146", dd: "\u2146", Dopf: "\ud835\udd3b", Dot: "\xa8", DoubleDot: "\xa8", die: "\xa8", uml: "\xa8", DotDot: "\u20dc", DotEqual: "\u2250", doteq: "\u2250", esdot: "\u2250", DoubleDownArrow: "\u21d3", Downarrow: "\u21d3", dArr: "\u21d3", DoubleLeftArrow: "\u21d0", Leftarrow: "\u21d0", lArr: "\u21d0", DoubleLeftRightArrow: "\u21d4", Leftrightarrow: "\u21d4", hArr: "\u21d4", iff: "\u21d4", DoubleLongLeftArrow: "\u27f8", Longleftarrow: "\u27f8", xlArr: "\u27f8", DoubleLongLeftRightArrow: "\u27fa", Longleftrightarrow: "\u27fa", xhArr: "\u27fa", DoubleLongRightArrow: "\u27f9", Longrightarrow: "\u27f9", xrArr: "\u27f9", DoubleRightArrow: "\u21d2", Implies: "\u21d2", Rightarrow: "\u21d2", rArr: "\u21d2", DoubleRightTee: "\u22a8", vDash: "\u22a8", DoubleUpArrow: "\u21d1", Uparrow: "\u21d1", uArr: "\u21d1", DoubleUpDownArrow: "\u21d5", Updownarrow: "\u21d5", vArr: "\u21d5", DoubleVerticalBar: "\u2225", par: "\u2225", parallel: "\u2225", shortparallel: "\u2225", spar: "\u2225", DownArrow: "\u2193", ShortDownArrow: "\u2193", darr: "\u2193", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21f5", duarr: "\u21f5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295e", DownLeftVector: "\u21bd", leftharpoondown: "\u21bd", lhard: "\u21bd", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295f", DownRightVector: "\u21c1", rhard: "\u21c1", rightharpoondown: "\u21c1", DownRightVectorBar: "\u2957", DownTee: "\u22a4", top: "\u22a4", DownTeeArrow: "\u21a7", mapstodown: "\u21a7", Dscr: "\ud835\udc9f", Dstrok: "\u0110", ENG: "\u014a", ETH: "\xd0", Eacute: "\xc9", Ecaron: "\u011a", Ecirc: "\xca", Ecy: "\u042d", Edot: "\u0116", Efr: "\ud835\udd08", Egrave: "\xc8", Element: "\u2208", in: "\u2208", isin: "\u2208", isinv: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25fb", EmptyVerySmallSquare: "\u25ab", Eogon: "\u0118", Eopf: "\ud835\udd3c", Epsilon: "\u0395", Equal: "\u2a75", EqualTilde: "\u2242", eqsim: "\u2242", esim: "\u2242", Equilibrium: "\u21cc", rightleftharpoons: "\u21cc", rlhar: "\u21cc", Escr: "\u2130", expectation: "\u2130", Esim: "\u2a73", Eta: "\u0397", Euml: "\xcb", Exists: "\u2203", exist: "\u2203", ExponentialE: "\u2147", ee: "\u2147", exponentiale: "\u2147", Fcy: "\u0424", Ffr: "\ud835\udd09", FilledSmallSquare: "\u25fc", FilledVerySmallSquare: "\u25aa", blacksquare: "\u25aa", squarf: "\u25aa", squf: "\u25aa", Fopf: "\ud835\udd3d", ForAll: "\u2200", forall: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", gt: ">", Gamma: "\u0393", Gammad: "\u03dc", Gbreve: "\u011e", Gcedil: "\u0122", Gcirc: "\u011c", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\ud835\udd0a", Gg: "\u22d9", ggg: "\u22d9", Gopf: "\ud835\udd3e", GreaterEqual: "\u2265", ge: "\u2265", geq: "\u2265", GreaterEqualLess: "\u22db", gel: "\u22db", gtreqless: "\u22db", GreaterFullEqual: "\u2267", gE: "\u2267", geqq: "\u2267", GreaterGreater: "\u2aa2", GreaterLess: "\u2277", gl: "\u2277", gtrless: "\u2277", GreaterSlantEqual: "\u2a7e", geqslant: "\u2a7e", ges: "\u2a7e", GreaterTilde: "\u2273", gsim: "\u2273", gtrsim: "\u2273", Gscr: "\ud835\udca2", Gt: "\u226b", NestedGreaterGreater: "\u226b", gg: "\u226b", HARDcy: "\u042a", Hacek: "\u02c7", caron: "\u02c7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210c", Poincareplane: "\u210c", HilbertSpace: "\u210b", Hscr: "\u210b", hamilt: "\u210b", Hopf: "\u210d", quaternions: "\u210d", HorizontalLine: "\u2500", boxh: "\u2500", Hstrok: "\u0126", HumpEqual: "\u224f", bumpe: "\u224f", bumpeq: "\u224f", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xcd", Icirc: "\xce", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Im: "\u2111", image: "\u2111", imagpart: "\u2111", Igrave: "\xcc", Imacr: "\u012a", ImaginaryI: "\u2148", ii: "\u2148", Int: "\u222c", Integral: "\u222b", int: "\u222b", Intersection: "\u22c2", bigcap: "\u22c2", xcap: "\u22c2", InvisibleComma: "\u2063", ic: "\u2063", InvisibleTimes: "\u2062", it: "\u2062", Iogon: "\u012e", Iopf: "\ud835\udd40", Iota: "\u0399", Iscr: "\u2110", imagline: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xcf", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\ud835\udd0d", Jopf: "\ud835\udd41", Jscr: "\ud835\udca5", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040c", Kappa: "\u039a", Kcedil: "\u0136", Kcy: "\u041a", Kfr: "\ud835\udd0e", Kopf: "\ud835\udd42", Kscr: "\ud835\udca6", LJcy: "\u0409", LT: "<", lt: "<", Lacute: "\u0139", Lambda: "\u039b", Lang: "\u27ea", Laplacetrf: "\u2112", Lscr: "\u2112", lagran: "\u2112", Larr: "\u219e", twoheadleftarrow: "\u219e", Lcaron: "\u013d", Lcedil: "\u013b", Lcy: "\u041b", LeftAngleBracket: "\u27e8", lang: "\u27e8", langle: "\u27e8", LeftArrow: "\u2190", ShortLeftArrow: "\u2190", larr: "\u2190", leftarrow: "\u2190", slarr: "\u2190", LeftArrowBar: "\u21e4", larrb: "\u21e4", LeftArrowRightArrow: "\u21c6", leftrightarrows: "\u21c6", lrarr: "\u21c6", LeftCeiling: "\u2308", lceil: "\u2308", LeftDoubleBracket: "\u27e6", lobrk: "\u27e6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21c3", dharl: "\u21c3", downharpoonleft: "\u21c3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230a", lfloor: "\u230a", LeftRightArrow: "\u2194", harr: "\u2194", leftrightarrow: "\u2194", LeftRightVector: "\u294e", LeftTee: "\u22a3", dashv: "\u22a3", LeftTeeArrow: "\u21a4", mapstoleft: "\u21a4", LeftTeeVector: "\u295a", LeftTriangle: "\u22b2", vartriangleleft: "\u22b2", vltri: "\u22b2", LeftTriangleBar: "\u29cf", LeftTriangleEqual: "\u22b4", ltrie: "\u22b4", trianglelefteq: "\u22b4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21bf", uharl: "\u21bf", upharpoonleft: "\u21bf", LeftUpVectorBar: "\u2958", LeftVector: "\u21bc", leftharpoonup: "\u21bc", lharu: "\u21bc", LeftVectorBar: "\u2952", LessEqualGreater: "\u22da", leg: "\u22da", lesseqgtr: "\u22da", LessFullEqual: "\u2266", lE: "\u2266", leqq: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", lg: "\u2276", LessLess: "\u2aa1", LessSlantEqual: "\u2a7d", leqslant: "\u2a7d", les: "\u2a7d", LessTilde: "\u2272", lesssim: "\u2272", lsim: "\u2272", Lfr: "\ud835\udd0f", Ll: "\u22d8", Lleftarrow: "\u21da", lAarr: "\u21da", Lmidot: "\u013f", LongLeftArrow: "\u27f5", longleftarrow: "\u27f5", xlarr: "\u27f5", LongLeftRightArrow: "\u27f7", longleftrightarrow: "\u27f7", xharr: "\u27f7", LongRightArrow: "\u27f6", longrightarrow: "\u27f6", xrarr: "\u27f6", Lopf: "\ud835\udd43", LowerLeftArrow: "\u2199", swarr: "\u2199", swarrow: "\u2199", LowerRightArrow: "\u2198", searr: "\u2198", searrow: "\u2198", Lsh: "\u21b0", lsh: "\u21b0", Lstrok: "\u0141", Lt: "\u226a", NestedLessLess: "\u226a", ll: "\u226a", Map: "\u2905", Mcy: "\u041c", MediumSpace: "\u205f", Mellintrf: "\u2133", Mscr: "\u2133", phmmat: "\u2133", Mfr: "\ud835\udd10", MinusPlus: "\u2213", mnplus: "\u2213", mp: "\u2213", Mopf: "\ud835\udd44", Mu: "\u039c", NJcy: "\u040a", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041d", NegativeMediumSpace: "\u200b", NegativeThickSpace: "\u200b", NegativeThinSpace: "\u200b", NegativeVeryThinSpace: "\u200b", ZeroWidthSpace: "\u200b", NewLine: "\n", Nfr: "\ud835\udd11", NoBreak: "\u2060", NonBreakingSpace: "\xa0", nbsp: "\xa0", Nopf: "\u2115", naturals: "\u2115", Not: "\u2aec", NotCongruent: "\u2262", nequiv: "\u2262", NotCupCap: "\u226d", NotDoubleVerticalBar: "\u2226", npar: "\u2226", nparallel: "\u2226", nshortparallel: "\u2226", nspar: "\u2226", NotElement: "\u2209", notin: "\u2209", notinva: "\u2209", NotEqual: "\u2260", ne: "\u2260", NotEqualTilde: "\u2242\u0338", nesim: "\u2242\u0338", NotExists: "\u2204", nexist: "\u2204", nexists: "\u2204", NotGreater: "\u226f", ngt: "\u226f", ngtr: "\u226f", NotGreaterEqual: "\u2271", nge: "\u2271", ngeq: "\u2271", NotGreaterFullEqual: "\u2267\u0338", ngE: "\u2267\u0338", ngeqq: "\u2267\u0338", NotGreaterGreater: "\u226b\u0338", nGtv: "\u226b\u0338", NotGreaterLess: "\u2279", ntgl: "\u2279", NotGreaterSlantEqual: "\u2a7e\u0338", ngeqslant: "\u2a7e\u0338", nges: "\u2a7e\u0338", NotGreaterTilde: "\u2275", ngsim: "\u2275", NotHumpDownHump: "\u224e\u0338", nbump: "\u224e\u0338", NotHumpEqual: "\u224f\u0338", nbumpe: "\u224f\u0338", NotLeftTriangle: "\u22ea", nltri: "\u22ea", ntriangleleft: "\u22ea", NotLeftTriangleBar: "\u29cf\u0338", NotLeftTriangleEqual: "\u22ec", nltrie: "\u22ec", ntrianglelefteq: "\u22ec", NotLess: "\u226e", nless: "\u226e", nlt: "\u226e", NotLessEqual: "\u2270", nle: "\u2270", nleq: "\u2270", NotLessGreater: "\u2278", ntlg: "\u2278", NotLessLess: "\u226a\u0338", nLtv: "\u226a\u0338", NotLessSlantEqual: "\u2a7d\u0338", nleqslant: "\u2a7d\u0338", nles: "\u2a7d\u0338", NotLessTilde: "\u2274", nlsim: "\u2274", NotNestedGreaterGreater: "\u2aa2\u0338", NotNestedLessLess: "\u2aa1\u0338", NotPrecedes: "\u2280", npr: "\u2280", nprec: "\u2280", NotPrecedesEqual: "\u2aaf\u0338", npre: "\u2aaf\u0338", npreceq: "\u2aaf\u0338", NotPrecedesSlantEqual: "\u22e0", nprcue: "\u22e0", NotReverseElement: "\u220c", notni: "\u220c", notniva: "\u220c", NotRightTriangle: "\u22eb", nrtri: "\u22eb", ntriangleright: "\u22eb", NotRightTriangleBar: "\u29d0\u0338", NotRightTriangleEqual: "\u22ed", nrtrie: "\u22ed", ntrianglerighteq: "\u22ed", NotSquareSubset: "\u228f\u0338", NotSquareSubsetEqual: "\u22e2", nsqsube: "\u22e2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22e3", nsqsupe: "\u22e3", NotSubset: "\u2282\u20d2", nsubset: "\u2282\u20d2", vnsub: "\u2282\u20d2", NotSubsetEqual: "\u2288", nsube: "\u2288", nsubseteq: "\u2288", NotSucceeds: "\u2281", nsc: "\u2281", nsucc: "\u2281", NotSucceedsEqual: "\u2ab0\u0338", nsce: "\u2ab0\u0338", nsucceq: "\u2ab0\u0338", NotSucceedsSlantEqual: "\u22e1", nsccue: "\u22e1", NotSucceedsTilde: "\u227f\u0338", NotSuperset: "\u2283\u20d2", nsupset: "\u2283\u20d2", vnsup: "\u2283\u20d2", NotSupersetEqual: "\u2289", nsupe: "\u2289", nsupseteq: "\u2289", NotTilde: "\u2241", nsim: "\u2241", NotTildeEqual: "\u2244", nsime: "\u2244", nsimeq: "\u2244", NotTildeFullEqual: "\u2247", ncong: "\u2247", NotTildeTilde: "\u2249", nap: "\u2249", napprox: "\u2249", NotVerticalBar: "\u2224", nmid: "\u2224", nshortmid: "\u2224", nsmid: "\u2224", Nscr: "\ud835\udca9", Ntilde: "\xd1", Nu: "\u039d", OElig: "\u0152", Oacute: "\xd3", Ocirc: "\xd4", Ocy: "\u041e", Odblac: "\u0150", Ofr: "\ud835\udd12", Ograve: "\xd2", Omacr: "\u014c", Omega: "\u03a9", ohm: "\u03a9", Omicron: "\u039f", Oopf: "\ud835\udd46", OpenCurlyDoubleQuote: "\u201c", ldquo: "\u201c", OpenCurlyQuote: "\u2018", lsquo: "\u2018", Or: "\u2a54", Oscr: "\ud835\udcaa", Oslash: "\xd8", Otilde: "\xd5", Otimes: "\u2a37", Ouml: "\xd6", OverBar: "\u203e", oline: "\u203e", OverBrace: "\u23de", OverBracket: "\u23b4", tbrk: "\u23b4", OverParenthesis: "\u23dc", PartialD: "\u2202", part: "\u2202", Pcy: "\u041f", Pfr: "\ud835\udd13", Phi: "\u03a6", Pi: "\u03a0", PlusMinus: "\xb1", plusmn: "\xb1", pm: "\xb1", Popf: "\u2119", primes: "\u2119", Pr: "\u2abb", Precedes: "\u227a", pr: "\u227a", prec: "\u227a", PrecedesEqual: "\u2aaf", pre: "\u2aaf", preceq: "\u2aaf", PrecedesSlantEqual: "\u227c", prcue: "\u227c", preccurlyeq: "\u227c", PrecedesTilde: "\u227e", precsim: "\u227e", prsim: "\u227e", Prime: "\u2033", Product: "\u220f", prod: "\u220f", Proportional: "\u221d", prop: "\u221d", propto: "\u221d", varpropto: "\u221d", vprop: "\u221d", Pscr: "\ud835\udcab", Psi: "\u03a8", QUOT: '"', quot: '"', Qfr: "\ud835\udd14", Qopf: "\u211a", rationals: "\u211a", Qscr: "\ud835\udcac", RBarr: "\u2910", drbkarow: "\u2910", REG: "\xae", circledR: "\xae", reg: "\xae", Racute: "\u0154", Rang: "\u27eb", Rarr: "\u21a0", twoheadrightarrow: "\u21a0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211c", Rfr: "\u211c", real: "\u211c", realpart: "\u211c", ReverseElement: "\u220b", SuchThat: "\u220b", ni: "\u220b", niv: "\u220b", ReverseEquilibrium: "\u21cb", leftrightharpoons: "\u21cb", lrhar: "\u21cb", ReverseUpEquilibrium: "\u296f", duhar: "\u296f", Rho: "\u03a1", RightAngleBracket: "\u27e9", rang: "\u27e9", rangle: "\u27e9", RightArrow: "\u2192", ShortRightArrow: "\u2192", rarr: "\u2192", rightarrow: "\u2192", srarr: "\u2192", RightArrowBar: "\u21e5", rarrb: "\u21e5", RightArrowLeftArrow: "\u21c4", rightleftarrows: "\u21c4", rlarr: "\u21c4", RightCeiling: "\u2309", rceil: "\u2309", RightDoubleBracket: "\u27e7", robrk: "\u27e7", RightDownTeeVector: "\u295d", RightDownVector: "\u21c2", dharr: "\u21c2", downharpoonright: "\u21c2", RightDownVectorBar: "\u2955", RightFloor: "\u230b", rfloor: "\u230b", RightTee: "\u22a2", vdash: "\u22a2", RightTeeArrow: "\u21a6", map: "\u21a6", mapsto: "\u21a6", RightTeeVector: "\u295b", RightTriangle: "\u22b3", vartriangleright: "\u22b3", vrtri: "\u22b3", RightTriangleBar: "\u29d0", RightTriangleEqual: "\u22b5", rtrie: "\u22b5", trianglerighteq: "\u22b5", RightUpDownVector: "\u294f", RightUpTeeVector: "\u295c", RightUpVector: "\u21be", uharr: "\u21be", upharpoonright: "\u21be", RightUpVectorBar: "\u2954", RightVector: "\u21c0", rharu: "\u21c0", rightharpoonup: "\u21c0", RightVectorBar: "\u2953", Ropf: "\u211d", reals: "\u211d", RoundImplies: "\u2970", Rrightarrow: "\u21db", rAarr: "\u21db", Rscr: "\u211b", realine: "\u211b", Rsh: "\u21b1", rsh: "\u21b1", RuleDelayed: "\u29f4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042c", Sacute: "\u015a", Sc: "\u2abc", Scaron: "\u0160", Scedil: "\u015e", Scirc: "\u015c", Scy: "\u0421", Sfr: "\ud835\udd16", ShortUpArrow: "\u2191", UpArrow: "\u2191", uarr: "\u2191", uparrow: "\u2191", Sigma: "\u03a3", SmallCircle: "\u2218", compfn: "\u2218", Sopf: "\ud835\udd4a", Sqrt: "\u221a", radic: "\u221a", Square: "\u25a1", squ: "\u25a1", square: "\u25a1", SquareIntersection: "\u2293", sqcap: "\u2293", SquareSubset: "\u228f", sqsub: "\u228f", sqsubset: "\u228f", SquareSubsetEqual: "\u2291", sqsube: "\u2291", sqsubseteq: "\u2291", SquareSuperset: "\u2290", sqsup: "\u2290", sqsupset: "\u2290", SquareSupersetEqual: "\u2292", sqsupe: "\u2292", sqsupseteq: "\u2292", SquareUnion: "\u2294", sqcup: "\u2294", Sscr: "\ud835\udcae", Star: "\u22c6", sstarf: "\u22c6", Sub: "\u22d0", Subset: "\u22d0", SubsetEqual: "\u2286", sube: "\u2286", subseteq: "\u2286", Succeeds: "\u227b", sc: "\u227b", succ: "\u227b", SucceedsEqual: "\u2ab0", sce: "\u2ab0", succeq: "\u2ab0", SucceedsSlantEqual: "\u227d", sccue: "\u227d", succcurlyeq: "\u227d", SucceedsTilde: "\u227f", scsim: "\u227f", succsim: "\u227f", Sum: "\u2211", sum: "\u2211", Sup: "\u22d1", Supset: "\u22d1", Superset: "\u2283", sup: "\u2283", supset: "\u2283", SupersetEqual: "\u2287", supe: "\u2287", supseteq: "\u2287", THORN: "\xde", TRADE: "\u2122", trade: "\u2122", TSHcy: "\u040b", TScy: "\u0426", Tab: "\t", Tau: "\u03a4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\ud835\udd17", Therefore: "\u2234", there4: "\u2234", therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205f\u200a", ThinSpace: "\u2009", thinsp: "\u2009", Tilde: "\u223c", sim: "\u223c", thicksim: "\u223c", thksim: "\u223c", TildeEqual: "\u2243", sime: "\u2243", simeq: "\u2243", TildeFullEqual: "\u2245", cong: "\u2245", TildeTilde: "\u2248", ap: "\u2248", approx: "\u2248", asymp: "\u2248", thickapprox: "\u2248", thkap: "\u2248", Topf: "\ud835\udd4b", TripleDot: "\u20db", tdot: "\u20db", Tscr: "\ud835\udcaf", Tstrok: "\u0166", Uacute: "\xda", Uarr: "\u219f", Uarrocir: "\u2949", Ubrcy: "\u040e", Ubreve: "\u016c", Ucirc: "\xdb", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\ud835\udd18", Ugrave: "\xd9", Umacr: "\u016a", UnderBar: "_", lowbar: "_", UnderBrace: "\u23df", UnderBracket: "\u23b5", bbrk: "\u23b5", UnderParenthesis: "\u23dd", Union: "\u22c3", bigcup: "\u22c3", xcup: "\u22c3", UnionPlus: "\u228e", uplus: "\u228e", Uogon: "\u0172", Uopf: "\ud835\udd4c", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21c5", udarr: "\u21c5", UpDownArrow: "\u2195", updownarrow: "\u2195", varr: "\u2195", UpEquilibrium: "\u296e", udhar: "\u296e", UpTee: "\u22a5", bot: "\u22a5", bottom: "\u22a5", perp: "\u22a5", UpTeeArrow: "\u21a5", mapstoup: "\u21a5", UpperLeftArrow: "\u2196", nwarr: "\u2196", nwarrow: "\u2196", UpperRightArrow: "\u2197", nearr: "\u2197", nearrow: "\u2197", Upsi: "\u03d2", upsih: "\u03d2", Upsilon: "\u03a5", Uring: "\u016e", Uscr: "\ud835\udcb0", Utilde: "\u0168", Uuml: "\xdc", VDash: "\u22ab", Vbar: "\u2aeb", Vcy: "\u0412", Vdash: "\u22a9", Vdashl: "\u2ae6", Vee: "\u22c1", bigvee: "\u22c1", xvee: "\u22c1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", mid: "\u2223", shortmid: "\u2223", smid: "\u2223", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", wr: "\u2240", wreath: "\u2240", VeryThinSpace: "\u200a", hairsp: "\u200a", Vfr: "\ud835\udd19", Vopf: "\ud835\udd4d", Vscr: "\ud835\udcb1", Vvdash: "\u22aa", Wcirc: "\u0174", Wedge: "\u22c0", bigwedge: "\u22c0", xwedge: "\u22c0", Wfr: "\ud835\udd1a", Wopf: "\ud835\udd4e", Wscr: "\ud835\udcb2", Xfr: "\ud835\udd1b", Xi: "\u039e", Xopf: "\ud835\udd4f", Xscr: "\ud835\udcb3", YAcy: "\u042f", YIcy: "\u0407", YUcy: "\u042e", Yacute: "\xdd", Ycirc: "\u0176", Ycy: "\u042b", Yfr: "\ud835\udd1c", Yopf: "\ud835\udd50", Yscr: "\ud835\udcb4", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017d", Zcy: "\u0417", Zdot: "\u017b", Zeta: "\u0396", Zfr: "\u2128", zeetrf: "\u2128", Zopf: "\u2124", integers: "\u2124", Zscr: "\ud835\udcb5", aacute: "\xe1", abreve: "\u0103", ac: "\u223e", mstpos: "\u223e", acE: "\u223e\u0333", acd: "\u223f", acirc: "\xe2", acy: "\u0430", aelig: "\xe6", afr: "\ud835\udd1e", agrave: "\xe0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03b1", amacr: "\u0101", amalg: "\u2a3f", and: "\u2227", wedge: "\u2227", andand: "\u2a55", andd: "\u2a5c", andslope: "\u2a58", andv: "\u2a5a", ang: "\u2220", angle: "\u2220", ange: "\u29a4", angmsd: "\u2221", measuredangle: "\u2221", angmsdaa: "\u29a8", angmsdab: "\u29a9", angmsdac: "\u29aa", angmsdad: "\u29ab", angmsdae: "\u29ac", angmsdaf: "\u29ad", angmsdag: "\u29ae", angmsdah: "\u29af", angrt: "\u221f", angrtvb: "\u22be", angrtvbd: "\u299d", angsph: "\u2222", angzarr: "\u237c", aogon: "\u0105", aopf: "\ud835\udd52", apE: "\u2a70", apacir: "\u2a6f", ape: "\u224a", approxeq: "\u224a", apid: "\u224b", apos: "'", aring: "\xe5", ascr: "\ud835\udcb6", ast: "*", midast: "*", atilde: "\xe3", auml: "\xe4", awint: "\u2a11", bNot: "\u2aed", backcong: "\u224c", bcong: "\u224c", backepsilon: "\u03f6", bepsi: "\u03f6", backprime: "\u2035", bprime: "\u2035", backsim: "\u223d", bsim: "\u223d", backsimeq: "\u22cd", bsime: "\u22cd", barvee: "\u22bd", barwed: "\u2305", barwedge: "\u2305", bbrktbrk: "\u23b6", bcy: "\u0431", bdquo: "\u201e", ldquor: "\u201e", bemptyv: "\u29b0", beta: "\u03b2", beth: "\u2136", between: "\u226c", twixt: "\u226c", bfr: "\ud835\udd1f", bigcirc: "\u25ef", xcirc: "\u25ef", bigodot: "\u2a00", xodot: "\u2a00", bigoplus: "\u2a01", xoplus: "\u2a01", bigotimes: "\u2a02", xotime: "\u2a02", bigsqcup: "\u2a06", xsqcup: "\u2a06", bigstar: "\u2605", starf: "\u2605", bigtriangledown: "\u25bd", xdtri: "\u25bd", bigtriangleup: "\u25b3", xutri: "\u25b3", biguplus: "\u2a04", xuplus: "\u2a04", bkarow: "\u290d", rbarr: "\u290d", blacklozenge: "\u29eb", lozf: "\u29eb", blacktriangle: "\u25b4", utrif: "\u25b4", blacktriangledown: "\u25be", dtrif: "\u25be", blacktriangleleft: "\u25c2", ltrif: "\u25c2", blacktriangleright: "\u25b8", rtrif: "\u25b8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20e5", bnequiv: "\u2261\u20e5", bnot: "\u2310", bopf: "\ud835\udd53", bowtie: "\u22c8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255d", boxUR: "\u255a", boxUl: "\u255c", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256c", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256b", boxVl: "\u2562", boxVr: "\u255f", boxbox: "\u29c9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250c", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252c", boxhu: "\u2534", boxminus: "\u229f", minusb: "\u229f", boxplus: "\u229e", plusb: "\u229e", boxtimes: "\u22a0", timesb: "\u22a0", boxuL: "\u255b", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256a", boxvL: "\u2561", boxvR: "\u255e", boxvh: "\u253c", boxvl: "\u2524", boxvr: "\u251c", brvbar: "\xa6", bscr: "\ud835\udcb7", bsemi: "\u204f", bsol: "\\", bsolb: "\u29c5", bsolhsub: "\u27c8", bull: "\u2022", bullet: "\u2022", bumpE: "\u2aae", cacute: "\u0107", cap: "\u2229", capand: "\u2a44", capbrcup: "\u2a49", capcap: "\u2a4b", capcup: "\u2a47", capdot: "\u2a40", caps: "\u2229\ufe00", caret: "\u2041", ccaps: "\u2a4d", ccaron: "\u010d", ccedil: "\xe7", ccirc: "\u0109", ccups: "\u2a4c", ccupssm: "\u2a50", cdot: "\u010b", cemptyv: "\u29b2", cent: "\xa2", cfr: "\ud835\udd20", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03c7", cir: "\u25cb", cirE: "\u29c3", circ: "\u02c6", circeq: "\u2257", cire: "\u2257", circlearrowleft: "\u21ba", olarr: "\u21ba", circlearrowright: "\u21bb", orarr: "\u21bb", circledS: "\u24c8", oS: "\u24c8", circledast: "\u229b", oast: "\u229b", circledcirc: "\u229a", ocir: "\u229a", circleddash: "\u229d", odash: "\u229d", cirfnint: "\u2a10", cirmid: "\u2aef", cirscir: "\u29c2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", comma: ",", commat: "@", comp: "\u2201", complement: "\u2201", congdot: "\u2a6d", copf: "\ud835\udd54", copysr: "\u2117", crarr: "\u21b5", cross: "\u2717", cscr: "\ud835\udcb8", csub: "\u2acf", csube: "\u2ad1", csup: "\u2ad0", csupe: "\u2ad2", ctdot: "\u22ef", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22de", curlyeqprec: "\u22de", cuesc: "\u22df", curlyeqsucc: "\u22df", cularr: "\u21b6", curvearrowleft: "\u21b6", cularrp: "\u293d", cup: "\u222a", cupbrcap: "\u2a48", cupcap: "\u2a46", cupcup: "\u2a4a", cupdot: "\u228d", cupor: "\u2a45", cups: "\u222a\ufe00", curarr: "\u21b7", curvearrowright: "\u21b7", curarrm: "\u293c", curlyvee: "\u22ce", cuvee: "\u22ce", curlywedge: "\u22cf", cuwed: "\u22cf", curren: "\xa4", cwint: "\u2231", cylcty: "\u232d", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", dash: "\u2010", hyphen: "\u2010", dbkarow: "\u290f", rBarr: "\u290f", dcaron: "\u010f", dcy: "\u0434", ddarr: "\u21ca", downdownarrows: "\u21ca", ddotseq: "\u2a77", eDDot: "\u2a77", deg: "\xb0", delta: "\u03b4", demptyv: "\u29b1", dfisht: "\u297f", dfr: "\ud835\udd21", diamondsuit: "\u2666", diams: "\u2666", digamma: "\u03dd", gammad: "\u03dd", disin: "\u22f2", div: "\xf7", divide: "\xf7", divideontimes: "\u22c7", divonx: "\u22c7", djcy: "\u0452", dlcorn: "\u231e", llcorner: "\u231e", dlcrop: "\u230d", dollar: "$", dopf: "\ud835\udd55", doteqdot: "\u2251", eDot: "\u2251", dotminus: "\u2238", minusd: "\u2238", dotplus: "\u2214", plusdo: "\u2214", dotsquare: "\u22a1", sdotb: "\u22a1", drcorn: "\u231f", lrcorner: "\u231f", drcrop: "\u230c", dscr: "\ud835\udcb9", dscy: "\u0455", dsol: "\u29f6", dstrok: "\u0111", dtdot: "\u22f1", dtri: "\u25bf", triangledown: "\u25bf", dwangle: "\u29a6", dzcy: "\u045f", dzigrarr: "\u27ff", eacute: "\xe9", easter: "\u2a6e", ecaron: "\u011b", ecir: "\u2256", eqcirc: "\u2256", ecirc: "\xea", ecolon: "\u2255", eqcolon: "\u2255", ecy: "\u044d", edot: "\u0117", efDot: "\u2252", fallingdotseq: "\u2252", efr: "\ud835\udd22", eg: "\u2a9a", egrave: "\xe8", egs: "\u2a96", eqslantgtr: "\u2a96", egsdot: "\u2a98", el: "\u2a99", elinters: "\u23e7", ell: "\u2113", els: "\u2a95", eqslantless: "\u2a95", elsdot: "\u2a97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", varnothing: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014b", ensp: "\u2002", eogon: "\u0119", eopf: "\ud835\udd56", epar: "\u22d5", eparsl: "\u29e3", eplus: "\u2a71", epsi: "\u03b5", epsilon: "\u03b5", epsiv: "\u03f5", straightepsilon: "\u03f5", varepsilon: "\u03f5", equals: "=", equest: "\u225f", questeq: "\u225f", equivDD: "\u2a78", eqvparsl: "\u29e5", erDot: "\u2253", risingdotseq: "\u2253", erarr: "\u2971", escr: "\u212f", eta: "\u03b7", eth: "\xf0", euml: "\xeb", euro: "\u20ac", excl: "!", fcy: "\u0444", female: "\u2640", ffilig: "\ufb03", fflig: "\ufb00", ffllig: "\ufb04", ffr: "\ud835\udd23", filig: "\ufb01", fjlig: "fj", flat: "\u266d", fllig: "\ufb02", fltns: "\u25b1", fnof: "\u0192", fopf: "\ud835\udd57", fork: "\u22d4", pitchfork: "\u22d4", forkv: "\u2ad9", fpartint: "\u2a0d", frac12: "\xbd", half: "\xbd", frac13: "\u2153", frac14: "\xbc", frac15: "\u2155", frac16: "\u2159", frac18: "\u215b", frac23: "\u2154", frac25: "\u2156", frac34: "\xbe", frac35: "\u2157", frac38: "\u215c", frac45: "\u2158", frac56: "\u215a", frac58: "\u215d", frac78: "\u215e", frasl: "\u2044", frown: "\u2322", sfrown: "\u2322", fscr: "\ud835\udcbb", gEl: "\u2a8c", gtreqqless: "\u2a8c", gacute: "\u01f5", gamma: "\u03b3", gap: "\u2a86", gtrapprox: "\u2a86", gbreve: "\u011f", gcirc: "\u011d", gcy: "\u0433", gdot: "\u0121", gescc: "\u2aa9", gesdot: "\u2a80", gesdoto: "\u2a82", gesdotol: "\u2a84", gesl: "\u22db\ufe00", gesles: "\u2a94", gfr: "\ud835\udd24", gimel: "\u2137", gjcy: "\u0453", glE: "\u2a92", gla: "\u2aa5", glj: "\u2aa4", gnE: "\u2269", gneqq: "\u2269", gnap: "\u2a8a", gnapprox: "\u2a8a", gne: "\u2a88", gneq: "\u2a88", gnsim: "\u22e7", gopf: "\ud835\udd58", gscr: "\u210a", gsime: "\u2a8e", gsiml: "\u2a90", gtcc: "\u2aa7", gtcir: "\u2a7a", gtdot: "\u22d7", gtrdot: "\u22d7", gtlPar: "\u2995", gtquest: "\u2a7c", gtrarr: "\u2978", gvertneqq: "\u2269\ufe00", gvnE: "\u2269\ufe00", hardcy: "\u044a", harrcir: "\u2948", harrw: "\u21ad", leftrightsquigarrow: "\u21ad", hbar: "\u210f", hslash: "\u210f", planck: "\u210f", plankv: "\u210f", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", mldr: "\u2026", hercon: "\u22b9", hfr: "\ud835\udd25", hksearow: "\u2925", searhk: "\u2925", hkswarow: "\u2926", swarhk: "\u2926", hoarr: "\u21ff", homtht: "\u223b", hookleftarrow: "\u21a9", larrhk: "\u21a9", hookrightarrow: "\u21aa", rarrhk: "\u21aa", hopf: "\ud835\udd59", horbar: "\u2015", hscr: "\ud835\udcbd", hstrok: "\u0127", hybull: "\u2043", iacute: "\xed", icirc: "\xee", icy: "\u0438", iecy: "\u0435", iexcl: "\xa1", ifr: "\ud835\udd26", igrave: "\xec", iiiint: "\u2a0c", qint: "\u2a0c", iiint: "\u222d", tint: "\u222d", iinfin: "\u29dc", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012b", imath: "\u0131", inodot: "\u0131", imof: "\u22b7", imped: "\u01b5", incare: "\u2105", infin: "\u221e", infintie: "\u29dd", intcal: "\u22ba", intercal: "\u22ba", intlarhk: "\u2a17", intprod: "\u2a3c", iprod: "\u2a3c", iocy: "\u0451", iogon: "\u012f", iopf: "\ud835\udd5a", iota: "\u03b9", iquest: "\xbf", iscr: "\ud835\udcbe", isinE: "\u22f9", isindot: "\u22f5", isins: "\u22f4", isinsv: "\u22f3", itilde: "\u0129", iukcy: "\u0456", iuml: "\xef", jcirc: "\u0135", jcy: "\u0439", jfr: "\ud835\udd27", jmath: "\u0237", jopf: "\ud835\udd5b", jscr: "\ud835\udcbf", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03ba", kappav: "\u03f0", varkappa: "\u03f0", kcedil: "\u0137", kcy: "\u043a", kfr: "\ud835\udd28", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045c", kopf: "\ud835\udd5c", kscr: "\ud835\udcc0", lAtail: "\u291b", lBarr: "\u290e", lEg: "\u2a8b", lesseqqgtr: "\u2a8b", lHar: "\u2962", lacute: "\u013a", laemptyv: "\u29b4", lambda: "\u03bb", langd: "\u2991", lap: "\u2a85", lessapprox: "\u2a85", laquo: "\xab", larrbfs: "\u291f", larrfs: "\u291d", larrlp: "\u21ab", looparrowleft: "\u21ab", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21a2", leftarrowtail: "\u21a2", lat: "\u2aab", latail: "\u2919", late: "\u2aad", lates: "\u2aad\ufe00", lbarr: "\u290c", lbbrk: "\u2772", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "\u298b", lbrksld: "\u298f", lbrkslu: "\u298d", lcaron: "\u013e", lcedil: "\u013c", lcy: "\u043b", ldca: "\u2936", ldrdhar: "\u2967", ldrushar: "\u294b", ldsh: "\u21b2", le: "\u2264", leq: "\u2264", leftleftarrows: "\u21c7", llarr: "\u21c7", leftthreetimes: "\u22cb", lthree: "\u22cb", lescc: "\u2aa8", lesdot: "\u2a7f", lesdoto: "\u2a81", lesdotor: "\u2a83", lesg: "\u22da\ufe00", lesges: "\u2a93", lessdot: "\u22d6", ltdot: "\u22d6", lfisht: "\u297c", lfr: "\ud835\udd29", lgE: "\u2a91", lharul: "\u296a", lhblk: "\u2584", ljcy: "\u0459", llhard: "\u296b", lltri: "\u25fa", lmidot: "\u0140", lmoust: "\u23b0", lmoustache: "\u23b0", lnE: "\u2268", lneqq: "\u2268", lnap: "\u2a89", lnapprox: "\u2a89", lne: "\u2a87", lneq: "\u2a87", lnsim: "\u22e6", loang: "\u27ec", loarr: "\u21fd", longmapsto: "\u27fc", xmap: "\u27fc", looparrowright: "\u21ac", rarrlp: "\u21ac", lopar: "\u2985", lopf: "\ud835\udd5d", loplus: "\u2a2d", lotimes: "\u2a34", lowast: "\u2217", loz: "\u25ca", lozenge: "\u25ca", lpar: "(", lparlt: "\u2993", lrhard: "\u296d", lrm: "\u200e", lrtri: "\u22bf", lsaquo: "\u2039", lscr: "\ud835\udcc1", lsime: "\u2a8d", lsimg: "\u2a8f", lsquor: "\u201a", sbquo: "\u201a", lstrok: "\u0142", ltcc: "\u2aa6", ltcir: "\u2a79", ltimes: "\u22c9", ltlarr: "\u2976", ltquest: "\u2a7b", ltrPar: "\u2996", ltri: "\u25c3", triangleleft: "\u25c3", lurdshar: "\u294a", luruhar: "\u2966", lvertneqq: "\u2268\ufe00", lvnE: "\u2268\ufe00", mDDot: "\u223a", macr: "\xaf", strns: "\xaf", male: "\u2642", malt: "\u2720", maltese: "\u2720", marker: "\u25ae", mcomma: "\u2a29", mcy: "\u043c", mdash: "\u2014", mfr: "\ud835\udd2a", mho: "\u2127", micro: "\xb5", midcir: "\u2af0", minus: "\u2212", minusdu: "\u2a2a", mlcp: "\u2adb", models: "\u22a7", mopf: "\ud835\udd5e", mscr: "\ud835\udcc2", mu: "\u03bc", multimap: "\u22b8", mumap: "\u22b8", nGg: "\u22d9\u0338", nGt: "\u226b\u20d2", nLeftarrow: "\u21cd", nlArr: "\u21cd", nLeftrightarrow: "\u21ce", nhArr: "\u21ce", nLl: "\u22d8\u0338", nLt: "\u226a\u20d2", nRightarrow: "\u21cf", nrArr: "\u21cf", nVDash: "\u22af", nVdash: "\u22ae", nacute: "\u0144", nang: "\u2220\u20d2", napE: "\u2a70\u0338", napid: "\u224b\u0338", napos: "\u0149", natur: "\u266e", natural: "\u266e", ncap: "\u2a43", ncaron: "\u0148", ncedil: "\u0146", ncongdot: "\u2a6d\u0338", ncup: "\u2a42", ncy: "\u043d", ndash: "\u2013", neArr: "\u21d7", nearhk: "\u2924", nedot: "\u2250\u0338", nesear: "\u2928", toea: "\u2928", nfr: "\ud835\udd2b", nharr: "\u21ae", nleftrightarrow: "\u21ae", nhpar: "\u2af2", nis: "\u22fc", nisd: "\u22fa", njcy: "\u045a", nlE: "\u2266\u0338", nleqq: "\u2266\u0338", nlarr: "\u219a", nleftarrow: "\u219a", nldr: "\u2025", nopf: "\ud835\udd5f", not: "\xac", notinE: "\u22f9\u0338", notindot: "\u22f5\u0338", notinvb: "\u22f7", notinvc: "\u22f6", notnivb: "\u22fe", notnivc: "\u22fd", nparsl: "\u2afd\u20e5", npart: "\u2202\u0338", npolint: "\u2a14", nrarr: "\u219b", nrightarrow: "\u219b", nrarrc: "\u2933\u0338", nrarrw: "\u219d\u0338", nscr: "\ud835\udcc3", nsub: "\u2284", nsubE: "\u2ac5\u0338", nsubseteqq: "\u2ac5\u0338", nsup: "\u2285", nsupE: "\u2ac6\u0338", nsupseteqq: "\u2ac6\u0338", ntilde: "\xf1", nu: "\u03bd", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22ad", nvHarr: "\u2904", nvap: "\u224d\u20d2", nvdash: "\u22ac", nvge: "\u2265\u20d2", nvgt: ">\u20d2", nvinfin: "\u29de", nvlArr: "\u2902", nvle: "\u2264\u20d2", nvlt: "<\u20d2", nvltrie: "\u22b4\u20d2", nvrArr: "\u2903", nvrtrie: "\u22b5\u20d2", nvsim: "\u223c\u20d2", nwArr: "\u21d6", nwarhk: "\u2923", nwnear: "\u2927", oacute: "\xf3", ocirc: "\xf4", ocy: "\u043e", odblac: "\u0151", odiv: "\u2a38", odsold: "\u29bc", oelig: "\u0153", ofcir: "\u29bf", ofr: "\ud835\udd2c", ogon: "\u02db", ograve: "\xf2", ogt: "\u29c1", ohbar: "\u29b5", olcir: "\u29be", olcross: "\u29bb", olt: "\u29c0", omacr: "\u014d", omega: "\u03c9", omicron: "\u03bf", omid: "\u29b6", oopf: "\ud835\udd60", opar: "\u29b7", operp: "\u29b9", or: "\u2228", vee: "\u2228", ord: "\u2a5d", order: "\u2134", orderof: "\u2134", oscr: "\u2134", ordf: "\xaa", ordm: "\xba", origof: "\u22b6", oror: "\u2a56", orslope: "\u2a57", orv: "\u2a5b", oslash: "\xf8", osol: "\u2298", otilde: "\xf5", otimesas: "\u2a36", ouml: "\xf6", ovbar: "\u233d", para: "\xb6", parsim: "\u2af3", parsl: "\u2afd", pcy: "\u043f", percnt: "%", period: ".", permil: "\u2030", pertenk: "\u2031", pfr: "\ud835\udd2d", phi: "\u03c6", phiv: "\u03d5", straightphi: "\u03d5", varphi: "\u03d5", phone: "\u260e", pi: "\u03c0", piv: "\u03d6", varpi: "\u03d6", planckh: "\u210e", plus: "+", plusacir: "\u2a23", pluscir: "\u2a22", plusdu: "\u2a25", pluse: "\u2a72", plussim: "\u2a26", plustwo: "\u2a27", pointint: "\u2a15", popf: "\ud835\udd61", pound: "\xa3", prE: "\u2ab3", prap: "\u2ab7", precapprox: "\u2ab7", precnapprox: "\u2ab9", prnap: "\u2ab9", precneqq: "\u2ab5", prnE: "\u2ab5", precnsim: "\u22e8", prnsim: "\u22e8", prime: "\u2032", profalar: "\u232e", profline: "\u2312", profsurf: "\u2313", prurel: "\u22b0", pscr: "\ud835\udcc5", psi: "\u03c8", puncsp: "\u2008", qfr: "\ud835\udd2e", qopf: "\ud835\udd62", qprime: "\u2057", qscr: "\ud835\udcc6", quatint: "\u2a16", quest: "?", rAtail: "\u291c", rHar: "\u2964", race: "\u223d\u0331", racute: "\u0155", raemptyv: "\u29b3", rangd: "\u2992", range: "\u29a5", raquo: "\xbb", rarrap: "\u2975", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291e", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21a3", rightarrowtail: "\u21a3", rarrw: "\u219d", rightsquigarrow: "\u219d", ratail: "\u291a", ratio: "\u2236", rbbrk: "\u2773", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "\u298c", rbrksld: "\u298e", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdsh: "\u21b3", rect: "\u25ad", rfisht: "\u297d", rfr: "\ud835\udd2f", rharul: "\u296c", rho: "\u03c1", rhov: "\u03f1", varrho: "\u03f1", rightrightarrows: "\u21c9", rrarr: "\u21c9", rightthreetimes: "\u22cc", rthree: "\u22cc", ring: "\u02da", rlm: "\u200f", rmoust: "\u23b1", rmoustache: "\u23b1", rnmid: "\u2aee", roang: "\u27ed", roarr: "\u21fe", ropar: "\u2986", ropf: "\ud835\udd63", roplus: "\u2a2e", rotimes: "\u2a35", rpar: ")", rpargt: "\u2994", rppolint: "\u2a12", rsaquo: "\u203a", rscr: "\ud835\udcc7", rtimes: "\u22ca", rtri: "\u25b9", triangleright: "\u25b9", rtriltri: "\u29ce", ruluhar: "\u2968", rx: "\u211e", sacute: "\u015b", scE: "\u2ab4", scap: "\u2ab8", succapprox: "\u2ab8", scaron: "\u0161", scedil: "\u015f", scirc: "\u015d", scnE: "\u2ab6", succneqq: "\u2ab6", scnap: "\u2aba", succnapprox: "\u2aba", scnsim: "\u22e9", succnsim: "\u22e9", scpolint: "\u2a13", scy: "\u0441", sdot: "\u22c5", sdote: "\u2a66", seArr: "\u21d8", sect: "\xa7", semi: ";", seswar: "\u2929", tosa: "\u2929", sext: "\u2736", sfr: "\ud835\udd30", sharp: "\u266f", shchcy: "\u0449", shcy: "\u0448", shy: "\xad", sigma: "\u03c3", sigmaf: "\u03c2", sigmav: "\u03c2", varsigma: "\u03c2", simdot: "\u2a6a", simg: "\u2a9e", simgE: "\u2aa0", siml: "\u2a9d", simlE: "\u2a9f", simne: "\u2246", simplus: "\u2a24", simrarr: "\u2972", smashp: "\u2a33", smeparsl: "\u29e4", smile: "\u2323", ssmile: "\u2323", smt: "\u2aaa", smte: "\u2aac", smtes: "\u2aac\ufe00", softcy: "\u044c", sol: "/", solb: "\u29c4", solbar: "\u233f", sopf: "\ud835\udd64", spades: "\u2660", spadesuit: "\u2660", sqcaps: "\u2293\ufe00", sqcups: "\u2294\ufe00", sscr: "\ud835\udcc8", star: "\u2606", sub: "\u2282", subset: "\u2282", subE: "\u2ac5", subseteqq: "\u2ac5", subdot: "\u2abd", subedot: "\u2ac3", submult: "\u2ac1", subnE: "\u2acb", subsetneqq: "\u2acb", subne: "\u228a", subsetneq: "\u228a", subplus: "\u2abf", subrarr: "\u2979", subsim: "\u2ac7", subsub: "\u2ad5", subsup: "\u2ad3", sung: "\u266a", sup1: "\xb9", sup2: "\xb2", sup3: "\xb3", supE: "\u2ac6", supseteqq: "\u2ac6", supdot: "\u2abe", supdsub: "\u2ad8", supedot: "\u2ac4", suphsol: "\u27c9", suphsub: "\u2ad7", suplarr: "\u297b", supmult: "\u2ac2", supnE: "\u2acc", supsetneqq: "\u2acc", supne: "\u228b", supsetneq: "\u228b", supplus: "\u2ac0", supsim: "\u2ac8", supsub: "\u2ad4", supsup: "\u2ad6", swArr: "\u21d9", swnwar: "\u292a", szlig: "\xdf", target: "\u2316", tau: "\u03c4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", telrec: "\u2315", tfr: "\ud835\udd31", theta: "\u03b8", thetasym: "\u03d1", thetav: "\u03d1", vartheta: "\u03d1", thorn: "\xfe", times: "\xd7", timesbar: "\u2a31", timesd: "\u2a30", topbot: "\u2336", topcir: "\u2af1", topf: "\ud835\udd65", topfork: "\u2ada", tprime: "\u2034", triangle: "\u25b5", utri: "\u25b5", triangleq: "\u225c", trie: "\u225c", tridot: "\u25ec", triminus: "\u2a3a", triplus: "\u2a39", trisb: "\u29cd", tritime: "\u2a3b", trpezium: "\u23e2", tscr: "\ud835\udcc9", tscy: "\u0446", tshcy: "\u045b", tstrok: "\u0167", uHar: "\u2963", uacute: "\xfa", ubrcy: "\u045e", ubreve: "\u016d", ucirc: "\xfb", ucy: "\u0443", udblac: "\u0171", ufisht: "\u297e", ufr: "\ud835\udd32", ugrave: "\xf9", uhblk: "\u2580", ulcorn: "\u231c", ulcorner: "\u231c", ulcrop: "\u230f", ultri: "\u25f8", umacr: "\u016b", uogon: "\u0173", uopf: "\ud835\udd66", upsi: "\u03c5", upsilon: "\u03c5", upuparrows: "\u21c8", uuarr: "\u21c8", urcorn: "\u231d", urcorner: "\u231d", urcrop: "\u230e", uring: "\u016f", urtri: "\u25f9", uscr: "\ud835\udcca", utdot: "\u22f0", utilde: "\u0169", uuml: "\xfc", uwangle: "\u29a7", vBar: "\u2ae8", vBarv: "\u2ae9", vangrt: "\u299c", varsubsetneq: "\u228a\ufe00", vsubne: "\u228a\ufe00", varsubsetneqq: "\u2acb\ufe00", vsubnE: "\u2acb\ufe00", varsupsetneq: "\u228b\ufe00", vsupne: "\u228b\ufe00", varsupsetneqq: "\u2acc\ufe00", vsupnE: "\u2acc\ufe00", vcy: "\u0432", veebar: "\u22bb", veeeq: "\u225a", vellip: "\u22ee", vfr: "\ud835\udd33", vopf: "\ud835\udd67", vscr: "\ud835\udccb", vzigzag: "\u299a", wcirc: "\u0175", wedbar: "\u2a5f", wedgeq: "\u2259", weierp: "\u2118", wp: "\u2118", wfr: "\ud835\udd34", wopf: "\ud835\udd68", wscr: "\ud835\udccc", xfr: "\ud835\udd35", xi: "\u03be", xnis: "\u22fb", xopf: "\ud835\udd69", xscr: "\ud835\udccd", yacute: "\xfd", yacy: "\u044f", ycirc: "\u0177", ycy: "\u044b", yen: "\xa5", yfr: "\ud835\udd36", yicy: "\u0457", yopf: "\ud835\udd6a", yscr: "\ud835\udcce", yucy: "\u044e", yuml: "\xff", zacute: "\u017a", zcaron: "\u017e", zcy: "\u0437", zdot: "\u017c", zeta: "\u03b6", zfr: "\ud835\udd37", zhcy: "\u0436", zigrarr: "\u21dd", zopf: "\ud835\udd6b", zscr: "\ud835\udccf", zwj: "\u200d", zwnj: "\u200c" };
   mn.ngsp = "\ue500";
   var yn = null;
   var gn = new (class e {
     static fromArray(t) {
      return t
       ? ((function (e, t) {
          if (null != t && (!Array.isArray(t) || 2 != t.length)) throw new Error(`Expected '${e}' to be an array, [start, end].`);
          if (null != t) {
           let e = t[0],
            r = t[1];
           yn.forEach((t) => {
            if (t.test(e) || t.test(r)) throw new Error(`['${e}', '${r}'] contains unusable interpolation symbol.`);
           });
          }
         })("interpolation", t),
         new e(t[0], t[1]))
       : gn;
     }
     constructor(e, t) {
      (this.start = e), (this.end = t);
     }
    })("{{", "}}"),
    Dn = class extends vr {
     constructor(e, t, r) {
      super(r, e), (this.tokenType = t);
     }
    },
    xn = class {
     constructor(e, t, r) {
      (this.tokens = e), (this.errors = t), (this.nonNormalizedIcuExpressions = r);
     }
    };
   var bn,
    vn = /\r\n?/g;
   function En(e) {
    return `Unexpected character "${0 === e ? "EOF" : String.fromCharCode(e)}"`;
   }
   function Cn(e) {
    return `Unknown entity "${e}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
   }
   !(function (e) {
    (e.HEX = "hexadecimal"), (e.DEC = "decimal");
   })(bn || (bn = {}));
   var Tn = class {
     constructor(e) {
      this.error = e;
     }
    },
    wn = class {
     constructor(e, t, r) {
      (this._getTagContentType = t), (this._currentTokenStart = null), (this._currentTokenType = null), (this._expansionCaseStack = []), (this._inInterpolation = !1), (this._fullNameStack = []), (this.tokens = []), (this.errors = []), (this.nonNormalizedIcuExpressions = []), (this._tokenizeIcu = r.tokenizeExpansionForms || !1), (this._interpolationConfig = r.interpolationConfig || gn), (this._leadingTriviaCodePoints = r.leadingTriviaChars && r.leadingTriviaChars.map((e) => e.codePointAt(0) || 0)), (this._canSelfClose = r.canSelfClose || !1), (this._allowHtmComponentClosingTags = r.allowHtmComponentClosingTags || !1);
      let n = r.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
      (this._cursor = r.escapedString ? new Ln(e, n) : new _n(e, n)), (this._preserveLineEndings = r.preserveLineEndings || !1), (this._i18nNormalizeLineEndingsInICUs = r.i18nNormalizeLineEndingsInICUs || !1), (this._tokenizeBlocks = r.tokenizeBlocks ?? !0);
      try {
       this._cursor.init();
      } catch (s) {
       this.handleError(s);
      }
     }
     _processCarriageReturns(e) {
      return this._preserveLineEndings ? e : e.replace(vn, "\n");
     }
     tokenize() {
      for (; 0 !== this._cursor.peek(); ) {
       let t = this._cursor.clone();
       try {
        if (this._attemptCharCode(60))
         if (this._attemptCharCode(33)) this._attemptStr("[CDATA[") ? this._consumeCdata(t) : this._attemptStr("--") ? this._consumeComment(t) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(t) : this._consumeBogusComment(t);
         else if (this._attemptCharCode(47)) this._consumeTagClose(t);
         else {
          let e = this._cursor.clone();
          this._attemptCharCode(63) ? ((this._cursor = e), this._consumeBogusComment(t)) : this._consumeTagOpen(t);
         }
        else
         this._tokenizeBlocks && this._attemptCharCode(64)
          ? this._consumeBlockStart(t)
          : !this._tokenizeBlocks || this._inInterpolation || this._isInExpansionCase() || this._isInExpansionForm() || !this._attemptCharCode(125)
            ? (this._tokenizeIcu && this._tokenizeExpansionForm()) ||
              this._consumeWithInterpolation(
               5,
               8,
               () => this._isTextEnd(),
               () => this._isTagStart(),
              )
            : this._consumeBlockEnd(t);
       } catch (e) {
        this.handleError(e);
       }
      }
      this._beginToken(30), this._endToken([]);
     }
     _getBlockName() {
      let e = !1,
       t = this._cursor.clone();
      return this._attemptCharCodeUntilFn((t) => (lr(t) ? !e : !Nn(t) || ((e = !0), !1))), this._cursor.getChars(t).trim();
     }
     _consumeBlockStart(e) {
      this._beginToken(25, e);
      let t = this._endToken([this._getBlockName()]);
      if (40 === this._cursor.peek()) {
       if ((this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(Sn), !this._attemptCharCode(41))) return void (t.type = 29);
       this._attemptCharCodeUntilFn(Sn);
      }
      this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : (t.type = 29);
     }
     _consumeBlockEnd(e) {
      this._beginToken(27, e), this._endToken([]);
     }
     _consumeBlockParameters() {
      for (this._attemptCharCodeUntilFn(Bn); 41 !== this._cursor.peek() && 0 !== this._cursor.peek(); ) {
       this._beginToken(28);
       let e = this._cursor.clone(),
        t = null,
        r = 0;
       for (; (59 !== this._cursor.peek() && 0 !== this._cursor.peek()) || null !== t; ) {
        let e = this._cursor.peek();
        if (92 === e) this._cursor.advance();
        else if (e === t) t = null;
        else if (null === t && fr(e)) t = e;
        else if (40 === e && null === t) r++;
        else if (41 === e && null === t) {
         if (0 === r) break;
         r > 0 && r--;
        }
        this._cursor.advance();
       }
       this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(Bn);
      }
     }
     _tokenizeExpansionForm() {
      if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), !0;
      if (
       (function (e) {
        return 125 !== e;
       })(this._cursor.peek()) &&
       this._isInExpansionForm()
      )
       return this._consumeExpansionCaseStart(), !0;
      if (125 === this._cursor.peek()) {
       if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), !0;
       if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), !0;
      }
      return !1;
     }
     _beginToken(e, t = this._cursor.clone()) {
      (this._currentTokenStart = t), (this._currentTokenType = e);
     }
     _endToken(e, t) {
      if (null === this._currentTokenStart) throw new Dn("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t));
      if (null === this._currentTokenType) throw new Dn("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
      let r = { type: this._currentTokenType, parts: e, sourceSpan: (t ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
      return this.tokens.push(r), (this._currentTokenStart = null), (this._currentTokenType = null), r;
     }
     _createError(e, t) {
      this._isInExpansionForm() && (e += ' (Do you have an unescaped "{" in your template? Use "{{ \'{\' }}") to escape it.)');
      let r = new Dn(e, this._currentTokenType, t);
      return (this._currentTokenStart = null), (this._currentTokenType = null), new Tn(r);
     }
     handleError(e) {
      if ((e instanceof On && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), !(e instanceof Tn))) throw e;
      this.errors.push(e.error);
     }
     _attemptCharCode(e) {
      return this._cursor.peek() === e && (this._cursor.advance(), !0);
     }
     _attemptCharCodeCaseInsensitive(e) {
      return (
       !!(function (e, t) {
        return In(e) === In(t);
       })(this._cursor.peek(), e) && (this._cursor.advance(), !0)
      );
     }
     _requireCharCode(e) {
      let t = this._cursor.clone();
      if (!this._attemptCharCode(e)) throw this._createError(En(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _attemptStr(e) {
      let t = e.length;
      if (this._cursor.charsLeft() < t) return !1;
      let r = this._cursor.clone();
      for (let n = 0; n < t; n++) if (!this._attemptCharCode(e.charCodeAt(n))) return (this._cursor = r), !1;
      return !0;
     }
     _attemptStrCaseInsensitive(e) {
      for (let t = 0; t < e.length; t++) if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t))) return !1;
      return !0;
     }
     _requireStr(e) {
      let t = this._cursor.clone();
      if (!this._attemptStr(e)) throw this._createError(En(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _requireStrCaseInsensitive(e) {
      let t = this._cursor.clone();
      if (!this._attemptStrCaseInsensitive(e)) throw this._createError(En(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _attemptCharCodeUntilFn(e) {
      for (; !e(this._cursor.peek()); ) this._cursor.advance();
     }
     _requireCharCodeUntilFn(e, t) {
      let r = this._cursor.clone();
      if ((this._attemptCharCodeUntilFn(e), this._cursor.diff(r) < t)) throw this._createError(En(this._cursor.peek()), this._cursor.getSpan(r));
     }
     _attemptUntilChar(e) {
      for (; this._cursor.peek() !== e; ) this._cursor.advance();
     }
     _readChar() {
      let e = String.fromCodePoint(this._cursor.peek());
      return this._cursor.advance(), e;
     }
     _consumeEntity(e) {
      this._beginToken(9);
      let t = this._cursor.clone();
      if ((this._cursor.advance(), this._attemptCharCode(35))) {
       let e = this._attemptCharCode(120) || this._attemptCharCode(88),
        r = this._cursor.clone();
       if ((this._attemptCharCodeUntilFn(kn), 59 != this._cursor.peek())) {
        this._cursor.advance();
        let r = e ? bn.HEX : bn.DEC;
        throw this._createError(
         (function (e, t) {
          return `Unable to parse entity "${t}" - ${e} character reference entities must end with ";"`;
         })(r, this._cursor.getChars(t)),
         this._cursor.getSpan(),
        );
       }
       let n = this._cursor.getChars(r);
       this._cursor.advance();
       try {
        let r = parseInt(n, e ? 16 : 10);
        this._endToken([String.fromCharCode(r), this._cursor.getChars(t)]);
       } catch {
        throw this._createError(Cn(this._cursor.getChars(t)), this._cursor.getSpan());
       }
      } else {
       let r = this._cursor.clone();
       if ((this._attemptCharCodeUntilFn(Pn), 59 != this._cursor.peek())) this._beginToken(e, t), (this._cursor = r), this._endToken(["&"]);
       else {
        let e = this._cursor.getChars(r);
        this._cursor.advance();
        let n = mn[e];
        if (!n) throw this._createError(Cn(e), this._cursor.getSpan(t));
        this._endToken([n, `&${e};`]);
       }
      }
     }
     _consumeRawText(e, t) {
      this._beginToken(e ? 6 : 7);
      let r = [];
      for (;;) {
       let n = this._cursor.clone(),
        s = t();
       if (((this._cursor = n), s)) break;
       e && 38 === this._cursor.peek() ? (this._endToken([this._processCarriageReturns(r.join(""))]), (r.length = 0), this._consumeEntity(6), this._beginToken(6)) : r.push(this._readChar());
      }
      this._endToken([this._processCarriageReturns(r.join(""))]);
     }
     _consumeComment(e) {
      this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("--\x3e")), this._beginToken(11), this._requireStr("--\x3e"), this._endToken([]);
     }
     _consumeBogusComment(e) {
      this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => 62 === this._cursor.peek()), this._beginToken(11), this._cursor.advance(), this._endToken([]);
     }
     _consumeCdata(e) {
      this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
     }
     _consumeDocType(e) {
      this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => 62 === this._cursor.peek()), this._beginToken(19), this._cursor.advance(), this._endToken([]);
     }
     _consumePrefixAndName() {
      let e,
       t = this._cursor.clone(),
       r = "";
      for (; 58 !== this._cursor.peek() && !Fn(this._cursor.peek()); ) this._cursor.advance();
      return 58 === this._cursor.peek() ? ((r = this._cursor.getChars(t)), this._cursor.advance(), (e = this._cursor.clone())) : (e = t), this._requireCharCodeUntilFn(An, "" === r ? 0 : 1), [r, this._cursor.getChars(e)];
     }
     _consumeTagOpen(e) {
      let t,
       r,
       n,
       s = [];
      try {
       if (!cr(this._cursor.peek())) throw this._createError(En(this._cursor.peek()), this._cursor.getSpan(e));
       for (n = this._consumeTagOpenStart(e), r = n.parts[0], t = n.parts[1], this._attemptCharCodeUntilFn(Sn); 47 !== this._cursor.peek() && 62 !== this._cursor.peek() && 60 !== this._cursor.peek() && 0 !== this._cursor.peek(); ) {
        let [e, t] = this._consumeAttributeName();
        if ((this._attemptCharCodeUntilFn(Sn), this._attemptCharCode(61))) {
         this._attemptCharCodeUntilFn(Sn);
         let r = this._consumeAttributeValue();
         s.push({ prefix: e, name: t, value: r });
        } else s.push({ prefix: e, name: t });
        this._attemptCharCodeUntilFn(Sn);
       }
       this._consumeTagOpenEnd();
      } catch (a) {
       if (a instanceof Tn) return void (n ? (n.type = 4) : (this._beginToken(5, e), this._endToken(["<"])));
       throw a;
      }
      if (this._canSelfClose && 2 === this.tokens[this.tokens.length - 1].type) return;
      let i = this._getTagContentType(t, r, this._fullNameStack.length > 0, s);
      this._handleFullNameStackForTagOpen(r, t), i === Lr.RAW_TEXT ? this._consumeRawTextWithTagClose(r, t, !1) : i === Lr.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r, t, !0);
     }
     _consumeRawTextWithTagClose(e, t, r) {
      this._consumeRawText(r, () => !!(this._attemptCharCode(60) && this._attemptCharCode(47) && (this._attemptCharCodeUntilFn(Sn), this._attemptStrCaseInsensitive(e ? `${e}:${t}` : t))) && (this._attemptCharCodeUntilFn(Sn), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((e) => 62 === e, 3), this._cursor.advance(), this._endToken([e, t]), this._handleFullNameStackForTagClose(e, t);
     }
     _consumeTagOpenStart(e) {
      this._beginToken(0, e);
      let t = this._consumePrefixAndName();
      return this._endToken(t);
     }
     _consumeAttributeName() {
      let e = this._cursor.peek();
      if (39 === e || 34 === e) throw this._createError(En(e), this._cursor.getSpan());
      this._beginToken(14);
      let t = this._consumePrefixAndName();
      return this._endToken(t), t;
     }
     _consumeAttributeValue() {
      let e;
      if (39 === this._cursor.peek() || 34 === this._cursor.peek()) {
       let t = this._cursor.peek();
       this._consumeQuote(t);
       let r = () => this._cursor.peek() === t;
       (e = this._consumeWithInterpolation(16, 17, r, r)), this._consumeQuote(t);
      } else {
       let t = () => An(this._cursor.peek());
       e = this._consumeWithInterpolation(16, 17, t, t);
      }
      return e;
     }
     _consumeQuote(e) {
      this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
     }
     _consumeTagOpenEnd() {
      let e = this._attemptCharCode(47) ? 2 : 1;
      this._beginToken(e), this._requireCharCode(62), this._endToken([]);
     }
     _consumeTagClose(e) {
      if ((this._beginToken(3, e), this._attemptCharCodeUntilFn(Sn), this._allowHtmComponentClosingTags && this._attemptCharCode(47))) this._attemptCharCodeUntilFn(Sn), this._requireCharCode(62), this._endToken([]);
      else {
       let [e, t] = this._consumePrefixAndName();
       this._attemptCharCodeUntilFn(Sn), this._requireCharCode(62), this._endToken([e, t]), this._handleFullNameStackForTagClose(e, t);
      }
     }
     _consumeExpansionFormStart() {
      this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
      let e = this._readUntil(44),
       t = this._processCarriageReturns(e);
      if (this._i18nNormalizeLineEndingsInICUs) this._endToken([t]);
      else {
       let r = this._endToken([e]);
       t !== e && this.nonNormalizedIcuExpressions.push(r);
      }
      this._requireCharCode(44), this._attemptCharCodeUntilFn(Sn), this._beginToken(7);
      let r = this._readUntil(44);
      this._endToken([r]), this._requireCharCode(44), this._attemptCharCodeUntilFn(Sn);
     }
     _consumeExpansionCaseStart() {
      this._beginToken(21);
      let e = this._readUntil(123).trim();
      this._endToken([e]), this._attemptCharCodeUntilFn(Sn), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(Sn), this._expansionCaseStack.push(22);
     }
     _consumeExpansionCaseEnd() {
      this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(Sn), this._expansionCaseStack.pop();
     }
     _consumeExpansionFormEnd() {
      this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
     }
     _consumeWithInterpolation(e, t, r, n) {
      this._beginToken(e);
      let s = [];
      for (; !r(); ) {
       let r = this._cursor.clone();
       this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(s.join(""))], r), (s.length = 0), this._consumeInterpolation(t, r, n), this._beginToken(e)) : 38 === this._cursor.peek() ? (this._endToken([this._processCarriageReturns(s.join(""))]), (s.length = 0), this._consumeEntity(e), this._beginToken(e)) : s.push(this._readChar());
      }
      this._inInterpolation = !1;
      let i = this._processCarriageReturns(s.join(""));
      return this._endToken([i]), i;
     }
     _consumeInterpolation(e, t, r) {
      let n = [];
      this._beginToken(e, t), n.push(this._interpolationConfig.start);
      let s = this._cursor.clone(),
       i = null,
       a = !1;
      for (; 0 !== this._cursor.peek() && (null === r || !r()); ) {
       let e = this._cursor.clone();
       if (this._isTagStart()) return (this._cursor = e), n.push(this._getProcessedChars(s, e)), void this._endToken(n);
       if (null === i) {
        if (this._attemptStr(this._interpolationConfig.end)) return n.push(this._getProcessedChars(s, e)), n.push(this._interpolationConfig.end), void this._endToken(n);
        this._attemptStr("//") && (a = !0);
       }
       let t = this._cursor.peek();
       this._cursor.advance(), 92 === t ? this._cursor.advance() : t === i ? (i = null) : !a && null === i && fr(t) && (i = t);
      }
      n.push(this._getProcessedChars(s, this._cursor)), this._endToken(n);
     }
     _getProcessedChars(e, t) {
      return this._processCarriageReturns(t.getChars(e));
     }
     _isTextEnd() {
      return !!(this._isTagStart() || 0 === this._cursor.peek() || (this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || (125 === this._cursor.peek() && this._isInExpansionCase()))) || (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || 125 === this._cursor.peek())));
     }
     _isTagStart() {
      if (60 === this._cursor.peek()) {
       let e = this._cursor.clone();
       e.advance();
       let t = e.peek();
       if ((97 <= t && t <= 122) || (65 <= t && t <= 90) || 47 === t || 33 === t) return !0;
      }
      return !1;
     }
     _isBlockStart() {
      if (this._tokenizeBlocks && 64 === this._cursor.peek()) {
       let e = this._cursor.clone();
       if ((e.advance(), Nn(e.peek()))) return !0;
      }
      return !1;
     }
     _readUntil(e) {
      let t = this._cursor.clone();
      return this._attemptUntilChar(e), this._cursor.getChars(t);
     }
     _isInExpansion() {
      return this._isInExpansionCase() || this._isInExpansionForm();
     }
     _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && 22 === this._expansionCaseStack[this._expansionCaseStack.length - 1];
     }
     _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && 20 === this._expansionCaseStack[this._expansionCaseStack.length - 1];
     }
     isExpansionFormStart() {
      if (123 !== this._cursor.peek()) return !1;
      if (this._interpolationConfig) {
       let e = this._cursor.clone(),
        t = this._attemptStr(this._interpolationConfig.start);
       return (this._cursor = e), !t;
      }
      return !0;
     }
     _handleFullNameStackForTagOpen(e, t) {
      let r = Vr(e, t);
      (0 === this._fullNameStack.length || this._fullNameStack[this._fullNameStack.length - 1] === r) && this._fullNameStack.push(r);
     }
     _handleFullNameStackForTagClose(e, t) {
      let r = Vr(e, t);
      0 !== this._fullNameStack.length && this._fullNameStack[this._fullNameStack.length - 1] === r && this._fullNameStack.pop();
     }
    };
   function Sn(e) {
    return !lr(e) || 0 === e;
   }
   function An(e) {
    return lr(e) || 62 === e || 60 === e || 47 === e || 39 === e || 34 === e || 61 === e || 0 === e;
   }
   function Fn(e) {
    return (e < 97 || 122 < e) && (e < 65 || 90 < e) && (e < 48 || e > 57);
   }
   function kn(e) {
    return (
     59 === e ||
     0 === e ||
     !(function (e) {
      return (e >= 97 && e <= 102) || (e >= 65 && e <= 70) || pr(e);
     })(e)
    );
   }
   function Pn(e) {
    return 59 === e || 0 === e || !cr(e);
   }
   function In(e) {
    return e >= 97 && e <= 122 ? e - 97 + 65 : e;
   }
   function Nn(e) {
    return cr(e) || pr(e) || 95 === e;
   }
   function Bn(e) {
    return 59 !== e && Sn(e);
   }
   var _n = class e {
     constructor(t, r) {
      if (t instanceof e) {
       (this.file = t.file), (this.input = t.input), (this.end = t.end);
       let e = t.state;
       this.state = { peek: e.peek, offset: e.offset, line: e.line, column: e.column };
      } else {
       if (!r) throw new Error("Programming error: the range argument must be provided with a file argument.");
       (this.file = t), (this.input = t.content), (this.end = r.endPos), (this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol });
      }
     }
     clone() {
      return new e(this);
     }
     peek() {
      return this.state.peek;
     }
     charsLeft() {
      return this.end - this.state.offset;
     }
     diff(e) {
      return this.state.offset - e.state.offset;
     }
     advance() {
      this.advanceState(this.state);
     }
     init() {
      this.updatePeek(this.state);
     }
     getSpan(e, t) {
      let r = (e = e || this);
      if (t) for (; this.diff(e) > 0 && -1 !== t.indexOf(e.peek()); ) r === e && (e = e.clone()), e.advance();
      let n = this.locationFromCursor(e),
       s = this.locationFromCursor(this),
       i = r !== e ? this.locationFromCursor(r) : n;
      return new br(n, s, i);
     }
     getChars(e) {
      return this.input.substring(e.state.offset, this.state.offset);
     }
     charAt(e) {
      return this.input.charCodeAt(e);
     }
     advanceState(e) {
      if (e.offset >= this.end) throw ((this.state = e), new On('Unexpected character "EOF"', this));
      let t = this.charAt(e.offset);
      10 === t ? (e.line++, (e.column = 0)) : hr(t) || e.column++, e.offset++, this.updatePeek(e);
     }
     updatePeek(e) {
      e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
     }
     locationFromCursor(e) {
      return new Dr(e.file, e.state.offset, e.state.line, e.state.column);
     }
    },
    Ln = class e extends _n {
     constructor(t, r) {
      t instanceof e ? (super(t), (this.internalState = { ...t.internalState })) : (super(t, r), (this.internalState = this.state));
     }
     advance() {
      (this.state = this.internalState), super.advance(), this.processEscapeSequence();
     }
     init() {
      super.init(), this.processEscapeSequence();
     }
     clone() {
      return new e(this);
     }
     getChars(e) {
      let t = e.clone(),
       r = "";
      for (; t.internalState.offset < this.internalState.offset; ) (r += String.fromCodePoint(t.peek())), t.advance();
      return r;
     }
     processEscapeSequence() {
      let e = () => this.internalState.peek;
      if (92 === e())
       if (((this.internalState = { ...this.state }), this.advanceState(this.internalState), 110 === e())) this.state.peek = 10;
       else if (114 === e()) this.state.peek = 13;
       else if (118 === e()) this.state.peek = 11;
       else if (116 === e()) this.state.peek = 9;
       else if (98 === e()) this.state.peek = 8;
       else if (102 === e()) this.state.peek = 12;
       else if (117 === e())
        if ((this.advanceState(this.internalState), 123 === e())) {
         this.advanceState(this.internalState);
         let t = this.clone(),
          r = 0;
         for (; 125 !== e(); ) this.advanceState(this.internalState), r++;
         this.state.peek = this.decodeHexDigits(t, r);
        } else {
         let e = this.clone();
         this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), (this.state.peek = this.decodeHexDigits(e, 4));
        }
       else if (120 === e()) {
        this.advanceState(this.internalState);
        let e = this.clone();
        this.advanceState(this.internalState), (this.state.peek = this.decodeHexDigits(e, 2));
       } else if (dr(e())) {
        let t = "",
         r = 0,
         n = this.clone();
        for (; dr(e()) && r < 3; ) (n = this.clone()), (t += String.fromCodePoint(e())), this.advanceState(this.internalState), r++;
        (this.state.peek = parseInt(t, 8)), (this.internalState = n.internalState);
       } else hr(this.internalState.peek) ? (this.advanceState(this.internalState), (this.state = this.internalState)) : (this.state.peek = this.internalState.peek);
     }
     decodeHexDigits(e, t) {
      let r = this.input.slice(e.internalState.offset, e.internalState.offset + t),
       n = parseInt(r, 16);
      if (isNaN(n)) throw ((e.state = e.internalState), new On("Invalid hexadecimal escape sequence", e));
      return n;
     }
    },
    On = class {
     constructor(e, t) {
      (this.msg = e), (this.cursor = t);
     }
    },
    Mn = class e extends vr {
     static create(t, r, n) {
      return new e(t, r, n);
     }
     constructor(e, t, r) {
      super(t, r), (this.elementName = e);
     }
    },
    jn = class {
     constructor(e, t) {
      (this.rootNodes = e), (this.errors = t);
     }
    },
    Rn = class {
     constructor(e) {
      this.getTagDefinition = e;
     }
     parse(e, t, r, n = !1, s) {
      let i =
        (e) =>
        (t, ...r) =>
         e(t.toLowerCase(), ...r),
       a = n ? this.getTagDefinition : i(this.getTagDefinition),
       o = (e) => a(e).getContentType(),
       u = n ? s : i(s),
       l = (function (e, t, r, n = {}) {
        let s = new wn(new xr(e, t), r, n);
        return (
         s.tokenize(),
         new xn(
          (function (e) {
           let t,
            r = [];
           for (let n = 0; n < e.length; n++) {
            let s = e[n];
            (t && 5 === t.type && 5 === s.type) || (t && 16 === t.type && 16 === s.type) ? ((t.parts[0] += s.parts[0]), (t.sourceSpan.end = s.sourceSpan.end)) : ((t = s), r.push(t));
           }
           return r;
          })(s.tokens),
          s.errors,
          s.nonNormalizedIcuExpressions,
         )
        );
       })(
        e,
        t,
        s
         ? (e, t, r, n) => {
            let s = u(e, t, r, n);
            return void 0 !== s ? s : o(e);
           }
         : o,
        r,
       ),
       p = (r && r.canSelfClose) || !1,
       c = (r && r.allowHtmComponentClosingTags) || !1,
       h = new qn(l.tokens, a, p, c, n);
      return h.build(), new jn(h.rootNodes, l.errors.concat(h.errors));
     }
    },
    qn = class e {
     constructor(e, t, r, n, s) {
      (this.tokens = e), (this.getTagDefinition = t), (this.canSelfClose = r), (this.allowHtmComponentClosingTags = n), (this.isTagNameCaseSensitive = s), (this._index = -1), (this._containerStack = []), (this.rootNodes = []), (this.errors = []), this._advance();
     }
     build() {
      for (; 30 !== this._peek.type; ) 0 === this._peek.type || 4 === this._peek.type ? this._consumeStartTag(this._advance()) : 3 === this._peek.type ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : 12 === this._peek.type ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : 10 === this._peek.type ? (this._closeVoidElement(), this._consumeComment(this._advance())) : 5 === this._peek.type || 7 === this._peek.type || 6 === this._peek.type ? (this._closeVoidElement(), this._consumeText(this._advance())) : 20 === this._peek.type ? this._consumeExpansion(this._advance()) : 25 === this._peek.type ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : 27 === this._peek.type ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : 29 === this._peek.type ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : 18 === this._peek.type ? this._consumeDocType(this._advance()) : this._advance();
      for (let e of this._containerStack) e instanceof cn && this.errors.push(Mn.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
     }
     _advance() {
      let e = this._peek;
      return this._index < this.tokens.length - 1 && this._index++, (this._peek = this.tokens[this._index]), e;
     }
     _advanceIf(e) {
      return this._peek.type === e ? this._advance() : null;
     }
     _consumeCdata(e) {
      let t = this._advance(),
       r = this._getText(t),
       n = this._advanceIf(13);
      this._addToParent(new nn(r, new br(e.sourceSpan.start, (n || t).sourceSpan.end), [t]));
     }
     _consumeComment(e) {
      let t = this._advanceIf(7),
       r = this._advanceIf(11),
       n = null != t ? t.parts[0].trim() : null,
       s = new br(e.sourceSpan.start, (r || t || e).sourceSpan.end);
      this._addToParent(new ln(n, s));
     }
     _consumeDocType(e) {
      let t = this._advanceIf(7),
       r = this._advanceIf(19),
       n = null != t ? t.parts[0].trim() : null,
       s = new br(e.sourceSpan.start, (r || t || e).sourceSpan.end);
      this._addToParent(new pn(n, s));
     }
     _consumeExpansion(e) {
      let t = this._advance(),
       r = this._advance(),
       n = [];
      for (; 21 === this._peek.type; ) {
       let e = this._parseExpansionCase();
       if (!e) return;
       n.push(e);
      }
      if (24 !== this._peek.type) return void this.errors.push(Mn.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      let s = new br(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
      this._addToParent(new sn(t.parts[0], r.parts[0], n, s, t.sourceSpan)), this._advance();
     }
     _parseExpansionCase() {
      let t = this._advance();
      if (22 !== this._peek.type) return this.errors.push(Mn.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
      let r = this._advance(),
       n = this._collectExpansionExpTokens(r);
      if (!n) return null;
      let s = this._advance();
      n.push({ type: 30, parts: [], sourceSpan: s.sourceSpan });
      let i = new e(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
      if ((i.build(), i.errors.length > 0)) return (this.errors = this.errors.concat(i.errors)), null;
      let a = new br(t.sourceSpan.start, s.sourceSpan.end, t.sourceSpan.fullStart),
       o = new br(r.sourceSpan.start, s.sourceSpan.end, r.sourceSpan.fullStart);
      return new an(t.parts[0], i.rootNodes, a, t.sourceSpan, o);
     }
     _collectExpansionExpTokens(e) {
      let t = [],
       r = [22];
      for (;;) {
       if (((20 === this._peek.type || 22 === this._peek.type) && r.push(this._peek.type), 23 === this._peek.type)) {
        if (!Un(r, 22)) return this.errors.push(Mn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if ((r.pop(), 0 === r.length)) return t;
       }
       if (24 === this._peek.type) {
        if (!Un(r, 20)) return this.errors.push(Mn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        r.pop();
       }
       if (30 === this._peek.type) return this.errors.push(Mn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
       t.push(this._advance());
      }
     }
     _getText(e) {
      let t = e.parts[0];
      if (t.length > 0 && "\n" == t[0]) {
       let e = this._getClosestParentElement();
       null != e && 0 == e.children.length && this.getTagDefinition(e.name).ignoreFirstLf && (t = t.substring(1));
      }
      return t;
     }
     _consumeText(e) {
      let t = [e],
       r = e.sourceSpan,
       n = e.parts[0];
      if (n.length > 0 && "\n" === n[0]) {
       let r = this._getContainer();
       null != r && 0 === r.children.length && this.getTagDefinition(r.name).ignoreFirstLf && ((n = n.substring(1)), (t[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [n] }));
      }
      for (; 8 === this._peek.type || 5 === this._peek.type || 9 === this._peek.type; ) (e = this._advance()), t.push(e), 8 === e.type ? (n += e.parts.join("").replace(/&([^;]+);/g, $n)) : 9 === e.type ? (n += e.parts[0]) : (n += e.parts.join(""));
      if (n.length > 0) {
       let s = e.sourceSpan;
       this._addToParent(new rn(n, new br(r.start, s.end, r.fullStart, r.details), t));
      }
     }
     _closeVoidElement() {
      let e = this._getContainer();
      e instanceof un && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
     }
     _consumeStartTag(e) {
      let [t, r] = e.parts,
       n = [];
      for (; 14 === this._peek.type; ) n.push(this._consumeAttr(this._advance()));
      let s = this._getElementFullName(t, r, this._getClosestParentElement()),
       i = !1;
      if (2 === this._peek.type) {
       this._advance(), (i = !0);
       let t = this.getTagDefinition(s);
       this.canSelfClose || t.canSelfClose || null !== $r(s) || t.isVoid || this.errors.push(Mn.create(s, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
      } else 1 === this._peek.type && (this._advance(), (i = !1));
      let a = this._peek.sourceSpan.fullStart,
       o = new br(e.sourceSpan.start, a, e.sourceSpan.fullStart),
       u = new br(e.sourceSpan.start, a, e.sourceSpan.fullStart),
       l = new br(e.sourceSpan.start.moveBy(1), e.sourceSpan.end),
       p = new un(s, n, [], o, u, void 0, l),
       c = this._getContainer();
      this._pushContainer(p, c instanceof un && this.getTagDefinition(c.name).isClosedByChild(p.name)), i ? this._popContainer(s, un, o) : 4 === e.type && (this._popContainer(s, un, null), this.errors.push(Mn.create(s, o, `Opening tag "${s}" not terminated.`)));
     }
     _pushContainer(e, t) {
      t && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
     }
     _consumeEndTag(e) {
      let t = this.allowHtmComponentClosingTags && 0 === e.parts.length ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
      if (t && this.getTagDefinition(t).isVoid) this.errors.push(Mn.create(t, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
      else if (!this._popContainer(t, un, e.sourceSpan)) {
       let r = `Unexpected closing tag "${t}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
       this.errors.push(Mn.create(t, e.sourceSpan, r));
      }
     }
     _popContainer(e, t, r) {
      let n = !1;
      for (let s = this._containerStack.length - 1; s >= 0; s--) {
       let i = this._containerStack[s];
       if ($r(i.name) ? i.name === e : (null == e || i.name.toLowerCase() === e.toLowerCase()) && i instanceof t) return (i.endSourceSpan = r), (i.sourceSpan.end = null !== r ? r.end : i.sourceSpan.end), this._containerStack.splice(s, this._containerStack.length - s), !n;
       (i instanceof cn || (i instanceof un && !this.getTagDefinition(i.name).closedByParent)) && (n = !0);
      }
      return !1;
     }
     _consumeAttr(e) {
      let t,
       r = Vr(e.parts[0], e.parts[1]),
       n = e.sourceSpan.end;
      15 === this._peek.type && (t = this._advance());
      let s,
       i,
       a = "",
       o = [];
      if (16 === this._peek.type)
       for (s = this._peek.sourceSpan, i = this._peek.sourceSpan.end; 16 === this._peek.type || 17 === this._peek.type || 9 === this._peek.type; ) {
        let e = this._advance();
        o.push(e), 17 === e.type ? (a += e.parts.join("").replace(/&([^;]+);/g, $n)) : 9 === e.type ? (a += e.parts[0]) : (a += e.parts.join("")), (i = n = e.sourceSpan.end);
       }
      15 === this._peek.type && (i = n = this._advance().sourceSpan.end);
      let u = s && i && new br((null == t ? void 0 : t.sourceSpan.start) ?? s.start, i, (null == t ? void 0 : t.sourceSpan.fullStart) ?? s.fullStart);
      return new on(r, a, new br(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, u, o.length > 0 ? o : void 0, void 0);
     }
     _consumeBlockOpen(e) {
      let t = [];
      for (; 28 === this._peek.type; ) {
       let e = this._advance();
       t.push(new hn(e.parts[0], e.sourceSpan));
      }
      26 === this._peek.type && this._advance();
      let r = this._peek.sourceSpan.fullStart,
       n = new br(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       s = new br(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       i = new cn(e.parts[0], t, [], n, s);
      this._pushContainer(i, !1);
     }
     _consumeBlockClose(e) {
      this._popContainer(null, cn, e.sourceSpan) || this.errors.push(Mn.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
     }
     _consumeIncompleteBlock(e) {
      let t = [];
      for (; 28 === this._peek.type; ) {
       let e = this._advance();
       t.push(new hn(e.parts[0], e.sourceSpan));
      }
      let r = this._peek.sourceSpan.fullStart,
       n = new br(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       s = new br(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       i = new cn(e.parts[0], t, [], n, s);
      this._pushContainer(i, !1), this._popContainer(null, cn, null), this.errors.push(Mn.create(e.parts[0], n, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
     }
     _getContainer() {
      return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
     }
     _getClosestParentElement() {
      for (let e = this._containerStack.length - 1; e > -1; e--) if (this._containerStack[e] instanceof un) return this._containerStack[e];
      return null;
     }
     _addToParent(e) {
      let t = this._getContainer();
      null === t ? this.rootNodes.push(e) : t.children.push(e);
     }
     _getElementFullName(e, t, r) {
      if ("" === e && "" === (e = this.getTagDefinition(t).implicitNamespacePrefix || "") && null != r) {
       let t = Rr(r.name)[1];
       this.getTagDefinition(t).preventNamespaceInheritance || (e = $r(r.name));
      }
      return Vr(e, t);
     }
    };
   function Un(e, t) {
    return e.length > 0 && e[e.length - 1] === t;
   }
   function $n(e, t) {
    return void 0 !== mn[t] ? mn[t] || e : /^#x[a-f0-9]+$/i.test(t) ? String.fromCodePoint(parseInt(t.slice(2), 16)) : /^#\d+$/.test(t) ? String.fromCodePoint(parseInt(t.slice(1), 10)) : e;
   }
   var Vn = class extends Rn {
     constructor() {
      super(en);
     }
     parse(e, t, r, n = !1, s) {
      return super.parse(e, t, r, n, s);
     }
    },
    zn = null,
    Wn = () => (zn || (zn = new Vn()), zn);
   function Hn(e, t = {}) {
    let { canSelfClose: r = !1, allowHtmComponentClosingTags: n = !1, isTagNameCaseSensitive: s = !1, getTagContentType: i, tokenizeAngularBlocks: a = !1 } = t;
    return Wn().parse(e, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: a }, s, i);
   }
   var Jn = function (e, t) {
     let r = new SyntaxError(e + " (" + t.loc.start.line + ":" + t.loc.start.column + ")");
     return Object.assign(r, t);
    },
    Kn = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
   var Gn = function (e) {
     let t = e.match(Kn);
     if (!t) return { content: e };
     let { startDelimiter: r, language: n, value: s = "", endDelimiter: i } = t.groups,
      a = n.trim() || "yaml";
     if (("+++" === r && (a = "toml"), "yaml" !== a && r !== i)) return { content: e };
     let [o] = t;
     return { frontMatter: { type: "front-matter", lang: a, value: s, startDelimiter: r, endDelimiter: i, raw: o.replace(/\n$/, "") }, content: u(!1, o, /[^\n]/g, " ") + e.slice(o.length) };
    },
    Xn = { attrs: !0, children: !0, cases: !0, expression: !0 },
    Yn = new Set(["parent"]),
    Qn = class e {
     constructor(e = {}) {
      for (let t of new Set([...Yn, ...Object.keys(e)])) this.setProperty(t, e[t]);
     }
     setProperty(e, t) {
      if (this[e] !== t) {
       if ((e in Xn && (t = t.map((e) => this.createChild(e))), !Yn.has(e))) return void (this[e] = t);
       Object.defineProperty(this, e, { value: t, enumerable: !1, configurable: !0 });
      }
     }
     map(t) {
      let r;
      for (let n in Xn) {
       let s = this[n];
       if (s) {
        let i = Zn(s, (e) => e.map(t));
        r !== s && (r || (r = new e({ parent: this.parent })), r.setProperty(n, i));
       }
      }
      if (r) for (let e in this) e in Xn || (r[e] = this[e]);
      return t(r || this);
     }
     walk(e) {
      for (let t in Xn) {
       let r = this[t];
       if (r) for (let t = 0; t < r.length; t++) r[t].walk(e);
      }
      e(this);
     }
     createChild(t) {
      let r = t instanceof e ? t.clone() : new e(t);
      return r.setProperty("parent", this), r;
     }
     insertChildBefore(e, t) {
      this.children.splice(this.children.indexOf(e), 0, this.createChild(t));
     }
     removeChild(e) {
      this.children.splice(this.children.indexOf(e), 1);
     }
     replaceChild(e, t) {
      this.children[this.children.indexOf(e)] = this.createChild(t);
     }
     clone() {
      return new e(this);
     }
     get firstChild() {
      var e;
      return null == (e = this.children) ? void 0 : e[0];
     }
     get lastChild() {
      var e;
      return null == (e = this.children) ? void 0 : e[this.children.length - 1];
     }
     get prev() {
      var e, t;
      return null == (t = null == (e = this.parent) ? void 0 : e.children) ? void 0 : t[this.parent.children.indexOf(this) - 1];
     }
     get next() {
      var e, t;
      return null == (t = null == (e = this.parent) ? void 0 : e.children) ? void 0 : t[this.parent.children.indexOf(this) + 1];
     }
     get rawName() {
      return this.hasExplicitNamespace ? this.fullName : this.name;
     }
     get fullName() {
      return this.namespace ? this.namespace + ":" + this.name : this.name;
     }
     get attrMap() {
      return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
     }
    };
   function Zn(e, t) {
    let r = e.map(t);
    return r.some((t, r) => t !== e[r]) ? r : e;
   }
   var es = [
    {
     regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s,
     parse: function (e, t, r) {
      let [, n, s, i] = r,
       a = 4 + n.length,
       o = e.sourceSpan.start.moveBy(a),
       l = o.moveBy(i.length),
       [p, c] = (() => {
        try {
         return [!0, t(i, o).children];
        } catch {
         return [!1, [{ type: "text", value: i, sourceSpan: new br(o, l) }]];
        }
       })();
      return { type: "ieConditionalComment", complete: p, children: c, condition: u(!1, s.trim(), /\s+/g, " "), sourceSpan: e.sourceSpan, startSourceSpan: new br(e.sourceSpan.start, o), endSourceSpan: new br(l, e.sourceSpan.end) };
     },
    },
    {
     regex: /^\[if([^\]]*)]><!$/,
     parse: function (e, t, r) {
      let [, n] = r;
      return { type: "ieConditionalStartComment", condition: u(!1, n.trim(), /\s+/g, " "), sourceSpan: e.sourceSpan };
     },
    },
    {
     regex: /^<!\s*\[endif]$/,
     parse: function (e) {
      return { type: "ieConditionalEndComment", sourceSpan: e.sourceSpan };
     },
    },
   ];
   var ts = new Map([
     ["*", new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate"])],
     ["a", new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])],
     ["applet", new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])],
     ["area", new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])],
     ["audio", new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])],
     ["base", new Set(["href", "target"])],
     ["basefont", new Set(["color", "face", "size"])],
     ["blockquote", new Set(["cite"])],
     ["body", new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])],
     ["br", new Set(["clear"])],
     ["button", new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])],
     ["canvas", new Set(["height", "width"])],
     ["caption", new Set(["align"])],
     ["col", new Set(["align", "char", "charoff", "span", "valign", "width"])],
     ["colgroup", new Set(["align", "char", "charoff", "span", "valign", "width"])],
     ["data", new Set(["value"])],
     ["del", new Set(["cite", "datetime"])],
     ["details", new Set(["name", "open"])],
     ["dialog", new Set(["open"])],
     ["dir", new Set(["compact"])],
     ["div", new Set(["align"])],
     ["dl", new Set(["compact"])],
     ["embed", new Set(["height", "src", "type", "width"])],
     ["fieldset", new Set(["disabled", "form", "name"])],
     ["font", new Set(["color", "face", "size"])],
     ["form", new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])],
     ["frame", new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])],
     ["frameset", new Set(["cols", "rows"])],
     ["h1", new Set(["align"])],
     ["h2", new Set(["align"])],
     ["h3", new Set(["align"])],
     ["h4", new Set(["align"])],
     ["h5", new Set(["align"])],
     ["h6", new Set(["align"])],
     ["head", new Set(["profile"])],
     ["hr", new Set(["align", "noshade", "size", "width"])],
     ["html", new Set(["manifest", "version"])],
     ["iframe", new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])],
     ["img", new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])],
     ["input", new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])],
     ["ins", new Set(["cite", "datetime"])],
     ["isindex", new Set(["prompt"])],
     ["label", new Set(["for", "form"])],
     ["legend", new Set(["align"])],
     ["li", new Set(["type", "value"])],
     ["link", new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])],
     ["map", new Set(["name"])],
     ["menu", new Set(["compact"])],
     ["meta", new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])],
     ["meter", new Set(["high", "low", "max", "min", "optimum", "value"])],
     ["object", new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])],
     ["ol", new Set(["compact", "reversed", "start", "type"])],
     ["optgroup", new Set(["disabled", "label"])],
     ["option", new Set(["disabled", "label", "selected", "value"])],
     ["output", new Set(["for", "form", "name"])],
     ["p", new Set(["align"])],
     ["param", new Set(["name", "type", "value", "valuetype"])],
     ["pre", new Set(["width"])],
     ["progress", new Set(["max", "value"])],
     ["q", new Set(["cite"])],
     ["script", new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])],
     ["select", new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])],
     ["slot", new Set(["name"])],
     ["source", new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])],
     ["style", new Set(["blocking", "media", "type"])],
     ["table", new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])],
     ["tbody", new Set(["align", "char", "charoff", "valign"])],
     ["td", new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])],
     ["template", new Set(["shadowrootdelegatesfocus", "shadowrootmode"])],
     ["textarea", new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])],
     ["tfoot", new Set(["align", "char", "charoff", "valign"])],
     ["th", new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])],
     ["thead", new Set(["align", "char", "charoff", "valign"])],
     ["time", new Set(["datetime"])],
     ["tr", new Set(["align", "bgcolor", "char", "charoff", "valign"])],
     ["track", new Set(["default", "kind", "label", "src", "srclang"])],
     ["ul", new Set(["compact", "type"])],
     ["video", new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])],
    ]),
    rs = new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
   function ns(e, t, r) {
    let { name: n, canSelfClose: s = !0, normalizeTagName: i = !1, normalizeAttributeName: a = !1, allowHtmComponentClosingTags: o = !1, isTagNameCaseSensitive: u = !1, shouldParseAsRawText: l } = t,
     { rootNodes: p, errors: c } = Hn(e, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u, getTagContentType: l ? (...e) => (l(...e) ? Lr.RAW_TEXT : void 0) : void 0, tokenizeAngularBlocks: "angular" === n || void 0 });
    if ("vue" === n) {
     if (p.some((e) => ("docType" === e.type && "html" === e.value) || ("element" === e.type && "html" === e.name.toLowerCase()))) return ns(e, us, r);
     let t,
      n = () => t ?? (t = Hn(e, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u })),
      i = (e) => n().rootNodes.find(({ startSourceSpan: t }) => t && t.start.offset === e.startSourceSpan.start.offset) ?? e;
     for (let [e, s] of p.entries()) {
      let { endSourceSpan: t, startSourceSpan: a } = s;
      if (null === t) (c = n().errors), (p[e] = i(s));
      else if (ss(s, r)) {
       let r = n().errors.find((e) => e.span.start.offset > a.start.offset && e.span.start.offset < t.end.offset);
       r && is(r), (p[e] = i(s));
      }
     }
    }
    c.length > 0 && is(c[0]);
    let h = (e) => {
      let t = e.name.startsWith(":") ? e.name.slice(1).split(":")[0] : null,
       r = e.nameSpan.toString(),
       n = null !== t && r.startsWith(`${t}:`),
       s = n ? r.slice(t.length + 1) : r;
      (e.name = s), (e.namespace = t), (e.hasExplicitNamespace = n);
     },
     d = (e, t) => {
      let r = e.toLowerCase();
      return t(r) ? r : e;
     };
    return (
     dn(
      new (class extends fn {
       visitExpansionCase(e, t) {
        "angular" === n &&
         this.visitChildren(t, (t) => {
          t(e.expression);
         });
       }
       visit(e) {
        ((e) => {
         switch (e.type) {
          case "element":
           h(e);
           for (let t of e.attrs) h(t), t.valueSpan ? ((t.value = t.valueSpan.toString()), /["']/.test(t.value[0]) && (t.value = t.value.slice(1, -1))) : (t.value = null);
           break;
          case "comment":
           e.value = e.sourceSpan.toString().slice(4, -3);
           break;
          case "text":
           e.value = e.sourceSpan.toString();
         }
        })(e),
         ((e) => {
          if ("element" === e.type) {
           let t = en(u ? e.name : e.name.toLowerCase());
           !e.namespace || e.namespace === t.implicitNamespacePrefix || me(e) ? (e.tagDefinition = t) : (e.tagDefinition = en(""));
          }
         })(e),
         ((e) => {
          if ("element" === e.type && (i && (!e.namespace || e.namespace === e.tagDefinition.implicitNamespacePrefix || me(e)) && (e.name = d(e.name, (e) => rs.has(e))), a)) for (let t of e.attrs) t.namespace || (t.name = d(t.name, (t) => ts.has(e.name) && (ts.get("*").has(t) || ts.get(e.name).has(t))));
         })(e),
         ((e) => {
          e.sourceSpan && e.endSourceSpan && (e.sourceSpan = new br(e.sourceSpan.start, e.endSourceSpan.end));
         })(e);
       }
      })(),
      p,
     ),
     p
    );
   }
   function ss(e, t) {
    var r;
    if ("element" !== e.type || "template" !== e.name) return !1;
    let n = null == (r = e.attrs.find((e) => "lang" === e.name)) ? void 0 : r.value;
    return !n || "html" === pe(t, { language: n });
   }
   function is(e) {
    let {
     msg: t,
     span: { start: r, end: n },
    } = e;
    throw Jn(t, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: e });
   }
   function as(e, t, r = {}, n = !0) {
    let { frontMatter: s, content: i } = n ? Gn(e) : { frontMatter: null, content: e },
     a = new xr(e, r.filepath),
     o = new Dr(a, 0, 0, 0),
     l = o.moveBy(e.length),
     p = { type: "root", sourceSpan: new br(o, l), children: ns(i, t, r) };
    if (s) {
     let e = new Dr(a, 0, 0, 0),
      t = e.moveBy(s.raw.length);
     (s.sourceSpan = new br(e, t)), p.children.unshift(s);
    }
    let c = new Qn(p),
     h = (n, s) => {
      let { offset: i } = s,
       a = as(u(!1, e.slice(0, i), /[^\n\r]/g, " ") + n, t, r, !1);
      a.sourceSpan = new br(s, $(!1, a.children, -1).sourceSpan.end);
      let o = a.children[0];
      return o.length === i ? a.children.shift() : ((o.sourceSpan = new br(o.sourceSpan.start.moveBy(i), o.sourceSpan.end)), (o.value = o.value.slice(i))), a;
     };
    return (
     c.walk((e) => {
      if ("comment" === e.type) {
       let t = (function (e, t) {
        if (e.value)
         for (let { regex: r, parse: n } of es) {
          let s = e.value.match(r);
          if (s) return n(e, t, s);
         }
        return null;
       })(e, h);
       t && e.parent.replaceChild(e, t);
      }
      (function (e) {
       if ("block" === e.type) {
        if (((e.name = u(!1, e.name.toLowerCase(), /\s+/g, " ").trim()), (e.type = "angularControlFlowBlock"), !Tt(e.parameters))) return void delete e.parameters;
        for (let t of e.parameters) t.type = "angularControlFlowBlockParameter";
        e.parameters = { type: "angularControlFlowBlockParameters", children: e.parameters, sourceSpan: new br(e.parameters[0].sourceSpan.start, $(!1, e.parameters, -1).sourceSpan.end) };
       }
      })(e),
       (function (e) {
        ("plural" === e.type || "select" === e.type) && ((e.clause = e.type), (e.type = "angularIcuExpression")), "expansionCase" === e.type && (e.type = "angularIcuCase");
       })(e);
     }),
     c
    );
   }
   function os(e) {
    return { parse: (t, r) => as(t, e, r), hasPragma: er, astFormat: "html", locStart: wt, locEnd: St };
   }
   var us = { name: "html", normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 },
    ls = os(us),
    ps = os({ name: "angular" }),
    cs = os({ name: "vue", isTagNameCaseSensitive: !0, shouldParseAsRawText: (e, t, r, n) => "html" !== e.toLowerCase() && !r && ("template" !== e || n.some(({ name: e, value: t }) => "lang" === e && "html" !== t && "" !== t && void 0 !== t)) }),
    hs = os({ name: "lwc", canSelfClose: !1 }),
    ds = { html: wr },
    fs = o;
  },
  69267: (e, t, r) => {
   r.d(t, { ZP: () => ns });
   var n = Object.create,
    s = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    p = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    c = (e, t, r) => (
     (r = null != e ? n(o(e)) : {}),
     ((e, t, r, n) => {
      if ((t && "object" == typeof t) || "function" == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && s(e, o, { get: () => t[o], enumerable: !(n = i(t, o)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : s(r, "default", { value: e, enumerable: !0 }), e)
    ),
    h = l((e) => {
     Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.extract = function (e) {
       let t = e.match(n);
       return t ? t[0].trimLeft() : "";
      }),
      (e.parse = function (e) {
       return p(e).pragmas;
      }),
      (e.parseWithComments = p),
      (e.print = function ({ comments: e = "", pragmas: t = {} }) {
       let r = "\n",
        n = " *",
        s = Object.keys(t),
        i = s
         .flatMap((e) => c(e, t[e]))
         .map((e) => `${n} ${e}${r}`)
         .join("");
       if (!e) {
        if (0 === s.length) return "";
        if (1 === s.length && !Array.isArray(t[s[0]])) {
         let e = t[s[0]];
         return `/** ${c(s[0], e)[0]} */`;
        }
       }
       let a =
        e
         .split(r)
         .map((e) => `${n} ${e}`)
         .join(r) + r;
       return "/**\n" + (e ? a : "") + (e && s.length ? n + r : "") + i + " */";
      }),
      (e.strip = function (e) {
       let t = e.match(n);
       return t && t[0] ? e.substring(t[0].length) : e;
      });
     var t = /\*\/$/,
      r = /^\/\*\*?/,
      n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
      s = /(^|\s+)\/\/([^\r\n]*)/g,
      i = /^(\r?\n)+/,
      a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
      o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
      u = /(\r?\n|^) *\* ?/g,
      l = [];
     function p(e) {
      e = e.replace(r, "").replace(t, "").replace(u, "$1");
      let n = "";
      for (; n !== e; ) (n = e), (e = e.replace(a, "\n$1 $2\n"));
      e = e.replace(i, "").trimRight();
      let p,
       c = Object.create(null),
       h = e.replace(o, "").replace(i, "").trimRight();
      for (; (p = o.exec(e)); ) {
       let e = p[2].replace(s, "");
       "string" == typeof c[p[1]] || Array.isArray(c[p[1]]) ? (c[p[1]] = l.concat(c[p[1]], e)) : (c[p[1]] = e);
      }
      return { comments: h, pragmas: c };
     }
     function c(e, t) {
      return l.concat(t).map((t) => `@${e} ${t}`.trim());
     }
    }),
    d = l((e, t) => {
     (t.exports.isClean = Symbol("isClean")), (t.exports.my = Symbol("my"));
    }),
    f = l((e, t) => {
     var r = String,
      n = function () {
       return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r };
      };
     (t.exports = n()), (t.exports.createColors = n);
    }),
    m = l(() => {}),
    y = l((e, t) => {
     var r = f(),
      n = m(),
      s = class e extends Error {
       constructor(t, r, n, s, i, a) {
        super(t), (this.name = "CssSyntaxError"), (this.reason = t), i && (this.file = i), s && (this.source = s), a && (this.plugin = a), typeof r < "u" && typeof n < "u" && ("number" == typeof r ? ((this.line = r), (this.column = n)) : ((this.line = r.line), (this.column = r.column), (this.endLine = n.line), (this.endColumn = n.column))), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, e);
       }
       setMessage() {
        (this.message = this.plugin ? this.plugin + ": " : ""), (this.message += this.file ? this.file : "<css input>"), typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), (this.message += ": " + this.reason);
       }
       showSourceCode(e) {
        if (!this.source) return "";
        let t = this.source;
        null == e && (e = r.isColorSupported), n && e && (t = n(t));
        let s,
         i,
         a = t.split(/\r?\n/),
         o = Math.max(this.line - 3, 0),
         u = Math.min(this.line + 2, a.length),
         l = String(u).length;
        if (e) {
         let { bold: e, gray: t, red: n } = r.createColors(!0);
         (s = (t) => e(n(t))), (i = (e) => t(e));
        } else s = i = (e) => e;
        return a
         .slice(o, u)
         .map((e, t) => {
          let r = o + 1 + t,
           n = " " + (" " + r).slice(-l) + " | ";
          if (r === this.line) {
           let t = i(n.replace(/\d/g, " ")) + e.slice(0, this.column - 1).replace(/[^\t]/g, " ");
           return s(">") + i(n) + e + "\n " + t + s("^");
          }
          return " " + i(n) + e;
         })
         .join("\n");
       }
       toString() {
        let e = this.showSourceCode();
        return e && (e = "\n\n" + e + "\n"), this.name + ": " + this.message + e;
       }
      };
     (t.exports = s), (s.default = s);
    }),
    g = l((e, t) => {
     var r = { after: "\n", beforeClose: "\n", beforeComment: "\n", beforeDecl: "\n", beforeOpen: " ", beforeRule: "\n", colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: !1 };
     var n = class {
      constructor(e) {
       this.builder = e;
      }
      atrule(e, t) {
       let r = "@" + e.name,
        n = e.params ? this.rawValue(e, "params") : "";
       if ((typeof e.raws.afterName < "u" ? (r += e.raws.afterName) : n && (r += " "), e.nodes)) this.block(e, r + n);
       else {
        let s = (e.raws.between || "") + (t ? ";" : "");
        this.builder(r + n + s, e);
       }
      }
      beforeAfter(e, t) {
       let r;
       r = "decl" === e.type ? this.raw(e, null, "beforeDecl") : "comment" === e.type ? this.raw(e, null, "beforeComment") : "before" === t ? this.raw(e, null, "beforeRule") : this.raw(e, null, "beforeClose");
       let n = e.parent,
        s = 0;
       for (; n && "root" !== n.type; ) (s += 1), (n = n.parent);
       if (r.includes("\n")) {
        let t = this.raw(e, null, "indent");
        if (t.length) for (let e = 0; e < s; e++) r += t;
       }
       return r;
      }
      block(e, t) {
       let r,
        n = this.raw(e, "between", "beforeOpen");
       this.builder(t + n + "{", e, "start"), e.nodes && e.nodes.length ? (this.body(e), (r = this.raw(e, "after"))) : (r = this.raw(e, "after", "emptyBody")), r && this.builder(r), this.builder("}", e, "end");
      }
      body(e) {
       let t = e.nodes.length - 1;
       for (; t > 0 && "comment" === e.nodes[t].type; ) t -= 1;
       let r = this.raw(e, "semicolon");
       for (let n = 0; n < e.nodes.length; n++) {
        let s = e.nodes[n],
         i = this.raw(s, "before");
        i && this.builder(i), this.stringify(s, t !== n || r);
       }
      }
      comment(e) {
       let t = this.raw(e, "left", "commentLeft"),
        r = this.raw(e, "right", "commentRight");
       this.builder("/*" + t + e.text + r + "*/", e);
      }
      decl(e, t) {
       let r = this.raw(e, "between", "colon"),
        n = e.prop + r + this.rawValue(e, "value");
       e.important && (n += e.raws.important || " !important"), t && (n += ";"), this.builder(n, e);
      }
      document(e) {
       this.body(e);
      }
      raw(e, t, n) {
       let s;
       if ((n || (n = t), t && ((s = e.raws[t]), typeof s < "u"))) return s;
       let i = e.parent;
       if ("before" === n && (!i || ("root" === i.type && i.first === e) || (i && "document" === i.type))) return "";
       if (!i) return r[n];
       let a = e.root();
       if ((a.rawCache || (a.rawCache = {}), typeof a.rawCache[n] < "u")) return a.rawCache[n];
       if ("before" === n || "after" === n) return this.beforeAfter(e, n);
       {
        let r = "raw" + ((o = n)[0].toUpperCase() + o.slice(1));
        this[r]
         ? (s = this[r](a, e))
         : a.walk((e) => {
            if (((s = e.raws[t]), typeof s < "u")) return !1;
           });
       }
       var o;
       return typeof s > "u" && (s = r[n]), (a.rawCache[n] = s), s;
      }
      rawBeforeClose(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length > 0 && typeof e.raws.after < "u") return (t = e.raws.after), t.includes("\n") && (t = t.replace(/[^\n]+$/, "")), !1;
        }),
        t && (t = t.replace(/\S/g, "")),
        t
       );
      }
      rawBeforeComment(e, t) {
       let r;
       return (
        e.walkComments((e) => {
         if (typeof e.raws.before < "u") return (r = e.raws.before), r.includes("\n") && (r = r.replace(/[^\n]+$/, "")), !1;
        }),
        typeof r > "u" ? (r = this.raw(t, null, "beforeDecl")) : r && (r = r.replace(/\S/g, "")),
        r
       );
      }
      rawBeforeDecl(e, t) {
       let r;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.before < "u") return (r = e.raws.before), r.includes("\n") && (r = r.replace(/[^\n]+$/, "")), !1;
        }),
        typeof r > "u" ? (r = this.raw(t, null, "beforeRule")) : r && (r = r.replace(/\S/g, "")),
        r
       );
      }
      rawBeforeOpen(e) {
       let t;
       return (
        e.walk((e) => {
         if ("decl" !== e.type && ((t = e.raws.between), typeof t < "u")) return !1;
        }),
        t
       );
      }
      rawBeforeRule(e) {
       let t;
       return (
        e.walk((r) => {
         if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < "u") return (t = r.raws.before), t.includes("\n") && (t = t.replace(/[^\n]+$/, "")), !1;
        }),
        t && (t = t.replace(/\S/g, "")),
        t
       );
      }
      rawColon(e) {
       let t;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.between < "u") return (t = e.raws.between.replace(/[^\s:]/g, "")), !1;
        }),
        t
       );
      }
      rawEmptyBody(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && 0 === e.nodes.length && ((t = e.raws.after), typeof t < "u")) return !1;
        }),
        t
       );
      }
      rawIndent(e) {
       if (e.raws.indent) return e.raws.indent;
       let t;
       return (
        e.walk((r) => {
         let n = r.parent;
         if (n && n !== e && n.parent && n.parent === e && typeof r.raws.before < "u") {
          let e = r.raws.before.split("\n");
          return (t = e[e.length - 1]), (t = t.replace(/\S/g, "")), !1;
         }
        }),
        t
       );
      }
      rawSemicolon(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length && "decl" === e.last.type && ((t = e.raws.semicolon), typeof t < "u")) return !1;
        }),
        t
       );
      }
      rawValue(e, t) {
       let r = e[t],
        n = e.raws[t];
       return n && n.value === r ? n.raw : r;
      }
      root(e) {
       this.body(e), e.raws.after && this.builder(e.raws.after);
      }
      rule(e) {
       this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
      }
      stringify(e, t) {
       if (!this[e.type]) throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
       this[e.type](e, t);
      }
     };
     (t.exports = n), (n.default = n);
    }),
    D = l((e, t) => {
     var r = g();
     function n(e, t) {
      new r(t).stringify(e);
     }
     (t.exports = n), (n.default = n);
    }),
    x = l((e, t) => {
     var { isClean: r, my: n } = d(),
      s = y(),
      i = g(),
      a = D();
     function o(e, t) {
      let r = new e.constructor();
      for (let n in e) {
       if (!Object.prototype.hasOwnProperty.call(e, n) || "proxyCache" === n) continue;
       let s = e[n],
        i = typeof s;
       "parent" === n && "object" === i ? t && (r[n] = t) : "source" === n ? (r[n] = s) : Array.isArray(s) ? (r[n] = s.map((e) => o(e, r))) : ("object" === i && null !== s && (s = o(s)), (r[n] = s));
      }
      return r;
     }
     var u = class {
      constructor(e = {}) {
       (this.raws = {}), (this[r] = !1), (this[n] = !0);
       for (let t in e)
        if ("nodes" === t) {
         this.nodes = [];
         for (let r of e[t]) "function" == typeof r.clone ? this.append(r.clone()) : this.append(r);
        } else this[t] = e[t];
      }
      addToError(e) {
       if (((e.postcssNode = this), e.stack && this.source && /\n\s{4}at /.test(e.stack))) {
        let t = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `$&${t.input.from}:${t.start.line}:${t.start.column}$&`);
       }
       return e;
      }
      after(e) {
       return this.parent.insertAfter(this, e), this;
      }
      assign(e = {}) {
       for (let t in e) this[t] = e[t];
       return this;
      }
      before(e) {
       return this.parent.insertBefore(this, e), this;
      }
      cleanRaws(e) {
       delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
      }
      clone(e = {}) {
       let t = o(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneAfter(e = {}) {
       let t = this.clone(e);
       return this.parent.insertAfter(this, t), t;
      }
      cloneBefore(e = {}) {
       let t = this.clone(e);
       return this.parent.insertBefore(this, t), t;
      }
      error(e, t = {}) {
       if (this.source) {
        let { end: r, start: n } = this.rangeBy(t);
        return this.source.input.error(e, { column: n.column, line: n.line }, { column: r.column, line: r.line }, t);
       }
       return new s(e);
      }
      getProxyProcessor() {
       return { get: (e, t) => ("proxyOf" === t ? e : "root" === t ? () => e.root().toProxy() : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ("prop" === t || "value" === t || "name" === t || "params" === t || "important" === t || "text" === t) && e.markDirty()), !0) };
      }
      markDirty() {
       if (this[r]) {
        this[r] = !1;
        let e = this;
        for (; (e = e.parent); ) e[r] = !1;
       }
      }
      next() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      positionBy(e, t) {
       let r = this.source.start;
       if (e.index) r = this.positionInside(e.index, t);
       else if (e.word) {
        let n = (t = this.toString()).indexOf(e.word);
        -1 !== n && (r = this.positionInside(n, t));
       }
       return r;
      }
      positionInside(e, t) {
       let r = t || this.toString(),
        n = this.source.start.column,
        s = this.source.start.line;
       for (let i = 0; i < e; i++) "\n" === r[i] ? ((n = 1), (s += 1)) : (n += 1);
       return { column: n, line: s };
      }
      prev() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      rangeBy(e) {
       let t = { column: this.source.start.column, line: this.source.start.line },
        r = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: t.column + 1, line: t.line };
       if (e.word) {
        let n = this.toString(),
         s = n.indexOf(e.word);
        -1 !== s && ((t = this.positionInside(s, n)), (r = this.positionInside(s + e.word.length, n)));
       } else e.start ? (t = { column: e.start.column, line: e.start.line }) : e.index && (t = this.positionInside(e.index)), e.end ? (r = { column: e.end.column, line: e.end.line }) : e.endIndex ? (r = this.positionInside(e.endIndex)) : e.index && (r = this.positionInside(e.index + 1));
       return (r.line < t.line || (r.line === t.line && r.column <= t.column)) && (r = { column: t.column + 1, line: t.line }), { end: r, start: t };
      }
      raw(e, t) {
       return new i().raw(this, e, t);
      }
      remove() {
       return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
      }
      replaceWith(...e) {
       if (this.parent) {
        let t = this,
         r = !1;
        for (let n of e) n === this ? (r = !0) : r ? (this.parent.insertAfter(t, n), (t = n)) : this.parent.insertBefore(t, n);
        r || this.remove();
       }
       return this;
      }
      root() {
       let e = this;
       for (; e.parent && "document" !== e.parent.type; ) e = e.parent;
       return e;
      }
      toJSON(e, t) {
       let r = {},
        n = null == t;
       t = t || new Map();
       let s = 0;
       for (let i in this) {
        if (!Object.prototype.hasOwnProperty.call(this, i) || "parent" === i || "proxyCache" === i) continue;
        let e = this[i];
        if (Array.isArray(e)) r[i] = e.map((e) => ("object" == typeof e && e.toJSON ? e.toJSON(null, t) : e));
        else if ("object" == typeof e && e.toJSON) r[i] = e.toJSON(null, t);
        else if ("source" === i) {
         let n = t.get(e.input);
         null == n && ((n = s), t.set(e.input, s), s++), (r[i] = { end: e.end, inputId: n, start: e.start });
        } else r[i] = e;
       }
       return n && (r.inputs = [...t.keys()].map((e) => e.toJSON())), r;
      }
      toProxy() {
       return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
      }
      toString(e = a) {
       e.stringify && (e = e.stringify);
       let t = "";
       return (
        e(this, (e) => {
         t += e;
        }),
        t
       );
      }
      warn(e, t, r) {
       let n = { node: this };
       for (let s in r) n[s] = r[s];
       return e.warn(t, n);
      }
      get proxyOf() {
       return this;
      }
     };
     (t.exports = u), (u.default = u);
    }),
    b = l((e, t) => {
     var r = x(),
      n = class extends r {
       constructor(e) {
        e && typeof e.value < "u" && "string" != typeof e.value && (e = { ...e, value: String(e.value) }), super(e), (this.type = "decl");
       }
       get variable() {
        return this.prop.startsWith("--") || "$" === this.prop[0];
       }
      };
     (t.exports = n), (n.default = n);
    }),
    v = l((e, t) => {
     var r = x(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = "comment");
       }
      };
     (t.exports = n), (n.default = n);
    }),
    E = l((e, t) => {
     var r,
      n,
      s,
      i,
      { isClean: a, my: o } = d(),
      u = b(),
      l = v(),
      p = x();
     function c(e) {
      return e.map((e) => (e.nodes && (e.nodes = c(e.nodes)), delete e.source, e));
     }
     function h(e) {
      if (((e[a] = !1), e.proxyOf.nodes)) for (let t of e.proxyOf.nodes) h(t);
     }
     var f = class e extends p {
      append(...e) {
       for (let t of e) {
        let e = this.normalize(t, this.last);
        for (let t of e) this.proxyOf.nodes.push(t);
       }
       return this.markDirty(), this;
      }
      cleanRaws(e) {
       if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
      }
      each(e) {
       if (!this.proxyOf.nodes) return;
       let t,
        r,
        n = this.getIterator();
       for (; this.indexes[n] < this.proxyOf.nodes.length && ((t = this.indexes[n]), (r = e(this.proxyOf.nodes[t], t)), !1 !== r); ) this.indexes[n] += 1;
       return delete this.indexes[n], r;
      }
      every(e) {
       return this.nodes.every(e);
      }
      getIterator() {
       this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1);
       let e = this.lastEach;
       return (this.indexes[e] = 0), e;
      }
      getProxyProcessor() {
       return { get: (e, t) => ("proxyOf" === t ? e : e[t] ? ("each" === t || ("string" == typeof t && t.startsWith("walk")) ? (...r) => e[t](...r.map((e) => ("function" == typeof e ? (t, r) => e(t.toProxy(), r) : e))) : "every" === t || "some" === t ? (r) => e[t]((e, ...t) => r(e.toProxy(), ...t)) : "root" === t ? () => e.root().toProxy() : "nodes" === t ? e.nodes.map((e) => e.toProxy()) : "first" === t || "last" === t ? e[t].toProxy() : e[t]) : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ("name" === t || "params" === t || "selector" === t) && e.markDirty()), !0) };
      }
      index(e) {
       return "number" == typeof e ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
      }
      insertAfter(e, t) {
       let r,
        n = this.index(e),
        s = this.normalize(t, this.proxyOf.nodes[n]).reverse();
       n = this.index(e);
       for (let i of s) this.proxyOf.nodes.splice(n + 1, 0, i);
       for (let i in this.indexes) (r = this.indexes[i]), n < r && (this.indexes[i] = r + s.length);
       return this.markDirty(), this;
      }
      insertBefore(e, t) {
       let r,
        n = this.index(e),
        s = 0 === n && "prepend",
        i = this.normalize(t, this.proxyOf.nodes[n], s).reverse();
       n = this.index(e);
       for (let a of i) this.proxyOf.nodes.splice(n, 0, a);
       for (let a in this.indexes) (r = this.indexes[a]), n <= r && (this.indexes[a] = r + i.length);
       return this.markDirty(), this;
      }
      normalize(t, i) {
       if ("string" == typeof t) t = c(r(t).nodes);
       else if (Array.isArray(t)) {
        t = t.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, "ignore");
       } else if ("root" === t.type && "document" !== this.type) {
        t = t.nodes.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, "ignore");
       } else if (t.type) t = [t];
       else if (t.prop) {
        if (typeof t.value > "u") throw new Error("Value field is missed in node creation");
        "string" != typeof t.value && (t.value = String(t.value)), (t = [new u(t)]);
       } else if (t.selector) t = [new n(t)];
       else if (t.name) t = [new s(t)];
       else {
        if (!t.text) throw new Error("Unknown node type in node creation");
        t = [new l(t)];
       }
       return t.map((t) => (t[o] || e.rebuild(t), (t = t.proxyOf).parent && t.parent.removeChild(t), t[a] && h(t), typeof t.raws.before > "u" && i && typeof i.raws.before < "u" && (t.raws.before = i.raws.before.replace(/\S/g, "")), (t.parent = this.proxyOf), t));
      }
      prepend(...e) {
       e = e.reverse();
       for (let t of e) {
        let e = this.normalize(t, this.first, "prepend").reverse();
        for (let t of e) this.proxyOf.nodes.unshift(t);
        for (let t in this.indexes) this.indexes[t] = this.indexes[t] + e.length;
       }
       return this.markDirty(), this;
      }
      push(e) {
       return (e.parent = this), this.proxyOf.nodes.push(e), this;
      }
      removeAll() {
       for (let e of this.proxyOf.nodes) e.parent = void 0;
       return (this.proxyOf.nodes = []), this.markDirty(), this;
      }
      removeChild(e) {
       let t;
       (e = this.index(e)), (this.proxyOf.nodes[e].parent = void 0), this.proxyOf.nodes.splice(e, 1);
       for (let r in this.indexes) (t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1);
       return this.markDirty(), this;
      }
      replaceValues(e, t, r) {
       return (
        r || ((r = t), (t = {})),
        this.walkDecls((n) => {
         (t.props && !t.props.includes(n.prop)) || (t.fast && !n.value.includes(t.fast)) || (n.value = n.value.replace(e, r));
        }),
        this.markDirty(),
        this
       );
      }
      some(e) {
       return this.nodes.some(e);
      }
      walk(e) {
       return this.each((t, r) => {
        let n;
        try {
         n = e(t, r);
        } catch (s) {
         throw t.addToError(s);
        }
        return !1 !== n && t.walk && (n = t.walk(e)), n;
       });
      }
      walkAtRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ("atrule" === r.type && e.test(r.name)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ("atrule" === r.type && r.name === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ("atrule" === e.type) return t(e, r);
          }));
      }
      walkComments(e) {
       return this.walk((t, r) => {
        if ("comment" === t.type) return e(t, r);
       });
      }
      walkDecls(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ("decl" === r.type && e.test(r.prop)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ("decl" === r.type && r.prop === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ("decl" === e.type) return t(e, r);
          }));
      }
      walkRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ("rule" === r.type && e.test(r.selector)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ("rule" === r.type && r.selector === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ("rule" === e.type) return t(e, r);
          }));
      }
      get first() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
      }
      get last() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
     };
     (f.registerParse = (e) => {
      r = e;
     }),
      (f.registerRule = (e) => {
       n = e;
      }),
      (f.registerAtRule = (e) => {
       s = e;
      }),
      (f.registerRoot = (e) => {
       i = e;
      }),
      (t.exports = f),
      (f.default = f),
      (f.rebuild = (e) => {
       "atrule" === e.type ? Object.setPrototypeOf(e, s.prototype) : "rule" === e.type ? Object.setPrototypeOf(e, n.prototype) : "decl" === e.type ? Object.setPrototypeOf(e, u.prototype) : "comment" === e.type ? Object.setPrototypeOf(e, l.prototype) : "root" === e.type && Object.setPrototypeOf(e, i.prototype),
        (e[o] = !0),
        e.nodes &&
         e.nodes.forEach((e) => {
          f.rebuild(e);
         });
      });
    }),
    C = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      n = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      s = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i;
     t.exports = function (e, t = {}) {
      let a,
       o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y = e.css.valueOf(),
       g = t.ignoreErrors,
       D = y.length,
       x = 0,
       b = [],
       v = [];
      function E(t) {
       throw e.error("Unclosed " + t, x);
      }
      return {
       back: function (e) {
        v.push(e);
       },
       endOfFile: function () {
        return 0 === v.length && x >= D;
       },
       nextToken: function (e) {
        if (v.length) return v.pop();
        if (x >= D) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((a = y.charCodeAt(x)), a)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          o = x;
          do {
           (o += 1), (a = y.charCodeAt(o));
          } while (32 === a || 10 === a || 9 === a || 13 === a || 12 === a);
          (m = ["space", y.slice(x, o)]), (x = o - 1);
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(a);
          m = [e, e, x];
          break;
         }
         case 40:
          if (((d = b.length ? b.pop()[1] : ""), (f = y.charCodeAt(x + 1)), "url" === d && 39 !== f && 34 !== f && 32 !== f && 10 !== f && 9 !== f && 12 !== f && 13 !== f)) {
           o = x;
           do {
            if (((c = !1), (o = y.indexOf(")", o + 1)), -1 === o)) {
             if (g || t) {
              o = x;
              break;
             }
             E("bracket");
            }
            for (h = o; 92 === y.charCodeAt(h - 1); ) (h -= 1), (c = !c);
           } while (c);
           (m = ["brackets", y.slice(x, o + 1), x, o]), (x = o);
          } else (o = y.indexOf(")", x + 1)), (l = y.slice(x, o + 1)), -1 === o || s.test(l) ? (m = ["(", "(", x]) : ((m = ["brackets", l, x, o]), (x = o));
          break;
         case 39:
         case 34:
          (u = 39 === a ? "'" : '"'), (o = x);
          do {
           if (((c = !1), (o = y.indexOf(u, o + 1)), -1 === o)) {
            if (g || t) {
             o = x + 1;
             break;
            }
            E("string");
           }
           for (h = o; 92 === y.charCodeAt(h - 1); ) (h -= 1), (c = !c);
          } while (c);
          (m = ["string", y.slice(x, o + 1), x, o]), (x = o);
          break;
         case 64:
          (r.lastIndex = x + 1), r.test(y), (o = 0 === r.lastIndex ? y.length - 1 : r.lastIndex - 2), (m = ["at-word", y.slice(x, o + 1), x, o]), (x = o);
          break;
         case 92:
          for (o = x, p = !0; 92 === y.charCodeAt(o + 1); ) (o += 1), (p = !p);
          if (((a = y.charCodeAt(o + 1)), p && 47 !== a && 32 !== a && 10 !== a && 9 !== a && 13 !== a && 12 !== a && ((o += 1), i.test(y.charAt(o))))) {
           for (; i.test(y.charAt(o + 1)); ) o += 1;
           32 === y.charCodeAt(o + 1) && (o += 1);
          }
          (m = ["word", y.slice(x, o + 1), x, o]), (x = o);
          break;
         default:
          47 === a && 42 === y.charCodeAt(x + 1) ? ((o = y.indexOf("*/", x + 2) + 1), 0 === o && (g || t ? (o = y.length) : E("comment")), (m = ["comment", y.slice(x, o + 1), x, o]), (x = o)) : ((n.lastIndex = x + 1), n.test(y), (o = 0 === n.lastIndex ? y.length - 1 : n.lastIndex - 2), (m = ["word", y.slice(x, o + 1), x, o]), b.push(m), (x = o));
        }
        return x++, m;
       },
       position: function () {
        return x;
       },
      };
     };
    }),
    T = l((e, t) => {
     var r = E(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = "atrule");
       }
       append(...e) {
        return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
       }
       prepend(...e) {
        return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
       }
      };
     (t.exports = n), (n.default = n), r.registerAtRule(n);
    }),
    w = l((e, t) => {
     var r,
      n,
      s = E(),
      i = class extends s {
       constructor(e) {
        super(e), (this.type = "root"), this.nodes || (this.nodes = []);
       }
       normalize(e, t, r) {
        let n = super.normalize(e);
        if (t)
         if ("prepend" === r) this.nodes.length > 1 ? (t.raws.before = this.nodes[1].raws.before) : delete t.raws.before;
         else if (this.first !== t) for (let s of n) s.raws.before = t.raws.before;
        return n;
       }
       removeChild(e, t) {
        let r = this.index(e);
        return !t && 0 === r && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
       }
       toResult(e = {}) {
        return new r(new n(), this, e).stringify();
       }
      };
     (i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       n = e;
      }),
      (t.exports = i),
      (i.default = i),
      s.registerRoot(i);
    }),
    S = l((e, t) => {
     var r = {
      comma: (e) => r.split(e, [","], !0),
      space(e) {
       let t = [" ", "\n", "\t"];
       return r.split(e, t);
      },
      split(e, t, r) {
       let n = [],
        s = "",
        i = !1,
        a = 0,
        o = !1,
        u = "",
        l = !1;
       for (let p of e) l ? (l = !1) : "\\" === p ? (l = !0) : o ? p === u && (o = !1) : '"' === p || "'" === p ? ((o = !0), (u = p)) : "(" === p ? (a += 1) : ")" === p ? a > 0 && (a -= 1) : 0 === a && t.includes(p) && (i = !0), i ? ("" !== s && n.push(s.trim()), (s = ""), (i = !1)) : (s += p);
       return (r || "" !== s) && n.push(s.trim()), n;
      },
     };
     (t.exports = r), (r.default = r);
    }),
    A = l((e, t) => {
     var r = E(),
      n = S(),
      s = class extends r {
       constructor(e) {
        super(e), (this.type = "rule"), this.nodes || (this.nodes = []);
       }
       get selectors() {
        return n.comma(this.selector);
       }
       set selectors(e) {
        let t = this.selector ? this.selector.match(/,\s*/) : null,
         r = t ? t[0] : "," + this.raw("between", "beforeOpen");
        this.selector = e.join(r);
       }
      };
     (t.exports = s), (s.default = s), r.registerRule(s);
    }),
    F = l((e, t) => {
     var r = b(),
      n = C(),
      s = v(),
      i = T(),
      a = w(),
      o = A(),
      u = { empty: !0, space: !0 };
     t.exports = class {
      constructor(e) {
       (this.input = e), (this.root = new a()), (this.current = this.root), (this.spaces = ""), (this.semicolon = !1), (this.customProperty = !1), this.createTokenizer(), (this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } });
      }
      atrule(e) {
       let t = new i();
       (t.name = e[1].slice(1)), "" === t.name && this.unnamedAtrule(t, e), this.init(t, e[2]);
       let r,
        n,
        s,
        a = !1,
        o = !1,
        u = [],
        l = [];
       for (; !this.tokenizer.endOfFile(); ) {
        if (((r = (e = this.tokenizer.nextToken())[0]), "(" === r || "[" === r ? l.push("(" === r ? ")" : "]") : "{" === r && l.length > 0 ? l.push("}") : r === l[l.length - 1] && l.pop(), 0 === l.length)) {
         if (";" === r) {
          (t.source.end = this.getPosition(e[2])), t.source.end.offset++, (this.semicolon = !0);
          break;
         }
         if ("{" === r) {
          o = !0;
          break;
         }
         if ("}" === r) {
          if (u.length > 0) {
           for (s = u.length - 1, n = u[s]; n && "space" === n[0]; ) n = u[--s];
           n && ((t.source.end = this.getPosition(n[3] || n[2])), t.source.end.offset++);
          }
          this.end(e);
          break;
         }
         u.push(e);
        } else u.push(e);
        if (this.tokenizer.endOfFile()) {
         a = !0;
         break;
        }
       }
       (t.raws.between = this.spacesAndCommentsFromEnd(u)), u.length ? ((t.raws.afterName = this.spacesAndCommentsFromStart(u)), this.raw(t, "params", u), a && ((e = u[u.length - 1]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++, (this.spaces = t.raws.between), (t.raws.between = ""))) : ((t.raws.afterName = ""), (t.params = "")), o && ((t.nodes = []), (this.current = t));
      }
      checkMissedSemicolon(e) {
       let t = this.colon(e);
       if (!1 === t) return;
       let r,
        n = 0;
       for (let s = t - 1; s >= 0 && ((r = e[s]), "space" === r[0] || ((n += 1), 2 !== n)); s--);
       throw this.input.error("Missed semicolon", "word" === r[0] ? r[3] + 1 : r[2]);
      }
      colon(e) {
       let t,
        r,
        n,
        s = 0;
       for (let [i, a] of e.entries()) {
        if (((t = a), (r = t[0]), "(" === r && (s += 1), ")" === r && (s -= 1), 0 === s && ":" === r)) {
         if (n) {
          if ("word" === n[0] && "progid" === n[1]) continue;
          return i;
         }
         this.doubleColon(t);
        }
        n = t;
       }
       return !1;
      }
      comment(e) {
       let t = new s();
       this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++;
       let r = e[1].slice(2, -2);
       if (/^\s*$/.test(r)) (t.text = ""), (t.raws.left = r), (t.raws.right = "");
       else {
        let e = r.match(/^(\s*)([^]*\S)(\s*)$/);
        (t.text = e[2]), (t.raws.left = e[1]), (t.raws.right = e[3]);
       }
      }
      createTokenizer() {
       this.tokenizer = n(this.input);
      }
      decl(e, t) {
       let n = new r();
       this.init(n, e[0][2]);
       let s,
        i = e[e.length - 1];
       for (
        ";" === i[0] && ((this.semicolon = !0), e.pop()),
         n.source.end = this.getPosition(
          i[3] ||
           i[2] ||
           (function (e) {
            for (let t = e.length - 1; t >= 0; t--) {
             let r = e[t],
              n = r[3] || r[2];
             if (n) return n;
            }
           })(e),
         ),
         n.source.end.offset++;
        "word" !== e[0][0];

       )
        1 === e.length && this.unknownWord(e), (n.raws.before += e.shift()[1]);
       for (n.source.start = this.getPosition(e[0][2]), n.prop = ""; e.length; ) {
        let t = e[0][0];
        if (":" === t || "space" === t || "comment" === t) break;
        n.prop += e.shift()[1];
       }
       for (n.raws.between = ""; e.length; ) {
        if (((s = e.shift()), ":" === s[0])) {
         n.raws.between += s[1];
         break;
        }
        "word" === s[0] && /\w/.test(s[1]) && this.unknownWord([s]), (n.raws.between += s[1]);
       }
       ("_" === n.prop[0] || "*" === n.prop[0]) && ((n.raws.before += n.prop[0]), (n.prop = n.prop.slice(1)));
       let a,
        o = [];
       for (; e.length && ((a = e[0][0]), "space" === a || "comment" === a); ) o.push(e.shift());
       this.precheckMissedSemicolon(e);
       for (let r = e.length - 1; r >= 0; r--) {
        if (((s = e[r]), "!important" === s[1].toLowerCase())) {
         n.important = !0;
         let t = this.stringFrom(e, r);
         (t = this.spacesFromEnd(e) + t), " !important" !== t && (n.raws.important = t);
         break;
        }
        if ("important" === s[1].toLowerCase()) {
         let t = e.slice(0),
          s = "";
         for (let e = r; e > 0; e--) {
          let r = t[e][0];
          if (0 === s.trim().indexOf("!") && "space" !== r) break;
          s = t.pop()[1] + s;
         }
         0 === s.trim().indexOf("!") && ((n.important = !0), (n.raws.important = s), (e = t));
        }
        if ("space" !== s[0] && "comment" !== s[0]) break;
       }
       e.some((e) => "space" !== e[0] && "comment" !== e[0]) && ((n.raws.between += o.map((e) => e[1]).join("")), (o = [])), this.raw(n, "value", o.concat(e), t), n.value.includes(":") && !t && this.checkMissedSemicolon(e);
      }
      doubleColon(e) {
       throw this.input.error("Double colon", { offset: e[2] }, { offset: e[2] + e[1].length });
      }
      emptyRule(e) {
       let t = new o();
       this.init(t, e[2]), (t.selector = ""), (t.raws.between = ""), (this.current = t);
      }
      end(e) {
       this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.semicolon = !1), (this.current.raws.after = (this.current.raws.after || "") + this.spaces), (this.spaces = ""), this.current.parent ? ((this.current.source.end = this.getPosition(e[2])), this.current.source.end.offset++, (this.current = this.current.parent)) : this.unexpectedClose(e);
      }
      endFile() {
       this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.current.raws.after = (this.current.raws.after || "") + this.spaces), (this.root.source.end = this.getPosition(this.tokenizer.position()));
      }
      freeSemicolon(e) {
       if (((this.spaces += e[1]), this.current.nodes)) {
        let e = this.current.nodes[this.current.nodes.length - 1];
        e && "rule" === e.type && !e.raws.ownSemicolon && ((e.raws.ownSemicolon = this.spaces), (this.spaces = ""));
       }
      }
      getPosition(e) {
       let t = this.input.fromOffset(e);
       return { column: t.col, line: t.line, offset: e };
      }
      init(e, t) {
       this.current.push(e), (e.source = { input: this.input, start: this.getPosition(t) }), (e.raws.before = this.spaces), (this.spaces = ""), "comment" !== e.type && (this.semicolon = !1);
      }
      other(e) {
       let t = !1,
        r = null,
        n = !1,
        s = null,
        i = [],
        a = e[1].startsWith("--"),
        o = [],
        u = e;
       for (; u; ) {
        if (((r = u[0]), o.push(u), "(" === r || "[" === r)) s || (s = u), i.push("(" === r ? ")" : "]");
        else if (a && n && "{" === r) s || (s = u), i.push("}");
        else if (0 === i.length) {
         if (";" === r) {
          if (n) return void this.decl(o, a);
          break;
         }
         if ("{" === r) return void this.rule(o);
         if ("}" === r) {
          this.tokenizer.back(o.pop()), (t = !0);
          break;
         }
         ":" === r && (n = !0);
        } else r === i[i.length - 1] && (i.pop(), 0 === i.length && (s = null));
        u = this.tokenizer.nextToken();
       }
       if ((this.tokenizer.endOfFile() && (t = !0), i.length > 0 && this.unclosedBracket(s), t && n)) {
        if (!a) for (; o.length && ((u = o[o.length - 1][0]), "space" === u || "comment" === u); ) this.tokenizer.back(o.pop());
        this.decl(o, a);
       } else this.unknownWord(o);
      }
      parse() {
       let e;
       for (; !this.tokenizer.endOfFile(); )
        switch (((e = this.tokenizer.nextToken()), e[0])) {
         case "space":
          this.spaces += e[1];
          break;
         case ";":
          this.freeSemicolon(e);
          break;
         case "}":
          this.end(e);
          break;
         case "comment":
          this.comment(e);
          break;
         case "at-word":
          this.atrule(e);
          break;
         case "{":
          this.emptyRule(e);
          break;
         default:
          this.other(e);
        }
       this.endFile();
      }
      precheckMissedSemicolon() {}
      raw(e, t, r, n) {
       let s,
        i,
        a,
        o,
        l = r.length,
        p = "",
        c = !0;
       for (let h = 0; h < l; h += 1) (s = r[h]), (i = s[0]), "space" !== i || h !== l - 1 || n ? ("comment" === i ? ((o = r[h - 1] ? r[h - 1][0] : "empty"), (a = r[h + 1] ? r[h + 1][0] : "empty"), u[o] || u[a] || "," === p.slice(-1) ? (c = !1) : (p += s[1])) : (p += s[1])) : (c = !1);
       if (!c) {
        let n = r.reduce((e, t) => e + t[1], "");
        e.raws[t] = { raw: n, value: p };
       }
       e[t] = p;
      }
      rule(e) {
       e.pop();
       let t = new o();
       this.init(t, e[0][2]), (t.raws.between = this.spacesAndCommentsFromEnd(e)), this.raw(t, "selector", e), (this.current = t);
      }
      spacesAndCommentsFromEnd(e) {
       let t,
        r = "";
       for (; e.length && ((t = e[e.length - 1][0]), "space" === t || "comment" === t); ) r = e.pop()[1] + r;
       return r;
      }
      spacesAndCommentsFromStart(e) {
       let t,
        r = "";
       for (; e.length && ((t = e[0][0]), "space" === t || "comment" === t); ) r += e.shift()[1];
       return r;
      }
      spacesFromEnd(e) {
       let t,
        r = "";
       for (; e.length && ((t = e[e.length - 1][0]), "space" === t); ) r = e.pop()[1] + r;
       return r;
      }
      stringFrom(e, t) {
       let r = "";
       for (let n = t; n < e.length; n++) r += e[n][1];
       return e.splice(t, e.length - t), r;
      }
      unclosedBlock() {
       let e = this.current.source.start;
       throw this.input.error("Unclosed block", e.line, e.column);
      }
      unclosedBracket(e) {
       throw this.input.error("Unclosed bracket", { offset: e[2] }, { offset: e[2] + 1 });
      }
      unexpectedClose(e) {
       throw this.input.error("Unexpected }", { offset: e[2] }, { offset: e[2] + 1 });
      }
      unknownWord(e) {
       throw this.input.error("Unknown word", { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
      }
      unnamedAtrule(e, t) {
       throw this.input.error("At-rule without name", { offset: t[2] }, { offset: t[2] + t[1].length });
      }
     };
    }),
    k = l(() => {}),
    P = l((e, t) => {
     t.exports = {
      nanoid: (e = 21) => {
       let t = "",
        r = e;
       for (; r--; ) t += "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[(64 * Math.random()) | 0];
       return t;
      },
      customAlphabet:
       (e, t = 21) =>
       (r = t) => {
        let n = "",
         s = r;
        for (; s--; ) n += e[(Math.random() * e.length) | 0];
        return n;
       },
     };
    }),
    I = l((e, t) => {
     t.exports = class {};
    }),
    N = l((e, t) => {
     var { SourceMapConsumer: r, SourceMapGenerator: n } = k(),
      { fileURLToPath: s, pathToFileURL: i } = {},
      { isAbsolute: a, resolve: o } = {},
      { nanoid: u } = P(),
      l = m(),
      p = y(),
      c = I(),
      h = Symbol("fromOffsetCache"),
      d = !(!r || !n),
      f = !(!o || !a),
      g = class {
       constructor(e, t = {}) {
        if (null === e || typeof e > "u" || ("object" == typeof e && !e.toString)) throw new Error(`PostCSS received ${e} instead of CSS string`);
        if (((this.css = e.toString()), "\ufeff" === this.css[0] || "\ufffe" === this.css[0] ? ((this.hasBOM = !0), (this.css = this.css.slice(1))) : (this.hasBOM = !1), t.from && (!f || /^\w+:\/\//.test(t.from) || a(t.from) ? (this.file = t.from) : (this.file = o(t.from))), f && d)) {
         let e = new c(this.css, t);
         if (e.text) {
          this.map = e;
          let t = e.consumer().file;
          !this.file && t && (this.file = this.mapResolve(t));
         }
        }
        this.file || (this.id = "<input css " + u(6) + ">"), this.map && (this.map.file = this.from);
       }
       error(e, t, r, n = {}) {
        let s, a, o;
        if (t && "object" == typeof t) {
         let e = t,
          n = r;
         if ("number" == typeof e.offset) {
          let n = this.fromOffset(e.offset);
          (t = n.line), (r = n.col);
         } else (t = e.line), (r = e.column);
         if ("number" == typeof n.offset) {
          let e = this.fromOffset(n.offset);
          (a = e.line), (o = e.col);
         } else (a = n.line), (o = n.column);
        } else if (!r) {
         let e = this.fromOffset(t);
         (t = e.line), (r = e.col);
        }
        let u = this.origin(t, r, a, o);
        return (s = u ? new p(e, void 0 === u.endLine ? u.line : { column: u.column, line: u.line }, void 0 === u.endLine ? u.column : { column: u.endColumn, line: u.endLine }, u.source, u.file, n.plugin) : new p(e, void 0 === a ? t : { column: r, line: t }, void 0 === a ? r : { column: o, line: a }, this.css, this.file, n.plugin)), (s.input = { column: r, endColumn: o, endLine: a, line: t, source: this.css }), this.file && (i && (s.input.url = i(this.file).toString()), (s.input.file = this.file)), s;
       }
       fromOffset(e) {
        let t, r;
        if (this[h]) r = this[h];
        else {
         let e = this.css.split("\n");
         r = new Array(e.length);
         let t = 0;
         for (let n = 0, s = e.length; n < s; n++) (r[n] = t), (t += e[n].length + 1);
         this[h] = r;
        }
        t = r[r.length - 1];
        let n = 0;
        if (e >= t) n = r.length - 1;
        else {
         let t,
          s = r.length - 2;
         for (; n < s; )
          if (((t = n + ((s - n) >> 1)), e < r[t])) s = t - 1;
          else {
           if (!(e >= r[t + 1])) {
            n = t;
            break;
           }
           n = t + 1;
          }
        }
        return { col: e - r[n] + 1, line: n + 1 };
       }
       mapResolve(e) {
        return /^\w+:\/\//.test(e) ? e : o(this.map.consumer().sourceRoot || this.map.root || ".", e);
       }
       origin(e, t, r, n) {
        if (!this.map) return !1;
        let o,
         u,
         l = this.map.consumer(),
         p = l.originalPositionFor({ column: t, line: e });
        if (!p.source) return !1;
        "number" == typeof r && (o = l.originalPositionFor({ column: n, line: r })), (u = a(p.source) ? i(p.source) : new URL(p.source, this.map.consumer().sourceRoot || i(this.map.mapFile)));
        let c = { column: p.column, endColumn: o && o.column, endLine: o && o.line, line: p.line, url: u.toString() };
        if ("file:" === u.protocol) {
         if (!s) throw new Error("file: protocol is not available in this PostCSS build");
         c.file = s(u);
        }
        let h = l.sourceContentFor(p.source);
        return h && (c.source = h), c;
       }
       toJSON() {
        let e = {};
        for (let t of ["hasBOM", "css", "file", "id"]) null != this[t] && (e[t] = this[t]);
        return this.map && ((e.map = { ...this.map }), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
       }
       get from() {
        return this.file || this.id;
       }
      };
     (t.exports = g), (g.default = g), l && l.registerInput && l.registerInput(g);
    }),
    B = l((e, t) => {
     var r = E(),
      n = F(),
      s = N();
     function i(e, t) {
      let r = new s(e, t),
       i = new n(r);
      try {
       i.parse();
      } catch (a) {
       throw a;
      }
      return i.root;
     }
     (t.exports = i), (i.default = i), r.registerParse(i);
    }),
    _ = l((e, t) => {
     var r = C(),
      n = N();
     t.exports = {
      isInlineComment(e) {
       if ("word" === e[0] && "//" === e[1].slice(0, 2)) {
        let t,
         s,
         i = e,
         a = [];
        for (; e; ) {
         if (/\r?\n/.test(e[1])) {
          if (/['"].*\r?\n/.test(e[1])) {
           a.push(e[1].substring(0, e[1].indexOf("\n"))), (s = e[1].substring(e[1].indexOf("\n")));
           let r = this.input.css.valueOf().substring(this.tokenizer.position());
           (s += r), (t = e[3] + r.length - s.length);
          } else this.tokenizer.back(e);
          break;
         }
         a.push(e[1]), (t = e[2]), (e = this.tokenizer.nextToken({ ignoreUnclosed: !0 }));
        }
        let o = ["comment", a.join(""), i[2], t];
        return this.inlineComment(o), s && ((this.input = new n(s)), (this.tokenizer = r(this.input))), !0;
       }
       if ("/" === e[1]) {
        let r = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
        if ("comment" === r[0] && /^\/\*/.test(r[1])) return (r[0] = "word"), (r[1] = r[1].slice(1)), (e[1] = "//"), this.tokenizer.back(r), t.exports.isInlineComment.bind(this)(e);
       }
       return !1;
      },
     };
    }),
    L = l((e, t) => {
     t.exports = {
      interpolation(e) {
       let t = [e, this.tokenizer.nextToken()],
        r = ["word", "}"];
       if (t[0][1].length > 1 || "{" !== t[1][0]) return this.tokenizer.back(t[1]), !1;
       for (e = this.tokenizer.nextToken(); e && r.includes(e[0]); ) t.push(e), (e = this.tokenizer.nextToken());
       let n = t.map((e) => e[1]),
        [s] = t,
        i = t.pop(),
        a = ["word", n.join(""), s[2], i[2]];
       return this.tokenizer.back(e), this.tokenizer.back(a), !0;
      },
     };
    }),
    O = l((e, t) => {
     var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/,
      n = /\.[0-9]/;
     t.exports = {
      isMixinToken: (e) => {
       let [, t] = e,
        [s] = t;
       return ("." === s || "#" === s) && !1 === r.test(t) && !1 === n.test(t);
      },
     };
    }),
    M = l((e, t) => {
     var r = C(),
      n = /^url\((.+)\)/;
     t.exports = (e) => {
      let { name: t, params: s = "" } = e;
      if ("import" === t && s.length) {
       e.import = !0;
       let t = r({ css: s });
       for (e.filename = s.replace(n, "$1"); !t.endOfFile(); ) {
        let [r, n] = t.nextToken();
        if ("word" === r && "url" === n) return;
        if ("brackets" === r) {
         (e.options = n), (e.filename = s.replace(n, "").trim());
         break;
        }
       }
      }
     };
    }),
    j = l((e, t) => {
     var r = /:$/,
      n = /^:(\s+)?/;
     t.exports = (e) => {
      let { name: t, params: s = "" } = e;
      if (":" === e.name.slice(-1)) {
       if (r.test(t)) {
        let [n] = t.match(r);
        (e.name = t.replace(n, "")), (e.raws.afterName = n + (e.raws.afterName || "")), (e.variable = !0), (e.value = e.params);
       }
       if (n.test(s)) {
        let [t] = s.match(n);
        (e.value = s.replace(t, "")), (e.raws.afterName = (e.raws.afterName || "") + t), (e.variable = !0);
       }
      }
     };
    }),
    R = l((e, t) => {
     var r = v(),
      n = F(),
      { isInlineComment: s } = _(),
      { interpolation: i } = L(),
      { isMixinToken: a } = O(),
      o = M(),
      u = j(),
      l = /(!\s*important)$/i;
     t.exports = class extends n {
      constructor(...e) {
       super(...e), (this.lastNode = null);
      }
      atrule(e) {
       i.bind(this)(e) || (super.atrule(e), o(this.lastNode), u(this.lastNode));
      }
      decl(...e) {
       super.decl(...e), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
      }
      each(e) {
       e[0][1] = ` ${e[0][1]}`;
       let t = e.findIndex((e) => "(" === e[0]),
        r = e.reverse().find((e) => ")" === e[0]),
        n = e.reverse().indexOf(r),
        s = e
         .splice(t, n)
         .map((e) => e[1])
         .join("");
       for (let i of e.reverse()) this.tokenizer.back(i);
       this.atrule(this.tokenizer.nextToken()), (this.lastNode.function = !0), (this.lastNode.params = s);
      }
      init(e, t, r) {
       super.init(e, t, r), (this.lastNode = e);
      }
      inlineComment(e) {
       let t = new r(),
        n = e[1].slice(2);
       if ((this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), (t.inline = !0), (t.raws.begin = "//"), /^\s*$/.test(n))) (t.text = ""), (t.raws.left = n), (t.raws.right = "");
       else {
        let e = n.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, t.raws.left, t.text, t.raws.right] = e;
       }
      }
      mixin(e) {
       let [t] = e,
        r = t[1].slice(0, 1),
        n = e.findIndex((e) => "brackets" === e[0]),
        s = e.findIndex((e) => "(" === e[0]),
        i = "";
       if ((n < 0 || n > 3) && s > 0) {
        let t = e.reduce((e, t, r) => (")" === t[0] ? r : e)),
         r = e
          .slice(s, t + s)
          .map((e) => e[1])
          .join(""),
         [n] = e.slice(s),
         i = [n[2], n[3]],
         [a] = e.slice(t, t + 1),
         o = [a[2], a[3]],
         u = ["brackets", r].concat(i, o),
         l = e.slice(0, s),
         p = e.slice(t + 1);
        (e = l).push(u), (e = e.concat(p));
       }
       let a = [];
       for (let u of e) if ((("!" === u[1] || a.length) && a.push(u), "important" === u[1])) break;
       if (a.length) {
        let [t] = a,
         r = e.indexOf(t),
         n = a[a.length - 1],
         s = [t[2], t[3]],
         i = [n[4], n[5]],
         o = ["word", a.map((e) => e[1]).join("")].concat(s, i);
        e.splice(r, a.length, o);
       }
       let o = e.findIndex((e) => l.test(e[1]));
       o > 0 && (([, i] = e[o]), e.splice(o, 1));
       for (let u of e.reverse()) this.tokenizer.back(u);
       this.atrule(this.tokenizer.nextToken()), (this.lastNode.mixin = !0), (this.lastNode.raws.identifier = r), i && ((this.lastNode.important = !0), (this.lastNode.raws.important = i));
      }
      other(e) {
       s.bind(this)(e) || super.other(e);
      }
      rule(e) {
       let t = e[e.length - 1],
        r = e[e.length - 2];
       if ("at-word" === r[0] && "{" === t[0] && (this.tokenizer.back(t), i.bind(this)(r))) {
        let t = this.tokenizer.nextToken();
        e = e.slice(0, e.length - 2).concat([t]);
        for (let r of e.reverse()) this.tokenizer.back(r);
       } else super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
      }
      unknownWord(e) {
       let [t] = e;
       "each" !== e[0][1] || "(" !== e[1][0] ? (a(t) ? this.mixin(e) : super.unknownWord(e)) : this.each(e);
      }
     };
    }),
    q = l((e, t) => {
     var r = g();
     t.exports = class extends r {
      atrule(e, t) {
       if (!e.mixin && !e.variable && !e.function) return void super.atrule(e, t);
       let r = `${e.function ? "" : e.raws.identifier || "@"}${e.name}`,
        n = e.params ? this.rawValue(e, "params") : "",
        s = e.raws.important || "";
       if ((e.variable && (n = e.value), typeof e.raws.afterName < "u" ? (r += e.raws.afterName) : n && (r += " "), e.nodes)) this.block(e, r + n + s);
       else {
        let i = (e.raws.between || "") + s + (t ? ";" : "");
        this.builder(r + n + i, e);
       }
      }
      comment(e) {
       if (e.inline) {
        let t = this.raw(e, "left", "commentLeft"),
         r = this.raw(e, "right", "commentRight");
        this.builder(`//${t}${e.text}${r}`, e);
       } else super.comment(e);
      }
     };
    }),
    U = l((e, t) => {
     var r = N(),
      n = R(),
      s = q();
     t.exports = {
      parse(e, t) {
       let s = new r(e, t),
        i = new n(s);
       return (
        i.parse(),
        i.root.walk((e) => {
         let t = s.css.lastIndexOf(e.source.input.css);
         if (0 === t) return;
         if (t + e.source.input.css.length !== s.css.length) throw new Error("Invalid state detected in postcss-less");
         let r = t + e.source.start.offset,
          n = s.fromOffset(t + e.source.start.offset);
         if (((e.source.start = { offset: r, line: n.line, column: n.col }), e.source.end)) {
          let r = t + e.source.end.offset,
           n = s.fromOffset(t + e.source.end.offset);
          e.source.end = { offset: r, line: n.line, column: n.col };
         }
        }),
        i.root
       );
      },
      stringify(e, t) {
       new s(t).stringify(e);
      },
      nodeToString(e) {
       let r = "";
       return (
        t.exports.stringify(e, (e) => {
         r += e;
        }),
        r
       );
      },
     };
    }),
    $ = l((e, t) => {
     t.exports = class {
      generate() {}
     };
    }),
    V = l((e, t) => {
     var r,
      n,
      s = E(),
      i = class extends s {
       constructor(e) {
        super({ type: "document", ...e }), this.nodes || (this.nodes = []);
       }
       toResult(e = {}) {
        return new r(new n(), this, e).stringify();
       }
      };
     (i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       n = e;
      }),
      (t.exports = i),
      (i.default = i);
    }),
    z = l((e, t) => {
     var r = {};
     t.exports = function (e) {
      r[e] || ((r[e] = !0), typeof console < "u" && console.warn && console.warn(e));
     };
    }),
    W = l((e, t) => {
     var r = class {
      constructor(e, t = {}) {
       if (((this.type = "warning"), (this.text = e), t.node && t.node.source)) {
        let e = t.node.rangeBy(t);
        (this.line = e.start.line), (this.column = e.start.column), (this.endLine = e.end.line), (this.endColumn = e.end.column);
       }
       for (let r in t) this[r] = t[r];
      }
      toString() {
       return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
      }
     };
     (t.exports = r), (r.default = r);
    }),
    H = l((e, t) => {
     var r = W(),
      n = class {
       constructor(e, t, r) {
        (this.processor = e), (this.messages = []), (this.root = t), (this.opts = r), (this.css = void 0), (this.map = void 0);
       }
       toString() {
        return this.css;
       }
       warn(e, t = {}) {
        t.plugin || (this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin));
        let n = new r(e, t);
        return this.messages.push(n), n;
       }
       warnings() {
        return this.messages.filter((e) => "warning" === e.type);
       }
       get content() {
        return this.css;
       }
      };
     (t.exports = n), (n.default = n);
    }),
    J = l((e, t) => {
     var { isClean: r, my: n } = d(),
      s = $(),
      i = D(),
      a = E(),
      o = V(),
      u = (z(), H()),
      l = B(),
      p = w(),
      c = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" },
      h = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 },
      f = { Once: !0, postcssPlugin: !0, prepare: !0 },
      m = 0;
     function y(e) {
      return "object" == typeof e && "function" == typeof e.then;
     }
     function g(e) {
      let t = !1,
       r = c[e.type];
      return "decl" === e.type ? (t = e.prop.toLowerCase()) : "atrule" === e.type && (t = e.name.toLowerCase()), t && e.append ? [r, r + "-" + t, m, r + "Exit", r + "Exit-" + t] : t ? [r, r + "-" + t, r + "Exit", r + "Exit-" + t] : e.append ? [r, m, r + "Exit"] : [r, r + "Exit"];
     }
     function x(e) {
      let t;
      return (t = "document" === e.type ? ["Document", m, "DocumentExit"] : "root" === e.type ? ["Root", m, "RootExit"] : g(e)), { eventIndex: 0, events: t, iterator: 0, node: e, visitorIndex: 0, visitors: [] };
     }
     function b(e) {
      return (e[r] = !1), e.nodes && e.nodes.forEach((e) => b(e)), e;
     }
     var v = {},
      C = class e {
       constructor(t, r, s) {
        let i;
        if (((this.stringified = !1), (this.processed = !1), "object" != typeof r || null === r || ("root" !== r.type && "document" !== r.type)))
         if (r instanceof e || r instanceof u) (i = b(r.root)), r.map && (typeof s.map > "u" && (s.map = {}), s.map.inline || (s.map.inline = !1), (s.map.prev = r.map));
         else {
          let e = l;
          s.syntax && (e = s.syntax.parse), s.parser && (e = s.parser), e.parse && (e = e.parse);
          try {
           i = e(r, s);
          } catch (o) {
           (this.processed = !0), (this.error = o);
          }
          i && !i[n] && a.rebuild(i);
         }
        else i = b(r);
        (this.result = new u(t, i, s)), (this.helpers = { ...v, postcss: v, result: this.result }), (this.plugins = this.processor.plugins.map((e) => ("object" == typeof e && e.prepare ? { ...e, ...e.prepare(this.result) } : e)));
       }
       async() {
        return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
       }
       catch(e) {
        return this.async().catch(e);
       }
       finally(e) {
        return this.async().then(e, e);
       }
       getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
       }
       handleError(e, t) {
        let r = this.result.lastPlugin;
        try {
         t && t.addToError(e), (this.error = e), "CssSyntaxError" !== e.name || e.plugin ? r.postcssVersion : ((e.plugin = r.postcssPlugin), e.setMessage());
        } catch (n) {
         console && console.error && console.error(n);
        }
        return e;
       }
       prepareVisitors() {
        this.listeners = {};
        let e = (e, t, r) => {
         this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push([e, r]);
        };
        for (let t of this.plugins)
         if ("object" == typeof t)
          for (let r in t) {
           if (!h[r] && /^[A-Z]/.test(r)) throw new Error(`Unknown event ${r} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
           if (!f[r])
            if ("object" == typeof t[r]) for (let n in t[r]) e(t, "*" === n ? r : r + "-" + n.toLowerCase(), t[r][n]);
            else "function" == typeof t[r] && e(t, r, t[r]);
          }
        this.hasListener = Object.keys(this.listeners).length > 0;
       }
       async runAsync() {
        this.plugin = 0;
        for (let t = 0; t < this.plugins.length; t++) {
         let r = this.plugins[t],
          n = this.runOnRoot(r);
         if (y(n))
          try {
           await n;
          } catch (e) {
           throw this.handleError(e);
          }
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let t = this.result.root;
         for (; !t[r]; ) {
          t[r] = !0;
          let n = [x(t)];
          for (; n.length > 0; ) {
           let t = this.visitTick(n);
           if (y(t))
            try {
             await t;
            } catch (e) {
             let t = n[n.length - 1].node;
             throw this.handleError(e, t);
            }
          }
         }
         if (this.listeners.OnceExit)
          for (let [r, n] of this.listeners.OnceExit) {
           this.result.lastPlugin = r;
           try {
            if ("document" === t.type) {
             let e = t.nodes.map((e) => n(e, this.helpers));
             await Promise.all(e);
            } else await n(t, this.helpers);
           } catch (e) {
            throw this.handleError(e);
           }
          }
        }
        return (this.processed = !0), this.stringify();
       }
       runOnRoot(e) {
        this.result.lastPlugin = e;
        try {
         if ("object" == typeof e && e.Once) {
          if ("document" === this.result.root.type) {
           let t = this.result.root.nodes.map((t) => e.Once(t, this.helpers));
           return y(t[0]) ? Promise.all(t) : t;
          }
          return e.Once(this.result.root, this.helpers);
         }
         if ("function" == typeof e) return e(this.result.root, this.result);
        } catch (t) {
         throw this.handleError(t);
        }
       }
       stringify() {
        if (this.error) throw this.error;
        if (this.stringified) return this.result;
        (this.stringified = !0), this.sync();
        let e = this.result.opts,
         t = i;
        e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
        let r = new s(t, this.result.root, this.result.opts).generate();
        return (this.result.css = r[0]), (this.result.map = r[1]), this.result;
       }
       sync() {
        if (this.error) throw this.error;
        if (this.processed) return this.result;
        if (((this.processed = !0), this.processing)) throw this.getAsyncError();
        for (let e of this.plugins) {
         if (y(this.runOnRoot(e))) throw this.getAsyncError();
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let e = this.result.root;
         for (; !e[r]; ) (e[r] = !0), this.walkSync(e);
         if (this.listeners.OnceExit)
          if ("document" === e.type) for (let t of e.nodes) this.visitSync(this.listeners.OnceExit, t);
          else this.visitSync(this.listeners.OnceExit, e);
        }
        return this.result;
       }
       then(e, t) {
        return this.async().then(e, t);
       }
       toString() {
        return this.css;
       }
       visitSync(e, t) {
        for (let [n, s] of e) {
         let e;
         this.result.lastPlugin = n;
         try {
          e = s(t, this.helpers);
         } catch (r) {
          throw this.handleError(r, t.proxyOf);
         }
         if ("root" !== t.type && "document" !== t.type && !t.parent) return !0;
         if (y(e)) throw this.getAsyncError();
        }
       }
       visitTick(e) {
        let t = e[e.length - 1],
         { node: n, visitors: s } = t;
        if ("root" !== n.type && "document" !== n.type && !n.parent) return void e.pop();
        if (s.length > 0 && t.visitorIndex < s.length) {
         let [e, r] = s[t.visitorIndex];
         (t.visitorIndex += 1), t.visitorIndex === s.length && ((t.visitors = []), (t.visitorIndex = 0)), (this.result.lastPlugin = e);
         try {
          return r(n.toProxy(), this.helpers);
         } catch (a) {
          throw this.handleError(a, n);
         }
        }
        if (0 !== t.iterator) {
         let s,
          i = t.iterator;
         for (; (s = n.nodes[n.indexes[i]]); ) if (((n.indexes[i] += 1), !s[r])) return (s[r] = !0), void e.push(x(s));
         (t.iterator = 0), delete n.indexes[i];
        }
        let i = t.events;
        for (; t.eventIndex < i.length; ) {
         let e = i[t.eventIndex];
         if (((t.eventIndex += 1), e === m)) return void (n.nodes && n.nodes.length && ((n[r] = !0), (t.iterator = n.getIterator())));
         if (this.listeners[e]) return void (t.visitors = this.listeners[e]);
        }
        e.pop();
       }
       walkSync(e) {
        e[r] = !0;
        let t = g(e);
        for (let n of t)
         if (n === m)
          e.nodes &&
           e.each((e) => {
            e[r] || this.walkSync(e);
           });
         else {
          let t = this.listeners[n];
          if (t && this.visitSync(t, e.toProxy())) return;
         }
       }
       warnings() {
        return this.sync().warnings();
       }
       get content() {
        return this.stringify().content;
       }
       get css() {
        return this.stringify().css;
       }
       get map() {
        return this.stringify().map;
       }
       get messages() {
        return this.sync().messages;
       }
       get opts() {
        return this.result.opts;
       }
       get processor() {
        return this.result.processor;
       }
       get root() {
        return this.sync().root;
       }
       get [Symbol.toStringTag]() {
        return "LazyResult";
       }
      };
     (C.registerPostcss = (e) => {
      v = e;
     }),
      (t.exports = C),
      (C.default = C),
      p.registerLazyResult(C),
      o.registerLazyResult(C);
    }),
    K = l((e, t) => {
     var r = $(),
      n = D(),
      s = (z(), B()),
      i = H(),
      a = class {
       constructor(e, t, s) {
        (t = t.toString()), (this.stringified = !1), (this._processor = e), (this._css = t), (this._opts = s), (this._map = void 0);
        let a,
         o = n;
        (this.result = new i(this._processor, a, this._opts)), (this.result.css = t);
        let u = this;
        Object.defineProperty(this.result, "root", { get: () => u.root });
        let l = new r(o, a, this._opts, t);
        if (l.isMap()) {
         let [e, t] = l.generate();
         e && (this.result.css = e), t && (this.result.map = t);
        } else l.clearAnnotation(), (this.result.css = l.css);
       }
       async() {
        return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
       }
       catch(e) {
        return this.async().catch(e);
       }
       finally(e) {
        return this.async().then(e, e);
       }
       sync() {
        if (this.error) throw this.error;
        return this.result;
       }
       then(e, t) {
        return this.async().then(e, t);
       }
       toString() {
        return this._css;
       }
       warnings() {
        return [];
       }
       get content() {
        return this.result.css;
       }
       get css() {
        return this.result.css;
       }
       get map() {
        return this.result.map;
       }
       get messages() {
        return [];
       }
       get opts() {
        return this.result.opts;
       }
       get processor() {
        return this.result.processor;
       }
       get root() {
        if (this._root) return this._root;
        let e,
         t = s;
        try {
         e = t(this._css, this._opts);
        } catch (r) {
         this.error = r;
        }
        if (this.error) throw this.error;
        return (this._root = e), e;
       }
       get [Symbol.toStringTag]() {
        return "NoWorkResult";
       }
      };
     (t.exports = a), (a.default = a);
    }),
    G = l((e, t) => {
     var r = K(),
      n = J(),
      s = V(),
      i = w(),
      a = class {
       constructor(e = []) {
        (this.version = "8.4.33"), (this.plugins = this.normalize(e));
       }
       normalize(e) {
        let t = [];
        for (let r of e)
         if ((!0 === r.postcss ? (r = r()) : r.postcss && (r = r.postcss), "object" == typeof r && Array.isArray(r.plugins))) t = t.concat(r.plugins);
         else if ("object" == typeof r && r.postcssPlugin) t.push(r);
         else if ("function" == typeof r) t.push(r);
         else if ("object" != typeof r || (!r.parse && !r.stringify)) throw new Error(r + " is not a PostCSS plugin");
        return t;
       }
       process(e, t = {}) {
        return this.plugins.length || t.parser || t.stringifier || t.syntax ? new n(this, e, t) : new r(this, e, t);
       }
       use(e) {
        return (this.plugins = this.plugins.concat(this.normalize([e]))), this;
       }
      };
     (t.exports = a), (a.default = a), i.registerProcessor(a), s.registerProcessor(a);
    }),
    X = l((e, t) => {
     var r = b(),
      n = I(),
      s = v(),
      i = T(),
      a = N(),
      o = w(),
      u = A();
     function l(e, t) {
      if (Array.isArray(e)) return e.map((e) => l(e));
      let { inputs: p, ...c } = e;
      if (p) {
       t = [];
       for (let e of p) {
        let r = { ...e, __proto__: a.prototype };
        r.map && (r.map = { ...r.map, __proto__: n.prototype }), t.push(r);
       }
      }
      if ((c.nodes && (c.nodes = e.nodes.map((e) => l(e, t))), c.source)) {
       let { inputId: e, ...r } = c.source;
       (c.source = r), null != e && (c.source.input = t[e]);
      }
      if ("root" === c.type) return new o(c);
      if ("decl" === c.type) return new r(c);
      if ("rule" === c.type) return new u(c);
      if ("comment" === c.type) return new s(c);
      if ("atrule" === c.type) return new i(c);
      throw new Error("Unknown node type: " + e.type);
     }
     (t.exports = l), (l.default = l);
    }),
    Y = l((e, t) => {
     var r = y(),
      n = b(),
      s = J(),
      i = E(),
      a = G(),
      o = D(),
      u = X(),
      l = V(),
      p = W(),
      c = v(),
      h = T(),
      d = H(),
      f = N(),
      m = B(),
      g = S(),
      C = A(),
      F = w(),
      k = x();
     function P(...e) {
      return 1 === e.length && Array.isArray(e[0]) && (e = e[0]), new a(e);
     }
     (P.plugin = function (e, t) {
      let r,
       n = !1;
      function s(...r) {
       console && console.warn && !n && ((n = !0), console.warn(e + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"));
       let s = t(...r);
       return (s.postcssPlugin = e), (s.postcssVersion = new a().version), s;
      }
      return (
       Object.defineProperty(s, "postcss", { get: () => (r || (r = s()), r) }),
       (s.process = function (e, t, r) {
        return P([s(r)]).process(e, t);
       }),
       s
      );
     }),
      (P.stringify = o),
      (P.parse = m),
      (P.fromJSON = u),
      (P.list = g),
      (P.comment = (e) => new c(e)),
      (P.atRule = (e) => new h(e)),
      (P.decl = (e) => new n(e)),
      (P.rule = (e) => new C(e)),
      (P.root = (e) => new F(e)),
      (P.document = (e) => new l(e)),
      (P.CssSyntaxError = r),
      (P.Declaration = n),
      (P.Container = i),
      (P.Processor = a),
      (P.Document = l),
      (P.Comment = c),
      (P.Warning = p),
      (P.AtRule = h),
      (P.Result = d),
      (P.Input = f),
      (P.Rule = C),
      (P.Root = F),
      (P.Node = k),
      s.registerPostcss(P),
      (t.exports = P),
      (P.default = P);
    }),
    Q = l((e, t) => {
     var { Container: r } = Y();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = "decl"), (this.isNested = !0), this.nodes || (this.nodes = []);
      }
     };
    }),
    Z = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      n = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      s = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i,
      a = /[\n\f\r]/g;
     t.exports = function (e, t = {}) {
      let o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       g = e.css.valueOf(),
       D = t.ignoreErrors,
       x = g.length,
       b = 0,
       v = [],
       E = [];
      function C(t) {
       throw e.error("Unclosed " + t, b);
      }
      function T() {
       let e = 1,
        t = !1,
        r = !1;
       for (; e > 0; ) (u += 1), g.length <= u && C("interpolation"), (o = g.charCodeAt(u)), (f = g.charCodeAt(u + 1)), t ? (r || o !== t ? (92 === o ? (r = !r) : r && (r = !1)) : ((t = !1), (r = !1))) : 39 === o || 34 === o ? (t = o) : 125 === o ? (e -= 1) : 35 === o && 123 === f && (e += 1);
      }
      return {
       back: function (e) {
        E.push(e);
       },
       endOfFile: function () {
        return 0 === E.length && b >= x;
       },
       nextToken: function (e) {
        if (E.length) return E.pop();
        if (b >= x) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((o = g.charCodeAt(b)), o)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          u = b;
          do {
           (u += 1), (o = g.charCodeAt(u));
          } while (32 === o || 10 === o || 9 === o || 13 === o || 12 === o);
          (m = ["space", g.slice(b, u)]), (b = u - 1);
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(o);
          m = [e, e, b];
          break;
         }
         case 44:
          m = ["word", ",", b, b + 1];
          break;
         case 40:
          if (((d = v.length ? v.pop()[1] : ""), (f = g.charCodeAt(b + 1)), "url" === d && 39 !== f && 34 !== f)) {
           for (y = 1, h = !1, u = b + 1; u <= g.length - 1; ) {
            if (((f = g.charCodeAt(u)), 92 === f)) h = !h;
            else if (40 === f) y += 1;
            else if (41 === f && ((y -= 1), 0 === y)) break;
            u += 1;
           }
           (p = g.slice(b, u + 1)), (m = ["brackets", p, b, u]), (b = u);
          } else (u = g.indexOf(")", b + 1)), (p = g.slice(b, u + 1)), -1 === u || s.test(p) ? (m = ["(", "(", b]) : ((m = ["brackets", p, b, u]), (b = u));
          break;
         case 39:
         case 34:
          for (l = o, u = b, h = !1; u < x && (u++, u === x && C("string"), (o = g.charCodeAt(u)), (f = g.charCodeAt(u + 1)), h || o !== l); ) 92 === o ? (h = !h) : h ? (h = !1) : 35 === o && 123 === f && T();
          (m = ["string", g.slice(b, u + 1), b, u]), (b = u);
          break;
         case 64:
          (r.lastIndex = b + 1), r.test(g), (u = 0 === r.lastIndex ? g.length - 1 : r.lastIndex - 2), (m = ["at-word", g.slice(b, u + 1), b, u]), (b = u);
          break;
         case 92:
          for (u = b, c = !0; 92 === g.charCodeAt(u + 1); ) (u += 1), (c = !c);
          if (((o = g.charCodeAt(u + 1)), c && 47 !== o && 32 !== o && 10 !== o && 9 !== o && 13 !== o && 12 !== o && ((u += 1), i.test(g.charAt(u))))) {
           for (; i.test(g.charAt(u + 1)); ) u += 1;
           32 === g.charCodeAt(u + 1) && (u += 1);
          }
          (m = ["word", g.slice(b, u + 1), b, u]), (b = u);
          break;
         default:
          (f = g.charCodeAt(b + 1)), 35 === o && 123 === f ? ((u = b), T(), (p = g.slice(b, u + 1)), (m = ["word", p, b, u]), (b = u)) : 47 === o && 42 === f ? ((u = g.indexOf("*/", b + 2) + 1), 0 === u && (D || t ? (u = g.length) : C("comment")), (m = ["comment", g.slice(b, u + 1), b, u]), (b = u)) : 47 === o && 47 === f ? ((a.lastIndex = b + 1), a.test(g), (u = 0 === a.lastIndex ? g.length - 1 : a.lastIndex - 2), (p = g.slice(b, u + 1)), (m = ["comment", p, b, u, "inline"]), (b = u)) : ((n.lastIndex = b + 1), n.test(g), (u = 0 === n.lastIndex ? g.length - 1 : n.lastIndex - 2), (m = ["word", g.slice(b, u + 1), b, u]), v.push(m), (b = u));
        }
        return b++, m;
       },
       position: function () {
        return b;
       },
      };
     };
    }),
    ee = l((e, t) => {
     var { Comment: r } = Y(),
      n = F(),
      s = Q(),
      i = Z();
     t.exports = class extends n {
      atrule(e) {
       let t = e[1],
        r = e;
       for (; !this.tokenizer.endOfFile(); ) {
        let e = this.tokenizer.nextToken();
        if ("word" !== e[0] || e[2] !== r[3] + 1) {
         this.tokenizer.back(e);
         break;
        }
        (t += e[1]), (r = e);
       }
       super.atrule(["at-word", t, e[2], r[3]]);
      }
      comment(e) {
       if ("inline" === e[4]) {
        let t = new r();
        this.init(t, e[2]), (t.raws.inline = !0);
        let n = this.input.fromOffset(e[3]);
        t.source.end = { column: n.col, line: n.line, offset: e[3] + 1 };
        let s = e[1].slice(2);
        if (/^\s*$/.test(s)) (t.text = ""), (t.raws.left = s), (t.raws.right = "");
        else {
         let e = s.match(/^(\s*)([^]*\S)(\s*)$/),
          r = e[2].replace(/(\*\/|\/\*)/g, "*//*");
         (t.text = r), (t.raws.left = e[1]), (t.raws.right = e[3]), (t.raws.text = e[2]);
        }
       } else super.comment(e);
      }
      createTokenizer() {
       this.tokenizer = i(this.input);
      }
      raw(e, t, r, n) {
       if ((super.raw(e, t, r, n), e.raws[t])) {
        let n = e.raws[t].raw;
        (e.raws[t].raw = r.reduce((e, t) => {
         if ("comment" === t[0] && "inline" === t[4]) {
          return e + "/*" + t[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*") + "*/";
         }
         return e + t[1];
        }, "")),
         n !== e.raws[t].raw && (e.raws[t].scss = n);
       }
      }
      rule(e) {
       let t = !1,
        r = 0,
        n = "";
       for (let s of e)
        if (t) "comment" !== s[0] && "{" !== s[0] && (n += s[1]);
        else {
         if ("space" === s[0] && s[1].includes("\n")) break;
         "(" === s[0] ? (r += 1) : ")" === s[0] ? (r -= 1) : 0 === r && ":" === s[0] && (t = !0);
        }
       if (!t || "" === n.trim() || /^[#:A-Za-z-]/.test(n)) super.rule(e);
       else {
        e.pop();
        let t,
         r,
         n = new s();
        this.init(n, e[0][2]);
        for (let s = e.length - 1; s >= 0; s--)
         if ("space" !== e[s][0]) {
          t = e[s];
          break;
         }
        if (t[3]) {
         let e = this.input.fromOffset(t[3]);
         n.source.end = { column: e.col, line: e.line, offset: t[3] + 1 };
        } else {
         let e = this.input.fromOffset(t[2]);
         n.source.end = { column: e.col, line: e.line, offset: t[2] + 1 };
        }
        for (; "word" !== e[0][0]; ) n.raws.before += e.shift()[1];
        if (e[0][2]) {
         let t = this.input.fromOffset(e[0][2]);
         n.source.start = { column: t.col, line: t.line, offset: e[0][2] };
        }
        for (n.prop = ""; e.length; ) {
         let t = e[0][0];
         if (":" === t || "space" === t || "comment" === t) break;
         n.prop += e.shift()[1];
        }
        for (n.raws.between = ""; e.length; ) {
         if (((r = e.shift()), ":" === r[0])) {
          n.raws.between += r[1];
          break;
         }
         n.raws.between += r[1];
        }
        ("_" === n.prop[0] || "*" === n.prop[0]) && ((n.raws.before += n.prop[0]), (n.prop = n.prop.slice(1))), (n.raws.between += this.spacesAndCommentsFromStart(e)), this.precheckMissedSemicolon(e);
        for (let s = e.length - 1; s > 0; s--) {
         if (((r = e[s]), "!important" === r[1])) {
          n.important = !0;
          let t = this.stringFrom(e, s);
          (t = this.spacesFromEnd(e) + t), " !important" !== t && (n.raws.important = t);
          break;
         }
         if ("important" === r[1]) {
          let t = e.slice(0),
           r = "";
          for (let e = s; e > 0; e--) {
           let n = t[e][0];
           if (0 === r.trim().indexOf("!") && "space" !== n) break;
           r = t.pop()[1] + r;
          }
          0 === r.trim().indexOf("!") && ((n.important = !0), (n.raws.important = r), (e = t));
         }
         if ("space" !== r[0] && "comment" !== r[0]) break;
        }
        this.raw(n, "value", e), n.value.includes(":") && this.checkMissedSemicolon(e), (this.current = n);
       }
      }
     };
    }),
    te = l((e, t) => {
     var { Input: r } = Y(),
      n = ee();
     t.exports = function (e, t) {
      let s = new r(e, t),
       i = new n(s);
      return i.parse(), i.root;
     };
    }),
    re = l((e) => {
     Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.default = function (e) {
       (this.after = e.after), (this.before = e.before), (this.type = e.type), (this.value = e.value), (this.sourceIndex = e.sourceIndex);
      });
    }),
    ne = l((e) => {
     Object.defineProperty(e, "__esModule", { value: !0 });
     var t,
      r = re(),
      n = (t = r) && t.__esModule ? t : { default: t };
     function s(e) {
      var t = this;
      this.constructor(e),
       (this.nodes = e.nodes),
       void 0 === this.after && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""),
       void 0 === this.before && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""),
       void 0 === this.sourceIndex && (this.sourceIndex = this.before.length),
       this.nodes.forEach(function (e) {
        e.parent = t;
       });
     }
     (s.prototype = Object.create(n.default.prototype)),
      (s.constructor = n.default),
      (s.prototype.walk = function (e, t) {
       for (var r = "string" == typeof e || e instanceof RegExp, n = r ? t : e, s = "string" == typeof e ? new RegExp(e) : e, i = 0; i < this.nodes.length; i++) {
        var a = this.nodes[i];
        if (((!r || s.test(a.type)) && n && !1 === n(a, i, this.nodes)) || (a.nodes && !1 === a.walk(e, t))) return !1;
       }
       return !0;
      }),
      (s.prototype.each = function () {
       for (var e = arguments.length <= 0 || void 0 === arguments[0] ? function () {} : arguments[0], t = 0; t < this.nodes.length; t++) {
        if (!1 === e(this.nodes[t], t, this.nodes)) return !1;
       }
       return !0;
      }),
      (e.default = s);
    }),
    se = l((e) => {
     Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.parseMediaFeature = s),
      (e.parseMediaQuery = i),
      (e.parseMediaList = function (e) {
       var n = [],
        s = 0,
        a = 0,
        o = /^(\s*)url\s*\(/.exec(e);
       if (null !== o) {
        for (var u = o[0].length, l = 1; l > 0; ) {
         var p = e[u];
         "(" === p && l++, ")" === p && l--, u++;
        }
        n.unshift(new t.default({ type: "url", value: e.substring(0, u).trim(), sourceIndex: o[1].length, before: o[1], after: /^(\s*)/.exec(e.substring(u))[1] })), (s = u);
       }
       for (var c = s; c < e.length; c++) {
        var h = e[c];
        if (("(" === h && a++, ")" === h && a--, 0 === a && "," === h)) {
         var d = e.substring(s, c),
          f = /^(\s*)/.exec(d)[1];
         n.push(new r.default({ type: "media-query", value: d.trim(), sourceIndex: s + f.length, nodes: i(d, s), before: f, after: /(\s*)$/.exec(d)[1] })), (s = c + 1);
        }
       }
       var m = e.substring(s),
        y = /^(\s*)/.exec(m)[1];
       return n.push(new r.default({ type: "media-query", value: m.trim(), sourceIndex: s + y.length, nodes: i(m, s), before: y, after: /(\s*)$/.exec(m)[1] })), n;
      });
     var t = n(re()),
      r = n(ne());
     function n(e) {
      return e && e.__esModule ? e : { default: e };
     }
     function s(e) {
      var t = [{ mode: "normal", character: null }],
       r = [],
       n = 0,
       s = "",
       i = null,
       a = null,
       o = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       u = e;
      "(" === e[0] && ")" === e[e.length - 1] && ((u = e.substring(1, e.length - 1)), o++);
      for (var l = 0; l < u.length; l++) {
       var p = u[l];
       if ((("'" === p || '"' === p) && (!0 === t[n].isCalculationEnabled ? (t.push({ mode: "string", isCalculationEnabled: !1, character: p }), n++) : "string" === t[n].mode && t[n].character === p && "\\" !== u[l - 1] && (t.pop(), n--)), "{" === p ? (t.push({ mode: "interpolation", isCalculationEnabled: !0 }), n++) : "}" === p && (t.pop(), n--), "normal" === t[n].mode && ":" === p)) {
        var c = u.substring(l + 1);
        ((a = { type: "value", before: /^(\s*)/.exec(c)[1], after: /(\s*)$/.exec(c)[1], value: c.trim() }).sourceIndex = a.before.length + l + 1 + o), (i = { type: "colon", sourceIndex: l + o, after: a.before, value: ":" });
        break;
       }
       s += p;
      }
      return ((s = { type: "media-feature", before: /^(\s*)/.exec(s)[1], after: /(\s*)$/.exec(s)[1], value: s.trim() }).sourceIndex = s.before.length + o), r.push(s), null !== i && ((i.before = s.after), r.push(i)), null !== a && r.push(a), r;
     }
     function i(e) {
      var n = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       i = [],
       a = 0,
       o = !1,
       u = void 0;
      u = { before: "", after: "", value: "" };
      for (var l = 0; l < e.length; l++) {
       var p = e[l];
       o ? ((u.value += p), ("{" === p || "(" === p) && a++, (")" === p || "}" === p) && a--) : -1 !== p.search(/\s/) ? (u.before += p) : ("(" === p && ((u.type = "media-feature-expression"), a++), (u.value = p), (u.sourceIndex = n + l), (o = !0)), o && 0 === a && (")" === p || l === e.length - 1 || -1 !== e[l + 1].search(/\s/)) && (-1 !== ["not", "only", "and"].indexOf(u.value) && (u.type = "keyword"), "media-feature-expression" === u.type && (u.nodes = s(u.value, u.sourceIndex)), i.push(Array.isArray(u.nodes) ? new r.default(u) : new t.default(u)), (u = { before: "", after: "", value: "" }), (o = !1));
      }
      for (var c = 0; c < i.length; c++)
       if (((u = i[c]), c > 0 && (i[c - 1].after = u.before), void 0 === u.type)) {
        if (c > 0) {
         if ("media-feature-expression" === i[c - 1].type) {
          u.type = "keyword";
          continue;
         }
         if ("not" === i[c - 1].value || "only" === i[c - 1].value) {
          u.type = "media-type";
          continue;
         }
         if ("and" === i[c - 1].value) {
          u.type = "media-feature-expression";
          continue;
         }
         "media-type" === i[c - 1].type && (i[c + 1] ? (u.type = "media-feature-expression" === i[c + 1].type ? "keyword" : "media-feature-expression") : (u.type = "media-feature-expression"));
        }
        if (0 === c) {
         if (!i[c + 1]) {
          u.type = "media-type";
          continue;
         }
         if (i[c + 1] && ("media-feature-expression" === i[c + 1].type || "keyword" === i[c + 1].type)) {
          u.type = "media-type";
          continue;
         }
         if (i[c + 2]) {
          if ("media-feature-expression" === i[c + 2].type) {
           (u.type = "media-type"), (i[c + 1].type = "keyword");
           continue;
          }
          if ("keyword" === i[c + 2].type) {
           (u.type = "keyword"), (i[c + 1].type = "media-type");
           continue;
          }
         }
         if (i[c + 3] && "media-feature-expression" === i[c + 3].type) {
          (u.type = "keyword"), (i[c + 1].type = "media-type"), (i[c + 2].type = "keyword");
          continue;
         }
        }
       }
      return i;
     }
    }),
    ie = l((e) => {
     Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.default = function (e) {
       return new n.default({ nodes: (0, s.parseMediaList)(e), type: "media-query-list", value: e.trim() });
      });
     var t,
      r = ne(),
      n = (t = r) && t.__esModule ? t : { default: t },
      s = se();
    }),
    ae = l((e, t) => {
     t.exports = function (e, t) {
      return (t = "number" == typeof t ? t : 1 / 0)
       ? (function e(r, n) {
          return r.reduce(function (r, s) {
           return Array.isArray(s) && n < t ? r.concat(e(s, n + 1)) : r.concat(s);
          }, []);
         })(e, 1)
       : Array.isArray(e)
         ? e.map(function (e) {
            return e;
           })
         : e;
     };
    }),
    oe = l((e, t) => {
     t.exports = function (e, t) {
      for (var r = -1, n = []; -1 !== (r = e.indexOf(t, r + 1)); ) n.push(r);
      return n;
     };
    }),
    ue = l((e, t) => {
     t.exports = function (e, t, r) {
      return 0 === e.length
       ? e
       : t
         ? (r || e.sort(t),
           (function (e, t) {
            for (var r = 1, n = e.length, s = e[0], i = e[0], a = 1; a < n; ++a)
             if (((i = s), t((s = e[a]), i))) {
              if (a === r) {
               r++;
               continue;
              }
              e[r++] = s;
             }
            return (e.length = r), e;
           })(e, t))
         : (r || e.sort(),
           (function (e) {
            for (var t = 1, r = e.length, n = e[0], s = e[0], i = 1; i < r; ++i, s = n)
             if (((s = n), (n = e[i]) !== s)) {
              if (i === t) {
               t++;
               continue;
              }
              e[t++] = n;
             }
            return (e.length = t), e;
           })(e));
     };
    }),
    le = l((e, t) => {
     e.__esModule = !0;
     var r =
      "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
       ? function (e) {
          return typeof e;
         }
       : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
         };
     var n = function e(t, n) {
       if ("object" !== (typeof t > "u" ? "undefined" : r(t))) return t;
       var s = new t.constructor();
       for (var i in t)
        if (t.hasOwnProperty(i)) {
         var a = t[i],
          o = typeof a > "u" ? "undefined" : r(a);
         "parent" === i && "object" === o
          ? n && (s[i] = n)
          : (s[i] =
             a instanceof Array
              ? a.map(function (t) {
                 return e(t, s);
                })
              : e(a, s));
        }
       return s;
      },
      s = (function () {
       function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        for (var r in ((function (e, t) {
         if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        })(this, e),
        t))
         this[r] = t[r];
        var n = t.spaces,
         s = (n = void 0 === n ? {} : n).before,
         i = void 0 === s ? "" : s,
         a = n.after,
         o = void 0 === a ? "" : a;
        this.spaces = { before: i, after: o };
       }
       return (
        (e.prototype.remove = function () {
         return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
        }),
        (e.prototype.replaceWith = function () {
         if (this.parent) {
          for (var e in arguments) this.parent.insertBefore(this, arguments[e]);
          this.remove();
         }
         return this;
        }),
        (e.prototype.next = function () {
         return this.parent.at(this.parent.index(this) + 1);
        }),
        (e.prototype.prev = function () {
         return this.parent.at(this.parent.index(this) - 1);
        }),
        (e.prototype.clone = function () {
         var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = n(this);
         for (var r in e) t[r] = e[r];
         return t;
        }),
        (e.prototype.toString = function () {
         return [this.spaces.before, String(this.value), this.spaces.after].join("");
        }),
        e
       );
      })();
     (e.default = s), (t.exports = e.default);
    }),
    pe = l((e) => {
     e.__esModule = !0;
     (e.TAG = "tag"), (e.STRING = "string"), (e.SELECTOR = "selector"), (e.ROOT = "root"), (e.PSEUDO = "pseudo"), (e.NESTING = "nesting"), (e.ID = "id"), (e.COMMENT = "comment"), (e.COMBINATOR = "combinator"), (e.CLASS = "class"), (e.ATTRIBUTE = "attribute"), (e.UNIVERSAL = "universal");
    }),
    ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = le(),
      i = (r = s) && r.__esModule ? r : { default: r },
      a = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return (t.default = e), t;
      })(pe());
     var o = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return n.nodes || (n.nodes = []), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.append = function (e) {
        return (e.parent = this), this.nodes.push(e), this;
       }),
       (t.prototype.prepend = function (e) {
        return (e.parent = this), this.nodes.unshift(e), this;
       }),
       (t.prototype.at = function (e) {
        return this.nodes[e];
       }),
       (t.prototype.index = function (e) {
        return "number" == typeof e ? e : this.nodes.indexOf(e);
       }),
       (t.prototype.removeChild = function (e) {
        (e = this.index(e)), (this.at(e).parent = void 0), this.nodes.splice(e, 1);
        var t = void 0;
        for (var r in this.indexes) (t = this.indexes[r]) >= e && (this.indexes[r] = t - 1);
        return this;
       }),
       (t.prototype.removeAll = function () {
        var e = this.nodes,
         t = Array.isArray(e),
         r = 0;
        for (e = t ? e : e[Symbol.iterator](); ; ) {
         var n;
         if (t) {
          if (r >= e.length) break;
          n = e[r++];
         } else {
          if ((r = e.next()).done) break;
          n = r.value;
         }
         n.parent = void 0;
        }
        return (this.nodes = []), this;
       }),
       (t.prototype.empty = function () {
        return this.removeAll();
       }),
       (t.prototype.insertAfter = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r + 1, 0, t);
        var n = void 0;
        for (var s in this.indexes) r <= (n = this.indexes[s]) && (this.indexes[s] = n + this.nodes.length);
        return this;
       }),
       (t.prototype.insertBefore = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r, 0, t);
        var n = void 0;
        for (var s in this.indexes) r <= (n = this.indexes[s]) && (this.indexes[s] = n + this.nodes.length);
        return this;
       }),
       (t.prototype.each = function (e) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var t = this.lastEach;
        if (((this.indexes[t] = 0), this.length)) {
         for (var r = void 0, n = void 0; this.indexes[t] < this.length && ((r = this.indexes[t]), !1 !== (n = e(this.at(r), r))); ) this.indexes[t] += 1;
         if ((delete this.indexes[t], !1 === n)) return !1;
        }
       }),
       (t.prototype.walk = function (e) {
        return this.each(function (t, r) {
         var n = e(t, r);
         if ((!1 !== n && t.length && (n = t.walk(e)), !1 === n)) return !1;
        });
       }),
       (t.prototype.walkAttributes = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ATTRIBUTE) return e.call(t, r);
        });
       }),
       (t.prototype.walkClasses = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.CLASS) return e.call(t, r);
        });
       }),
       (t.prototype.walkCombinators = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMBINATOR) return e.call(t, r);
        });
       }),
       (t.prototype.walkComments = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMMENT) return e.call(t, r);
        });
       }),
       (t.prototype.walkIds = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ID) return e.call(t, r);
        });
       }),
       (t.prototype.walkNesting = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.NESTING) return e.call(t, r);
        });
       }),
       (t.prototype.walkPseudos = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.PSEUDO) return e.call(t, r);
        });
       }),
       (t.prototype.walkTags = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.TAG) return e.call(t, r);
        });
       }),
       (t.prototype.walkUniversals = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.UNIVERSAL) return e.call(t, r);
        });
       }),
       (t.prototype.split = function (e) {
        var t = this,
         r = [];
        return this.reduce(function (n, s, i) {
         var a = e.call(t, s);
         return r.push(s), a ? (n.push(r), (r = [])) : i === t.length - 1 && n.push(r), n;
        }, []);
       }),
       (t.prototype.map = function (e) {
        return this.nodes.map(e);
       }),
       (t.prototype.reduce = function (e, t) {
        return this.nodes.reduce(e, t);
       }),
       (t.prototype.every = function (e) {
        return this.nodes.every(e);
       }),
       (t.prototype.some = function (e) {
        return this.nodes.some(e);
       }),
       (t.prototype.filter = function (e) {
        return this.nodes.filter(e);
       }),
       (t.prototype.sort = function (e) {
        return this.nodes.sort(e);
       }),
       (t.prototype.toString = function () {
        return this.map(String).join("");
       }),
       n(t, [
        {
         key: "first",
         get: function () {
          return this.at(0);
         },
        },
        {
         key: "last",
         get: function () {
          return this.at(this.length - 1);
         },
        },
        {
         key: "length",
         get: function () {
          return this.nodes.length;
         },
        },
       ]),
       t
      );
     })(i.default);
     (e.default = o), (t.exports = e.default);
    }),
    he = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ce(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ROOT), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.reduce(function (e, t) {
         var r = String(t);
         return r ? e + r + "," : "";
        }, "").slice(0, -1);
        return this.trailingComma ? e + "," : e;
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    de = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ce(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.SELECTOR), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    fe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = le();
     var i = (function (e) {
      function t() {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        })(this, t),
        (function (e, t) {
         if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
        })(this, e.apply(this, arguments))
       );
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
       }),
       n(t, [
        {
         key: "ns",
         get: function () {
          var e = this.namespace;
          return e ? ("string" == typeof e ? e : "") + "|" : "";
         },
        },
       ]),
       t
      );
     })(((r = s) && r.__esModule ? r : { default: r }).default);
     (e.default = i), (t.exports = e.default);
    }),
    me = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.CLASS), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, "." + this.value, this.spaces.after].join("");
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ye = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = le(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.COMMENT), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ge = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ID), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, "#" + this.value, this.spaces.after].join("");
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    De = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.TAG), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    xe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = le(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.STRING), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    be = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ce(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.PSEUDO), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.spaces.before, String(this.value), e, this.spaces.after].join("");
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ve = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ATTRIBUTE), (n.raws = {}), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = [this.spaces.before, "[", this.ns, this.attribute];
        return this.operator && e.push(this.operator), this.value && e.push(this.value), this.raws.insensitive ? e.push(this.raws.insensitive) : this.insensitive && e.push(" i"), e.push("]"), e.concat(this.spaces.after).join("");
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ee = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = fe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.UNIVERSAL), (n.value = "*"), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = le(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.COMBINATOR), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Te = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = le(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = pe();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.NESTING), (n.value = "&"), n;
      }
      return (
       (function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    we = l((e, t) => {
     (e.__esModule = !0),
      (e.default = function (e) {
       return e.sort(function (e, t) {
        return e - t;
       });
      }),
      (t.exports = e.default);
    }),
    Se = l((e, t) => {
     (e.__esModule = !0),
      (e.default = function (e) {
       for (
        var t = [],
         A = e.css.valueOf(),
         F = void 0,
         k = void 0,
         P = void 0,
         I = void 0,
         N = void 0,
         B = void 0,
         _ = void 0,
         L = void 0,
         O = void 0,
         M = void 0,
         j = void 0,
         R = A.length,
         q = -1,
         U = 1,
         $ = 0,
         V = function (t, r) {
          if (!e.safe) throw e.error("Unclosed " + t, U, $ - q, $);
          k = (A += r).length - 1;
         };
        $ < R;

       ) {
        switch (((F = A.charCodeAt($)) === a && ((q = $), (U += 1)), F)) {
         case a:
         case o:
         case l:
         case p:
         case u:
          k = $;
          do {
           (k += 1), (F = A.charCodeAt(k)) === a && ((q = k), (U += 1));
          } while (F === o || F === a || F === l || F === p || F === u);
          t.push(["space", A.slice($, k), U, $ - q, $]), ($ = k - 1);
          break;
         case c:
         case h:
         case d:
         case f:
          k = $;
          do {
           (k += 1), (F = A.charCodeAt(k));
          } while (F === c || F === h || F === d || F === f);
          t.push(["combinator", A.slice($, k), U, $ - q, $]), ($ = k - 1);
          break;
         case v:
          t.push(["*", "*", U, $ - q, $]);
          break;
         case C:
          t.push(["&", "&", U, $ - q, $]);
          break;
         case m:
          t.push([",", ",", U, $ - q, $]);
          break;
         case D:
          t.push(["[", "[", U, $ - q, $]);
          break;
         case x:
          t.push(["]", "]", U, $ - q, $]);
          break;
         case E:
          t.push([":", ":", U, $ - q, $]);
          break;
         case b:
          t.push([";", ";", U, $ - q, $]);
          break;
         case y:
          t.push(["(", "(", U, $ - q, $]);
          break;
         case g:
          t.push([")", ")", U, $ - q, $]);
          break;
         case r:
         case n:
          (P = F === r ? "'" : '"'), (k = $);
          do {
           for (M = !1, -1 === (k = A.indexOf(P, k + 1)) && V("quote", P), j = k; A.charCodeAt(j - 1) === s; ) (j -= 1), (M = !M);
          } while (M);
          t.push(["string", A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         case T:
          (w.lastIndex = $ + 1), w.test(A), (k = 0 === w.lastIndex ? A.length - 1 : w.lastIndex - 2), t.push(["at-word", A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         case s:
          for (k = $, _ = !0; A.charCodeAt(k + 1) === s; ) (k += 1), (_ = !_);
          (F = A.charCodeAt(k + 1)), _ && F !== i && F !== o && F !== a && F !== l && F !== p && F !== u && (k += 1), t.push(["word", A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         default:
          F === i && A.charCodeAt($ + 1) === v ? (0 === (k = A.indexOf("*/", $ + 2) + 1) && V("comment", "*/"), (N = (I = (B = A.slice($, k + 1)).split("\n")).length - 1) > 0 ? ((L = U + N), (O = k - I[N].length)) : ((L = U), (O = q)), t.push(["comment", B, U, $ - q, L, k - O, $]), (q = O), (U = L), ($ = k)) : ((S.lastIndex = $ + 1), S.test(A), (k = 0 === S.lastIndex ? A.length - 1 : S.lastIndex - 2), t.push(["word", A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k));
        }
        $++;
       }
       return t;
      });
     var r = 39,
      n = 34,
      s = 92,
      i = 47,
      a = 10,
      o = 32,
      u = 12,
      l = 9,
      p = 13,
      c = 43,
      h = 62,
      d = 126,
      f = 124,
      m = 44,
      y = 40,
      g = 41,
      D = 91,
      x = 93,
      b = 59,
      v = 42,
      E = 58,
      C = 38,
      T = 64,
      w = /[ \n\t\r\{\(\)'"\\;/]/g,
      S = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
     t.exports = e.default;
    }),
    Ae = l((e, t) => {
     e.__esModule = !0;
     var r = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      n = v(ae()),
      s = v(oe()),
      i = v(ue()),
      a = v(he()),
      o = v(de()),
      u = v(me()),
      l = v(ye()),
      p = v(ge()),
      c = v(De()),
      h = v(xe()),
      d = v(be()),
      f = v(ve()),
      m = v(Ee()),
      y = v(Ce()),
      g = v(Te()),
      D = v(we()),
      x = v(Se()),
      b = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return (t.default = e), t;
      })(pe());
     function v(e) {
      return e && e.__esModule ? e : { default: e };
     }
     var E = (function () {
      function e(t) {
       (function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
       })(this, e),
        (this.input = t),
        (this.lossy = !1 === t.options.lossless),
        (this.position = 0),
        (this.root = new a.default());
       var r = new o.default();
       return this.root.append(r), (this.current = r), this.lossy ? (this.tokens = (0, x.default)({ safe: t.safe, css: t.css.trim() })) : (this.tokens = (0, x.default)(t)), this.loop();
      }
      return (
       (e.prototype.attribute = function () {
        var e = "",
         t = void 0,
         r = this.currToken;
        for (this.position++; this.position < this.tokens.length && "]" !== this.currToken[0]; ) (e += this.tokens[this.position][1]), this.position++;
        this.position === this.tokens.length && !~e.indexOf("]") && this.error("Expected a closing square bracket.");
        var n = e.split(/((?:[*~^$|]?=))([^]*)/),
         s = n[0].split(/(\|)/g),
         i = { operator: n[1], value: n[2], source: { start: { line: r[2], column: r[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: r[4] };
        if ((s.length > 1 ? ("" === s[0] && (s[0] = !0), (i.attribute = this.parseValue(s[2])), (i.namespace = this.parseNamespace(s[0]))) : (i.attribute = this.parseValue(n[0])), (t = new f.default(i)), n[2])) {
         var a = n[2].split(/(\s+i\s*?)$/),
          o = a[0].trim();
         (t.value = this.lossy ? o : a[0]), a[1] && ((t.insensitive = !0), this.lossy || (t.raws.insensitive = a[1])), (t.quoted = "'" === o[0] || '"' === o[0]), (t.raws.unquoted = t.quoted ? o.slice(1, -1) : o);
        }
        this.newNode(t), this.position++;
       }),
       (e.prototype.combinator = function () {
        if ("|" === this.currToken[1]) return this.namespace();
        for (var e = new y.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && ("space" === this.currToken[0] || "combinator" === this.currToken[0]); ) this.nextToken && "combinator" === this.nextToken[0] ? ((e.spaces.before = this.parseSpace(this.currToken[1])), (e.source.start.line = this.nextToken[2]), (e.source.start.column = this.nextToken[3]), (e.source.end.column = this.nextToken[3]), (e.source.end.line = this.nextToken[2]), (e.sourceIndex = this.nextToken[4])) : this.prevToken && "combinator" === this.prevToken[0] ? (e.spaces.after = this.parseSpace(this.currToken[1])) : "combinator" === this.currToken[0] ? (e.value = this.currToken[1]) : "space" === this.currToken[0] && (e.value = this.parseSpace(this.currToken[1], " ")), this.position++;
        return this.newNode(e);
       }),
       (e.prototype.comma = function () {
        if (this.position === this.tokens.length - 1) return (this.root.trailingComma = !0), void this.position++;
        var e = new o.default();
        this.current.parent.append(e), (this.current = e), this.position++;
       }),
       (e.prototype.comment = function () {
        var e = new l.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
        this.newNode(e), this.position++;
       }),
       (e.prototype.error = function (e) {
        throw new this.input.error(e);
       }),
       (e.prototype.missingBackslash = function () {
        return this.error("Expected a backslash preceding the semicolon.");
       }),
       (e.prototype.missingParenthesis = function () {
        return this.error("Expected opening parenthesis.");
       }),
       (e.prototype.missingSquareBracket = function () {
        return this.error("Expected opening square bracket.");
       }),
       (e.prototype.namespace = function () {
        var e = (this.prevToken && this.prevToken[1]) || !0;
        return "word" === this.nextToken[0] ? (this.position++, this.word(e)) : "*" === this.nextToken[0] ? (this.position++, this.universal(e)) : void 0;
       }),
       (e.prototype.nesting = function () {
        this.newNode(new g.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
       }),
       (e.prototype.parentheses = function () {
        var e = this.current.last;
        if (e && e.type === b.PSEUDO) {
         var t = new o.default(),
          r = this.current;
         e.append(t), (this.current = t);
         var n = 1;
         for (this.position++; this.position < this.tokens.length && n; ) "(" === this.currToken[0] && n++, ")" === this.currToken[0] && n--, n ? this.parse() : ((t.parent.source.end.line = this.currToken[2]), (t.parent.source.end.column = this.currToken[3]), this.position++);
         n && this.error("Expected closing parenthesis."), (this.current = r);
        } else {
         var s = 1;
         for (this.position++, e.value += "("; this.position < this.tokens.length && s; ) "(" === this.currToken[0] && s++, ")" === this.currToken[0] && s--, (e.value += this.parseParenthesisToken(this.currToken)), this.position++;
         s && this.error("Expected closing parenthesis.");
        }
       }),
       (e.prototype.pseudo = function () {
        for (var e = this, t = "", r = this.currToken; this.currToken && ":" === this.currToken[0]; ) (t += this.currToken[1]), this.position++;
        if (!this.currToken) return this.error("Expected pseudo-class or pseudo-element");
        if ("word" === this.currToken[0]) {
         var n = void 0;
         this.splitWord(!1, function (s, i) {
          (t += s), (n = new d.default({ value: t, source: { start: { line: r[2], column: r[3] }, end: { line: e.currToken[4], column: e.currToken[5] } }, sourceIndex: r[4] })), e.newNode(n), i > 1 && e.nextToken && "(" === e.nextToken[0] && e.error("Misplaced parenthesis.");
         });
        } else this.error('Unexpected "' + this.currToken[0] + '" found.');
       }),
       (e.prototype.space = function () {
        var e = this.currToken;
        0 === this.position || "," === this.prevToken[0] || "(" === this.prevToken[0] ? ((this.spaces = this.parseSpace(e[1])), this.position++) : this.position === this.tokens.length - 1 || "," === this.nextToken[0] || ")" === this.nextToken[0] ? ((this.current.last.spaces.after = this.parseSpace(e[1])), this.position++) : this.combinator();
       }),
       (e.prototype.string = function () {
        var e = this.currToken;
        this.newNode(new h.default({ value: this.currToken[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
       }),
       (e.prototype.universal = function (e) {
        var t = this.nextToken;
        if (t && "|" === t[1]) return this.position++, this.namespace();
        this.newNode(new m.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), e), this.position++;
       }),
       (e.prototype.splitWord = function (e, t) {
        for (var r = this, a = this.nextToken, o = this.currToken[1]; a && "word" === a[0]; ) {
         this.position++;
         var l = this.currToken[1];
         if (((o += l), l.lastIndexOf("\\") === l.length - 1)) {
          var h = this.nextToken;
          h && "space" === h[0] && ((o += this.parseSpace(h[1], " ")), this.position++);
         }
         a = this.nextToken;
        }
        var d = (0, s.default)(o, "."),
         f = (0, s.default)(o, "#"),
         m = (0, s.default)(o, "#{");
        m.length &&
         (f = f.filter(function (e) {
          return !~m.indexOf(e);
         }));
        var y = (0, D.default)((0, i.default)((0, n.default)([[0], d, f])));
        y.forEach(function (n, s) {
         var i = y[s + 1] || o.length,
          a = o.slice(n, i);
         if (0 === s && t) return t.call(r, a, y.length);
         var l = void 0;
         (l = ~d.indexOf(n) ? new u.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] }) : ~f.indexOf(n) ? new p.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] }) : new c.default({ value: a, source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] })), r.newNode(l, e);
        }),
         this.position++;
       }),
       (e.prototype.word = function (e) {
        var t = this.nextToken;
        return t && "|" === t[1] ? (this.position++, this.namespace()) : this.splitWord(e);
       }),
       (e.prototype.loop = function () {
        for (; this.position < this.tokens.length; ) this.parse(!0);
        return this.root;
       }),
       (e.prototype.parse = function (e) {
        switch (this.currToken[0]) {
         case "space":
          this.space();
          break;
         case "comment":
          this.comment();
          break;
         case "(":
          this.parentheses();
          break;
         case ")":
          e && this.missingParenthesis();
          break;
         case "[":
          this.attribute();
          break;
         case "]":
          this.missingSquareBracket();
          break;
         case "at-word":
         case "word":
          this.word();
          break;
         case ":":
          this.pseudo();
          break;
         case ";":
          this.missingBackslash();
          break;
         case ",":
          this.comma();
          break;
         case "*":
          this.universal();
          break;
         case "&":
          this.nesting();
          break;
         case "combinator":
          this.combinator();
          break;
         case "string":
          this.string();
        }
       }),
       (e.prototype.parseNamespace = function (e) {
        if (this.lossy && "string" == typeof e) {
         var t = e.trim();
         return !t.length || t;
        }
        return e;
       }),
       (e.prototype.parseSpace = function (e, t) {
        return this.lossy ? t || "" : e;
       }),
       (e.prototype.parseValue = function (e) {
        return this.lossy && e && "string" == typeof e ? e.trim() : e;
       }),
       (e.prototype.parseParenthesisToken = function (e) {
        return this.lossy ? ("space" === e[0] ? this.parseSpace(e[1], " ") : this.parseValue(e[1])) : e[1];
       }),
       (e.prototype.newNode = function (e, t) {
        return t && (e.namespace = this.parseNamespace(t)), this.spaces && ((e.spaces.before = this.spaces), (this.spaces = "")), this.current.append(e);
       }),
       r(e, [
        {
         key: "currToken",
         get: function () {
          return this.tokens[this.position];
         },
        },
        {
         key: "nextToken",
         get: function () {
          return this.tokens[this.position + 1];
         },
        },
        {
         key: "prevToken",
         get: function () {
          return this.tokens[this.position - 1];
         },
        },
       ]),
       e
      );
     })();
     (e.default = E), (t.exports = e.default);
    }),
    Fe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = Ae(),
      i = (r = s) && r.__esModule ? r : { default: r };
     var a = (function () {
      function e(t) {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        })(this, e),
        (this.func = t || function () {}),
        this
       );
      }
      return (
       (e.prototype.process = function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
         r = new i.default({
          css: e,
          error: function (e) {
           throw new Error(e);
          },
          options: t,
         });
        return (this.res = r), this.func(r), this;
       }),
       n(e, [
        {
         key: "result",
         get: function () {
          return String(this.res);
         },
        },
       ]),
       e
      );
     })();
     (e.default = a), (t.exports = e.default);
    }),
    ke = l((e, t) => {
     var r = function (e, t) {
      let n = new e.constructor();
      for (let s in e) {
       if (!e.hasOwnProperty(s)) continue;
       let i = e[s],
        a = typeof i;
       "parent" === s && "object" === a ? t && (n[s] = t) : "source" === s ? (n[s] = i) : i instanceof Array ? (n[s] = i.map((e) => r(e, n))) : "before" !== s && "after" !== s && "between" !== s && "semicolon" !== s && ("object" === a && null !== i && (i = r(i)), (n[s] = i));
      }
      return n;
     };
     t.exports = class {
      constructor(e) {
       (e = e || {}), (this.raws = { before: "", after: "" });
       for (let t in e) this[t] = e[t];
      }
      remove() {
       return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
      }
      toString() {
       return [this.raws.before, String(this.value), this.raws.after].join("");
      }
      clone(e) {
       e = e || {};
       let t = r(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneBefore(e) {
       e = e || {};
       let t = this.clone(e);
       return this.parent.insertBefore(this, t), t;
      }
      cloneAfter(e) {
       e = e || {};
       let t = this.clone(e);
       return this.parent.insertAfter(this, t), t;
      }
      replaceWith() {
       let e = Array.prototype.slice.call(arguments);
       if (this.parent) {
        for (let t of e) this.parent.insertBefore(this, t);
        this.remove();
       }
       return this;
      }
      moveTo(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.append(this), this;
      }
      moveBefore(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertBefore(e, this), this;
      }
      moveAfter(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertAfter(e, this), this;
      }
      next() {
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      prev() {
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      toJSON() {
       let e = {};
       for (let t in this) {
        if (!this.hasOwnProperty(t) || "parent" === t) continue;
        let r = this[t];
        r instanceof Array ? (e[t] = r.map((e) => ("object" == typeof e && e.toJSON ? e.toJSON() : e))) : "object" == typeof r && r.toJSON ? (e[t] = r.toJSON()) : (e[t] = r);
       }
       return e;
      }
      root() {
       let e = this;
       for (; e.parent; ) e = e.parent;
       return e;
      }
      cleanRaws(e) {
       delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
      }
      positionInside(e) {
       let t = this.toString(),
        r = this.source.start.column,
        n = this.source.start.line;
       for (let s = 0; s < e; s++) "\n" === t[s] ? ((r = 1), (n += 1)) : (r += 1);
       return { line: n, column: r };
      }
      positionBy(e) {
       let t = this.source.start;
       if (Object(e).index) t = this.positionInside(e.index);
       else if (Object(e).word) {
        let r = this.toString().indexOf(e.word);
        -1 !== r && (t = this.positionInside(r));
       }
       return t;
      }
     };
    }),
    Pe = l((e, t) => {
     var r = ke(),
      n = class extends r {
       constructor(e) {
        super(e), this.nodes || (this.nodes = []);
       }
       push(e) {
        return (e.parent = this), this.nodes.push(e), this;
       }
       each(e) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1);
        let t,
         r,
         n = this.lastEach;
        if (((this.indexes[n] = 0), this.nodes)) {
         for (; this.indexes[n] < this.nodes.length && ((t = this.indexes[n]), (r = e(this.nodes[t], t)), !1 !== r); ) this.indexes[n] += 1;
         return delete this.indexes[n], r;
        }
       }
       walk(e) {
        return this.each((t, r) => {
         let n = e(t, r);
         return !1 !== n && t.walk && (n = t.walk(e)), n;
        });
       }
       walkType(e, t) {
        if (!e || !t) throw new Error("Parameters {type} and {callback} are required.");
        let r = "function" == typeof e;
        return this.walk((n, s) => {
         if ((r && n instanceof e) || (!r && n.type === e)) return t.call(this, n, s);
        });
       }
       append(e) {
        return (e.parent = this), this.nodes.push(e), this;
       }
       prepend(e) {
        return (e.parent = this), this.nodes.unshift(e), this;
       }
       cleanRaws(e) {
        if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
       }
       insertAfter(e, t) {
        let r,
         n = this.index(e);
        this.nodes.splice(n + 1, 0, t);
        for (let s in this.indexes) (r = this.indexes[s]), n <= r && (this.indexes[s] = r + this.nodes.length);
        return this;
       }
       insertBefore(e, t) {
        let r,
         n = this.index(e);
        this.nodes.splice(n, 0, t);
        for (let s in this.indexes) (r = this.indexes[s]), n <= r && (this.indexes[s] = r + this.nodes.length);
        return this;
       }
       removeChild(e) {
        let t;
        (e = this.index(e)), (this.nodes[e].parent = void 0), this.nodes.splice(e, 1);
        for (let r in this.indexes) (t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1);
        return this;
       }
       removeAll() {
        for (let e of this.nodes) e.parent = void 0;
        return (this.nodes = []), this;
       }
       every(e) {
        return this.nodes.every(e);
       }
       some(e) {
        return this.nodes.some(e);
       }
       index(e) {
        return "number" == typeof e ? e : this.nodes.indexOf(e);
       }
       get first() {
        if (this.nodes) return this.nodes[0];
       }
       get last() {
        if (this.nodes) return this.nodes[this.nodes.length - 1];
       }
       toString() {
        let e = this.nodes.map(String).join("");
        return this.value && (e = this.value + e), this.raws.before && (e = this.raws.before + e), this.raws.after && (e += this.raws.after), e;
       }
      };
     (n.registerWalker = (e) => {
      let t = "walk" + e.name;
      t.lastIndexOf("s") !== t.length - 1 && (t += "s"),
       !n.prototype[t] &&
        (n.prototype[t] = function (t) {
         return this.walkType(e, t);
        });
     }),
      (t.exports = n);
    }),
    Ie = l((e, t) => {
     var r = Pe();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = "root");
      }
     };
    }),
    Ne = l((e, t) => {
     var r = Pe();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = "value"), (this.unbalanced = 0);
      }
     };
    }),
    Be = l((e, t) => {
     var r = Pe(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = "atword");
       }
       toString() {
        this.quoted && this.raws.quote;
        return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    _e = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "colon");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Le = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "comma");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Oe = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "comment"), (this.inline = Object(e).inline || !1);
       }
       toString() {
        return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Me = l((e, t) => {
     var r = Pe(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = "func"), (this.unbalanced = -1);
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    je = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "number"), (this.unit = Object(e).unit || "");
       }
       toString() {
        return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Re = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "operator");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    qe = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "paren"), (this.parenType = "");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Ue = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "string");
       }
       toString() {
        let e = this.quoted ? this.raws.quote : "";
        return [this.raws.before, e, this.value + "", e, this.raws.after].join("");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    $e = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "word");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Ve = l((e, t) => {
     var r = Pe(),
      n = ke(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = "unicode-range");
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    ze = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       super(e), (this.name = this.constructor.name), (this.message = e || "An error ocurred while tokzenizing."), "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack);
      }
     };
     t.exports = r;
    }),
    We = l((e, t) => {
     var r = /[ \n\t\r\{\(\)'"\\;,/]/g,
      n = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g,
      s = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g,
      i = /^[a-z0-9]/i,
      a = /^[a-f0-9?\-]/i,
      o = ze();
     t.exports = function (e, t) {
      t = t || {};
      let u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       g,
       D,
       x = [],
       b = e.valueOf(),
       v = b.length,
       E = -1,
       C = 1,
       T = 0,
       w = 0,
       S = null;
      function A(e) {
       throw new o(`Unclosed ${e} at line: ${C}, column: ${T - E}, token: ${T}`);
      }
      for (; T < v; ) {
       switch (((u = b.charCodeAt(T)), 10 === u && ((E = T), (C += 1)), u)) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
         l = T;
         do {
          (l += 1), (u = b.charCodeAt(l)), 10 === u && ((E = l), (C += 1));
         } while (32 === u || 10 === u || 9 === u || 13 === u || 12 === u);
         x.push(["space", b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 58:
         (l = T + 1), x.push(["colon", b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 44:
         (l = T + 1), x.push(["comma", b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 123:
         x.push(["{", "{", C, T - E, C, l - E, T]);
         break;
        case 125:
         x.push(["}", "}", C, T - E, C, l - E, T]);
         break;
        case 40:
         w++, (S = !S && 1 === w && x.length > 0 && "word" === x[x.length - 1][0] && "url" === x[x.length - 1][1]), x.push(["(", "(", C, T - E, C, l - E, T]);
         break;
        case 41:
         w--, (S = S && w > 0), x.push([")", ")", C, T - E, C, l - E, T]);
         break;
        case 39:
        case 34:
         (p = 39 === u ? "'" : '"'), (l = T);
         do {
          for (y = !1, l = b.indexOf(p, l + 1), -1 === l && A("quote"), g = l; 92 === b.charCodeAt(g - 1); ) (g -= 1), (y = !y);
         } while (y);
         x.push(["string", b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 64:
         (r.lastIndex = T + 1), r.test(b), (l = 0 === r.lastIndex ? b.length - 1 : r.lastIndex - 2), x.push(["atword", b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 92:
         (l = T), (u = b.charCodeAt(l + 1)), x.push(["word", b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 43:
        case 45:
        case 42:
         (l = T + 1), (D = b.slice(T + 1, l + 1));
         b.slice(T - 1, T);
         if (45 === u && 45 === D.charCodeAt(0)) {
          l++, x.push(["word", b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
          break;
         }
         x.push(["operator", b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        default:
         if (47 === u && (42 === b.charCodeAt(T + 1) || (t.loose && !S && 47 === b.charCodeAt(T + 1)))) {
          if (42 === b.charCodeAt(T + 1)) (l = b.indexOf("*/", T + 2) + 1), 0 === l && A("comment");
          else {
           let e = b.indexOf("\n", T + 2);
           l = -1 !== e ? e - 1 : v;
          }
          (d = b.slice(T, l + 1)), (c = d.split("\n")), (h = c.length - 1), h > 0 ? ((f = C + h), (m = l - c[h].length)) : ((f = C), (m = E)), x.push(["comment", d, C, T - E, f, l - m, T]), (E = m), (C = f), (T = l);
         } else if (35 !== u || i.test(b.slice(T + 1, T + 2)))
          if ((117 !== u && 85 !== u) || 43 !== b.charCodeAt(T + 1))
           if (47 === u) (l = T + 1), x.push(["operator", b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
           else {
            let e = n;
            if ((u >= 48 && u <= 57 && (e = s), (e.lastIndex = T + 1), e.test(b), (l = 0 === e.lastIndex ? b.length - 1 : e.lastIndex - 2), e === s || 46 === u)) {
             let e = b.charCodeAt(l),
              t = b.charCodeAt(l + 1),
              r = b.charCodeAt(l + 2);
             (101 === e || 69 === e) && (45 === t || 43 === t) && r >= 48 && r <= 57 && ((s.lastIndex = l + 2), s.test(b), (l = 0 === s.lastIndex ? b.length - 1 : s.lastIndex - 2));
            }
            x.push(["word", b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
           }
          else {
           l = T + 2;
           do {
            (l += 1), (u = b.charCodeAt(l));
           } while (l < v && a.test(b.slice(l, l + 1)));
           x.push(["unicoderange", b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
          }
         else (l = T + 1), x.push(["#", b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
       }
       T++;
      }
      return x;
     };
    }),
    He = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       super(e), (this.name = this.constructor.name), (this.message = e || "An error ocurred while parsing."), "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack);
      }
     };
     t.exports = r;
    }),
    Je = l((e, t) => {
     var r = Ie(),
      n = Ne(),
      s = Be(),
      i = _e(),
      a = Le(),
      o = Oe(),
      u = Me(),
      l = je(),
      p = Re(),
      c = qe(),
      h = Ue(),
      d = $e(),
      f = Ve(),
      m = We(),
      y = ae(),
      g = oe(),
      D = ue(),
      x = He();
     t.exports = class {
      constructor(e, t) {
       (this.cache = []), (this.input = e), (this.options = Object.assign({}, { loose: !1 }, t)), (this.position = 0), (this.unbalanced = 0), (this.root = new r());
       let s = new n();
       this.root.append(s), (this.current = s), (this.tokens = m(e, this.options));
      }
      parse() {
       return this.loop();
      }
      colon() {
       let e = this.currToken;
       this.newNode(new i({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      comma() {
       let e = this.currToken;
       this.newNode(new a({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      comment() {
       let e,
        t = !1,
        r = this.currToken[1].replace(/\/\*|\*\//g, "");
       this.options.loose && r.startsWith("//") && ((r = r.substring(2)), (t = !0)), (e = new o({ value: r, inline: t, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })), this.newNode(e), this.position++;
      }
      error(e, t) {
       throw new x(e + ` at line: ${t[2]}, column ${t[3]}`);
      }
      loop() {
       for (; this.position < this.tokens.length; ) this.parseTokens();
       return !this.current.last && this.spaces ? (this.current.raws.before += this.spaces) : this.spaces && (this.current.last.raws.after += this.spaces), (this.spaces = ""), this.root;
      }
      operator() {
       let e,
        t = this.currToken[1];
       if ("+" === t || "-" === t)
        if ((this.options.loose || (this.position > 0 && ("func" === this.current.type && "calc" === this.current.value ? (("space" !== this.prevToken[0] && "(" !== this.prevToken[0]) || ("space" !== this.nextToken[0] && "word" !== this.nextToken[0]) || ("word" === this.nextToken[0] && "operator" !== this.current.last.type && "(" !== this.current.last.value)) && this.error("Syntax Error", this.currToken) : ("space" === this.nextToken[0] || "operator" === this.nextToken[0] || "operator" === this.prevToken[0]) && this.error("Syntax Error", this.currToken))), this.options.loose)) {
         if ((!this.current.nodes.length || (this.current.last && "operator" === this.current.last.type)) && "word" === this.nextToken[0]) return this.word();
        } else if ("word" === this.nextToken[0]) return this.word();
       return (e = new p({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++, this.newNode(e);
      }
      parseTokens() {
       switch (this.currToken[0]) {
        case "space":
         this.space();
         break;
        case "colon":
         this.colon();
         break;
        case "comma":
         this.comma();
         break;
        case "comment":
         this.comment();
         break;
        case "(":
         this.parenOpen();
         break;
        case ")":
         this.parenClose();
         break;
        case "atword":
        case "word":
        default:
         this.word();
         break;
        case "operator":
         this.operator();
         break;
        case "string":
         this.string();
         break;
        case "unicoderange":
         this.unicodeRange();
       }
      }
      parenOpen() {
       let e,
        t = 1,
        r = this.position + 1,
        n = this.currToken;
       for (; r < this.tokens.length && t; ) {
        let e = this.tokens[r];
        "(" === e[0] && t++, ")" === e[0] && t--, r++;
       }
       if ((t && this.error("Expected closing parenthesis", n), (e = this.current.last), e && "func" === e.type && e.unbalanced < 0 && ((e.unbalanced = 0), (this.current = e)), this.current.unbalanced++, this.newNode(new c({ value: n[1], source: { start: { line: n[2], column: n[3] }, end: { line: n[4], column: n[5] } }, sourceIndex: n[6] })), this.position++, "func" === this.current.type && this.current.unbalanced && "url" === this.current.value && "string" !== this.currToken[0] && ")" !== this.currToken[0] && !this.options.loose)) {
        let e = this.nextToken,
         t = this.currToken[1],
         r = { line: this.currToken[2], column: this.currToken[3] };
        for (; e && ")" !== e[0] && this.current.unbalanced; ) this.position++, (t += this.currToken[1]), (e = this.nextToken);
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d({ value: t, source: { start: r, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
       }
      }
      parenClose() {
       let e = this.currToken;
       this.newNode(new c({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++, (!(this.position >= this.tokens.length - 1) || this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", e), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
      }
      space() {
       let e = this.currToken;
       this.position === this.tokens.length - 1 || "," === this.nextToken[0] || ")" === this.nextToken[0] ? ((this.current.last.raws.after += e[1]), this.position++) : ((this.spaces = e[1]), this.position++);
      }
      unicodeRange() {
       let e = this.currToken;
       this.newNode(new f({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      splitWord() {
       let e,
        t,
        r = this.nextToken,
        n = this.currToken[1],
        i = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
       if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(n))
        for (; r && "word" === r[0]; ) {
         this.position++;
         let e = this.currToken[1];
         (n += e), (r = this.nextToken);
        }
       var a;
       (e = g(n, "@")),
        (a = D(y([[0], e]))),
        (t = a.sort((e, t) => e - t)),
        t.forEach((a, o) => {
         let p,
          c = t[o + 1] || n.length,
          h = n.slice(a, c);
         if (~e.indexOf(a)) p = new s({ value: h.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] });
         else if (i.test(this.currToken[1])) {
          let e = h.replace(i, "");
          p = new l({ value: h.replace(e, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o], unit: e });
         } else (p = new (r && "(" === r[0] ? u : d)({ value: h, source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] })), "word" === p.type ? ((p.isHex = /^#(.+)/.test(h)), (p.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(h))) : this.cache.push(this.current);
         this.newNode(p);
        }),
        this.position++;
      }
      string() {
       let e,
        t = this.currToken,
        r = this.currToken[1],
        n = /^(\"|\')/,
        s = n.test(r),
        i = "";
       s && ((i = r.match(n)[0]), (r = r.slice(1, r.length - 1))), (e = new h({ value: r, source: { start: { line: t[2], column: t[3] }, end: { line: t[4], column: t[5] } }, sourceIndex: t[6], quoted: s })), (e.raws.quote = i), this.newNode(e), this.position++;
      }
      word() {
       return this.splitWord();
      }
      newNode(e) {
       return this.spaces && ((e.raws.before += this.spaces), (this.spaces = "")), this.current.append(e);
      }
      get currToken() {
       return this.tokens[this.position];
      }
      get nextToken() {
       return this.tokens[this.position + 1];
      }
      get prevToken() {
       return this.tokens[this.position - 1];
      }
     };
    }),
    Ke = {};
   p(Ke, { languages: () => xn, options: () => bn, parsers: () => vn, printers: () => rs });
   var Ge = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    Xe = "string",
    Ye = "array",
    Qe = "cursor",
    Ze = "indent",
    et = "align",
    tt = "trim",
    rt = "group",
    nt = "fill",
    st = "if-break",
    it = "indent-if-break",
    at = "line-suffix",
    ot = "line-suffix-boundary",
    ut = "line",
    lt = "label",
    pt = "break-parent",
    ct = new Set([Qe, Ze, et, tt, rt, nt, st, it, at, ot, ut, lt, pt]);
   var ht = function (e) {
    if ("string" == typeof e) return Xe;
    if (Array.isArray(e)) return Ye;
    if (!e) return;
    let { type: t } = e;
    return ct.has(t) ? t : void 0;
   };
   function dt(e) {
    let t = null === e ? "null" : typeof e;
    if ("string" !== t && "object" !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (ht(e)) throw new Error("doc is valid.");
    let r = Object.prototype.toString.call(e);
    if ("[object Object]" !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e))([...ct].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var ft = class extends Error {
     name = "InvalidDocError";
     constructor(e) {
      super(dt(e)), (this.doc = e);
     }
    },
    mt = () => {},
    yt = mt,
    gt = mt;
   function Dt(e) {
    return yt(e), { type: Ze, contents: e };
   }
   function xt(e, t) {
    return yt(t), { type: et, contents: t, n: e };
   }
   function bt(e, t = {}) {
    return yt(e), gt(t.expandedStates, !0), { type: rt, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function vt(e) {
    return xt(-1, e);
   }
   function Et(e) {
    return gt(e), { type: nt, parts: e };
   }
   function Ct(e, t = "", r = {}) {
    return yt(e), "" !== t && yt(t), { type: st, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   var Tt = { type: pt },
    wt = { type: ut },
    St = { type: ut, soft: !0 },
    At = [{ type: ut, hard: !0 }, Tt];
   function Ft(e, t) {
    yt(e), gt(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   var kt = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || "string" == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    },
    Pt = (e) => {
     if (Array.isArray(e)) return e;
     if (e.type !== nt) throw new Error(`Expect doc to be 'array' or '${nt}'.`);
     return e.parts;
    };
   function It(e, t) {
    if ("string" == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (ht(e)) {
       case Ye:
        return t(e.map(n));
       case nt:
        return t({ ...e, parts: e.parts.map(n) });
       case st:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case rt: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case et:
       case Ze:
       case it:
       case lt:
       case at:
        return t({ ...e, contents: n(e.contents) });
       case Xe:
       case Qe:
       case tt:
       case ot:
       case ut:
       case pt:
        return t(e);
       default:
        throw new ft(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function Nt(e) {
    return e.type !== ut || e.hard ? (e.type === st ? e.flatContents : e) : e.soft ? "" : " ";
   }
   var Bt = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    _t = "'";
   var Lt = function (e, t) {
    let r = !0 === t || t === _t ? _t : '"',
     n = r === _t ? '"' : _t,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var Ot = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = Ge(!1, e, /\\(.)|(["'])/gs, (e, s, i) => (s === n ? s : i === t ? "\\" + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s) ? s : "\\" + s)));
    return t + s + t;
   };
   var Mt = function (e, t) {
     let r = e.slice(1, -1),
      n = "json" === t.parser || "jsonc" === t.parser || ("json5" === t.parser && "preserve" === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : Lt(r, t.singleQuote);
     return Ot(r, n, !("css" === t.parser || "less" === t.parser || "scss" === t.parser || t.__embeddedInHtml));
    },
    jt = class extends Error {
     name = "UnexpectedNodeError";
     constructor(e, t, r = "type") {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    };
   var Rt = function (e) {
     return "front-matter" === (null == e ? void 0 : e.type);
    },
    qt = new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma", "spaces"]);
   function Ut(e, t, r) {
    if ((Rt(e) && "yaml" === e.lang && delete t.value, "css-comment" === e.type && "css-root" === r.type && r.nodes.length > 0 && (((r.nodes[0] === e || (Rt(r.nodes[0]) && r.nodes[1] === e)) && (delete t.text, /^\*\s*@(?:format|prettier)\s*$/.test(e.text))) || ("css-root" === r.type && kt(!1, r.nodes, -1) === e)))) return null;
    if (
     ("value-root" === e.type && delete t.text,
     ("media-query" === e.type || "media-query-list" === e.type || "media-feature-expression" === e.type) && delete t.value,
     "css-rule" === e.type && delete t.params,
     "selector-combinator" === e.type && (t.value = Ge(!1, t.value, /\s+/g, " ")),
     "media-feature" === e.type && (t.value = Ge(!1, t.value, " ", "")),
     (("value-word" === e.type && ((e.isColor && e.isHex) || ["initial", "inherit", "unset", "revert"].includes(t.value.toLowerCase()))) || "media-feature" === e.type || "selector-root-invalid" === e.type || "selector-pseudo" === e.type) && (t.value = t.value.toLowerCase()),
     "css-decl" === e.type && (t.prop = t.prop.toLowerCase()),
     ("css-atrule" === e.type || "css-import" === e.type) && (t.name = t.name.toLowerCase()),
     "value-number" === e.type && (t.unit = t.unit.toLowerCase()),
     "value-unknown" === e.type && (t.value = Ge(!1, t.value, /;$/g, "")),
     ("media-feature" === e.type || "media-keyword" === e.type || "media-type" === e.type || "media-unknown" === e.type || "media-url" === e.type || "media-value" === e.type || "selector-attribute" === e.type || "selector-string" === e.type || "selector-class" === e.type || "selector-combinator" === e.type || "value-string" === e.type) &&
      t.value &&
      (t.value = (function (e) {
       return Ge(!1, Ge(!1, e, "'", '"'), /\\([^\da-f])/gi, "$1");
      })(t.value)),
     "selector-attribute" === e.type && ((t.attribute = t.attribute.trim()), t.namespace && "string" == typeof t.namespace && ((t.namespace = t.namespace.trim()), 0 === t.namespace.length && (t.namespace = !0)), t.value && ((t.value = Ge(!1, t.value.trim(), /^["']|["']$/g, "")), delete t.quoted)),
     ("media-value" === e.type || "media-type" === e.type || "value-number" === e.type || "selector-root-invalid" === e.type || "selector-class" === e.type || "selector-combinator" === e.type || "selector-tag" === e.type) &&
      t.value &&
      (t.value = Ge(!1, t.value, /([\d+.e-]+)([a-z]*)/gi, (e, t, r) => {
       let n = Number(t);
       return Number.isNaN(n) ? e : n + r.toLowerCase();
      })),
     "selector-tag" === e.type)
    ) {
     let r = e.value.toLowerCase();
     ["from", "to"].includes(r) && (t.value = r);
    }
    if (("css-atrule" === e.type && "supports" === e.name.toLowerCase() && delete t.value, "selector-unknown" === e.type && delete t.value, "value-comma_group" === e.type)) {
     let r = e.groups.findIndex((e) => "value-number" === e.type && "..." === e.unit);
     -1 !== r && ((t.groups[r].unit = ""), t.groups.splice(r + 1, 0, { type: "value-word", value: "...", isColor: !1, isHex: !1 }));
    }
    return "value-comma_group" === e.type && e.groups.some((e) => ("value-atword" === e.type && e.value.endsWith("[")) || ("value-word" === e.type && e.value.startsWith("]"))) ? { type: "value-atword", value: e.groups.map((e) => e.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } } : void 0;
   }
   Ut.ignoredProperties = qt;
   var $t = Ut;
   var Vt = async function (e, t) {
    if ("yaml" === e.lang) {
     let r = e.value.trim(),
      n = r ? await t(r, { parser: "yaml" }) : "";
     return (function (e) {
      return xt({ type: "root" }, e);
     })([e.startDelimiter, At, n, n ? At : "", e.endDelimiter]);
    }
   };
   function zt(e) {
    let { node: t } = e;
    if ("front-matter" === t.type)
     return async (e) => {
      let r = await Vt(t, e);
      return r ? [r, At] : void 0;
     };
   }
   zt.getVisitorKeys = (e) => ("css-root" === e.type ? ["frontMatter"] : []);
   var Wt = zt,
    Ht = null;
   function Jt(e) {
    if (null !== Ht && (Ht.property, 1)) {
     let e = Ht;
     return (Ht = Jt.prototype = null), e;
    }
    return (Ht = Jt.prototype = e ?? Object.create(null)), new Jt();
   }
   for (let ss = 0; ss <= 10; ss++) Jt();
   var Kt = (function (e, t = "type") {
    return (
     (function (e) {
      Jt(e);
     })(e),
     function (r) {
      let n = r[t],
       s = e[n];
      if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
      return s;
     }
    );
   })({ "front-matter": [], "css-root": ["frontMatter", "nodes"], "css-comment": [], "css-rule": ["selector", "nodes"], "css-decl": ["value", "selector", "nodes"], "css-atrule": ["selector", "params", "value", "nodes"], "media-query-list": ["nodes"], "media-query": ["nodes"], "media-type": [], "media-feature-expression": ["nodes"], "media-feature": [], "media-colon": [], "media-value": [], "media-keyword": [], "media-url": [], "media-unknown": [], "selector-root": ["nodes"], "selector-selector": ["nodes"], "selector-comment": [], "selector-string": [], "selector-tag": [], "selector-id": [], "selector-class": [], "selector-attribute": [], "selector-combinator": ["nodes"], "selector-universal": [], "selector-pseudo": ["nodes"], "selector-nesting": [], "selector-unknown": [], "value-value": ["group"], "value-root": ["group"], "value-comment": [], "value-comma_group": ["groups"], "value-paren_group": ["open", "groups", "close"], "value-func": ["group"], "value-paren": [], "value-number": [], "value-operator": [], "value-word": [], "value-colon": [], "value-comma": [], "value-string": [], "value-atword": [], "value-unicode-range": [], "value-unknown": [] });
   var Gt = function (e, t) {
    let r = 0;
    for (let n = 0; n < e.line - 1; ++n) r = t.indexOf("\n", r) + 1;
    return r + e.column;
   };
   function Xt(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   Xt(/\s/);
   var Yt = Xt(" \t"),
    Qt = Xt(",; \t"),
    Zt = Xt(/[^\n\r]/);
   function er(e, t) {
    var r, n, s;
    if ("number" == typeof (null == (n = null == (r = e.source) ? void 0 : r.start) ? void 0 : n.offset)) return e.source.start.offset;
    if ("number" == typeof e.sourceIndex) return e.sourceIndex;
    if (null != (s = e.source) && s.start) return Gt(e.source.start, t);
    throw Object.assign(new Error("Can not locate node."), { node: e });
   }
   function tr(e, t) {
    var r, n;
    if ("css-comment" === e.type && e.inline) return Zt(t, e.source.startOffset);
    if ("number" == typeof (null == (n = null == (r = e.source) ? void 0 : r.end) ? void 0 : n.offset)) return e.source.end.offset;
    if (e.source) {
     if (e.source.end) return Gt(e.source.end, t);
     if (Bt(e.nodes)) return tr(kt(!1, e.nodes, -1), t);
    }
    return null;
   }
   function rr(e, t) {
    e.source && ((e.source.startOffset = er(e, t)), (e.source.endOffset = tr(e, t)));
    for (let r in e) {
     let n = e[r];
     "source" === r || !n || "object" != typeof n || ("value-root" === n.type || "value-unknown" === n.type ? nr(n, sr(e), n.text || n.value) : rr(n, t));
    }
   }
   function nr(e, t, r) {
    e.source && ((e.source.startOffset = er(e, r) + t), (e.source.endOffset = tr(e, r) + t));
    for (let n in e) {
     let s = e[n];
     "source" === n || !s || "object" != typeof s || nr(s, t, r);
    }
   }
   function sr(e) {
    var t;
    let r = e.source.startOffset;
    return "string" == typeof e.prop && (r += e.prop.length), "css-atrule" === e.type && "string" == typeof e.name && (r += 1 + e.name.length + e.raws.afterName.match(/^\s*:?\s*/)[0].length), "css-atrule" !== e.type && "string" == typeof (null == (t = e.raws) ? void 0 : t.between) && (r += e.raws.between.length), r;
   }
   function ir(e) {
    var t;
    return null == (t = e.source) ? void 0 : t.startOffset;
   }
   function ar(e) {
    var t;
    return null == (t = e.source) ? void 0 : t.endOffset;
   }
   var or = c(h(), 1);
   var ur = function (e) {
    if (!e.startsWith("#!")) return "";
    let t = e.indexOf("\n");
    return -1 === t ? e : e.slice(0, t);
   };
   function lr(e) {
    let t = ur(e);
    t && (e = e.slice(t.length + 1));
    let r = (0, or.extract)(e),
     { pragmas: n, comments: s } = (0, or.parseWithComments)(r);
    return { shebang: t, text: e, pragmas: n, comments: s };
   }
   var pr = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
   var cr = function (e) {
    let t = e.match(pr);
    if (!t) return { content: e };
    let { startDelimiter: r, language: n, value: s = "", endDelimiter: i } = t.groups,
     a = n.trim() || "yaml";
    if (("+++" === r && (a = "toml"), "yaml" !== a && r !== i)) return { content: e };
    let [o] = t;
    return { frontMatter: { type: "front-matter", lang: a, value: s, startDelimiter: r, endDelimiter: i, raw: o.replace(/\n$/, "") }, content: Ge(!1, o, /[^\n]/g, " ") + e.slice(o.length) };
   };
   var hr = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
   var dr = new Set(["initial", "inherit", "unset", "revert"]);
   function fr(e, t) {
    var r;
    let n = e.findAncestor((e) => "css-atrule" === e.type);
    return (null == (r = null == n ? void 0 : n.name) ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(t.toLowerCase());
   }
   function mr(e) {
    return e.includes("$") || e.includes("@") || e.includes("#") || e.startsWith("%") || e.startsWith("--") || e.startsWith(":--") || (e.includes("(") && e.includes(")")) ? e : e.toLowerCase();
   }
   function yr(e, t) {
    var r;
    let n = e.findAncestor((e) => "value-func" === e.type);
    return (null == (r = null == n ? void 0 : n.value) ? void 0 : r.toLowerCase()) === t;
   }
   function gr(e) {
    var t;
    let r = e.findAncestor((e) => "css-rule" === e.type),
     n = null == (t = null == r ? void 0 : r.raws) ? void 0 : t.selector;
    return n && (n.startsWith(":import") || n.startsWith(":export"));
   }
   function Dr(e, t) {
    let r = Array.isArray(t) ? t : [t],
     n = e.findAncestor((e) => "css-atrule" === e.type);
    return n && r.includes(n.name.toLowerCase());
   }
   function xr(e, t) {
    var r;
    let n = null == (r = e.parent) ? void 0 : r.nodes;
    return n && n.indexOf(t) === n.length - 1;
   }
   function br(e) {
    let { selector: t } = e;
    return !!t && (("string" == typeof t && /^@.+:.*$/.test(t)) || (t.value && /^@.+:.*$/.test(t.value)));
   }
   function vr(e) {
    return "value-word" === e.type && ["from", "through", "end"].includes(e.value);
   }
   function Er(e) {
    return "value-word" === e.type && ["and", "or", "not"].includes(e.value);
   }
   function Cr(e) {
    return "value-word" === e.type && "in" === e.value;
   }
   function Tr(e) {
    return "value-operator" === e.type && "*" === e.value;
   }
   function wr(e) {
    return "value-operator" === e.type && "/" === e.value;
   }
   function Sr(e) {
    return "value-operator" === e.type && "+" === e.value;
   }
   function Ar(e) {
    return "value-operator" === e.type && "-" === e.value;
   }
   function Fr(e) {
    return (
     Tr(e) ||
     wr(e) ||
     Sr(e) ||
     Ar(e) ||
     (function (e) {
      return "value-operator" === e.type && "%" === e.value;
     })(e)
    );
   }
   function kr(e) {
    return "value-word" === e.type && ["==", "!="].includes(e.value);
   }
   function Pr(e) {
    return "value-word" === e.type && ["<", ">", "<=", ">="].includes(e.value);
   }
   function Ir(e, t) {
    return "scss" === t.parser && "css-atrule" === e.type && ["if", "else", "for", "each", "while"].includes(e.name);
   }
   function Nr(e) {
    var t;
    return (null == (t = e.raws) ? void 0 : t.params) && /^\(\s*\)$/.test(e.raws.params);
   }
   function Br(e) {
    return e.name.startsWith("prettier-placeholder");
   }
   function _r(e) {
    return e.prop.startsWith("@prettier-placeholder");
   }
   function Lr(e, t) {
    return "$$" === e.value && "value-func" === e.type && "value-word" === (null == t ? void 0 : t.type) && !t.raws.before;
   }
   function Or(e) {
    var t, r, n;
    return "value-paren_group" === (null == (n = null == (r = null == (t = e.value) ? void 0 : t.group) ? void 0 : r.group) ? void 0 : n.type) && null !== e.value.group.group.open && null !== e.value.group.group.close;
   }
   function Mr(e) {
    var t;
    return "" === (null == (t = e.raws) ? void 0 : t.before);
   }
   function jr(e) {
    var t, r;
    return "value-comma_group" === e.type && "value-colon" === (null == (r = null == (t = e.groups) ? void 0 : t[1]) ? void 0 : r.type);
   }
   function Rr(e) {
    var t;
    return "value-paren_group" === e.type && (null == (t = e.groups) ? void 0 : t[0]) && jr(e.groups[0]);
   }
   function qr(e, t) {
    var r;
    if ("scss" !== t.parser) return !1;
    let { node: n } = e;
    if (0 === n.groups.length) return !1;
    let s = e.grandparent;
    if (!(Rr(n) || (s && Rr(s)))) return !1;
    let i = e.findAncestor((e) => "css-decl" === e.type);
    return !!((null != (r = null == i ? void 0 : i.prop) && r.startsWith("$")) || Rr(s) || "value-func" === s.type);
   }
   function Ur(e) {
    return "value-comment" === e.type && e.inline;
   }
   function $r(e) {
    return "value-word" === e.type && "#" === e.value;
   }
   function Vr(e) {
    return "value-word" === e.type && "{" === e.value;
   }
   function zr(e) {
    return "value-word" === e.type && "}" === e.value;
   }
   function Wr(e) {
    return ["value-word", "value-atword"].includes(e.type);
   }
   function Hr(e) {
    return "value-colon" === (null == e ? void 0 : e.type);
   }
   function Jr(e) {
    return e.value && ["not", "and", "or"].includes(e.value.toLowerCase());
   }
   function Kr(e) {
    return "value-func" === e.type && hr.has(e.value.toLowerCase());
   }
   function Gr(e) {
    return /\/\//.test(e.split(/[\n\r]/).pop());
   }
   function Xr(e) {
    return "value-atword" === (null == e ? void 0 : e.type) && e.value.startsWith("prettier-placeholder-");
   }
   function Yr(e) {
    var t, r;
    return "value-paren_group" === e.type && "(" === (null == (t = e.open) ? void 0 : t.value) && ")" === (null == (r = e.close) ? void 0 : r.value);
   }
   var Qr = function (e, t, r) {
    var n;
    let { node: s } = e,
     i = e.parent,
     a = e.grandparent,
     o = (function (e) {
      var t, r;
      return null == (r = null == (t = e.findAncestor((e) => "css-decl" === e.type)) ? void 0 : t.prop) ? void 0 : r.toLowerCase();
     })(e),
     u = o && "value-value" === i.type && ("grid" === o || o.startsWith("grid-template")),
     l = e.findAncestor((e) => "css-atrule" === e.type),
     p = l && Ir(l, t),
     c = s.groups.some((e) => Ur(e)),
     h = e.map(r, "groups"),
     d = [],
     f = yr(e, "url"),
     m = !1,
     y = !1;
    for (let g = 0; g < s.groups.length; ++g) {
     d.push(h[g]);
     let r = s.groups[g - 1],
      o = s.groups[g],
      c = s.groups[g + 1],
      D = s.groups[g + 2];
     if (f) {
      ((c && Sr(c)) || Sr(o)) && d.push(" ");
      continue;
     }
     if ((Dr(e, "forward") && "value-word" === o.type && o.value && void 0 !== r && "value-word" === r.type && "as" === r.value && "value-operator" === c.type && "*" === c.value) || !c || ("value-word" === o.type && o.value.endsWith("-") && Xr(c))) continue;
     if ("value-string" === o.type && o.quoted) {
      let e = o.value.lastIndexOf("#{"),
       t = o.value.lastIndexOf("}");
      -1 !== e && -1 !== t ? (m = e > t) : -1 !== e ? (m = !0) : -1 !== t && (m = !1);
     }
     if (m || Hr(o) || Hr(c) || ("value-atword" === o.type && ("" === o.value || o.value.endsWith("["))) || ("value-word" === c.type && c.value.startsWith("]")) || "~" === o.value || ("value-string" !== o.type && o.value && o.value.includes("\\") && c && "value-comment" !== c.type) || (null != r && r.value && r.value.indexOf("\\") === r.value.length - 1 && "value-operator" === o.type && "/" === o.value) || "\\" === o.value || Lr(o, c) || $r(o) || Vr(o) || zr(c) || (Vr(c) && Mr(c)) || (zr(o) && Mr(c)) || ("--" === o.value && $r(c))) continue;
     let x = Fr(o),
      b = Fr(c);
     if ((((x && $r(c)) || (b && zr(o))) && Mr(c)) || (!r && wr(o)) || (yr(e, "calc") && (Sr(o) || Sr(c) || Ar(o) || Ar(c)) && Mr(c))) continue;
     let v = (Sr(o) || Ar(o)) && 0 === g && ("value-number" === c.type || c.isHex) && a && Kr(a) && !Mr(c),
      E = "value-func" === (null == D ? void 0 : D.type) || (D && Wr(D)) || "value-func" === o.type || Wr(o),
      C = "value-func" === c.type || Wr(c) || "value-func" === (null == r ? void 0 : r.type) || (r && Wr(r));
     if ("scss" === t.parser && x && "-" === o.value && "value-func" === c.type && ar(o) !== ir(c)) d.push(" ");
     else if ((Tr(c) || Tr(o) || yr(e, "calc") || v || !((wr(c) && !E) || (wr(o) && !C) || (Sr(c) && !E) || (Sr(o) && !C) || Ar(c) || Ar(o)) || !(Mr(c) || (x && (!r || (r && Fr(r)))))) && (("scss" !== t.parser && "less" !== t.parser) || !x || "-" !== o.value || !Yr(c) || ar(o) !== ir(c.open) || "(" !== c.open.value)) {
      if (Ur(o)) {
       if ("value-paren_group" === i.type) {
        d.push(vt(At));
        continue;
       }
       d.push(At);
       continue;
      }
      if (p && (kr(c) || Pr(c) || Er(c) || Cr(o) || vr(o))) {
       d.push(" ");
       continue;
      }
      if (l && "namespace" === l.name.toLowerCase()) {
       d.push(" ");
       continue;
      }
      if (u) {
       o.source && c.source && o.source.start.line !== c.source.start.line ? (d.push(At), (y = !0)) : d.push(" ");
       continue;
      }
      if (b) {
       d.push(" ");
       continue;
      }
      if (!("..." === (null == c ? void 0 : c.value) || (Xr(o) && Xr(c) && ar(o) === ir(c)))) {
       if (Xr(o) && Yr(c) && ar(o) === ir(c.open)) {
        d.push(St);
        continue;
       }
       if ("with" === o.value && Yr(c)) {
        d.push(" ");
        continue;
       }
       (null != (n = o.value) && n.endsWith("#") && "{" === c.value && Yr(c.group)) || d.push(wt);
      }
     }
    }
    return (
     c && d.push(Tt),
     y && d.unshift(At),
     p
      ? bt(Dt(d))
      : (function (e) {
           var t;
           let { node: r } = e;
           return "url" === r.groups[0].value && 2 === r.groups.length && "import" === (null == (t = e.findAncestor((e) => "css-atrule" === e.type)) ? void 0 : t.name);
          })(e)
        ? bt(Et(d))
        : bt(Dt(Et(d)))
    );
   };
   var Zr = function (e) {
     return e
      .toLowerCase()
      .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2")
      .replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1")
      .replace(/^([+-])?\./, "$10.")
      .replace(/(\.\d+?)0+(?=e|$)/, "$1")
      .replace(/\.(?=e|$)/, "");
    },
    en = new Map([
     ["em", "em"],
     ["rem", "rem"],
     ["ex", "ex"],
     ["rex", "rex"],
     ["cap", "cap"],
     ["rcap", "rcap"],
     ["ch", "ch"],
     ["rch", "rch"],
     ["ic", "ic"],
     ["ric", "ric"],
     ["lh", "lh"],
     ["rlh", "rlh"],
     ["vw", "vw"],
     ["svw", "svw"],
     ["lvw", "lvw"],
     ["dvw", "dvw"],
     ["vh", "vh"],
     ["svh", "svh"],
     ["lvh", "lvh"],
     ["dvh", "dvh"],
     ["vi", "vi"],
     ["svi", "svi"],
     ["lvi", "lvi"],
     ["dvi", "dvi"],
     ["vb", "vb"],
     ["svb", "svb"],
     ["lvb", "lvb"],
     ["dvb", "dvb"],
     ["vmin", "vmin"],
     ["svmin", "svmin"],
     ["lvmin", "lvmin"],
     ["dvmin", "dvmin"],
     ["vmax", "vmax"],
     ["svmax", "svmax"],
     ["lvmax", "lvmax"],
     ["dvmax", "dvmax"],
     ["cm", "cm"],
     ["mm", "mm"],
     ["q", "Q"],
     ["in", "in"],
     ["pt", "pt"],
     ["pc", "pc"],
     ["px", "px"],
     ["deg", "deg"],
     ["grad", "grad"],
     ["rad", "rad"],
     ["turn", "turn"],
     ["s", "s"],
     ["ms", "ms"],
     ["hz", "Hz"],
     ["khz", "kHz"],
     ["dpi", "dpi"],
     ["dpcm", "dpcm"],
     ["dppx", "dppx"],
     ["x", "x"],
     ["cqw", "cqw"],
     ["cqh", "cqh"],
     ["cqi", "cqi"],
     ["cqb", "cqb"],
     ["cqmin", "cqmin"],
     ["cqmax", "cqmax"],
    ]);
   function tn(e) {
    let t = e.toLowerCase();
    return en.has(t) ? en.get(t) : e;
   }
   var rn = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs,
    nn = new RegExp(rn.source + `|(${/[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/gi.source})?(${/(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/gi.source})(${/[a-z]+/gi.source})?`, "gi");
   function sn(e, t) {
    return Ge(!1, e, rn, (e) => Mt(e, t));
   }
   function an(e, t) {
    let r = t.singleQuote ? "'" : '"';
    return e.includes('"') || e.includes("'") ? e : r + e + r;
   }
   function on(e) {
    return Ge(!1, e, nn, (e, t, r, n, s) => (!r && n ? un(n) + mr(s || "") : e));
   }
   function un(e) {
    return Zr(e).replace(/\.0(?=$|e)/, "");
   }
   var ln = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ("\r" === e.charAt(t - 1) && "\n" === s) return t - 2;
     if ("\n" === s || "\r" === s || "\u2028" === s || "\u2029" === s) return t - 1;
    } else {
     if ("\r" === s && "\n" === e.charAt(t + 1)) return t + 2;
     if ("\n" === s || "\r" === s || "\u2028" === s || "\u2029" === s) return t + 1;
    }
    return t;
   };
   var pn = function (e, t, r = {}) {
    let n = Yt(e, r.backwards ? t - 1 : t, r);
    return n !== ln(e, n, r);
   };
   var cn = function (e, t) {
    if (!1 === t) return !1;
    if ("/" === e.charAt(t) && "*" === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ("*" === e.charAt(r) && "/" === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var hn = function (e, t) {
    return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? Zt(e, t) : t);
   };
   var dn = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = Qt(e, n)), (n = cn(e, n)), (n = Yt(e, n));
    return (n = hn(e, n)), (n = ln(e, n)), !1 !== n && pn(e, n);
   };
   function fn(e, t) {
    return (function (e) {
     return "value-func" === e.type && "var" === e.value.toLowerCase();
    })(e.grandparent) &&
     (function ({ node: e, parent: t }, r) {
      return !(!e.source || !r.originalText.slice(ir(e), ir(t.close)).trimEnd().endsWith(","));
     })(e, t)
     ? ","
     : "value-comment" === e.node.type ||
         ("value-comma_group" === e.node.type && e.node.groups.every((e) => "value-comment" === e.type)) ||
         !(function (e) {
          return "es5" === e.trailingComma || "all" === e.trailingComma;
         })(t) ||
         !e.callParent(() => qr(e, t))
       ? ""
       : Ct(",");
   }
   function mn(e, t, r) {
    let { node: n, parent: s } = e,
     i = e.map(({ node: e }) => ("string" == typeof e ? e : r()), "groups");
    if (
     s &&
     (function (e) {
      return "value-func" === e.type && "url" === e.value.toLowerCase();
     })(s) &&
     (1 === n.groups.length || (n.groups.length > 0 && "value-comma_group" === n.groups[0].type && n.groups[0].groups.length > 0 && "value-word" === n.groups[0].groups[0].type && n.groups[0].groups[0].value.startsWith("data:")))
    )
     return [n.open ? r("open") : "", Ft(",", i), n.close ? r("close") : ""];
    if (!n.open) {
     let t = yn(e),
      r = Ft([",", t ? At : wt], i);
     return Dt(t ? [At, r] : bt(Et(r)));
    }
    let a = e.map(({ node: r, isLast: n, index: s }) => {
      var a;
      let o = i[s];
      if (jr(r) && "value-comma_group" === r.type && r.groups && "value-paren_group" !== r.groups[0].type && "value-paren_group" === (null == (a = r.groups[2]) ? void 0 : a.type)) {
       let e = Pt(o.contents.contents);
       (e[1] = bt(e[1])), (o = bt(vt(o)));
      }
      let u = [o, n ? fn(e, t) : ","];
      if (!n && "value-comma_group" === r.type && Bt(r.groups)) {
       let e = kt(!1, r.groups, -1);
       !e.source && e.close && (e = e.close), e.source && dn(t.originalText, ar(e)) && u.push(At);
      }
      return u;
     }, "groups"),
     o = (function (e, t) {
      if (!jr(t)) return !1;
      let { groups: r } = t,
       n = r.indexOf(e);
      return -1 !== n && Hr(r[n + 1]);
     })(n, s),
     u = (function (e, t) {
      var r, n;
      if ("(" !== (null == (r = e.open) ? void 0 : r.value) || ")" !== (null == (n = e.close) ? void 0 : n.value) || e.groups.some((e) => "value-comma_group" !== e.type)) return !1;
      if ("value-comma_group" === t.type) {
       let r = t.groups.indexOf(e) - 1,
        n = t.groups[r];
       if ("value-word" === (null == n ? void 0 : n.type) && "with" === n.value) return !0;
      }
      return !1;
     })(n, s),
     l = qr(e, t),
     p = u || (l && !o),
     c = u || o,
     h = bt([n.open ? r("open") : "", Dt([St, Ft(wt, a)]), St, n.close ? r("close") : ""], { shouldBreak: p });
    return c ? vt(h) : h;
   }
   function yn(e) {
    return e.match(
     (e) => "value-paren_group" === e.type && !e.open && e.groups.some((e) => "value-comma_group" === e.type),
     (e, t) => "group" === t && "value-value" === e.type,
     (e, t) => "group" === t && "value-root" === e.type,
     (e, t) => "value" === t && (("css-decl" === e.type && !e.prop.startsWith("--")) || ("css-atrule" === e.type && e.variable)),
    );
   }
   var gn = function (e, t, r) {
    let n = [];
    return (
     e.each(() => {
      let { node: s, previous: i } = e;
      if (("css-comment" === (null == i ? void 0 : i.type) && "prettier-ignore" === i.text.trim() ? n.push(t.originalText.slice(ir(s), ar(s))) : n.push(r()), e.isLast)) return;
      let { next: a } = e;
      ("css-comment" === a.type && !pn(t.originalText, ir(a), { backwards: !0 }) && !Rt(s)) || ("css-atrule" === a.type && "else" === a.name && "css-comment" !== s.type) ? n.push(" ") : (n.push(t.__isHTMLStyleAttribute ? wt : At), dn(t.originalText, ar(s)) && !Rt(s) && n.push(At));
     }, "nodes"),
     n
    );
   };
   var Dn = {
     print: function (e, t, r) {
      var n, s, i, a, o, u;
      let { node: l } = e;
      switch (l.type) {
       case "front-matter":
        return [l.raw, At];
       case "css-root": {
        let n = gn(e, t, r),
         s = l.raws.after.trim();
        return s.startsWith(";") && (s = s.slice(1).trim()), [l.frontMatter ? [r("frontMatter"), At] : "", n, s ? ` ${s}` : "", l.nodes.length > 0 ? At : ""];
       }
       case "css-comment": {
        let e = l.inline || l.raws.inline,
         r = t.originalText.slice(ir(l), ar(l));
        return e ? r.trimEnd() : r;
       }
       case "css-rule":
        return [r("selector"), l.important ? " !important" : "", l.nodes ? ["selector-unknown" === (null == (n = l.selector) ? void 0 : n.type) && Gr(l.selector.value) ? wt : l.selector ? " " : "", "{", l.nodes.length > 0 ? Dt([At, gn(e, t, r)]) : "", At, "}", br(l) ? ";" : ""] : ";"];
       case "css-decl": {
        let n = e.parent,
         { between: a } = l.raws,
         o = a.trim(),
         u = ":" === o,
         p = "string" == typeof l.value && /^ *$/.test(l.value),
         c = "string" == typeof l.value ? l.value : r("value");
        return (
         (c = (function (e) {
          var t, r;
          return "value-root" === (null == (t = e.value) ? void 0 : t.type) && "value-value" === (null == (r = e.value.group) ? void 0 : r.type) && "composes" === e.prop.toLowerCase();
         })(l)
          ? (function (e) {
             return It(e, Nt);
            })(c)
          : c),
         !u && Gr(o) && !(null != (i = null == (s = l.value) ? void 0 : s.group) && i.group && e.call(() => yn(e), "value", "group", "group")) && (c = Dt([At, vt(c)])),
         [Ge(!1, l.raws.before, /[\s;]/g, ""), ("css-atrule" === n.type && n.variable) || gr(e) ? l.prop : mr(l.prop), o.startsWith("//") ? " " : "", o, l.extend || p ? "" : " ", "less" === t.parser && l.extend && l.selector ? ["extend(", r("selector"), ")"] : "", c, l.raws.important ? l.raws.important.replace(/\s*!\s*important/i, " !important") : l.important ? " !important" : "", l.raws.scssDefault ? l.raws.scssDefault.replace(/\s*!default/i, " !default") : l.scssDefault ? " !default" : "", l.raws.scssGlobal ? l.raws.scssGlobal.replace(/\s*!global/i, " !global") : l.scssGlobal ? " !global" : "", l.nodes ? [" {", Dt([St, gn(e, t, r)]), St, "}"] : _r(l) && !n.raws.semicolon && ";" !== t.originalText[ar(l) - 1] ? "" : t.__isHTMLStyleAttribute && xr(e, l) ? Ct(";") : ";"]
        );
       }
       case "css-atrule": {
        let n = e.parent,
         s = Br(l) && !n.raws.semicolon && ";" !== t.originalText[ar(l) - 1];
        if ("less" === t.parser) {
         if (l.mixin) return [r("selector"), l.important ? " !important" : "", s ? "" : ";"];
         if (l.function) return [l.name, "string" == typeof l.params ? l.params : r("params"), s ? "" : ";"];
         if (l.variable) return ["@", l.name, ": ", l.value ? r("value") : "", l.raws.between.trim() ? l.raws.between.trim() + " " : "", l.nodes ? ["{", Dt([l.nodes.length > 0 ? St : "", gn(e, t, r)]), St, "}"] : "", s ? "" : ";"];
        }
        let i = "import" === l.name && "value-unknown" === (null == (a = l.params) ? void 0 : a.type) && l.params.value.endsWith(";");
        return ["@", Nr(l) || l.name.endsWith(":") || Br(l) ? l.name : mr(l.name), l.params ? [Nr(l) ? "" : Br(l) ? ("" === l.raws.afterName ? "" : l.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(l.raws.afterName) ? [At, At] : /^\s*\n/.test(l.raws.afterName) ? At : " ") : " ", "string" == typeof l.params ? l.params : r("params")] : "", l.selector ? Dt([" ", r("selector")]) : "", l.value ? bt([" ", r("value"), Ir(l, t) ? (Or(l) ? " " : wt) : ""]) : "else" === l.name ? " " : "", l.nodes ? [Ir(l, t) ? "" : (l.selector && !l.selector.nodes && "string" == typeof l.selector.value && Gr(l.selector.value)) || (!l.selector && "string" == typeof l.params && Gr(l.params)) ? wt : " ", "{", Dt([l.nodes.length > 0 ? St : "", gn(e, t, r)]), St, "}"] : s || i ? "" : ";"];
       }
       case "media-query-list": {
        let t = [];
        return (
         e.each(({ node: e }) => {
          ("media-query" === e.type && "" === e.value) || t.push(r());
         }, "nodes"),
         bt(Dt(Ft(wt, t)))
        );
       }
       case "media-query":
        return [Ft(" ", e.map(r, "nodes")), xr(e, l) ? "" : ","];
       case "media-type":
       case "media-value":
        return on(sn(l.value, t));
       case "media-feature-expression":
        return l.nodes ? ["(", ...e.map(r, "nodes"), ")"] : l.value;
       case "media-feature":
        return mr(sn(Ge(!1, l.value, / +/g, " "), t));
       case "media-colon":
        return [l.value, " "];
       case "media-keyword":
       case "selector-string":
        return sn(l.value, t);
       case "media-url":
        return sn(Ge(!1, Ge(!1, l.value, /^url\(\s+/gi, "url("), /\s+\)$/g, ")"), t);
       case "media-unknown":
       case "selector-comment":
       case "selector-nesting":
       case "value-paren":
       case "value-operator":
       case "value-unicode-range":
       case "value-unknown":
        return l.value;
       case "selector-root":
        return bt([Dr(e, "custom-selector") ? [e.findAncestor((e) => "css-atrule" === e.type).customSelector, wt] : "", Ft([",", Dr(e, ["extend", "custom-selector", "nest"]) ? wt : At], e.map(r, "nodes"))]);
       case "selector-selector":
        return bt(Dt(e.map(r, "nodes")));
       case "selector-tag":
        return [l.namespace ? [!0 === l.namespace ? "" : l.namespace.trim(), "|"] : "", "selector-nesting" === (null == (o = e.previous) ? void 0 : o.type) ? l.value : on(fr(e, l.value) ? l.value.toLowerCase() : l.value)];
       case "selector-id":
        return ["#", l.value];
       case "selector-class":
        return [".", on(sn(l.value, t))];
       case "selector-attribute":
        return ["[", l.namespace ? [!0 === l.namespace ? "" : l.namespace.trim(), "|"] : "", l.attribute.trim(), l.operator ?? "", l.value ? an(sn(l.value.trim(), t), t) : "", l.insensitive ? " i" : "", "]"];
       case "selector-combinator":
        if ("+" === l.value || ">" === l.value || "~" === l.value || ">>>" === l.value) {
         let t = e.parent;
         return ["selector-selector" === t.type && t.nodes[0] === l ? "" : wt, l.value, xr(e, l) ? "" : " "];
        }
        return [l.value.trim().startsWith("(") ? wt : "", on(sn(l.value.trim(), t)) || wt];
       case "selector-universal":
        return [l.namespace ? [!0 === l.namespace ? "" : l.namespace.trim(), "|"] : "", l.value];
       case "selector-pseudo":
        return [mr(l.value), Bt(l.nodes) ? bt(["(", Dt([St, Ft([",", wt], e.map(r, "nodes"))]), St, ")"]) : ""];
       case "selector-unknown": {
        let r = e.findAncestor((e) => "css-rule" === e.type);
        if (null != r && r.isSCSSNesterProperty) return on(sn(mr(l.value), t));
        let n = e.parent;
        if (null != (u = n.raws) && u.selector) {
         let e = ir(n),
          r = e + n.raws.selector.length;
         return t.originalText.slice(e, r).trim();
        }
        let s = e.grandparent;
        if ("value-paren_group" === n.type && "value-func" === (null == s ? void 0 : s.type) && "selector" === s.value) {
         let e = ar(n.open) + 1,
          r = ir(n.close),
          s = t.originalText.slice(e, r).trim();
         return Gr(s) ? [Tt, s] : s;
        }
        return l.value;
       }
       case "value-value":
       case "value-root":
        return r("group");
       case "value-comment":
        return t.originalText.slice(ir(l), ar(l));
       case "value-comma_group":
        return Qr(e, t, r);
       case "value-paren_group":
        return mn(e, t, r);
       case "value-func":
        return [l.value, Dr(e, "supports") && Jr(l) ? " " : "", r("group")];
       case "value-number":
        return [un(l.value), tn(l.unit)];
       case "value-word":
        return (l.isColor && l.isHex) ||
         (function (e) {
          return dr.has(e.toLowerCase());
         })(l.value)
         ? l.value.toLowerCase()
         : l.value;
       case "value-colon": {
        let { previous: t } = e;
        return [l.value, ("string" == typeof (null == t ? void 0 : t.value) && t.value.endsWith("\\")) || yr(e, "url") ? "" : wt];
       }
       case "value-string":
        return Mt(l.raws.quote + l.value + l.raws.quote, t);
       case "value-atword":
        return ["@", l.value];
       default:
        throw new jt(l, "PostCSS");
      }
     },
     embed: Wt,
     insertPragma: function (e) {
      let { frontMatter: t, content: r } = cr(e);
      return (
       (t ? t.raw + "\n\n" : "") +
       (function (e) {
        let { shebang: t, text: r, pragmas: n, comments: s } = lr(e),
         i = (0, or.strip)(r);
        return (t ? `${t}\n` : "") + (0, or.print)({ pragmas: { format: "", ...n }, comments: s.trimStart() }) + (i.startsWith("\n") ? "\n" : "\n\n") + i;
       })(r)
      );
     },
     massageAstNode: $t,
     getVisitorKeys: Kt,
    },
    xn = [
     { linguistLanguageId: 50, name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css", ".wxss"], parsers: ["css"], vscodeLanguageIds: ["css"] },
     { linguistLanguageId: 262764437, name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", parsers: ["css"], vscodeLanguageIds: ["postcss"] },
     { linguistLanguageId: 198, name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["less"], vscodeLanguageIds: ["less"] },
     { linguistLanguageId: 329, name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], parsers: ["scss"], vscodeLanguageIds: ["scss"] },
    ],
    bn = { singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." } },
    vn = {};
   p(vn, { css: () => Zn, less: () => es, scss: () => ts });
   var En = c(B(), 1),
    Cn = c(U(), 1),
    Tn = c(te(), 1);
   var wn = function (e, t) {
    let r = new SyntaxError(e + " (" + t.loc.start.line + ":" + t.loc.start.column + ")");
    return Object.assign(r, t);
   };
   function Sn(e, t, r) {
    if (e && "object" == typeof e) {
     delete e.parent;
     for (let n in e) Sn(e[n], t, r), "type" === n && "string" == typeof e[n] && !e[n].startsWith(t) && (!r || !r.test(e[n])) && (e[n] = t + e[n]);
    }
    return e;
   }
   function An(e) {
    if (e && "object" == typeof e) {
     delete e.parent;
     for (let t in e) An(e[t]);
     !Array.isArray(e) && e.value && !e.type && (e.type = "unknown");
    }
    return e;
   }
   var Fn = c(ie(), 1).default.default;
   var kn = function (e) {
     let t;
     try {
      t = Fn(e);
     } catch {
      return { type: "selector-unknown", value: e };
     }
     return Sn(An(t), "media-");
    },
    Pn = c(Fe(), 1);
   var In = function (e) {
     if (/\/\/|\/\*/.test(e)) return { type: "selector-unknown", value: e.trim() };
     let t;
     try {
      new Pn.default((e) => {
       t = e;
      }).process(e);
     } catch {
      return { type: "selector-unknown", value: e };
     }
     return Sn(t, "selector-");
    },
    Nn = c(Je(), 1),
    Bn = (e) => {
     for (; e.parent; ) e = e.parent;
     return e;
    };
   var _n = function (e) {
    return Bn(e)
     .text.slice(e.group.open.sourceIndex + 1, e.group.close.sourceIndex)
     .trim();
   };
   var Ln = function (e) {
    if (Bt(e)) for (let t = e.length - 1; t > 0; t--) if ("word" === e[t].type && "{" === e[t].value && "word" === e[t - 1].type && e[t - 1].value.endsWith("#")) return !0;
    return !1;
   };
   var On = function (e) {
    return e.some((e) => "string" === e.type || ("func" === e.type && !e.value.endsWith("\\")));
   };
   var Mn = function (e, t) {
    return !("scss" !== t.parser || "word" !== (null == e ? void 0 : e.type) || !e.value.startsWith("$"));
   };
   function jn(e, t) {
    var r;
    let { nodes: n } = e,
     s = { open: null, close: null, groups: [], type: "paren_group" },
     i = [s],
     a = s,
     o = { groups: [], type: "comma_group" },
     u = [o];
    for (let l = 0; l < n.length; ++l) {
     let a = n[l];
     if (("scss" === t.parser && "number" === a.type && ".." === a.unit && a.value.endsWith(".") && ((a.value = a.value.slice(0, -1)), (a.unit = "...")), "func" === a.type && "selector" === a.value && (a.group.groups = [In(Bn(e).text.slice(a.group.open.sourceIndex + 1, a.group.close.sourceIndex))]), "func" === a.type && "url" === a.value)) {
      let e = (null == (r = a.group) ? void 0 : r.groups) ?? [],
       n = [];
      for (let t = 0; t < e.length; t++) {
       let r = e[t];
       "comma_group" === r.type ? (n = [...n, ...r.groups]) : n.push(r);
      }
      (Ln(n) || (!On(n) && !Mn(n[0], t))) && (a.group.groups = [_n(a)]);
     }
     if ("paren" === a.type && "(" === a.value) (s = { open: a, close: null, groups: [], type: "paren_group" }), i.push(s), (o = { groups: [], type: "comma_group" }), u.push(o);
     else if ("paren" === a.type && ")" === a.value) {
      if ((o.groups.length > 0 && s.groups.push(o), (s.close = a), 1 === u.length)) throw new Error("Unbalanced parenthesis");
      u.pop(), (o = kt(!1, u, -1)), o.groups.push(s), i.pop(), (s = kt(!1, i, -1));
     } else "comma" === a.type ? (s.groups.push(o), (o = { groups: [], type: "comma_group" }), (u[u.length - 1] = o)) : o.groups.push(a);
    }
    return o.groups.length > 0 && s.groups.push(o), a;
   }
   function Rn(e) {
    return ("paren_group" === e.type && !e.open && !e.close && 1 === e.groups.length) || ("comma_group" === e.type && 1 === e.groups.length) ? Rn(e.groups[0]) : "paren_group" === e.type || "comma_group" === e.type ? { ...e, groups: e.groups.map(Rn) } : e;
   }
   function qn(e, t) {
    if (e && "object" == typeof e) for (let r in e) "parent" !== r && (qn(e[r], t), "nodes" === r && ((e.group = Rn(jn(e, t))), delete e[r]));
    return e;
   }
   var Un = function (e, t) {
     if ("less" === t.parser && e.startsWith("~`")) return { type: "value-unknown", value: e };
     let r = null;
     try {
      r = new Nn.default(e, { loose: !0 }).parse();
     } catch {
      return { type: "value-unknown", value: e };
     }
     return (r.text = e), Sn(qn(r, t), "value-", /^selector-/);
    },
    $n = new Set(["import", "use", "forward"]);
   var Vn = function (e) {
    return $n.has(e);
   };
   var zn = function (e, t) {
     return (
      !("scss" !== t.parser || !e.selector) &&
      e.selector
       .replace(/\/\*.*?\*\//, "")
       .replace(/\/\/.*\n/, "")
       .trim()
       .endsWith(":")
     );
    },
    Wn = /(\s*)(!default).*$/,
    Hn = /(\s*)(!global).*$/;
   function Jn(e, t) {
    var r, n;
    if (e && "object" == typeof e) {
     delete e.parent;
     for (let r in e) Jn(e[r], t);
     if (!e.type) return e;
     if ((e.raws ?? (e.raws = {}), "css-decl" === e.type && "string" == typeof e.prop && e.prop.startsWith("--") && "string" == typeof e.value && e.value.startsWith("{"))) {
      let n;
      if (e.value.trimEnd().endsWith("}")) {
       let s,
        i,
        a = t.originalText.slice(0, e.source.start.offset),
        o = "a".repeat(e.prop.length) + t.originalText.slice(e.source.start.offset + e.prop.length, e.source.end.offset),
        u = Ge(!1, a, /[^\n]/g, " ") + o;
       s = "scss" === t.parser ? Yn : "less" === t.parser ? Xn : Gn;
       try {
        i = s(u, { ...t });
       } catch {}
       1 === (null == (r = null == i ? void 0 : i.nodes) ? void 0 : r.length) && "css-rule" === i.nodes[0].type && (n = i.nodes[0].nodes);
      }
      return (e.value = n ? { type: "css-rule", nodes: n } : { type: "value-unknown", value: e.raws.value.raw }), e;
     }
     let s = "";
     "string" == typeof e.selector && ((s = e.raws.selector ? e.raws.selector.scss ?? e.raws.selector.raw : e.selector), e.raws.between && e.raws.between.trim().length > 0 && (s += e.raws.between), (e.raws.selector = s));
     let i = "";
     "string" == typeof e.value && ((i = e.raws.value ? e.raws.value.scss ?? e.raws.value.raw : e.value), (i = i.trim()), (e.raws.value = i));
     let a = "";
     if (("string" == typeof e.params && ((a = e.raws.params ? e.raws.params.scss ?? e.raws.params.raw : e.params), e.raws.afterName && e.raws.afterName.trim().length > 0 && (a = e.raws.afterName + a), e.raws.between && e.raws.between.trim().length > 0 && (a += e.raws.between), (a = a.trim()), (e.raws.params = a)), s.trim().length > 0)) return s.startsWith("@") && s.endsWith(":") ? e : e.mixin ? ((e.selector = Un(s, t)), e) : (zn(e, t) && (e.isSCSSNesterProperty = !0), (e.selector = In(s)), e);
     if (i.length > 0) {
      let r = i.match(Wn);
      r && ((i = i.slice(0, r.index)), (e.scssDefault = !0), "!default" !== r[0].trim() && (e.raws.scssDefault = r[0]));
      let n = i.match(Hn);
      if ((n && ((i = i.slice(0, n.index)), (e.scssGlobal = !0), "!global" !== n[0].trim() && (e.raws.scssGlobal = n[0])), i.startsWith("progid:"))) return { type: "value-unknown", value: i };
      e.value = Un(i, t);
     }
     if (("less" === t.parser && "css-decl" === e.type && i.startsWith("extend(") && (e.extend || (e.extend = ":" === e.raws.between), e.extend && !e.selector && (delete e.value, (e.selector = In(i.slice(7, -1))))), "css-atrule" === e.type)) {
      if ("less" === t.parser) {
       if (e.mixin) {
        let t = e.raws.identifier + e.name + e.raws.afterName + e.raws.params;
        return (e.selector = In(t)), delete e.params, e;
       }
       if (e.function) return e;
      }
      if ("css" === t.parser && "custom-selector" === e.name) {
       let t = e.params.match(/:--\S+\s+/)[0].trim();
       return (e.customSelector = t), (e.selector = In(e.params.slice(t.length).trim())), delete e.params, e;
      }
      if ("less" === t.parser) {
       if (e.name.includes(":") && !e.params) {
        e.variable = !0;
        let r = e.name.split(":");
        (e.name = r[0]), (e.value = Un(r.slice(1).join(":"), t));
       }
       if (!["page", "nest", "keyframes"].includes(e.name) && ":" === (null == (n = e.params) ? void 0 : n[0])) {
        e.variable = !0;
        let r = e.params.slice(1);
        r && (e.value = Un(r, t)), (e.raws.afterName += ":");
       }
       if (e.variable) return delete e.params, e.value || delete e.value, e;
      }
     }
     if ("css-atrule" === e.type && a.length > 0) {
      let { name: r } = e,
       n = e.name.toLowerCase();
      return "warn" === r || "error" === r ? ((e.params = { type: "media-unknown", value: a }), e) : "extend" === r || "nest" === r ? ((e.selector = In(a)), delete e.params, e) : "at-root" === r ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(a) ? (e.params = Un(a, t)) : ((e.selector = In(a)), delete e.params), e) : Vn(n) ? ((e.import = !0), delete e.filename, (e.params = Un(a, t)), e) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(r) ? ((a = a.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2")), (a = a.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2")), (e.value = Un(a, t)), delete e.params, e) : ["media", "custom-media"].includes(n) ? (a.includes("#{") ? { type: "media-unknown", value: a } : ((e.params = kn(a)), e)) : ((e.params = a), e);
     }
    }
    return e;
   }
   function Kn(e, t, r) {
    let n,
     s = cr(t),
     { frontMatter: i } = s;
    t = s.content;
    try {
     n = e(t, { map: !1 });
    } catch (a) {
     let { name: e, reason: t, line: r, column: n } = a;
     throw "number" != typeof r ? a : wn(`${e}: ${t}`, { loc: { start: { line: r, column: n } }, cause: a });
    }
    return (r.originalText = t), (n = Jn(Sn(n, "css-"), r)), rr(n, t), i && ((i.source = { startOffset: 0, endOffset: i.raw.length }), (n.frontMatter = i)), n;
   }
   function Gn(e, t = {}) {
    return Kn(En.default.default, e, t);
   }
   function Xn(e, t = {}) {
    return Kn(
     (e) =>
      Cn.default.parse(
       (function (e) {
        let t,
         r = "initial",
         n = "initial",
         s = !1,
         i = [];
        for (let a = 0; a < e.length; a++) {
         let o = e[a];
         switch (r) {
          case "initial":
           if ("'" === o) {
            r = "single-quotes";
            continue;
           }
           if ('"' === o) {
            r = "double-quotes";
            continue;
           }
           if (("u" === o || "U" === o) && "url(" === e.slice(a, a + 4).toLowerCase()) {
            (r = "url"), (a += 3);
            continue;
           }
           if ("*" === o && "/" === e[a - 1]) {
            r = "comment-block";
            continue;
           }
           if ("/" === o && "/" === e[a - 1]) {
            (r = "comment-inline"), (t = a - 1);
            continue;
           }
           continue;
          case "single-quotes":
           if (("'" === o && "\\" !== e[a - 1] && ((r = n), (n = "initial")), "\n" === o || "\r" === o)) return e;
           continue;
          case "double-quotes":
           if (('"' === o && "\\" !== e[a - 1] && ((r = n), (n = "initial")), "\n" === o || "\r" === o)) return e;
           continue;
          case "url":
           if ((")" === o && (r = "initial"), "\n" === o || "\r" === o)) return e;
           if ("'" === o) {
            (r = "single-quotes"), (n = "url");
            continue;
           }
           if ('"' === o) {
            (r = "double-quotes"), (n = "url");
            continue;
           }
           continue;
          case "comment-block":
           "/" === o && "*" === e[a - 1] && (r = "initial");
           continue;
          case "comment-inline":
           ('"' === o || "'" === o || "*" === o) && (s = !0), ("\n" === o || "\r" === o) && (s && i.push([t, a]), (r = "initial"), (s = !1));
           continue;
         }
        }
        for (let [a, o] of i) e = e.slice(0, a) + Ge(!1, e.slice(a, o), /["'*]/g, " ") + e.slice(o);
        return e;
       })(e),
      ),
     e,
     t,
    );
   }
   function Yn(e, t = {}) {
    return Kn(Tn.default, e, t);
   }
   var Qn = {
     astFormat: "postcss",
     hasPragma: function (e) {
      return (function (e) {
       let { pragmas: t } = lr(e);
       return Object.prototype.hasOwnProperty.call(t, "prettier") || Object.prototype.hasOwnProperty.call(t, "format");
      })(cr(e).content);
     },
     locStart: ir,
     locEnd: ar,
    },
    Zn = { ...Qn, parse: Gn },
    es = { ...Qn, parse: Xn },
    ts = { ...Qn, parse: Yn },
    rs = { postcss: Dn },
    ns = Ke;
  },
  80495: (e, t, r) => {
   r.d(t, { ZP: () => wn });
   var n = Object.create,
    s = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    p = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    c = (e, t, r, n) => {
     if ((t && "object" == typeof t) || "function" == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && s(e, o, { get: () => t[o], enumerable: !(n = i(t, o)) || n.enumerable });
     return e;
    },
    h = (e, t, r) => ((r = null != e ? n(o(e)) : {}), c(!t && e && e.__esModule ? r : s(r, "default", { value: e, enumerable: !0 }), e)),
    d = (e, t, r) => {
     if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
     t instanceof WeakSet ? t.add(e) : t.set(e, r);
    },
    f = (e, t, r) => (
     ((e, t, r) => {
      if (!t.has(e)) throw TypeError("Cannot " + r);
     })(e, t, "access private method"),
     r
    ),
    m = l((e) => {
     function t() {}
     function r(e, t, r, n, s) {
      for (var i = 0, a = t.length, o = 0, u = 0; i < a; i++) {
       var l = t[i];
       if (l.removed) {
        if (((l.value = e.join(n.slice(u, u + l.count))), (u += l.count), i && t[i - 1].added)) {
         var p = t[i - 1];
         (t[i - 1] = t[i]), (t[i] = p);
        }
       } else {
        if (!l.added && s) {
         var c = r.slice(o, o + l.count);
         (c = c.map(function (e, t) {
          var r = n[u + t];
          return r.length > e.length ? r : e;
         })),
          (l.value = e.join(c));
        } else l.value = e.join(r.slice(o, o + l.count));
        (o += l.count), l.added || (u += l.count);
       }
      }
      var h = t[a - 1];
      return a > 1 && "string" == typeof h.value && (h.added || h.removed) && e.equals("", h.value) && ((t[a - 2].value += h.value), t.pop()), t;
     }
     Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.default = t),
      (t.prototype = {
       diff: function (e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
         s = n.callback;
        "function" == typeof n && ((s = n), (n = {})), (this.options = n);
        var i = this;
        function a(e) {
         return s
          ? (setTimeout(function () {
             s(void 0, e);
            }, 0),
            !0)
          : e;
        }
        (e = this.castInput(e)), (t = this.castInput(t)), (e = this.removeEmpty(this.tokenize(e)));
        var o = (t = this.removeEmpty(this.tokenize(t))).length,
         u = e.length,
         l = 1,
         p = o + u;
        n.maxEditLength && (p = Math.min(p, n.maxEditLength));
        var c = [{ newPos: -1, components: [] }],
         h = this.extractCommon(c[0], t, e, 0);
        if (c[0].newPos + 1 >= o && h + 1 >= u) return a([{ value: this.join(t), count: t.length }]);
        function d() {
         for (var n = -1 * l; n <= l; n += 2) {
          var s = void 0,
           p = c[n - 1],
           h = c[n + 1],
           d = (h ? h.newPos : 0) - n;
          p && (c[n - 1] = void 0);
          var f = p && p.newPos + 1 < o,
           m = h && 0 <= d && d < u;
          if (f || m) {
           if ((!f || (m && p.newPos < h.newPos) ? ((s = { newPos: (y = h).newPos, components: y.components.slice(0) }), i.pushComponent(s.components, void 0, !0)) : ((s = p).newPos++, i.pushComponent(s.components, !0, void 0)), (d = i.extractCommon(s, t, e, n)), s.newPos + 1 >= o && d + 1 >= u)) return a(r(i, s.components, t, e, i.useLongestToken));
           c[n] = s;
          } else c[n] = void 0;
         }
         var y;
         l++;
        }
        if (s)
         !(function e() {
          setTimeout(function () {
           if (l > p) return s();
           d() || e();
          }, 0);
         })();
        else
         for (; l <= p; ) {
          var f = d();
          if (f) return f;
         }
       },
       pushComponent: function (e, t, r) {
        var n = e[e.length - 1];
        n && n.added === t && n.removed === r ? (e[e.length - 1] = { count: n.count + 1, added: t, removed: r }) : e.push({ count: 1, added: t, removed: r });
       },
       extractCommon: function (e, t, r, n) {
        for (var s = t.length, i = r.length, a = e.newPos, o = a - n, u = 0; a + 1 < s && o + 1 < i && this.equals(t[a + 1], r[o + 1]); ) a++, o++, u++;
        return u && e.components.push({ count: u }), (e.newPos = a), o;
       },
       equals: function (e, t) {
        return this.options.comparator ? this.options.comparator(e, t) : e === t || (this.options.ignoreCase && e.toLowerCase() === t.toLowerCase());
       },
       removeEmpty: function (e) {
        for (var t = [], r = 0; r < e.length; r++) e[r] && t.push(e[r]);
        return t;
       },
       castInput: function (e) {
        return e;
       },
       tokenize: function (e) {
        return e.split("");
       },
       join: function (e) {
        return e.join("");
       },
      });
    }),
    y = l((e) => {
     var t;
     Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.diffArrays = function (e, t, n) {
       return r.diff(e, t, n);
      }),
      (e.arrayDiff = void 0);
     var r = new ((t = m()) && t.__esModule ? t : { default: t }).default();
     (e.arrayDiff = r),
      (r.tokenize = function (e) {
       return e.slice();
      }),
      (r.join = r.removeEmpty =
       function (e) {
        return e;
       });
    }),
    g = l((e, t) => {
     var r = new Proxy(String, { get: () => r });
     t.exports = r;
    }),
    D = {};
   p(D, { default: () => b, shouldHighlight: () => x });
   var x,
    b,
    v,
    E,
    C =
     ((v = () => {
      (x = () => !1), (b = String);
     }),
     () => (v && (E = v((v = 0))), E)),
    T = l((e) => {
     Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.codeFrameColumns = u),
      (e.default = function (e, t, r, n = {}) {
       if (!a) {
        a = !0;
        let e = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        (new Error(e).name = "DeprecationWarning"), console.warn(new Error(e));
       }
       return (r = Math.max(r, 0)), u(e, { start: { column: r, line: t } }, n);
      });
     var t,
      r = (C(), ((e) => c(s({}, "__esModule", { value: !0 }), e))(D)),
      n = (function (e, t) {
       if (!t && e && e.__esModule) return e;
       if (null === e || ("object" != typeof e && "function" != typeof e)) return { default: e };
       var r = i(t);
       if (r && r.has(e)) return r.get(e);
       var n = { __proto__: null },
        s = Object.defineProperty && Object.getOwnPropertyDescriptor;
       for (var a in e)
        if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
         var o = s ? Object.getOwnPropertyDescriptor(e, a) : null;
         o && (o.get || o.set) ? Object.defineProperty(n, a, o) : (n[a] = e[a]);
        }
       return (n.default = e), r && r.set(e, n), n;
      })(g(), !0);
     function i(e) {
      if ("function" != typeof WeakMap) return null;
      var t = new WeakMap(),
       r = new WeakMap();
      return (i = function (e) {
       return e ? r : t;
      })(e);
     }
     var a = !1;
     var o = /\r\n|[\n\r\u2028\u2029]/;
     function u(e, s, i = {}) {
      let a = (i.highlightCode || i.forceColor) && (0, r.shouldHighlight)(i),
       u = (function (e) {
        return e ? (null != t || (t = new n.default.constructor({ enabled: !0, level: 1 })), t) : n.default;
       })(i.forceColor),
       l = (function (e) {
        return { gutter: e.grey, marker: e.red.bold, message: e.red.bold };
       })(u),
       p = (e, t) => (a ? e(t) : t),
       c = e.split(o),
       {
        start: h,
        end: d,
        markerLines: f,
       } = (function (e, t, r) {
        let n = Object.assign({ column: 0, line: -1 }, e.start),
         s = Object.assign({}, n, e.end),
         { linesAbove: i = 2, linesBelow: a = 3 } = r || {},
         o = n.line,
         u = n.column,
         l = s.line,
         p = s.column,
         c = Math.max(o - (i + 1), 0),
         h = Math.min(t.length, l + a);
        -1 === o && (c = 0), -1 === l && (h = t.length);
        let d = l - o,
         f = {};
        if (d)
         for (let m = 0; m <= d; m++) {
          let e = m + o;
          if (u)
           if (0 === m) {
            let r = t[e - 1].length;
            f[e] = [u, r - u + 1];
           } else if (m === d) f[e] = [0, p];
           else {
            let r = t[e - m].length;
            f[e] = [0, r];
           }
          else f[e] = !0;
         }
        else f[o] = u === p ? !u || [u, 0] : [u, p - u];
        return { start: c, end: h, markerLines: f };
       })(s, c, i),
       m = s.start && "number" == typeof s.start.column,
       y = String(d).length,
       g = (a ? (0, r.default)(e, i) : e)
        .split(o, d)
        .slice(h, d)
        .map((e, t) => {
         let r = h + 1 + t,
          n = ` ${` ${r}`.slice(-y)} |`,
          s = f[r],
          a = !f[r + 1];
         if (s) {
          let t = "";
          if (Array.isArray(s)) {
           let r = e.slice(0, Math.max(s[0] - 1, 0)).replace(/[^\t]/g, " "),
            o = s[1] || 1;
           (t = ["\n ", p(l.gutter, n.replace(/\d/g, " ")), " ", r, p(l.marker, "^").repeat(o)].join("")), a && i.message && (t += " " + p(l.message, i.message));
          }
          return [p(l.marker, ">"), p(l.gutter, n), e.length > 0 ? ` ${e}` : "", t].join("");
         }
         return ` ${p(l.gutter, n)}${e.length > 0 ? ` ${e}` : ""}`;
        })
        .join("\n");
      return i.message && !m && (g = `${" ".repeat(y + 1)}${i.message}\n${g}`), a ? u.reset(g) : g;
     }
    }),
    w = {};
   p(w, { __debug: () => Tn, check: () => En, doc: () => Zr, format: () => vn, formatWithCursor: () => bn, getSupportInfo: () => Cn, util: () => sn, version: () => nn });
   var S = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    A = h(y(), 1);
   function F(e) {
    switch (e) {
     case "cr":
      return "\r";
     case "crlf":
      return "\r\n";
     default:
      return "\n";
    }
   }
   function k(e, t) {
    let r;
    switch (t) {
     case "\n":
      r = /\n/g;
      break;
     case "\r":
      r = /\r/g;
      break;
     case "\r\n":
      r = /\r\n/g;
      break;
     default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
    }
    let n = e.match(r);
    return n ? n.length : 0;
   }
   var P = "string",
    I = "array",
    N = "cursor",
    B = "indent",
    _ = "align",
    L = "trim",
    O = "group",
    M = "fill",
    j = "if-break",
    R = "indent-if-break",
    q = "line-suffix",
    U = "line-suffix-boundary",
    $ = "line",
    V = "label",
    z = "break-parent",
    W = new Set([N, B, _, L, O, M, j, R, q, U, $, V, z]);
   var H = function (e) {
    if ("string" == typeof e) return P;
    if (Array.isArray(e)) return I;
    if (!e) return;
    let { type: t } = e;
    return W.has(t) ? t : void 0;
   };
   function J(e) {
    let t = null === e ? "null" : typeof e;
    if ("string" !== t && "object" !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (H(e)) throw new Error("doc is valid.");
    let r = Object.prototype.toString.call(e);
    if ("[object Object]" !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e))([...W].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var K = class extends Error {
     name = "InvalidDocError";
     constructor(e) {
      super(J(e)), (this.doc = e);
     }
    },
    G = K,
    X = {};
   var Y = function (e, t, r, n) {
     let s = [e];
     for (; s.length > 0; ) {
      let e = s.pop();
      if (e === X) {
       r(s.pop());
       continue;
      }
      r && s.push(e, X);
      let i = H(e);
      if (!i) throw new G(e);
      if (!1 !== (null == t ? void 0 : t(e)))
       switch (i) {
        case I:
        case M: {
         let t = i === I ? e : e.parts;
         for (let e = t.length - 1; e >= 0; --e) s.push(t[e]);
         break;
        }
        case j:
         s.push(e.flatContents, e.breakContents);
         break;
        case O:
         if (n && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) s.push(e.expandedStates[t]);
         else s.push(e.contents);
         break;
        case _:
        case B:
        case R:
        case V:
        case q:
         s.push(e.contents);
         break;
        case P:
        case N:
        case L:
        case U:
        case $:
        case z:
         break;
        default:
         throw new G(e);
       }
     }
    },
    Q = () => {},
    Z = Q,
    ee = Q;
   function te(e) {
    return Z(e), { type: B, contents: e };
   }
   function re(e, t) {
    return Z(t), { type: _, contents: t, n: e };
   }
   function ne(e, t = {}) {
    return Z(e), ee(t.expandedStates, !0), { type: O, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function se(e) {
    return ee(e), { type: M, parts: e };
   }
   function ie(e) {
    return Z(e), { type: q, contents: e };
   }
   var ae = { type: U },
    oe = { type: z },
    ue = { type: L },
    le = { type: $, hard: !0 },
    pe = { type: $, hard: !0, literal: !0 },
    ce = { type: $ },
    he = { type: $, soft: !0 },
    de = [le, oe],
    fe = [pe, oe],
    me = { type: N };
   function ye(e, t) {
    Z(e), ee(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   function ge(e, t, r) {
    Z(e);
    let n = e;
    if (t > 0) {
     for (let e = 0; e < Math.floor(t / r); ++e) n = te(n);
     (n = re(t % r, n)), (n = re(Number.NEGATIVE_INFINITY, n));
    }
    return n;
   }
   function De(e) {
    var t;
    if (!e) return "";
    if (Array.isArray(e)) {
     let t = [];
     for (let r of e)
      if (Array.isArray(r)) t.push(...De(r));
      else {
       let e = De(r);
       "" !== e && t.push(e);
      }
     return t;
    }
    return e.type === j ? { ...e, breakContents: De(e.breakContents), flatContents: De(e.flatContents) } : e.type === O ? { ...e, contents: De(e.contents), expandedStates: null == (t = e.expandedStates) ? void 0 : t.map(De) } : e.type === M ? { type: "fill", parts: e.parts.map(De) } : e.contents ? { ...e, contents: De(e.contents) } : e;
   }
   var xe = (e, t, r) => {
    if (!e || null != t) return Array.isArray(t) || "string" == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
   };
   var be = (e) =>
     !(
      (function (e) {
       return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
      })(e) ||
      (function (e) {
       return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9800 && e <= 9811) || 9855 === e || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12771) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 19903) || (e >= 19968 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || 94192 === e || 94193 === e || (e >= 94208 && e <= 100343) || (e >= 100352 && e <= 101589) || (e >= 101632 && e <= 101640) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128727) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129672) || (e >= 129680 && e <= 129725) || (e >= 129727 && e <= 129733) || (e >= 129742 && e <= 129755) || (e >= 129760 && e <= 129768) || (e >= 129776 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
      })(e)
     ),
    ve = /[^\x20-\x7F]/;
   var Ee = function (e) {
     if (!e) return 0;
     if (!ve.test(e)) return e.length;
     e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, "  ");
     let t = 0;
     for (let r of e) {
      let e = r.codePointAt(0);
      e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (t += be(e) ? 1 : 2);
     }
     return t;
    },
    Ce = (e) => {
     if (Array.isArray(e)) return e;
     if (e.type !== M) throw new Error(`Expect doc to be 'array' or '${M}'.`);
     return e.parts;
    };
   function Te(e, t) {
    if ("string" == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (H(e)) {
       case I:
        return t(e.map(n));
       case M:
        return t({ ...e, parts: e.parts.map(n) });
       case j:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case O: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case _:
       case B:
       case R:
       case V:
       case q:
        return t({ ...e, contents: n(e.contents) });
       case P:
       case N:
       case L:
       case U:
       case $:
       case z:
        return t(e);
       default:
        throw new G(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function we(e, t, r) {
    let n = r,
     s = !1;
    return (
     Y(e, function (e) {
      if (s) return !1;
      let r = t(e);
      void 0 !== r && ((s = !0), (n = r));
     }),
     n
    );
   }
   function Se(e) {
    if ((e.type === O && e.break) || (e.type === $ && e.hard) || e.type === z) return !0;
   }
   function Ae(e) {
    if (e.length > 0) {
     let t = xe(!1, e, -1);
     !t.expandedStates && !t.break && (t.break = "propagated");
    }
    return null;
   }
   function Fe(e) {
    return e.type !== $ || e.hard ? (e.type === j ? e.flatContents : e) : e.soft ? "" : " ";
   }
   function ke(e) {
    for (e = [...e]; e.length >= 2 && xe(!1, e, -2).type === $ && xe(!1, e, -1).type === z; ) e.length -= 2;
    if (e.length > 0) {
     let t = Pe(xe(!1, e, -1));
     e[e.length - 1] = t;
    }
    return e;
   }
   function Pe(e) {
    switch (H(e)) {
     case _:
     case B:
     case R:
     case O:
     case q:
     case V: {
      let t = Pe(e.contents);
      return { ...e, contents: t };
     }
     case j:
      return { ...e, breakContents: Pe(e.breakContents), flatContents: Pe(e.flatContents) };
     case M:
      return { ...e, parts: ke(e.parts) };
     case I:
      return ke(e);
     case P:
      return e.replace(/[\n\r]*$/, "");
     case N:
     case L:
     case U:
     case $:
     case z:
      break;
     default:
      throw new G(e);
    }
    return e;
   }
   function Ie(e) {
    return Pe(
     (function (e) {
      return Te(e, (e) =>
       (function (e) {
        switch (H(e)) {
         case M:
          if (e.parts.every((e) => "" === e)) return "";
          break;
         case O:
          if (!(e.contents || e.id || e.break || e.expandedStates)) return "";
          if (e.contents.type === O && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
          break;
         case _:
         case B:
         case R:
         case q:
          if (!e.contents) return "";
          break;
         case j:
          if (!e.flatContents && !e.breakContents) return "";
          break;
         case I: {
          let t = [];
          for (let r of e) {
           if (!r) continue;
           let [e, ...n] = Array.isArray(r) ? r : [r];
           "string" == typeof e && "string" == typeof xe(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...n);
          }
          return 0 === t.length ? "" : 1 === t.length ? t[0] : t;
         }
         case P:
         case N:
         case L:
         case U:
         case $:
         case V:
         case z:
          break;
         default:
          throw new G(e);
        }
        return e;
       })(e),
      );
     })(e),
    );
   }
   function Ne(e) {
    if (e.type === $) return !0;
   }
   function Be(e, t) {
    return e.type === V ? { ...e, contents: t(e.contents) } : t(e);
   }
   var _e = Symbol("MODE_BREAK"),
    Le = Symbol("MODE_FLAT"),
    Oe = Symbol("cursor");
   function Me(e, t) {
    return Re(e, { type: "indent" }, t);
   }
   function je(e, t, r) {
    return t === Number.NEGATIVE_INFINITY ? e.root || { value: "", length: 0, queue: [] } : t < 0 ? Re(e, { type: "dedent" }, r) : t ? ("root" === t.type ? { ...e, root: e } : Re(e, { type: "string" == typeof t ? "stringAlign" : "numberAlign", n: t }, r)) : e;
   }
   function Re(e, t, r) {
    let n = "dedent" === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     s = "",
     i = 0,
     a = 0,
     o = 0;
    for (let d of n)
     switch (d.type) {
      case "indent":
       p(), r.useTabs ? u(1) : l(r.tabWidth);
       break;
      case "stringAlign":
       p(), (s += d.n), (i += d.n.length);
       break;
      case "numberAlign":
       (a += 1), (o += d.n);
       break;
      default:
       throw new Error(`Unexpected type '${d.type}'`);
     }
    return c(), { ...e, value: s, length: i, queue: n };
    function u(e) {
     (s += "\t".repeat(e)), (i += r.tabWidth * e);
    }
    function l(e) {
     (s += " ".repeat(e)), (i += e);
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     o > 0 && l(o), h();
    }
    function h() {
     (a = 0), (o = 0);
    }
   }
   function qe(e) {
    let t = 0,
     r = 0,
     n = e.length;
    e: for (; n--; ) {
     let s = e[n];
     if (s !== Oe)
      for (let r = s.length - 1; r >= 0; r--) {
       let i = s[r];
       if (" " !== i && "\t" !== i) {
        e[n] = s.slice(0, r + 1);
        break e;
       }
       t++;
      }
     else r++;
    }
    if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(Oe);
    return t;
   }
   function Ue(e, t, r, n, s, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = [e],
     u = [];
    for (; r >= 0; ) {
     if (0 === o.length) {
      if (0 === a) return !0;
      o.push(t[--a]);
      continue;
     }
     let { mode: e, doc: l } = o.pop();
     switch (H(l)) {
      case P:
       u.push(l), (r -= Ee(l));
       break;
      case I:
      case M: {
       let t = Ce(l);
       for (let r = t.length - 1; r >= 0; r--) o.push({ mode: e, doc: t[r] });
       break;
      }
      case B:
      case _:
      case R:
      case V:
       o.push({ mode: e, doc: l.contents });
       break;
      case L:
       r += qe(u);
       break;
      case O: {
       if (i && l.break) return !1;
       let t = l.break ? _e : e,
        r = l.expandedStates && t === _e ? xe(!1, l.expandedStates, -1) : l.contents;
       o.push({ mode: t, doc: r });
       break;
      }
      case j: {
       let t = (l.groupId ? s[l.groupId] || Le : e) === _e ? l.breakContents : l.flatContents;
       t && o.push({ mode: e, doc: t });
       break;
      }
      case $:
       if (e === _e || l.hard) return !0;
       l.soft || (u.push(" "), r--);
       break;
      case q:
       n = !0;
       break;
      case U:
       if (n) return !1;
     }
    }
    return !1;
   }
   function $e(e, t) {
    let r = {},
     n = t.printWidth,
     s = F(t.endOfLine),
     i = 0,
     a = [{ ind: { value: "", length: 0, queue: [] }, mode: _e, doc: e }],
     o = [],
     u = !1,
     l = [],
     p = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      Y(
       e,
       function (e) {
        if ((e.type === z && Ae(r), e.type === O)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === O && r.pop().break && Ae(r);
       },
       !0,
      );
     })(e);
     a.length > 0;

    ) {
     let { ind: e, mode: c, doc: h } = a.pop();
     switch (H(h)) {
      case P: {
       let e = "\n" !== s ? S(!1, h, "\n", s) : h;
       o.push(e), a.length > 0 && (i += Ee(e));
       break;
      }
      case I:
       for (let t = h.length - 1; t >= 0; t--) a.push({ ind: e, mode: c, doc: h[t] });
       break;
      case N:
       if (p >= 2) throw new Error("There are too many 'cursor' in doc.");
       o.push(Oe), p++;
       break;
      case B:
       a.push({ ind: Me(e, t), mode: c, doc: h.contents });
       break;
      case _:
       a.push({ ind: je(e, h.n, t), mode: c, doc: h.contents });
       break;
      case L:
       i -= qe(o);
       break;
      case O:
       switch (c) {
        case Le:
         if (!u) {
          a.push({ ind: e, mode: h.break ? _e : Le, doc: h.contents });
          break;
         }
        case _e: {
         u = !1;
         let t = { ind: e, mode: Le, doc: h.contents },
          s = n - i,
          o = l.length > 0;
         if (!h.break && Ue(t, a, s, o, r)) a.push(t);
         else if (h.expandedStates) {
          let t = xe(!1, h.expandedStates, -1);
          if (h.break) {
           a.push({ ind: e, mode: _e, doc: t });
           break;
          }
          for (let n = 1; n < h.expandedStates.length + 1; n++) {
           if (n >= h.expandedStates.length) {
            a.push({ ind: e, mode: _e, doc: t });
            break;
           }
           {
            let t = h.expandedStates[n],
             i = { ind: e, mode: Le, doc: t };
            if (Ue(i, a, s, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ ind: e, mode: _e, doc: h.contents });
         break;
        }
       }
       h.id && (r[h.id] = xe(!1, a, -1).mode);
       break;
      case M: {
       let t = n - i,
        { parts: s } = h;
       if (0 === s.length) break;
       let [o, u] = s,
        p = { ind: e, mode: Le, doc: o },
        d = { ind: e, mode: _e, doc: o },
        f = Ue(p, [], t, l.length > 0, r, !0);
       if (1 === s.length) {
        f ? a.push(p) : a.push(d);
        break;
       }
       let m = { ind: e, mode: Le, doc: u },
        y = { ind: e, mode: _e, doc: u };
       if (2 === s.length) {
        f ? a.push(m, p) : a.push(y, d);
        break;
       }
       s.splice(0, 2);
       let g = { ind: e, mode: c, doc: se(s) },
        D = s[0];
       Ue({ ind: e, mode: Le, doc: [o, u, D] }, [], t, l.length > 0, r, !0) ? a.push(g, m, p) : f ? a.push(g, y, p) : a.push(g, y, d);
       break;
      }
      case j:
      case R: {
       let t = h.groupId ? r[h.groupId] : c;
       if (t === _e) {
        let t = h.type === j ? h.breakContents : h.negate ? h.contents : te(h.contents);
        t && a.push({ ind: e, mode: c, doc: t });
       }
       if (t === Le) {
        let t = h.type === j ? h.flatContents : h.negate ? te(h.contents) : h.contents;
        t && a.push({ ind: e, mode: c, doc: t });
       }
       break;
      }
      case q:
       l.push({ ind: e, mode: c, doc: h.contents });
       break;
      case U:
       l.length > 0 && a.push({ ind: e, mode: c, doc: le });
       break;
      case $:
       switch (c) {
        case Le:
         if (!h.hard) {
          h.soft || (o.push(" "), (i += 1));
          break;
         }
         u = !0;
        case _e:
         if (l.length > 0) {
          a.push({ ind: e, mode: c, doc: h }, ...l.reverse()), (l.length = 0);
          break;
         }
         h.literal ? (e.root ? (o.push(s, e.root.value), (i = e.root.length)) : (o.push(s), (i = 0))) : ((i -= qe(o)), o.push(s + e.value), (i = e.length));
       }
       break;
      case V:
       a.push({ ind: e, mode: c, doc: h.contents });
       break;
      case z:
       break;
      default:
       throw new G(h);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let c = o.indexOf(Oe);
    if (-1 !== c) {
     let e = o.indexOf(Oe, c + 1),
      t = o.slice(0, c).join(""),
      r = o.slice(c + 1, e).join("");
     return { formatted: t + r + o.slice(e + 1).join(""), cursorNodeStart: t.length, cursorNodeText: r };
    }
    return { formatted: o.join("") };
   }
   var Ve,
    ze,
    We,
    He,
    Je = function (e, t, r = 0) {
     let n = 0;
     for (let s = r; s < e.length; ++s) "\t" === e[s] ? (n = n + t - (n % t)) : n++;
     return n;
    };
   (Ve = new WeakSet()),
    (ze = function (e) {
     let { stack: t } = this;
     for (let r = t.length - 1; r >= 0; r -= 2) if (!Array.isArray(t[r]) && --e < 0) return r;
     return -1;
    }),
    (We = new WeakSet()),
    (He = function* () {
     let { stack: e } = this;
     for (let t = e.length - 3; t >= 0; t -= 2) {
      let r = e[t];
      Array.isArray(r) || (yield r);
     }
    });
   var Ke = class {
     constructor(e) {
      d(this, Ve), d(this, We), (this.stack = [e]);
     }
     get key() {
      let { stack: e, siblings: t } = this;
      return xe(!1, e, null === t ? -2 : -4) ?? null;
     }
     get index() {
      return null === this.siblings ? null : xe(!1, this.stack, -2);
     }
     get node() {
      return xe(!1, this.stack, -1);
     }
     get parent() {
      return this.getNode(1);
     }
     get grandparent() {
      return this.getNode(2);
     }
     get isInArray() {
      return null !== this.siblings;
     }
     get siblings() {
      let { stack: e } = this,
       t = xe(!1, e, -3);
      return Array.isArray(t) ? t : null;
     }
     get next() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index + 1];
     }
     get previous() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index - 1];
     }
     get isFirst() {
      return 0 === this.index;
     }
     get isLast() {
      let { siblings: e, index: t } = this;
      return null !== e && t === e.length - 1;
     }
     get isRoot() {
      return 1 === this.stack.length;
     }
     get root() {
      return this.stack[0];
     }
     get ancestors() {
      return [...f(this, We, He).call(this)];
     }
     getName() {
      let { stack: e } = this,
       { length: t } = e;
      return t > 1 ? xe(!1, e, -2) : null;
     }
     getValue() {
      return xe(!1, this.stack, -1);
     }
     getNode(e = 0) {
      let t = f(this, Ve, ze).call(this, e);
      return -1 === t ? null : this.stack[t];
     }
     getParentNode(e = 0) {
      return this.getNode(e + 1);
     }
     call(e, ...t) {
      let { stack: r } = this,
       { length: n } = r,
       s = xe(!1, r, -1);
      for (let i of t) (s = s[i]), r.push(i, s);
      try {
       return e(this);
      } finally {
       r.length = n;
      }
     }
     callParent(e, t = 0) {
      let r = f(this, Ve, ze).call(this, t + 1),
       n = this.stack.splice(r + 1);
      try {
       return e(this);
      } finally {
       this.stack.push(...n);
      }
     }
     each(e, ...t) {
      let { stack: r } = this,
       { length: n } = r,
       s = xe(!1, r, -1);
      for (let i of t) (s = s[i]), r.push(i, s);
      try {
       for (let t = 0; t < s.length; ++t) r.push(t, s[t]), e(this, t, s), (r.length -= 2);
      } finally {
       r.length = n;
      }
     }
     map(e, ...t) {
      let r = [];
      return (
       this.each(
        (t, n, s) => {
         r[n] = e(t, n, s);
        },
        ...t,
       ),
       r
      );
     }
     match(...e) {
      let t = this.stack.length - 1,
       r = null,
       n = this.stack[t--];
      for (let s of e) {
       if (void 0 === n) return !1;
       let e = null;
       if (("number" == typeof r && ((e = r), (r = this.stack[t--]), (n = this.stack[t--])), s && !s(n, r, e))) return !1;
       (r = this.stack[t--]), (n = this.stack[t--]);
      }
      return !0;
     }
     findAncestor(e) {
      for (let t of f(this, We, He).call(this)) if (e(t)) return t;
     }
     hasAncestor(e) {
      for (let t of f(this, We, He).call(this)) if (e(t)) return !0;
      return !1;
     }
    },
    Ge = new Proxy(() => {}, { get: () => Ge }),
    Xe = Ge;
   var Ye = function (e) {
    return null !== e && "object" == typeof e;
   };
   function* Qe(e, t) {
    let { getVisitorKeys: r, filter: n = () => !0 } = t,
     s = (e) => Ye(e) && n(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) s(e) && (yield e);
     else s(t) && (yield t);
    }
   }
   function Ze(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   var et = Ze(/\s/),
    tt = Ze(" \t"),
    rt = Ze(",; \t"),
    nt = Ze(/[^\n\r]/);
   var st = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ("\r" === e.charAt(t - 1) && "\n" === s) return t - 2;
     if ("\n" === s || "\r" === s || "\u2028" === s || "\u2029" === s) return t - 1;
    } else {
     if ("\r" === s && "\n" === e.charAt(t + 1)) return t + 2;
     if ("\n" === s || "\r" === s || "\u2028" === s || "\u2029" === s) return t + 1;
    }
    return t;
   };
   var it = function (e, t, r = {}) {
    let n = tt(e, r.backwards ? t - 1 : t, r);
    return n !== st(e, n, r);
   };
   var at = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    ot = new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]),
    ut = (e) => Object.keys(e).filter((e) => !ot.has(e));
   var lt = function (e) {
    return e ? (t) => e(t, ot) : ut;
   };
   function pt(e, t) {
    (e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || "(unknown type)",
       r = String(e.name || (e.id && ("object" == typeof e.id ? e.id.name : e.id)) || (e.key && ("object" == typeof e.key ? e.key.name : e.key)) || (e.value && ("object" == typeof e.value ? "" : String(e.value))) || e.operator || "");
      return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t + (r ? " " + r : "");
     })(e));
   }
   function ct(e, t) {
    (t.leading = !0), (t.trailing = !1), pt(e, t);
   }
   function ht(e, t, r) {
    (t.leading = !1), (t.trailing = !1), r && (t.marker = r), pt(e, t);
   }
   function dt(e, t) {
    (t.leading = !1), (t.trailing = !0), pt(e, t);
   }
   var ft = new WeakMap();
   function mt(e, t) {
    if (ft.has(e)) return ft.get(e);
    let {
     printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: s },
     locStart: i,
     locEnd: a,
    } = t;
    if (!n) return [];
    let o = ((null == r ? void 0 : r(e, t)) ?? [...Qe(e, { getVisitorKeys: lt(s) })]).flatMap((e) => (n(e) ? [e] : mt(e, t)));
    return o.sort((e, t) => i(e) - i(t) || a(e) - a(t)), ft.set(e, o), o;
   }
   function yt(e, t, r, n) {
    let s,
     i,
     { locStart: a, locEnd: o } = r,
     u = a(t),
     l = o(t),
     p = mt(e, r),
     c = 0,
     h = p.length;
    for (; c < h; ) {
     let e = (c + h) >> 1,
      n = p[e],
      d = a(n),
      f = o(n);
     if (d <= u && l <= f) return yt(n, t, r, n);
     if (f <= u) (s = n), (c = e + 1);
     else {
      if (!(l <= d)) throw new Error("Comment location overlaps with node location");
      (i = n), (h = e);
     }
    }
    if ("TemplateLiteral" === (null == n ? void 0 : n.type)) {
     let { quasis: e } = n,
      a = Et(e, t, r);
     s && Et(e, s, r) !== a && (s = null), i && Et(e, i, r) !== a && (i = null);
    }
    return { enclosingNode: n, precedingNode: s, followingNode: i };
   }
   var gt = () => !1;
   var Dt = (e) => !/[\S\n\u2028\u2029]/.test(e);
   function xt(e, t, r, n) {
    let { comment: s, precedingNode: i } = r[n],
     { locStart: a, locEnd: o } = t,
     u = a(s);
    if (i)
     for (let l = n - 1; l >= 0; l--) {
      let { comment: t, precedingNode: n } = r[l];
      if (n !== i || !Dt(e.slice(o(t), u))) break;
      u = a(t);
     }
    return it(e, u, { backwards: !0 });
   }
   function bt(e, t, r, n) {
    let { comment: s, followingNode: i } = r[n],
     { locStart: a, locEnd: o } = t,
     u = o(s);
    if (i)
     for (let l = n + 1; l < r.length; l++) {
      let { comment: t, followingNode: n } = r[l];
      if (n !== i || !Dt(e.slice(u, a(t)))) break;
      u = o(t);
     }
    return it(e, u);
   }
   function vt(e, t) {
    var r, n;
    let s = e.length;
    if (0 === s) return;
    let i,
     { precedingNode: a, followingNode: o } = e[0],
     u = t.locStart(o);
    for (i = s; i > 0; --i) {
     let { comment: s, precedingNode: l, followingNode: p } = e[i - 1];
     Xe.strictEqual(l, a), Xe.strictEqual(p, o);
     let c = t.originalText.slice(t.locEnd(s), u);
     if (!((null == (n = (r = t.printer).isGap) ? void 0 : n.call(r, c, t)) ?? /^[\s(]*$/.test(c))) break;
     u = t.locStart(s);
    }
    for (let [l, { comment: p }] of e.entries()) l < i ? dt(a, p) : ct(o, p);
    for (let l of [a, o]) l.comments && l.comments.length > 1 && l.comments.sort((e, r) => t.locStart(e) - t.locStart(r));
    e.length = 0;
   }
   function Et(e, t, r) {
    let n = r.locStart(t) - 1;
    for (let s = 1; s < e.length; ++s) if (n < r.locStart(e[s])) return s - 1;
    return 0;
   }
   var Ct = function (e, t) {
    let r = t - 1;
    return (r = tt(e, r, { backwards: !0 })), (r = st(e, r, { backwards: !0 })), (r = tt(e, r, { backwards: !0 })), r !== st(e, r, { backwards: !0 });
   };
   function Tt(e, t) {
    return (e.node.printed = !0), t.printer.printComment(e, t);
   }
   function wt(e, t) {
    let r = e.node;
    if (!r) return {};
    let n = t[Symbol.for("printedComments")];
    if (0 === (r.comments || []).filter((e) => !n.has(e)).length) return { leading: "", trailing: "" };
    let s,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (null != n && n.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           var r;
           let n = e.node,
            s = [Tt(e, t)],
            { printer: i, originalText: a, locStart: o, locEnd: u } = t;
           if (null == (r = i.isBlockComment) ? void 0 : r.call(i, n)) {
            let e = it(a, u(n)) ? (it(a, o(n), { backwards: !0 }) ? de : ce) : " ";
            s.push(e);
           } else s.push(de);
           let l = st(a, tt(a, u(n)));
           return !1 !== l && it(a, l) && s.push(de), s;
          })(e, t),
         )
       : u &&
         ((s = (function (e, t, r) {
          var n;
          let s = e.node,
           i = Tt(e, t),
           { printer: a, originalText: o, locStart: u } = t,
           l = null == (n = a.isBlockComment) ? void 0 : n.call(a, s);
          if ((null != r && r.hasLineSuffix && (null == r || !r.isBlock)) || it(o, u(s), { backwards: !0 })) {
           let e = Ct(o, u(s));
           return { doc: ie([de, e ? de : "", i]), isBlock: l, hasLineSuffix: !0 };
          }
          return !l || (null != r && r.hasLineSuffix) ? { doc: [ie([" ", i]), oe], isBlock: l, hasLineSuffix: !0 } : { doc: [" ", i], isBlock: l, hasLineSuffix: !1 };
         })(e, t, s)),
         a.push(s.doc));
     }, "comments"),
     { leading: i, trailing: a }
    );
   }
   var St = function (e) {
     return () => {};
    },
    At = class extends Error {
     name = "ConfigError";
    },
    Ft = class extends Error {
     name = "UndefinedParserError";
    },
    kt = {
     cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" },
     endOfLine: {
      category: "Global",
      type: "choice",
      default: "lf",
      description: "Which end of line characters to apply.",
      choices: [
       { value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" },
       { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" },
       { value: "cr", description: "Carriage Return character only (\\r), used very rarely" },
       { value: "auto", description: "Maintain existing\n(mixed values within one file are normalised by looking at what's used after the first line)" },
      ],
     },
     filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." },
     insertPragma: { category: "Special", type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" },
     parser: {
      category: "Global",
      type: "choice",
      default: void 0,
      description: "Which parser to use.",
      exception: (e) => "string" == typeof e || "function" == typeof e,
      choices: [
       { value: "flow", description: "Flow" },
       { value: "babel", description: "JavaScript" },
       { value: "babel-flow", description: "Flow" },
       { value: "babel-ts", description: "TypeScript" },
       { value: "typescript", description: "TypeScript" },
       { value: "acorn", description: "JavaScript" },
       { value: "espree", description: "JavaScript" },
       { value: "meriyah", description: "JavaScript" },
       { value: "css", description: "CSS" },
       { value: "less", description: "Less" },
       { value: "scss", description: "SCSS" },
       { value: "json", description: "JSON" },
       { value: "json5", description: "JSON5" },
       { value: "jsonc", description: "JSON with Comments" },
       { value: "json-stringify", description: "JSON.stringify" },
       { value: "graphql", description: "GraphQL" },
       { value: "markdown", description: "Markdown" },
       { value: "mdx", description: "MDX" },
       { value: "vue", description: "Vue" },
       { value: "yaml", description: "YAML" },
       { value: "glimmer", description: "Ember / Handlebars" },
       { value: "html", description: "HTML" },
       { value: "angular", description: "Angular" },
       { value: "lwc", description: "Lightning Web Components" },
      ],
     },
     plugins: { type: "path", array: !0, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => "string" == typeof e || "object" == typeof e, cliName: "plugin", cliCategory: "Config" },
     printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } },
     rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: "Format code ending at a given character offset (exclusive).\nThe range will extend forwards to the end of the selected statement.", cliCategory: "Editor" },
     rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: "Format code starting at a given character offset.\nThe range will extend backwards to the start of the first line containing the selected statement.", cliCategory: "Editor" },
     requirePragma: { category: "Special", type: "boolean", default: !1, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment\nin order for it to be formatted.", cliCategory: "Other" },
     tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } },
     useTabs: { category: "Global", type: "boolean", default: !1, description: "Indent with tabs instead of spaces." },
     embeddedLanguageFormatting: {
      category: "Global",
      type: "choice",
      default: "auto",
      description: "Control how Prettier formats quoted code embedded in the file.",
      choices: [
       { value: "auto", description: "Format embedded code if Prettier can automatically identify it." },
       { value: "off", description: "Never automatically format embedded code." },
      ],
     },
    };
   function Pt({ plugins: e = [], showDeprecated: t = !1 } = {}) {
    let r = e.flatMap((e) => e.languages ?? []),
     n = [];
    for (let s of (function (e) {
     let t = [];
     for (let [r, n] of Object.entries(e)) {
      let e = { name: r, ...n };
      Array.isArray(e.default) && (e.default = xe(!1, e.default, -1).value), t.push(e);
     }
     return t;
    })(Object.assign({}, ...e.map(({ options: e }) => e), kt)))
     (!t && s.deprecated) ||
      (Array.isArray(s.choices) && (t || (s.choices = s.choices.filter((e) => !e.deprecated)), "parser" === s.name && (s.choices = [...s.choices, ...It(s.choices, r, e)])),
      (s.pluginDefaults = Object.fromEntries(
       e
        .filter((e) => {
         var t;
         return void 0 !== (null == (t = e.defaultOptions) ? void 0 : t[s.name]);
        })
        .map((e) => [e.name, e.defaultOptions[s.name]]),
      )),
      n.push(s));
    return { languages: r, options: n };
   }
   function* It(e, t, r) {
    let n = new Set(e.map((e) => e.value));
    for (let s of t)
     if (s.parsers)
      for (let e of s.parsers)
       if (!n.has(e)) {
        n.add(e);
        let t = r.find((t) => t.parsers && Object.prototype.hasOwnProperty.call(t.parsers, e)),
         i = s.name;
        null != t && t.name && (i += ` (plugin: ${t.name})`), yield { value: e, description: i };
       }
   }
   var Nt = (e) => String(e).split(/[/\\]/).pop();
   function Bt(e, t) {
    if (!t) return;
    let r = Nt(t).toLowerCase();
    return e.find(({ filenames: e }) => (null == e ? void 0 : e.some((e) => e.toLowerCase() === r))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.some((e) => r.endsWith(e))));
   }
   var _t = function (e, t) {
     let r = e.plugins.flatMap((e) => e.languages ?? []),
      n =
       (function (e, t) {
        if (t) return e.find(({ name: e }) => e.toLowerCase() === t) ?? e.find(({ aliases: e }) => (null == e ? void 0 : e.includes(t))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.includes(`.${t}`)));
       })(r, t.language) ??
       Bt(r, t.physicalFile) ??
       Bt(r, t.file) ??
       void t.physicalFile;
     return null == n ? void 0 : n.parsers[0];
    },
    Lt = {
     key: (e) => (/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e)),
     value(e) {
      if (null === e || "object" != typeof e) return JSON.stringify(e);
      if (Array.isArray(e)) return `[${e.map((e) => Lt.value(e)).join(", ")}]`;
      let t = Object.keys(e);
      return 0 === t.length ? "{}" : `{ ${t.map((t) => `${Lt.key(t)}: ${Lt.value(e[t])}`).join(", ")} }`;
     },
     pair: ({ key: e, value: t }) => Lt.value({ [e]: t }),
    },
    Ot = h(g(), 1),
    Mt = h(g(), 1),
    jt = Symbol.for("vnopts.VALUE_NOT_EXIST"),
    Rt = Symbol.for("vnopts.VALUE_UNCHANGED"),
    qt = " ".repeat(2);
   function Ut(e, t, r, n) {
    return [`Invalid ${Mt.default.red(n.key(e))} value.`, `Expected ${Mt.default.blue(r)},`, `but received ${t === jt ? Mt.default.gray("nothing") : Mt.default.red(n.value(t))}.`].join(" ");
   }
   function $t({ text: e, list: t }, r) {
    let n = [];
    return e && n.push(`- ${Mt.default.blue(e)}`), t && n.push([`- ${Mt.default.blue(t.title)}:`].concat(t.values.map((e) => $t(e, r - qt.length).replace(/^|\n/g, `$&${qt}`))).join("\n")), Vt(n, r);
   }
   function Vt(e, t) {
    if (1 === e.length) return e[0];
    let [r, n] = e,
     [s, i] = e.map((e) => e.split("\n", 1)[0].length);
    return s > t && s > i ? n : r;
   }
   var zt = h(g(), 1),
    Wt = [],
    Ht = [];
   var Jt = (e, t, { descriptor: r, logger: n, schemas: s }) => {
     let i = [`Ignored unknown option ${zt.default.yellow(r.pair({ key: e, value: t }))}.`],
      a = Object.keys(s)
       .sort()
       .find(
        (t) =>
         (function (e, t) {
          if (e === t) return 0;
          let r = e;
          e.length > t.length && ((e = t), (t = r));
          let n = e.length,
           s = t.length;
          for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-s); ) n--, s--;
          let i = 0;
          for (; i < n && e.charCodeAt(i) === t.charCodeAt(i); ) i++;
          if (((n -= i), (s -= i), 0 === n)) return s;
          let a,
           o,
           u,
           l,
           p = 0,
           c = 0;
          for (; p < n; ) (Ht[p] = e.charCodeAt(i + p)), (Wt[p] = ++p);
          for (; c < s; ) for (a = t.charCodeAt(i + c), u = c++, o = c, p = 0; p < n; p++) (l = a === Ht[p] ? u : u + 1), (u = Wt[p]), (o = Wt[p] = u > o ? (l > o ? o + 1 : l) : l > u ? u + 1 : l);
          return o;
         })(e, t) < 3,
       );
     a && i.push(`Did you mean ${zt.default.blue(r.key(a))}?`), n.warn(i.join(" "));
    },
    Kt = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
   var Gt = class {
    static create(e) {
     return (function (e, t) {
      let r = new e(t),
       n = Object.create(r);
      for (let s of Kt) s in t && (n[s] = Xt(t[s], r, Gt.prototype[s].length));
      return n;
     })(this, e);
    }
    constructor(e) {
     this.name = e.name;
    }
    default(e) {}
    expected(e) {
     return "nothing";
    }
    validate(e, t) {
     return !1;
    }
    deprecated(e, t) {
     return !1;
    }
    forward(e, t) {}
    redirect(e, t) {}
    overlap(e, t, r) {
     return e;
    }
    preprocess(e, t) {
     return e;
    }
    postprocess(e, t) {
     return Rt;
    }
   };
   function Xt(e, t, r) {
    return "function" == typeof e ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
   }
   var Yt = class extends Gt {
     constructor(e) {
      super(e), (this._sourceName = e.sourceName);
     }
     expected(e) {
      return e.schemas[this._sourceName].expected(e);
     }
     validate(e, t) {
      return t.schemas[this._sourceName].validate(e, t);
     }
     redirect(e, t) {
      return this._sourceName;
     }
    },
    Qt = class extends Gt {
     expected() {
      return "anything";
     }
     validate() {
      return !0;
     }
    },
    Zt = class extends Gt {
     constructor({ valueSchema: e, name: t = e.name, ...r }) {
      super({ ...r, name: t }), (this._valueSchema = e);
     }
     expected(e) {
      let { text: t, list: r } = e.normalizeExpectedResult(this._valueSchema.expected(e));
      return { text: t && `an array of ${t}`, list: r && { title: "an array of the following values", values: [{ list: r }] } };
     }
     validate(e, t) {
      if (!Array.isArray(e)) return !1;
      let r = [];
      for (let n of e) {
       let e = t.normalizeValidateResult(this._valueSchema.validate(n, t), n);
       !0 !== e && r.push(e.value);
      }
      return 0 === r.length || { value: r };
     }
     deprecated(e, t) {
      let r = [];
      for (let n of e) {
       let e = t.normalizeDeprecatedResult(this._valueSchema.deprecated(n, t), n);
       !1 !== e && r.push(...e.map(({ value: e }) => ({ value: [e] })));
      }
      return r;
     }
     forward(e, t) {
      let r = [];
      for (let n of e) {
       let e = t.normalizeForwardResult(this._valueSchema.forward(n, t), n);
       r.push(...e.map(er));
      }
      return r;
     }
     redirect(e, t) {
      let r = [],
       n = [];
      for (let s of e) {
       let e = t.normalizeRedirectResult(this._valueSchema.redirect(s, t), s);
       "remain" in e && r.push(e.remain), n.push(...e.redirect.map(er));
      }
      return 0 === r.length ? { redirect: n } : { redirect: n, remain: r };
     }
     overlap(e, t) {
      return e.concat(t);
     }
    };
   function er({ from: e, to: t }) {
    return { from: [e], to: t };
   }
   var tr = class extends Gt {
    expected() {
     return "true or false";
    }
    validate(e) {
     return "boolean" == typeof e;
    }
   };
   function rr(e, t) {
    let r = Object.create(null);
    for (let n of e) {
     let e = n[t];
     if (r[e]) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
     r[e] = n;
    }
    return r;
   }
   function nr(e, t) {
    if (e === t) return 0;
    let r = typeof e,
     n = typeof t,
     s = ["undefined", "object", "boolean", "number", "string"];
    return r !== n ? s.indexOf(r) - s.indexOf(n) : "string" !== r ? Number(e) - Number(t) : e.localeCompare(t);
   }
   function sr(e) {
    return void 0 === e ? {} : e;
   }
   function ir(e) {
    if ("string" == typeof e) return { text: e };
    let { text: t, list: r } = e;
    return (
     (function (e, t) {
      if (!e) throw new Error(t);
     })(void 0 !== (t || r), "Unexpected `expected` result, there should be at least one field."),
     r ? { text: t, list: { title: r.title, values: r.values.map(ir) } } : { text: t }
    );
   }
   function ar(e, t) {
    return !0 === e || (!1 === e ? { value: t } : e);
   }
   function or(e, t, r = !1) {
    return !1 !== e && (!0 === e ? !!r || [{ value: t }] : "value" in e ? [e] : 0 !== e.length && e);
   }
   function ur(e, t) {
    return "string" == typeof e || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
   }
   function lr(e, t) {
    return void 0 === e ? [] : Array.isArray(e) ? e.map((e) => ur(e, t)) : [ur(e, t)];
   }
   function pr(e, t) {
    let r = lr("object" == typeof e && "redirect" in e ? e.redirect : e, t);
    return 0 === r.length ? { remain: t, redirect: r } : "object" == typeof e && "remain" in e ? { remain: e.remain, redirect: r } : { redirect: r };
   }
   var cr,
    hr = class extends Gt {
     constructor(e) {
      super(e),
       (this._choices = (function (e, t) {
        let r = new Map();
        for (let n of e) {
         let e = n[t];
         if (r.has(e)) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
         r.set(e, n);
        }
        return r;
       })(
        e.choices.map((e) => (e && "object" == typeof e ? e : { value: e })),
        "value",
       ));
     }
     expected({ descriptor: e }) {
      let t = Array.from(this._choices.keys())
        .map((e) => this._choices.get(e))
        .filter(({ hidden: e }) => !e)
        .map((e) => e.value)
        .sort(nr)
        .map(e.value),
       r = t.slice(0, -2),
       n = t.slice(-2);
      return { text: r.concat(n.join(" or ")).join(", "), list: { title: "one of the following values", values: t } };
     }
     validate(e) {
      return this._choices.has(e);
     }
     deprecated(e) {
      let t = this._choices.get(e);
      return !(!t || !t.deprecated) && { value: e };
     }
     forward(e) {
      let t = this._choices.get(e);
      return t ? t.forward : void 0;
     }
     redirect(e) {
      let t = this._choices.get(e);
      return t ? t.redirect : void 0;
     }
    },
    dr = class extends Gt {
     expected() {
      return "a number";
     }
     validate(e, t) {
      return "number" == typeof e;
     }
    },
    fr = class extends dr {
     expected() {
      return "an integer";
     }
     validate(e, t) {
      return (
       !0 === t.normalizeValidateResult(super.validate(e, t), e) &&
       (function (e) {
        return e === Math.floor(e);
       })(e)
      );
     }
    },
    mr = class extends Gt {
     expected() {
      return "a string";
     }
     validate(e) {
      return "string" == typeof e;
     }
    },
    yr = Lt,
    gr = Jt,
    Dr = (e, t, r) => {
     let { text: n, list: s } = r.normalizeExpectedResult(r.schemas[e].expected(r)),
      i = [];
     return n && i.push(Ut(e, t, n, r.descriptor)), s && i.push([Ut(e, t, s.title, r.descriptor)].concat(s.values.map((e) => $t(e, r.loggerPrintWidth))).join("\n")), Vt(i, r.loggerPrintWidth);
    },
    xr = (e, t, { descriptor: r }) => {
     let n = [`${Ot.default.yellow("string" == typeof e ? r.key(e) : r.pair(e))} is deprecated`];
     return t && n.push(`we now treat it as ${Ot.default.blue("string" == typeof t ? r.key(t) : r.pair(t))}`), n.join("; ") + ".";
    },
    br = class {
     constructor(e, t) {
      let { logger: r = console, loggerPrintWidth: n = 80, descriptor: s = yr, unknown: i = gr, invalid: a = Dr, deprecated: o = xr, missing: u = () => !1, required: l = () => !1, preprocess: p = (e) => e, postprocess: c = () => Rt } = t || {};
      (this._utils = { descriptor: s, logger: r || { warn: () => {} }, loggerPrintWidth: n, schemas: rr(e, "name"), normalizeDefaultResult: sr, normalizeExpectedResult: ir, normalizeDeprecatedResult: or, normalizeForwardResult: lr, normalizeRedirectResult: pr, normalizeValidateResult: ar }),
       (this._unknownHandler = i),
       (this._invalidHandler = (function (e) {
        return (...t) => {
         let r = e(...t);
         return "string" == typeof r ? new Error(r) : r;
        };
       })(a)),
       (this._deprecatedHandler = o),
       (this._identifyMissing = (e, t) => !(e in t) || u(e, t)),
       (this._identifyRequired = l),
       (this._preprocess = p),
       (this._postprocess = c),
       this.cleanHistory();
     }
     cleanHistory() {
      this._hasDeprecationWarned = (function () {
       let e = Object.create(null);
       return (t) => {
        let r = JSON.stringify(t);
        return !!e[r] || ((e[r] = !0), !1);
       };
      })();
     }
     normalize(e) {
      let t = {},
       r = [this._preprocess(e, this._utils)],
       n = () => {
        for (; 0 !== r.length; ) {
         let e = r.shift(),
          n = this._applyNormalization(e, t);
         r.push(...n);
        }
       };
      n();
      for (let s of Object.keys(this._utils.schemas)) {
       let e = this._utils.schemas[s];
       if (!(s in t)) {
        let t = sr(e.default(this._utils));
        "value" in t && r.push({ [s]: t.value });
       }
      }
      n();
      for (let s of Object.keys(this._utils.schemas)) {
       if (!(s in t)) continue;
       let e = this._utils.schemas[s],
        r = t[s],
        n = e.postprocess(r, this._utils);
       n !== Rt && (this._applyValidation(n, s, e), (t[s] = n));
      }
      return this._applyPostprocess(t), this._applyRequiredCheck(t), t;
     }
     _applyNormalization(e, t) {
      let r = [],
       { knownKeys: n, unknownKeys: s } = this._partitionOptionKeys(e);
      for (let i of n) {
       let n = this._utils.schemas[i],
        s = n.preprocess(e[i], this._utils);
       this._applyValidation(s, i, n);
       let a = ({ from: e, to: t }) => {
         r.push("string" == typeof t ? { [t]: e } : { [t.key]: t.value });
        },
        o = ({ value: e, redirectTo: t }) => {
         let r = or(n.deprecated(e, this._utils), s, !0);
         if (!1 !== r)
          if (!0 === r) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, t, this._utils));
          else
           for (let { value: n } of r) {
            let e = { key: i, value: n };
            if (!this._hasDeprecationWarned(e)) {
             let r = "string" == typeof t ? { key: t, value: n } : t;
             this._utils.logger.warn(this._deprecatedHandler(e, r, this._utils));
            }
           }
        };
       lr(n.forward(s, this._utils), s).forEach(a);
       let u = pr(n.redirect(s, this._utils), s);
       if ((u.redirect.forEach(a), "remain" in u)) {
        let e = u.remain;
        (t[i] = i in t ? n.overlap(t[i], e, this._utils) : e), o({ value: e });
       }
       for (let { from: e, to: t } of u.redirect) o({ value: e, redirectTo: t });
      }
      for (let i of s) {
       let n = e[i];
       this._applyUnknownHandler(i, n, t, (e, t) => {
        r.push({ [e]: t });
       });
      }
      return r;
     }
     _applyRequiredCheck(e) {
      for (let t of Object.keys(this._utils.schemas)) if (this._identifyMissing(t, e) && this._identifyRequired(t)) throw this._invalidHandler(t, jt, this._utils);
     }
     _partitionOptionKeys(e) {
      let [t, r] = (function (e, t) {
       let r = [],
        n = [];
       for (let s of e) t(s) ? r.push(s) : n.push(s);
       return [r, n];
      })(
       Object.keys(e).filter((t) => !this._identifyMissing(t, e)),
       (e) => e in this._utils.schemas,
      );
      return { knownKeys: t, unknownKeys: r };
     }
     _applyValidation(e, t, r) {
      let n = ar(r.validate(e, this._utils), e);
      if (!0 !== n) throw this._invalidHandler(t, n.value, this._utils);
     }
     _applyUnknownHandler(e, t, r, n) {
      let s = this._unknownHandler(e, t, this._utils);
      if (s)
       for (let i of Object.keys(s)) {
        if (this._identifyMissing(i, s)) continue;
        let e = s[i];
        i in this._utils.schemas ? n(i, e) : (r[i] = e);
       }
     }
     _applyPostprocess(e) {
      let t = this._postprocess(e, this._utils);
      if (t !== Rt) {
       if (t.delete) for (let r of t.delete) delete e[r];
       if (t.override) {
        let { knownKeys: r, unknownKeys: n } = this._partitionOptionKeys(t.override);
        for (let s of r) {
         let r = t.override[s];
         this._applyValidation(r, s, this._utils.schemas[s]), (e[s] = r);
        }
        for (let s of n) {
         let r = t.override[s];
         this._applyUnknownHandler(s, r, e, (t, r) => {
          let n = this._utils.schemas[t];
          this._applyValidation(r, t, n), (e[t] = r);
         });
        }
       }
      }
     }
    };
   function vr(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
    let s,
     { name: i } = e,
     a = { name: i },
     o = {};
    switch (e.type) {
     case "int":
      (s = fr), t && (a.preprocess = Number);
      break;
     case "string":
     case "path":
      s = mr;
      break;
     case "choice":
      (s = hr), (a.choices = e.choices.map((t) => (null != t && t.redirect ? { ...t, redirect: { to: { key: e.name, value: t.redirect } } } : t)));
      break;
     case "boolean":
      s = tr;
      break;
     case "flag":
      (s = n), (a.flags = r.flatMap((e) => [e.alias, e.description && e.name, e.oppositeDescription && `no-${e.name}`].filter(Boolean)));
      break;
     default:
      throw new Error(`Unexpected type ${e.type}`);
    }
    if ((e.exception ? (a.validate = (t, r, n) => e.exception(t) || r.validate(t, n)) : (a.validate = (e, t, r) => void 0 === e || t.validate(e, r)), e.redirect && (o.redirect = (t) => (t ? { to: { key: e.redirect.option, value: e.redirect.value } } : void 0)), e.deprecated && (o.deprecated = !0), t && !e.array)) {
     let e = a.preprocess || ((e) => e);
     a.preprocess = (t, r, n) => r.preprocess(e(Array.isArray(t) ? xe(!1, t, -1) : t), n);
    }
    return e.array ? Zt.create({ ...(t ? { preprocess: (e) => (Array.isArray(e) ? e : [e]) } : {}), ...o, valueSchema: s.create(a) }) : s.create({ ...a, ...o });
   }
   var Er = function (e, t, { logger: r = !1, isCLI: n = !1, passThrough: s = !1, FlagSchema: i, descriptor: a } = {}) {
     if (n) {
      if (!i) throw new Error("'FlagSchema' option is required.");
      if (!a) throw new Error("'descriptor' option is required.");
     } else a = Lt;
     let o = s
       ? Array.isArray(s)
         ? (e, t) => (s.includes(e) ? { [e]: t } : void 0)
         : (e, t) => ({ [e]: t })
       : (e, t, r) => {
          let { _: n, ...s } = r.schemas;
          return Jt(e, t, { ...r, schemas: s });
         },
      u = (function (e, { isCLI: t, FlagSchema: r }) {
       let n = [];
       t && n.push(Qt.create({ name: "_" }));
       for (let s of e) n.push(vr(s, { isCLI: t, optionInfos: e, FlagSchema: r })), s.alias && t && n.push(Yt.create({ name: s.alias, sourceName: s.name }));
       return n;
      })(t, { isCLI: n, FlagSchema: i }),
      l = new br(u, { logger: r, unknown: o, descriptor: a }),
      p = !1 !== r;
     p && cr && (l._hasDeprecationWarned = cr);
     let c = l.normalize(e);
     return p && (cr = l._hasDeprecationWarned), c;
    },
    Cr = (e, t, r) => {
     if (!e || null != t) {
      if (t.findLast) return t.findLast(r);
      for (let e = t.length - 1; e >= 0; e--) {
       let n = t[e];
       if (r(n, e, t)) return n;
      }
     }
    };
   function Tr(e, t) {
    if (!t) throw new Error("parserName is required.");
    let r = Cr(!1, e, (e) => e.parsers && Object.prototype.hasOwnProperty.call(e.parsers, t));
    if (r) return r;
    let n = `Couldn't resolve parser "${t}".`;
    throw ((n += " Plugins must be explicitly added to the standalone bundle."), new At(n));
   }
   function wr({ plugins: e, parser: t }) {
    return Sr(Tr(e, t), t);
   }
   function Sr(e, t) {
    let r = e.parsers[t];
    return "function" == typeof r ? r() : r;
   }
   var Ar = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
   var Fr = async function (e, t = {}) {
     var r;
     let n = { ...e };
     if (!n.parser) {
      if (!n.filepath) throw new Ft("No parser and no file path given, couldn't infer a parser.");
      if (((n.parser = _t(n, { physicalFile: n.filepath })), !n.parser)) throw new Ft(`No parser could be inferred for file "${n.filepath}".`);
     }
     let s = Pt({ plugins: e.plugins, showDeprecated: !0 }).options,
      i = { ...Ar, ...Object.fromEntries(s.filter((e) => void 0 !== e.default).map((e) => [e.name, e.default])) },
      a = Tr(n.plugins, n.parser),
      o = await Sr(a, n.parser);
     (n.astFormat = o.astFormat), (n.locEnd = o.locEnd), (n.locStart = o.locStart);
     let u =
       null != (r = a.printers) && r[o.astFormat]
        ? a
        : (function (e, t) {
           if (!t) throw new Error("astFormat is required.");
           let r = Cr(!1, e, (e) => e.printers && Object.prototype.hasOwnProperty.call(e.printers, t));
           if (r) return r;
           let n = `Couldn't find plugin for AST format "${t}".`;
           throw ((n += " Plugins must be explicitly added to the standalone bundle."), new At(n));
          })(n.plugins, o.astFormat),
      l = await (function (e, t) {
       let r = e.printers[t];
       return "function" == typeof r ? r() : r;
      })(u, o.astFormat);
     n.printer = l;
     let p = { ...i, ...(u.defaultOptions ? Object.fromEntries(Object.entries(u.defaultOptions).filter(([, e]) => void 0 !== e)) : {}) };
     for (let [c, h] of Object.entries(p)) (null === n[c] || void 0 === n[c]) && (n[c] = h);
     return "json" === n.parser && (n.trailingComma = "none"), Er(n, s, { passThrough: Object.keys(Ar), ...t });
    },
    kr = h(T(), 1);
   var Pr = async function (e, t) {
    let r,
     n = await wr(t),
     s = n.preprocess ? n.preprocess(e, t) : e;
    t.originalText = s;
    try {
     r = await n.parse(s, t, t);
    } catch (i) {
     !(function (e, t) {
      let { loc: r } = e;
      if (r) {
       let n = (0, kr.codeFrameColumns)(t, r, { highlightCode: !0 });
       throw ((e.message += "\n" + n), (e.codeFrame = n), e);
      }
      throw e;
     })(i, e);
    }
    return { text: s, ast: r };
   };
   async function Ir(e, t, r, n, s) {
    let {
     embeddedLanguageFormatting: i,
     printer: { embed: a, hasPrettierIgnore: o = () => !1, getVisitorKeys: u },
    } = r;
    if (!a || "auto" !== i) return;
    if (a.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
    let l = lt(a.getVisitorKeys ?? u),
     p = [];
    !(function t() {
     let { node: n } = e;
     if (null === n || "object" != typeof n || o(e)) return;
     for (let r of l(n)) Array.isArray(n[r]) ? e.each(t, r) : e.call(t, r);
     let i = a(e, r);
     if (i) {
      if ("function" == typeof i) return void p.push({ print: i, node: n, pathStack: [...e.stack] });
      s.set(n, i);
     }
    })();
    let c = e.stack;
    for (let { print: f, node: m, pathStack: y } of p)
     try {
      e.stack = y;
      let n = await f(h, t, e, r);
      n && s.set(m, n);
     } catch (d) {
      if (globalThis.PRETTIER_DEBUG) throw d;
     }
    function h(e, t) {
     return (async function (e, t, r, n) {
      let s = await Fr({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: !0 }),
       { ast: i } = await Pr(e, s),
       a = await n(i, s);
      return Ie(a);
     })(e, t, r, n);
    }
    e.stack = c;
   }
   var Nr = function (e, t) {
    let { originalText: r, [Symbol.for("comments")]: n, locStart: s, locEnd: i, [Symbol.for("printedComments")]: a } = t,
     { node: o } = e,
     u = s(o),
     l = i(o);
    for (let p of n) s(p) >= u && i(p) <= l && a.add(p);
    return r.slice(u, l);
   };
   async function Br(e, t) {
    ({ ast: e } = await Lr(e, t));
    let r = new Map(),
     n = new Ke(e),
     s = St(t),
     i = new Map();
    await Ir(n, o, t, Br, i);
    let a = await _r(n, t, o, void 0, i);
    return (
     (function (e) {
      let { [Symbol.for("comments")]: t, [Symbol.for("printedComments")]: r } = e;
      for (let n of t) {
       if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
       delete n.printed;
      }
     })(t),
     a
    );
    function o(e, t) {
     return void 0 === e || e === n ? u(t) : Array.isArray(e) ? n.call(() => u(t), ...e) : n.call(() => u(t), e);
    }
    function u(e) {
     s(n);
     let a = n.node;
     if (null == a) return "";
     let u = a && "object" == typeof a && void 0 === e;
     if (u && r.has(a)) return r.get(a);
     let l = _r(n, t, o, e, i);
     return u && r.set(a, l), l;
    }
   }
   function _r(e, t, r, n, s) {
    var i;
    let a,
     { node: o } = e,
     { printer: u } = t;
    return (
     (a = null != (i = u.hasPrettierIgnore) && i.call(u, e) ? Nr(e, t) : s.has(o) ? s.get(o) : u.print(e, t, r, n)),
     o === t.cursorNode && (a = Be(a, (e) => [me, e, me])),
     u.printComment &&
      (!u.willPrintOwnComments || !u.willPrintOwnComments(e, t)) &&
      (a = (function (e, t, r) {
       let { leading: n, trailing: s } = wt(e, r);
       return n || s ? Be(t, (e) => [n, e, s]) : t;
      })(e, a, t)),
     a
    );
   }
   async function Lr(e, t) {
    let r = e.comments ?? [];
    (t[Symbol.for("comments")] = r),
     (t[Symbol.for("tokens")] = e.tokens ?? []),
     (t[Symbol.for("printedComments")] = new Set()),
     (function (e, t) {
      let { comments: r } = e;
      if ((delete e.comments, !at(r) || !t.printer.canAttachComment)) return;
      let n = [],
       {
        locStart: s,
        locEnd: i,
        printer: { experimentalFeatures: { avoidAstMutation: a = !1 } = {}, handleComments: o = {} },
        originalText: u,
       } = t,
       { ownLine: l = gt, endOfLine: p = gt, remaining: c = gt } = o,
       h = r.map((n, s) => ({ ...yt(e, n, t), comment: n, text: u, options: t, ast: e, isLastComment: r.length - 1 === s }));
      for (let [d, f] of h.entries()) {
       let e,
        { comment: t, precedingNode: r, enclosingNode: o, followingNode: u, text: m, options: y, ast: g, isLastComment: D } = f;
       if ("json" === y.parser || "json5" === y.parser || "jsonc" === y.parser || "__js_expression" === y.parser || "__ts_expression" === y.parser || "__vue_expression" === y.parser || "__vue_ts_expression" === y.parser) {
        if (s(t) - s(g) <= 0) {
         ct(g, t);
         continue;
        }
        if (i(t) - i(g) >= 0) {
         dt(g, t);
         continue;
        }
       }
       if ((a ? (e = [f]) : ((t.enclosingNode = o), (t.precedingNode = r), (t.followingNode = u), (e = [t, m, y, g, D])), xt(m, y, h, d))) (t.placement = "ownLine"), l(...e) || (u ? ct(u, t) : r ? dt(r, t) : ht(o || g, t));
       else if (bt(m, y, h, d)) (t.placement = "endOfLine"), p(...e) || (r ? dt(r, t) : u ? ct(u, t) : ht(o || g, t));
       else if (((t.placement = "remaining"), !c(...e)))
        if (r && u) {
         let e = n.length;
         e > 0 && n[e - 1].followingNode !== u && vt(n, y), n.push(f);
        } else r ? dt(r, t) : u ? ct(u, t) : ht(o || g, t);
      }
      if ((vt(n, t), !a)) for (let d of r) delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
     })(e, t);
    let {
     printer: { preprocess: n },
    } = t;
    return { ast: (e = n ? await n(e, t) : e), comments: r };
   }
   var Or = function (e, t) {
    let { cursorOffset: r, locStart: n, locEnd: s } = t,
     i = lt(t.printer.getVisitorKeys),
     a = (e) => n(e) <= r && s(e) >= r,
     o = e;
    for (let u of (function* (e, t) {
     let r = [e];
     for (let n = 0; n < r.length; n++) {
      let e = r[n];
      for (let n of Qe(e, t)) yield n, r.push(n);
     }
    })(e, { getVisitorKeys: i, filter: a }))
     o = u;
    return o;
   };
   var Mr = function (e, t) {
     let {
      printer: { massageAstNode: r, getVisitorKeys: n },
     } = t;
     if (!r) return e;
     let s = lt(n),
      i = r.ignoredProperties ?? new Set();
     return (function e(t, n) {
      if (null === t || "object" != typeof t) return t;
      if (Array.isArray(t)) return t.map((t) => e(t, n)).filter(Boolean);
      let a = {},
       o = new Set(s(t));
      for (let r in t) !Object.prototype.hasOwnProperty.call(t, r) || i.has(r) || (o.has(r) ? (a[r] = e(t[r], t)) : (a[r] = t[r]));
      let u = r(t, a, n);
      if (null !== u) return u ?? a;
     })(e);
    },
    jr = ({ parser: e }) => "json" === e || "json5" === e || "jsonc" === e || "json-stringify" === e;
   function Rr(e) {
    let t = e.length - 1;
    for (;;) {
     let r = e[t];
     if ("Program" !== (null == r ? void 0 : r.type) && "File" !== (null == r ? void 0 : r.type)) break;
     t--;
    }
    return e.slice(0, t + 1);
   }
   function qr(e, t, r, n, s = [], i) {
    let { locStart: a, locEnd: o } = r,
     u = a(e),
     l = o(e);
    if (!(t > l || t < u || ("rangeEnd" === i && t === u) || ("rangeStart" === i && t === l))) {
     for (let a of mt(e, r)) {
      let o = qr(a, t, r, n, [e, ...s], i);
      if (o) return o;
     }
     if (!n || n(e, s[0])) return { node: e, parentNodes: s };
    }
   }
   var Ur = new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]),
    $r = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
   function Vr(e, t, r) {
    if (!t) return !1;
    switch (e.parser) {
     case "flow":
     case "babel":
     case "babel-flow":
     case "babel-ts":
     case "typescript":
     case "acorn":
     case "espree":
     case "meriyah":
     case "__babel_estree":
      return (function (e, t) {
       return "DeclareExportDeclaration" !== t && "TypeParameterDeclaration" !== e && ("Directive" === e || "TypeAlias" === e || "TSExportAssignment" === e || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
      })(t.type, null == r ? void 0 : r.type);
     case "json":
     case "json5":
     case "jsonc":
     case "json-stringify":
      return Ur.has(t.type);
     case "graphql":
      return $r.has(t.kind);
     case "vue":
      return "root" !== t.tag;
    }
    return !1;
   }
   function zr(e, t, r) {
    let { rangeStart: n, rangeEnd: s, locStart: i, locEnd: a } = t;
    Xe.ok(s > n);
    let o = e.slice(n, s).search(/\S/),
     u = -1 === o;
    if (!u) for (n += o; s > n && !/\S/.test(e[s - 1]); --s);
    let l,
     p,
     c = qr(r, n, t, (e, r) => Vr(t, e, r), [], "rangeStart"),
     h = u ? c : qr(r, s, t, (e) => Vr(t, e), [], "rangeEnd");
    if (!c || !h) return { rangeStart: 0, rangeEnd: 0 };
    if (jr(t)) {
     let e = (function (e, t) {
      let r = [e.node, ...e.parentNodes],
       n = new Set([t.node, ...t.parentNodes]);
      return r.find((e) => Ur.has(e.type) && n.has(e));
     })(c, h);
     (l = e), (p = e);
    } else
     ({ startNode: l, endNode: p } = (function (e, t, { locStart: r, locEnd: n }) {
      let s = e.node,
       i = t.node;
      if (s === i) return { startNode: s, endNode: i };
      let a = r(e.node);
      for (let u of Rr(t.parentNodes)) {
       if (!(r(u) >= a)) break;
       i = u;
      }
      let o = n(t.node);
      for (let u of Rr(e.parentNodes)) {
       if (!(n(u) <= o)) break;
       if (((s = u), s === i)) break;
      }
      return { startNode: s, endNode: i };
     })(c, h, t));
    return { rangeStart: Math.min(i(l), i(p)), rangeEnd: Math.max(a(l), a(p)) };
   }
   var Wr = "\ufeff",
    Hr = Symbol("cursor");
   async function Jr(e, t, r = 0) {
    if (!e || 0 === e.trim().length) return { formatted: "", cursorOffset: -1, comments: [] };
    let { ast: n, text: s } = await Pr(e, t);
    t.cursorOffset >= 0 && (t.cursorNode = Or(n, t));
    let i = await Br(n, t);
    r > 0 && (i = ge([de, i], r, t.tabWidth));
    let a = $e(i, t);
    if (r > 0) {
     let e = a.formatted.trim();
     void 0 !== a.cursorNodeStart && (a.cursorNodeStart -= a.formatted.indexOf(e)), (a.formatted = e + F(t.endOfLine));
    }
    let o = t[Symbol.for("comments")];
    if (t.cursorOffset >= 0) {
     let e, r, n, i, u;
     if ((t.cursorNode && a.cursorNodeText ? ((e = t.locStart(t.cursorNode)), (r = s.slice(e, t.locEnd(t.cursorNode))), (n = t.cursorOffset - e), (i = a.cursorNodeStart), (u = a.cursorNodeText)) : ((e = 0), (r = s), (n = t.cursorOffset), (i = 0), (u = a.formatted)), r === u)) return { formatted: a.formatted, cursorOffset: i + n, comments: o };
     let l = r.split("");
     l.splice(n, 0, Hr);
     let p = u.split(""),
      c = (0, A.diffArrays)(l, p),
      h = i;
     for (let t of c)
      if (t.removed) {
       if (t.value.includes(Hr)) break;
      } else h += t.count;
     return { formatted: a.formatted, cursorOffset: h, comments: o };
    }
    return { formatted: a.formatted, cursorOffset: -1, comments: o };
   }
   function Kr(e, t, r) {
    return "number" != typeof t || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
   }
   function Gr(e, t) {
    let { cursorOffset: r, rangeStart: n, rangeEnd: s } = t;
    return (r = Kr(e, r, -1)), (n = Kr(e, n, 0)), (s = Kr(e, s, e.length)), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: s };
   }
   function Xr(e, t) {
    let { cursorOffset: r, rangeStart: n, rangeEnd: s, endOfLine: i } = Gr(e, t),
     a = e.charAt(0) === Wr;
    if (
     (a && ((e = e.slice(1)), r--, n--, s--),
     "auto" === i &&
      (i = (function (e) {
       let t = e.indexOf("\r");
       return t >= 0 ? ("\n" === e.charAt(t + 1) ? "crlf" : "cr") : "lf";
      })(e)),
     e.includes("\r"))
    ) {
     let t = (t) => k(e.slice(0, Math.max(t, 0)), "\r\n");
     (r -= t(r)),
      (n -= t(n)),
      (s -= t(s)),
      (e = (function (e) {
       return S(!1, e, /\r\n?/g, "\n");
      })(e));
    }
    return { hasBOM: a, text: e, options: Gr(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: s, endOfLine: i }) };
   }
   async function Yr(e, t) {
    let r = await wr(t);
    return !r.hasPragma || r.hasPragma(e);
   }
   async function Qr(e, t) {
    let r,
     { hasBOM: n, text: s, options: i } = Xr(e, await Fr(t));
    return (i.rangeStart >= i.rangeEnd && "" !== s) || (i.requirePragma && !(await Yr(s, i)))
     ? { formatted: e, cursorOffset: t.cursorOffset, comments: [] }
     : (i.rangeStart > 0 || i.rangeEnd < s.length
        ? (r = await (async function (e, t) {
           let { ast: r, text: n } = await Pr(e, t),
            { rangeStart: s, rangeEnd: i } = zr(n, t, r),
            a = n.slice(s, i),
            o = Math.min(s, n.lastIndexOf("\n", s) + 1),
            u = n.slice(o, s).match(/^\s*/)[0],
            l = Je(u, t.tabWidth),
            p = await Jr(a, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > s && t.cursorOffset <= i ? t.cursorOffset - s : -1, endOfLine: "lf" }, l),
            c = p.formatted.trimEnd(),
            { cursorOffset: h } = t;
           h > i ? (h += c.length - a.length) : p.cursorOffset >= 0 && (h = p.cursorOffset + s);
           let d = n.slice(0, s) + c + n.slice(i);
           if ("lf" !== t.endOfLine) {
            let e = F(t.endOfLine);
            h >= 0 && "\r\n" === e && (h += k(d.slice(0, h), "\n")), (d = S(!1, d, "\n", e));
           }
           return { formatted: d, cursorOffset: h, comments: p.comments };
          })(s, i))
        : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !(await Yr(s, i)) && (s = i.printer.insertPragma(s)), (r = await Jr(s, i))),
       n && ((r.formatted = Wr + r.formatted), r.cursorOffset >= 0 && r.cursorOffset++),
       r);
   }
   var Zr = {};
   p(Zr, { builders: () => en, printer: () => tn, utils: () => rn });
   var en = {
     join: ye,
     line: ce,
     softline: he,
     hardline: de,
     literalline: fe,
     group: ne,
     conditionalGroup: function (e, t) {
      return ne(e[0], { ...t, expandedStates: e });
     },
     fill: se,
     lineSuffix: ie,
     lineSuffixBoundary: ae,
     cursor: me,
     breakParent: oe,
     ifBreak: function (e, t = "", r = {}) {
      return Z(e), "" !== t && Z(t), { type: j, breakContents: e, flatContents: t, groupId: r.groupId };
     },
     trim: ue,
     indent: te,
     indentIfBreak: function (e, t) {
      return Z(e), { type: R, contents: e, groupId: t.groupId, negate: t.negate };
     },
     align: re,
     addAlignmentToDoc: ge,
     markAsRoot: function (e) {
      return re({ type: "root" }, e);
     },
     dedentToRoot: function (e) {
      return re(Number.NEGATIVE_INFINITY, e);
     },
     dedent: function (e) {
      return re(-1, e);
     },
     hardlineWithoutBreakParent: le,
     literallineWithoutBreakParent: pe,
     label: function (e, t) {
      return Z(t), e ? { type: V, label: e, contents: t } : t;
     },
     concat: (e) => e,
    },
    tn = { printDocToString: $e },
    rn = {
     willBreak: function (e) {
      return we(e, Se, !1);
     },
     traverseDoc: Y,
     findInDoc: we,
     mapDoc: Te,
     removeLines: function (e) {
      return Te(e, Fe);
     },
     stripTrailingHardline: Ie,
     replaceEndOfLine: function (e, t = fe) {
      return Te(e, (e) => ("string" == typeof e ? ye(t, e.split("\n")) : e));
     },
     canBreak: function (e) {
      return we(e, Ne, !1);
     },
    },
    nn = "3.2.4",
    sn = {};
   p(sn, { addDanglingComment: () => ht, addLeadingComment: () => ct, addTrailingComment: () => dt, getAlignmentSize: () => Je, getIndentSize: () => pn, getMaxContinuousCount: () => cn, getNextNonSpaceNonCommentCharacter: () => hn, getNextNonSpaceNonCommentCharacterIndex: () => yn, getStringWidth: () => Ee, hasNewline: () => it, hasNewlineInRange: () => dn, hasSpaces: () => fn, isNextLineEmpty: () => Dn, isNextLineEmptyAfterIndex: () => ln, isPreviousLineEmpty: () => gn, makeString: () => mn, skip: () => Ze, skipEverythingButNewLine: () => nt, skipInlineComment: () => an, skipNewline: () => st, skipSpaces: () => tt, skipToLineEnd: () => rt, skipTrailingComment: () => on, skipWhitespace: () => et });
   var an = function (e, t) {
    if (!1 === t) return !1;
    if ("/" === e.charAt(t) && "*" === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ("*" === e.charAt(r) && "/" === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var on = function (e, t) {
    return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? nt(e, t) : t);
   };
   var un = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = tt(e, n)), (n = an(e, n)), (n = on(e, n)), (n = st(e, n));
    return n;
   };
   var ln = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = rt(e, n)), (n = an(e, n)), (n = tt(e, n));
    return (n = on(e, n)), (n = st(e, n)), !1 !== n && it(e, n);
   };
   var pn = function (e, t) {
    let r = e.lastIndexOf("\n");
    return -1 === r ? 0 : Je(e.slice(r + 1).match(/^[\t ]*/)[0], t);
   };
   var cn = function (e, t) {
    let r = e.match(
     new RegExp(
      `(${(function (e) {
       if ("string" != typeof e) throw new TypeError("Expected a string");
       return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      })(t)})+`,
      "g",
     ),
    );
    return null === r ? 0 : r.reduce((e, r) => Math.max(e, r.length / t.length), 0);
   };
   var hn = function (e, t) {
    let r = un(e, t);
    return !1 === r ? "" : e.charAt(r);
   };
   var dn = function (e, t, r) {
    for (let n = t; n < r; ++n) if ("\n" === e.charAt(n)) return !0;
    return !1;
   };
   var fn = function (e, t, r = {}) {
    return tt(e, r.backwards ? t - 1 : t, r) !== t;
   };
   var mn = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = S(!1, e, /\\(.)|(["'])/gs, (e, s, i) => (s === n ? s : i === t ? "\\" + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s) ? s : "\\" + s)));
    return t + s + t;
   };
   function yn(e, t) {
    return 2 === arguments.length || "number" == typeof t
     ? un(e, t)
     : (function (e, t, r) {
        return un(e, r(t));
       })(...arguments);
   }
   function gn(e, t) {
    return 2 === arguments.length || "number" == typeof t
     ? Ct(e, t)
     : (function (e, t, r) {
        return Ct(e, r(t));
       })(...arguments);
   }
   function Dn(e, t) {
    return 2 === arguments.length || "number" == typeof t
     ? ln(e, t)
     : (function (e, t, r) {
        return ln(e, r(t));
       })(...arguments);
   }
   function xn(e, t = 1) {
    return async (...r) => {
     let n = r[t] ?? {},
      s = n.plugins ?? [];
     return (r[t] = { ...n, plugins: Array.isArray(s) ? s : Object.values(s) }), e(...r);
    };
   }
   var bn = xn(Qr);
   async function vn(e, t) {
    let { formatted: r } = await bn(e, { ...t, cursorOffset: -1 });
    return r;
   }
   async function En(e, t) {
    return (await vn(e, t)) === e;
   }
   var Cn = xn(Pt, 0),
    Tn = {
     parse: xn(async function (e, t, r) {
      let { text: n, options: s } = Xr(e, await Fr(t)),
       i = await Pr(n, s);
      return r && (r.preprocessForPrint && (i.ast = await Lr(i.ast, s)), r.massage && (i.ast = Mr(i.ast, s))), i;
     }),
     formatAST: xn(async function (e, t) {
      return (t = await Fr(t)), $e(await Br(e, t), t);
     }),
     formatDoc: xn(async function (e, t) {
      let r = (function (e) {
        let t = Object.create(null),
         r = new Set();
        return (function e(t, r, s) {
         var i, a;
         if ("string" == typeof t) return JSON.stringify(t);
         if (Array.isArray(t)) {
          let r = t.map(e).filter(Boolean);
          return 1 === r.length ? r[0] : `[${r.join(", ")}]`;
         }
         if (t.type === $) {
          let e = (null == (i = null == s ? void 0 : s[r + 1]) ? void 0 : i.type) === z;
          return t.literal ? (e ? "literalline" : "literallineWithoutBreakParent") : t.hard ? (e ? "hardline" : "hardlineWithoutBreakParent") : t.soft ? "softline" : "line";
         }
         if (t.type === z) return (null == (a = null == s ? void 0 : s[r - 1]) ? void 0 : a.type) === $ && s[r - 1].hard ? void 0 : "breakParent";
         if (t.type === L) return "trim";
         if (t.type === B) return "indent(" + e(t.contents) + ")";
         if (t.type === _) return t.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e(t.contents) + ")" : t.n < 0 ? "dedent(" + e(t.contents) + ")" : "root" === t.n.type ? "markAsRoot(" + e(t.contents) + ")" : "align(" + JSON.stringify(t.n) + ", " + e(t.contents) + ")";
         if (t.type === j) return "ifBreak(" + e(t.breakContents) + (t.flatContents ? ", " + e(t.flatContents) : "") + (t.groupId ? (t.flatContents ? "" : ', ""') + `, { groupId: ${n(t.groupId)} }` : "") + ")";
         if (t.type === R) {
          let r = [];
          t.negate && r.push("negate: true"), t.groupId && r.push(`groupId: ${n(t.groupId)}`);
          let s = r.length > 0 ? `, { ${r.join(", ")} }` : "";
          return `indentIfBreak(${e(t.contents)}${s})`;
         }
         if (t.type === O) {
          let r = [];
          t.break && "propagated" !== t.break && r.push("shouldBreak: true"), t.id && r.push(`id: ${n(t.id)}`);
          let s = r.length > 0 ? `, { ${r.join(", ")} }` : "";
          return t.expandedStates ? `conditionalGroup([${t.expandedStates.map((t) => e(t)).join(",")}]${s})` : `group(${e(t.contents)}${s})`;
         }
         if (t.type === M) return `fill([${t.parts.map((t) => e(t)).join(", ")}])`;
         if (t.type === q) return "lineSuffix(" + e(t.contents) + ")";
         if (t.type === U) return "lineSuffixBoundary";
         if (t.type === V) return `label(${JSON.stringify(t.label)}, ${e(t.contents)})`;
         throw new Error("Unknown doc type " + t.type);
        })(De(e));
        function n(e) {
         if ("symbol" != typeof e) return JSON.stringify(String(e));
         if (e in t) return t[e];
         let n = e.description || "symbol";
         for (let s = 0; ; s++) {
          let i = n + (s > 0 ? ` #${s}` : "");
          if (!r.has(i)) return r.add(i), (t[e] = `Symbol.for(${JSON.stringify(i)})`);
         }
        }
       })(e),
       { formatted: n } = await Qr(r, { ...t, parser: "__js_expression" });
      return n;
     }),
     printToDoc: xn(async function (e, t) {
      t = await Fr(t);
      let { ast: r } = await Pr(e, t);
      return Br(r, t);
     }),
     printDocToString: xn(async function (e, t) {
      return $e(e, await Fr(t));
     }),
    },
    wn = w;
  },
 },
]);
